/*
  ==============================================================================

   This file is part of the JUCE library - "Jules' Utility Class Extensions"
   Copyright 2004-11 by Raw Material Software Ltd.

  ------------------------------------------------------------------------------

   JUCE can be redistributed and/or modified under the terms of the GNU General
   Public License (Version 2), as published by the Free Software Foundation.
   A copy of the license is included in the JUCE distribution, or can be found
   online at www.gnu.org/licenses.

   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

  ------------------------------------------------------------------------------

   To release a closed-source product which uses JUCE, commercial licenses are
   available: visit www.rawmaterialsoftware.com/juce for more information.

  ==============================================================================
*/

#define JUCE_AMALGAMATED_INCLUDE 1
#if !defined(__APPLE__) || defined(__OBJC__)

/*** Start of inlined file: juce_gui_basics.cpp ***/
#if defined (__JUCE_GUI_BASICS_JUCEHEADER__) && ! JUCE_AMALGAMATED_INCLUDE
 /* When you add this cpp file to your project, you mustn't include it in a file where you've
	already included any other headers - just put it inside a file on its own, possibly with your config
	flags preceding it, but don't include anything else. That also includes avoiding any automatic prefix
	header files that the compiler may be using.
 */
 #error "Incorrect use of JUCE cpp file"
#endif

// Your project must contain an AppConfig.h file with your project-specific settings in it,
// and your header search path must make it accessible to the module's files.
#include "AppConfig.h"


/*** Start of inlined file: juce_BasicNativeHeaders.h ***/
#ifndef __JUCE_BASICNATIVEHEADERS_JUCEHEADER__
#define __JUCE_BASICNATIVEHEADERS_JUCEHEADER__


/*** Start of inlined file: juce_TargetPlatform.h ***/
#ifndef __JUCE_TARGETPLATFORM_JUCEHEADER__
#define __JUCE_TARGETPLATFORM_JUCEHEADER__

/*  This file figures out which platform is being built, and defines some macros
	that the rest of the code can use for OS-specific compilation.

	Macros that will be set here are:

	- One of JUCE_WINDOWS, JUCE_MAC JUCE_LINUX, JUCE_IOS, JUCE_ANDROID, etc.
	- Either JUCE_32BIT or JUCE_64BIT, depending on the architecture.
	- Either JUCE_LITTLE_ENDIAN or JUCE_BIG_ENDIAN.
	- Either JUCE_INTEL or JUCE_PPC
	- Either JUCE_GCC or JUCE_MSVC
*/

#if (defined (_WIN32) || defined (_WIN64))
  #define       JUCE_WIN32 1
  #define       JUCE_WINDOWS 1
#elif defined (JUCE_ANDROID)
  #undef        JUCE_ANDROID
  #define       JUCE_ANDROID 1
#elif defined (LINUX) || defined (__linux__)
  #define     JUCE_LINUX 1
#elif defined (__APPLE_CPP__) || defined(__APPLE_CC__)
  #define Point CarbonDummyPointName // (workaround to avoid definition of "Point" by old Carbon headers)
  #define Component CarbonDummyCompName
  #include <CoreFoundation/CoreFoundation.h> // (needed to find out what platform we're using)
  #undef Point
  #undef Component

  #if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
	#define     JUCE_IPHONE 1
	#define     JUCE_IOS 1
  #else
	#define     JUCE_MAC 1
  #endif
#else
  #error "Unknown platform!"
#endif

#if JUCE_WINDOWS
  #ifdef _MSC_VER
	#ifdef _WIN64
	  #define JUCE_64BIT 1
	#else
	  #define JUCE_32BIT 1
	#endif
  #endif

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  #ifdef __MINGW32__
	#define JUCE_MINGW 1
  #endif

  /** If defined, this indicates that the processor is little-endian. */
  #define JUCE_LITTLE_ENDIAN 1

  #define JUCE_INTEL 1
#endif

#if JUCE_MAC || JUCE_IOS

  #if defined (DEBUG) || defined (_DEBUG) || ! (defined (NDEBUG) || defined (_NDEBUG))
	#define JUCE_DEBUG 1
  #endif

  #if ! (defined (DEBUG) || defined (_DEBUG) || defined (NDEBUG) || defined (_NDEBUG))
	#warning "Neither NDEBUG or DEBUG has been defined - you should set one of these to make it clear whether this is a release build,"
  #endif

  #ifdef __LITTLE_ENDIAN__
	#define JUCE_LITTLE_ENDIAN 1
  #else
	#define JUCE_BIG_ENDIAN 1
  #endif
#endif

#if JUCE_MAC

  #if defined (__ppc__) || defined (__ppc64__)
	#define JUCE_PPC 1
  #else
	#define JUCE_INTEL 1
  #endif

  #ifdef __LP64__
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_4
	#error "Building for OSX 10.3 is no longer supported!"
  #endif

  #ifndef MAC_OS_X_VERSION_10_5
	#error "To build with 10.4 compatibility, use a 10.5 or 10.6 SDK and set the deployment target to 10.4"
  #endif

#endif

#if JUCE_LINUX || JUCE_ANDROID

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  // Allow override for big-endian Linux platforms
  #if defined (__LITTLE_ENDIAN__) || ! defined (JUCE_BIG_ENDIAN)
	#define JUCE_LITTLE_ENDIAN 1
	#undef JUCE_BIG_ENDIAN
  #else
	#undef JUCE_LITTLE_ENDIAN
	#define JUCE_BIG_ENDIAN 1
  #endif

  #if defined (__LP64__) || defined (_LP64)
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if __MMX__ || __SSE__ || __amd64__
	#define JUCE_INTEL 1
  #endif
#endif

// Compiler type macros.

#ifdef __GNUC__
  #define JUCE_GCC 1
#elif defined (_MSC_VER)
  #define JUCE_MSVC 1

  #if _MSC_VER < 1500
	#define JUCE_VC8_OR_EARLIER 1

	#if _MSC_VER < 1400
	  #define JUCE_VC7_OR_EARLIER 1

	  #if _MSC_VER < 1300
		#warning "MSVC 6.0 is no longer supported!"
	  #endif
	#endif
  #endif

  #if JUCE_64BIT || ! JUCE_VC7_OR_EARLIER
	#define JUCE_USE_INTRINSICS 1
  #endif
#else
  #error unknown compiler
#endif

#endif   // __JUCE_TARGETPLATFORM_JUCEHEADER__

/*** End of inlined file: juce_TargetPlatform.h ***/

#undef T

#if JUCE_MAC || JUCE_IOS

 #if JUCE_IOS
  #import <Foundation/Foundation.h>
  #import <UIKit/UIKit.h>
  #import <CoreData/CoreData.h>
  #import <MobileCoreServices/MobileCoreServices.h>
  #include <sys/fcntl.h>
 #else
  #define Point CarbonDummyPointName
  #define Component CarbonDummyCompName
  #import <Cocoa/Cocoa.h>
  #import <CoreAudio/HostTime.h>
  #undef Point
  #undef Component
  #include <sys/dir.h>
 #endif

 #include <sys/socket.h>
 #include <sys/sysctl.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <sys/mount.h>
 #include <sys/utsname.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <dlfcn.h>
 #include <ifaddrs.h>
 #include <net/if_dl.h>
 #include <mach/mach_time.h>
 #include <mach-o/dyld.h>

#elif JUCE_WINDOWS
 #if JUCE_MSVC
  #ifndef _CPPRTTI
   #error "You're compiling without RTTI enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #ifndef _CPPUNWIND
   #error "You're compiling without exceptions enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #pragma warning (push)
  #pragma warning (disable : 4100 4201 4514 4312 4995)
 #endif

 #define STRICT 1
 #define WIN32_LEAN_AND_MEAN 1
 #define _WIN32_WINNT 0x0600
 #define _UNICODE 1
 #define UNICODE 1
 #ifndef _WIN32_IE
  #define _WIN32_IE 0x0400
 #endif

 #include <windows.h>
 #include <shellapi.h>
 #include <tchar.h>
 #include <stddef.h>
 #include <ctime>
 #include <wininet.h>
 #include <nb30.h>
 #include <iphlpapi.h>
 #include <mapi.h>
 #include <float.h>
 #include <process.h>
 #include <shlobj.h>
 #include <shlwapi.h>
 #include <mmsystem.h>

 #if JUCE_MINGW
  #include <basetyps.h>
 #else
  #include <crtdbg.h>
  #include <comutil.h>
 #endif

 #undef PACKED

 #if JUCE_MSVC
  #pragma warning (pop)
  #pragma warning (4: 4511 4512 4100 /*4365*/)  // (enable some warnings that are turned off in VC8)
 #endif

 #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "kernel32.lib")
  #pragma comment (lib, "user32.lib")
  #pragma comment (lib, "shell32.lib")
  #pragma comment (lib, "wininet.lib")
  #pragma comment (lib, "advapi32.lib")
  #pragma comment (lib, "ws2_32.lib")
  #pragma comment (lib, "version.lib")
  #pragma comment (lib, "shlwapi.lib")
  #pragma comment (lib, "winmm.lib")

  #ifdef _NATIVE_WCHAR_T_DEFINED
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppwd.lib")
   #else
	#pragma comment (lib, "comsuppw.lib")
   #endif
  #else
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppd.lib")
   #else
	#pragma comment (lib, "comsupp.lib")
   #endif
  #endif
 #endif

 /* Used with DynamicLibrary to simplify importing functions

	functionName: function to import
	localFunctionName: name you want to use to actually call it (must be different)
	returnType: the return type
	object: the DynamicLibrary to use
	params: list of params (bracketed)
 */
 #define JUCE_DLL_FUNCTION(functionName, localFunctionName, returnType, object, params) \
	typedef returnType (WINAPI *type##localFunctionName) params; \
	type##localFunctionName localFunctionName = (type##localFunctionName)object.getFunction (#functionName);

#elif JUCE_LINUX
 #include <sched.h>
 #include <pthread.h>
 #include <sys/time.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <sys/dir.h>
 #include <sys/ptrace.h>
 #include <sys/vfs.h>
 #include <sys/wait.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <pwd.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <netdb.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #include <sys/sysinfo.h>
 #include <sys/file.h>
 #include <sys/prctl.h>
 #include <signal.h>
 #include <stddef.h>

#elif JUCE_ANDROID
 #include <jni.h>
 #include <pthread.h>
 #include <sched.h>
 #include <sys/time.h>
 #include <utime.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
 #include <sys/ptrace.h>
 #include <sys/sysinfo.h>
 #include <sys/mman.h>
 #include <pwd.h>
 #include <dirent.h>
 #include <fnmatch.h>
 #include <sys/wait.h>
#endif

// Need to clear various moronic redefinitions made by system headers..
#undef max
#undef min
#undef direct
#undef check

#endif   // __JUCE_BASICNATIVEHEADERS_JUCEHEADER__

/*** End of inlined file: juce_BasicNativeHeaders.h ***/

#include "juce_gui_basics_amalgam.h"

#if JUCE_MODULE_AVAILABLE_juce_opengl
#include "juce_opengl_amalgam.h"
#endif

#if JUCE_MAC
 #import <WebKit/WebKit.h>
 #define Point CarbonDummyPointName
 #define Component CarbonDummyCompName
 #import <Carbon/Carbon.h> // still needed for SetSystemUIMode()
 #undef Point
 #undef Component

#elif JUCE_WINDOWS
 #include <windowsx.h>
 #include <vfw.h>
 #include <commdlg.h>

 #if JUCE_WEB_BROWSER
  #include <Exdisp.h>
  #include <exdispid.h>
 #endif

 #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment(lib, "vfw32.lib")
  #pragma comment(lib, "imm32.lib")
 #endif

 #if JUCE_OPENGL
  #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
   #pragma comment(lib, "OpenGL32.Lib")
   #pragma comment(lib, "GlU32.Lib")
  #endif
 #endif

 #if JUCE_QUICKTIME && JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "QTMLClient.lib")
 #endif

 #if JUCE_DIRECT2D && JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "Dwrite.lib")
  #pragma comment (lib, "D2d1.lib")
 #endif

 #if JUCE_MINGW
  #include <Imm.h>
 #endif

#elif JUCE_LINUX
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
 #include <X11/Xresource.h>
 #include <X11/Xutil.h>
 #include <X11/Xmd.h>
 #include <X11/keysym.h>
 #include <X11/XKBlib.h>
 #include <X11/cursorfont.h>
 #include <unistd.h>

 #if JUCE_USE_XINERAMA
  /* If you're trying to use Xinerama, you'll need to install the "libxinerama-dev" package..  */
  #include <X11/extensions/Xinerama.h>
 #endif

 #if JUCE_USE_XSHM
  #include <X11/extensions/XShm.h>
  #include <sys/shm.h>
  #include <sys/ipc.h>
 #endif

 #if JUCE_USE_XRENDER
  // If you're missing these headers, try installing the libxrender-dev and libxcomposite-dev
  #include <X11/extensions/Xrender.h>
  #include <X11/extensions/Xcomposite.h>
 #endif

 #if JUCE_USE_XCURSOR
  // If you're missing this header, try installing the libxcursor-dev package
  #include <X11/Xcursor/Xcursor.h>
 #endif

 #undef SIZEOF
 #undef KeyPress
#endif

namespace juce
{

// START_AUTOINCLUDE components/*.cpp, mouse/*.cpp, keyboard/*.cpp, buttons/*.cpp,
// drawables/*.cpp, filebrowser/*.cpp, layout/*.cpp, lookandfeel/*.cpp,
// menus/*.cpp, positioning/*.cpp, properties/*.cpp, widgets/*.cpp,
// windows/*.cpp, commands/*.cpp, application/*.cpp, misc/*.cpp

/*** Start of inlined file: juce_Component.cpp ***/
#define CHECK_MESSAGE_MANAGER_IS_LOCKED \
	jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

#define CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN \
	jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager() || getPeer() == nullptr);

Component* Component::currentlyFocusedComponent = nullptr;

class Component::MouseListenerList
{
public:
	MouseListenerList() noexcept
		: numDeepMouseListeners (0)
	{
	}

	void addListener (MouseListener* const newListener, const bool wantsEventsForAllNestedChildComponents)
	{
		if (! listeners.contains (newListener))
		{
			if (wantsEventsForAllNestedChildComponents)
			{
				listeners.insert (0, newListener);
				++numDeepMouseListeners;
			}
			else
			{
				listeners.add (newListener);
			}
		}
	}

	void removeListener (MouseListener* const listenerToRemove)
	{
		const int index = listeners.indexOf (listenerToRemove);

		if (index >= 0)
		{
			if (index < numDeepMouseListeners)
				--numDeepMouseListeners;

			listeners.remove (index);
		}
	}

	static void sendMouseEvent (Component& comp, Component::BailOutChecker& checker,
								void (MouseListener::*eventMethod) (const MouseEvent&), const MouseEvent& e)
	{
		if (checker.shouldBailOut())
			return;

		{
			MouseListenerList* const list = comp.mouseListeners;

			if (list != nullptr)
			{
				for (int i = list->listeners.size(); --i >= 0;)
				{
					(list->listeners.getUnchecked(i)->*eventMethod) (e);

					if (checker.shouldBailOut())
						return;

					i = jmin (i, list->listeners.size());
				}
			}
		}

		for (Component* p = comp.parentComponent; p != nullptr; p = p->parentComponent)
		{
			MouseListenerList* const list = p->mouseListeners;

			if (list != nullptr && list->numDeepMouseListeners > 0)
			{
				BailOutChecker2 checker2 (checker, p);

				for (int i = list->numDeepMouseListeners; --i >= 0;)
				{
					(list->listeners.getUnchecked(i)->*eventMethod) (e);

					if (checker2.shouldBailOut())
						return;

					i = jmin (i, list->numDeepMouseListeners);
				}
			}
		}
	}

	static void sendWheelEvent (Component& comp, Component::BailOutChecker& checker, const MouseEvent& e,
								const float wheelIncrementX, const float wheelIncrementY)
	{
		{
			MouseListenerList* const list = comp.mouseListeners;

			if (list != nullptr)
			{
				for (int i = list->listeners.size(); --i >= 0;)
				{
					list->listeners.getUnchecked(i)->mouseWheelMove (e, wheelIncrementX, wheelIncrementY);

					if (checker.shouldBailOut())
						return;

					i = jmin (i, list->listeners.size());
				}
			}
		}

		for (Component* p = comp.parentComponent; p != nullptr; p = p->parentComponent)
		{
			MouseListenerList* const list = p->mouseListeners;

			if (list != nullptr && list->numDeepMouseListeners > 0)
			{
				BailOutChecker2 checker2 (checker, p);

				for (int i = list->numDeepMouseListeners; --i >= 0;)
				{
					list->listeners.getUnchecked(i)->mouseWheelMove (e, wheelIncrementX, wheelIncrementY);

					if (checker2.shouldBailOut())
						return;

					i = jmin (i, list->numDeepMouseListeners);
				}
			}
		}
	}

private:
	Array <MouseListener*> listeners;
	int numDeepMouseListeners;

	class BailOutChecker2
	{
	public:
		BailOutChecker2 (Component::BailOutChecker& checker_, Component* const component)
			: checker (checker_), safePointer (component)
		{
		}

		bool shouldBailOut() const noexcept
		{
			return checker.shouldBailOut() || safePointer == 0;
		}

	private:
		Component::BailOutChecker& checker;
		const WeakReference<Component> safePointer;

		JUCE_DECLARE_NON_COPYABLE (BailOutChecker2);
	};

	JUCE_DECLARE_NON_COPYABLE (MouseListenerList);
};

struct Component::ComponentHelpers
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	static void* runModalLoopCallback (void* userData)
	{
		return (void*) (pointer_sized_int) static_cast <Component*> (userData)->runModalLoop();
	}
   #endif

	static Identifier getColourPropertyId (const int colourId)
	{
		String s;
		s.preallocateBytes (32);
		s << "jcclr_" << String::toHexString (colourId);
		return s;
	}

	static inline bool hitTest (Component& comp, const Point<int>& localPoint)
	{
		return isPositiveAndBelow (localPoint.x, comp.getWidth())
				 && isPositiveAndBelow (localPoint.y, comp.getHeight())
				 && comp.hitTest (localPoint.x, localPoint.y);
	}

	static Point<int> convertFromParentSpace (const Component& comp, const Point<int>& pointInParentSpace)
	{
		if (comp.affineTransform == nullptr)
			return pointInParentSpace - comp.getPosition();

		return pointInParentSpace.toFloat().transformedBy (comp.affineTransform->inverted()).toInt() - comp.getPosition();
	}

	static Rectangle<int> convertFromParentSpace (const Component& comp, const Rectangle<int>& areaInParentSpace)
	{
		if (comp.affineTransform == nullptr)
			return areaInParentSpace - comp.getPosition();

		return areaInParentSpace.toFloat().transformed (comp.affineTransform->inverted()).getSmallestIntegerContainer() - comp.getPosition();
	}

	static Point<int> convertToParentSpace (const Component& comp, const Point<int>& pointInLocalSpace)
	{
		if (comp.affineTransform == nullptr)
			return pointInLocalSpace + comp.getPosition();

		return (pointInLocalSpace + comp.getPosition()).toFloat().transformedBy (*comp.affineTransform).toInt();
	}

	static Rectangle<int> convertToParentSpace (const Component& comp, const Rectangle<int>& areaInLocalSpace)
	{
		if (comp.affineTransform == nullptr)
			return areaInLocalSpace + comp.getPosition();

		return (areaInLocalSpace + comp.getPosition()).toFloat().transformed (*comp.affineTransform).getSmallestIntegerContainer();
	}

	template <typename Type>
	static Type convertFromDistantParentSpace (const Component* parent, const Component& target, const Type& coordInParent)
	{
		const Component* const directParent = target.getParentComponent();
		jassert (directParent != nullptr);

		if (directParent == parent)
			return convertFromParentSpace (target, coordInParent);

		return convertFromParentSpace (target, convertFromDistantParentSpace (parent, *directParent, coordInParent));
	}

	template <typename Type>
	static Type convertCoordinate (const Component* target, const Component* source, Type p)
	{
		while (source != nullptr)
		{
			if (source == target)
				return p;

			if (source->isParentOf (target))
				return convertFromDistantParentSpace (source, *target, p);

			if (source->isOnDesktop())
			{
				p = source->getPeer()->localToGlobal (p);
				source = nullptr;
			}
			else
			{
				p = convertToParentSpace (*source, p);
				source = source->getParentComponent();
			}
		}

		jassert (source == nullptr);
		if (target == nullptr)
			return p;

		const Component* const topLevelComp = target->getTopLevelComponent();

		if (topLevelComp->isOnDesktop())
			p = topLevelComp->getPeer()->globalToLocal (p);
		else
			p = convertFromParentSpace (*topLevelComp, p);

		if (topLevelComp == target)
			return p;

		return convertFromDistantParentSpace (topLevelComp, *target, p);
	}

	static Rectangle<int> getUnclippedArea (const Component& comp)
	{
		Rectangle<int> r (comp.getLocalBounds());

		Component* const p = comp.getParentComponent();

		if (p != nullptr)
			r = r.getIntersection (convertFromParentSpace (comp, getUnclippedArea (*p)));

		return r;
	}

	static void clipObscuredRegions (const Component& comp, Graphics& g, const Rectangle<int>& clipRect, const Point<int>& delta)
	{
		for (int i = comp.childComponentList.size(); --i >= 0;)
		{
			const Component& child = *comp.childComponentList.getUnchecked(i);

			if (child.isVisible() && ! child.isTransformed())
			{
				const Rectangle<int> newClip (clipRect.getIntersection (child.bounds));

				if (! newClip.isEmpty())
				{
					if (child.isOpaque() && child.componentTransparency == 0)
					{
						g.excludeClipRegion (newClip + delta);
					}
					else
					{
						const Point<int> childPos (child.getPosition());
						clipObscuredRegions (child, g, newClip - childPos, childPos + delta);
					}
				}
			}
		}
	}

	static void subtractObscuredRegions (const Component& comp, RectangleList& result,
										 const Point<int>& delta, const Rectangle<int>& clipRect,
										 const Component* const compToAvoid)
	{
		for (int i = comp.childComponentList.size(); --i >= 0;)
		{
			const Component* const c = comp.childComponentList.getUnchecked(i);

			if (c != compToAvoid && c->isVisible())
			{
				if (c->isOpaque() && c->componentTransparency == 0)
				{
					Rectangle<int> childBounds (c->bounds.getIntersection (clipRect));
					childBounds.translate (delta.x, delta.y);

					result.subtract (childBounds);
				}
				else
				{
					Rectangle<int> newClip (clipRect.getIntersection (c->bounds));
					newClip.translate (-c->getX(), -c->getY());

					subtractObscuredRegions (*c, result, c->getPosition() + delta,
											 newClip, compToAvoid);
				}
			}
		}
	}

	static Rectangle<int> getParentOrMainMonitorBounds (const Component& comp)
	{
		return comp.getParentComponent() != nullptr ? comp.getParentComponent()->getLocalBounds()
													: Desktop::getInstance().getDisplays().getMainDisplay().userArea;
	}
};

Component::Component()
  : parentComponent (nullptr),
	lookAndFeel (nullptr),
	effect (nullptr),
	componentFlags (0),
	componentTransparency (0)
{
}

Component::Component (const String& name)
  : componentName (name),
	parentComponent (nullptr),
	lookAndFeel (nullptr),
	effect (nullptr),
	componentFlags (0),
	componentTransparency (0)
{
}

Component::~Component()
{
	static_jassert (sizeof (flags) <= sizeof (componentFlags));

	componentListeners.call (&ComponentListener::componentBeingDeleted, *this);

	masterReference.clear();

	while (childComponentList.size() > 0)
		removeChildComponent (childComponentList.size() - 1, false, true);

	if (parentComponent != nullptr)
		parentComponent->removeChildComponent (parentComponent->childComponentList.indexOf (this), true, false);
	else if (currentlyFocusedComponent == this || isParentOf (currentlyFocusedComponent))
		giveAwayFocus (currentlyFocusedComponent != this);

	if (flags.hasHeavyweightPeerFlag)
		removeFromDesktop();

	// Something has added some children to this component during its destructor! Not a smart idea!
	jassert (childComponentList.size() == 0);
}

void Component::setName (const String& name)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	if (componentName != name)
	{
		componentName = name;

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			jassert (peer != nullptr);
			if (peer != nullptr)
				peer->setTitle (name);
		}

		BailOutChecker checker (this);
		componentListeners.callChecked (checker, &ComponentListener::componentNameChanged, *this);
	}
}

void Component::setComponentID (const String& newID)
{
	componentID = newID;
}

void Component::setVisible (bool shouldBeVisible)
{
	if (flags.visibleFlag != shouldBeVisible)
	{
		// if component methods are being called from threads other than the message
		// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
		CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

		const WeakReference<Component> safePointer (this);
		flags.visibleFlag = shouldBeVisible;

		if (shouldBeVisible)
			repaint();
		else
			repaintParent();

		sendFakeMouseMove();

		if (! shouldBeVisible)
		{
			if (cachedImage != nullptr)
				cachedImage->releaseResources();

			if (currentlyFocusedComponent == this || isParentOf (currentlyFocusedComponent))
			{
				if (parentComponent != nullptr)
					parentComponent->grabKeyboardFocus();
				else
					giveAwayFocus (true);
			}
		}

		if (safePointer != nullptr)
		{
			sendVisibilityChangeMessage();

			if (safePointer != nullptr && flags.hasHeavyweightPeerFlag)
			{
				ComponentPeer* const peer = getPeer();

				jassert (peer != nullptr);
				if (peer != nullptr)
				{
					peer->setVisible (shouldBeVisible);
					internalHierarchyChanged();
				}
			}
		}
	}
}

void Component::visibilityChanged() {}

void Component::sendVisibilityChangeMessage()
{
	BailOutChecker checker (this);
	visibilityChanged();

	if (! checker.shouldBailOut())
		componentListeners.callChecked (checker, &ComponentListener::componentVisibilityChanged, *this);
}

bool Component::isShowing() const
{
	if (! flags.visibleFlag)
		return false;

	if (parentComponent != nullptr)
		return parentComponent->isShowing();

	const ComponentPeer* const peer = getPeer();
	return peer != nullptr && ! peer->isMinimised();
}

void* Component::getWindowHandle() const
{
	const ComponentPeer* const peer = getPeer();

	if (peer != nullptr)
		return peer->getNativeHandle();

	return nullptr;
}

void Component::addToDesktop (int styleWanted, void* nativeWindowToAttachTo)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (isOpaque())
		styleWanted &= ~ComponentPeer::windowIsSemiTransparent;
	else
		styleWanted |= ComponentPeer::windowIsSemiTransparent;

	int currentStyleFlags = 0;

	// don't use getPeer(), so that we only get the peer that's specifically
	// for this comp, and not for one of its parents.
	ComponentPeer* peer = ComponentPeer::getPeerFor (this);

	if (peer != nullptr)
		currentStyleFlags = peer->getStyleFlags();

	if (styleWanted != currentStyleFlags || ! flags.hasHeavyweightPeerFlag)
	{
		const WeakReference<Component> safePointer (this);

	   #if JUCE_LINUX
		// it's wise to give the component a non-zero size before
		// putting it on the desktop, as X windows get confused by this, and
		// a (1, 1) minimum size is enforced here.
		setSize (jmax (1, getWidth()),
				 jmax (1, getHeight()));
	   #endif

		const Point<int> topLeft (getScreenPosition());

		bool wasFullscreen = false;
		bool wasMinimised = false;
		ComponentBoundsConstrainer* currentConstainer = nullptr;
		Rectangle<int> oldNonFullScreenBounds;

		if (peer != nullptr)
		{
			ScopedPointer<ComponentPeer> oldPeerToDelete (peer);

			wasFullscreen = peer->isFullScreen();
			wasMinimised = peer->isMinimised();
			currentConstainer = peer->getConstrainer();
			oldNonFullScreenBounds = peer->getNonFullScreenBounds();

			flags.hasHeavyweightPeerFlag = false;
			Desktop::getInstance().removeDesktopComponent (this);
			internalHierarchyChanged(); // give comps a chance to react to the peer change before the old peer is deleted.

			if (safePointer == nullptr)
				return;

			setTopLeftPosition (topLeft);
		}

		if (parentComponent != nullptr)
			parentComponent->removeChildComponent (this);

		if (safePointer != nullptr)
		{
			flags.hasHeavyweightPeerFlag = true;

			peer = createNewPeer (styleWanted, nativeWindowToAttachTo);

			Desktop::getInstance().addDesktopComponent (this);

			bounds.setPosition (topLeft);
			peer->setBounds (topLeft.x, topLeft.y, getWidth(), getHeight(), false);
			peer->setVisible (isVisible());

			peer = ComponentPeer::getPeerFor (this);
			if (peer == nullptr)
				return;

			if (wasFullscreen)
			{
				peer->setFullScreen (true);
				peer->setNonFullScreenBounds (oldNonFullScreenBounds);
			}

			if (wasMinimised)
				peer->setMinimised (true);

		   #if JUCE_WINDOWS
			if (isAlwaysOnTop())
				peer->setAlwaysOnTop (true);
		   #endif

			peer->setConstrainer (currentConstainer);

			repaint();
			internalHierarchyChanged();
		}
	}
}

void Component::removeFromDesktop()
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	if (flags.hasHeavyweightPeerFlag)
	{
		ComponentPeer* const peer = ComponentPeer::getPeerFor (this);
		jassert (peer != nullptr);

		flags.hasHeavyweightPeerFlag = false;
		delete peer;

		Desktop::getInstance().removeDesktopComponent (this);
	}
}

bool Component::isOnDesktop() const noexcept
{
	return flags.hasHeavyweightPeerFlag;
}

ComponentPeer* Component::getPeer() const
{
	if (flags.hasHeavyweightPeerFlag)
		return ComponentPeer::getPeerFor (this);
	else if (parentComponent == nullptr)
		return nullptr;

	return parentComponent->getPeer();
}

void Component::userTriedToCloseWindow()
{
	/* This means that the user's trying to get rid of your window with the 'close window' system
	   menu option (on windows) or possibly the task manager - you should really handle this
	   and delete or hide your component in an appropriate way.

	   If you want to ignore the event and don't want to trigger this assertion, just override
	   this method and do nothing.
	*/
	jassertfalse;
}

void Component::minimisationStateChanged (bool) {}

void Component::setOpaque (const bool shouldBeOpaque)
{
	if (shouldBeOpaque != flags.opaqueFlag)
	{
		flags.opaqueFlag = shouldBeOpaque;

		if (flags.hasHeavyweightPeerFlag)
		{
			const ComponentPeer* const peer = ComponentPeer::getPeerFor (this);

			if (peer != nullptr)
			{
				// to make it recreate the heavyweight window
				addToDesktop (peer->getStyleFlags());
			}
		}

		repaint();
	}
}

bool Component::isOpaque() const noexcept
{
	return flags.opaqueFlag;
}

class StandardCachedComponentImage  : public CachedComponentImage
{
public:
	StandardCachedComponentImage (Component& owner_) noexcept : owner (owner_) {}

	void paint (Graphics& g)
	{
		const Rectangle<int> bounds (owner.getLocalBounds());

		if (image.isNull() || image.getBounds() != bounds)
		{
			image = Image (owner.isOpaque() ? Image::RGB : Image::ARGB,
						   jmax (1, bounds.getWidth()), jmax (1, bounds.getHeight()), ! owner.isOpaque());

			validArea.clear();
		}

		{
			Graphics imG (image);
			LowLevelGraphicsContext* const lg = imG.getInternalContext();

			for (RectangleList::Iterator i (validArea); i.next();)
				lg->excludeClipRectangle (*i.getRectangle());

			if (! lg->isClipEmpty())
			{
				if (! owner.isOpaque())
				{
					lg->setFill (Colours::transparentBlack);
					lg->fillRect (bounds, true);
					lg->setFill (Colours::black);
				}

				owner.paintEntireComponent (imG, true);
			}
		}

		validArea = bounds;

		g.setColour (Colours::black.withAlpha (owner.getAlpha()));
		g.drawImageAt (image, 0, 0);
	}

	void invalidateAll()                            { validArea.clear(); }
	void invalidate (const Rectangle<int>& area)    { validArea.subtract (area); }
	void releaseResources()                         { image = Image::null; }

private:
	Image image;
	RectangleList validArea;
	Component& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StandardCachedComponentImage);
};

void Component::setCachedComponentImage (CachedComponentImage* newCachedImage)
{
	if (cachedImage != newCachedImage)
	{
		cachedImage = newCachedImage;
		repaint();
	}
}

void Component::setBufferedToImage (const bool shouldBeBuffered)
{
	// This assertion means that this component is already using a custom CachedComponentImage,
	// so by calling setBufferedToImage, you'll be deleting the custom one - this is almost certainly
	// not what you wanted to happen... If you really do know what you're doing here, and want to
	// avoid this assertion, just call setCachedComponentImage (nullptr) before setBufferedToImage().
	jassert (cachedImage == nullptr || dynamic_cast <StandardCachedComponentImage*> (cachedImage.get()) != nullptr);

	if (shouldBeBuffered)
	{
		if (cachedImage == nullptr)
			cachedImage = new StandardCachedComponentImage (*this);
	}
	else
	{
		cachedImage = nullptr;
	}
}

void Component::reorderChildInternal (const int sourceIndex, const int destIndex)
{
	if (sourceIndex != destIndex)
	{
		Component* const c = childComponentList.getUnchecked (sourceIndex);
		jassert (c != nullptr);
		c->repaintParent();

		childComponentList.move (sourceIndex, destIndex);

		sendFakeMouseMove();
		internalChildrenChanged();
	}
}

void Component::toFront (const bool setAsForeground)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	if (flags.hasHeavyweightPeerFlag)
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			peer->toFront (setAsForeground);

			if (setAsForeground && ! hasKeyboardFocus (true))
				grabKeyboardFocus();
		}
	}
	else if (parentComponent != nullptr)
	{
		const Array<Component*>& childList = parentComponent->childComponentList;

		if (childList.getLast() != this)
		{
			const int index = childList.indexOf (this);

			if (index >= 0)
			{
				int insertIndex = -1;

				if (! flags.alwaysOnTopFlag)
				{
					insertIndex = childList.size() - 1;

					while (insertIndex > 0 && childList.getUnchecked (insertIndex)->isAlwaysOnTop())
						--insertIndex;
				}

				parentComponent->reorderChildInternal (index, insertIndex);
			}
		}

		if (setAsForeground)
		{
			internalBroughtToFront();
			grabKeyboardFocus();
		}
	}
}

void Component::toBehind (Component* const other)
{
	if (other != nullptr && other != this)
	{
		// the two components must belong to the same parent..
		jassert (parentComponent == other->parentComponent);

		if (parentComponent != nullptr)
		{
			const Array<Component*>& childList = parentComponent->childComponentList;
			const int index = childList.indexOf (this);

			if (index >= 0 && childList [index + 1] != other)
			{
				int otherIndex = childList.indexOf (other);

				if (otherIndex >= 0)
				{
					if (index < otherIndex)
						--otherIndex;

					parentComponent->reorderChildInternal (index, otherIndex);
				}
			}
		}
		else if (isOnDesktop())
		{
			jassert (other->isOnDesktop());

			if (other->isOnDesktop())
			{
				ComponentPeer* const us = getPeer();
				ComponentPeer* const them = other->getPeer();

				jassert (us != nullptr && them != nullptr);
				if (us != nullptr && them != nullptr)
					us->toBehind (them);
			}
		}
	}
}

void Component::toBack()
{
	if (isOnDesktop())
	{
		jassertfalse; //xxx need to add this to native window
	}
	else if (parentComponent != nullptr)
	{
		const Array<Component*>& childList = parentComponent->childComponentList;

		if (childList.getFirst() != this)
		{
			const int index = childList.indexOf (this);

			if (index > 0)
			{
				int insertIndex = 0;

				if (flags.alwaysOnTopFlag)
					while (insertIndex < childList.size() && ! childList.getUnchecked (insertIndex)->isAlwaysOnTop())
						++insertIndex;

				parentComponent->reorderChildInternal (index, insertIndex);
			}
		}
	}
}

void Component::setAlwaysOnTop (const bool shouldStayOnTop)
{
	if (shouldStayOnTop != flags.alwaysOnTopFlag)
	{
		BailOutChecker checker (this);

		flags.alwaysOnTopFlag = shouldStayOnTop;

		if (isOnDesktop())
		{
			ComponentPeer* const peer = getPeer();

			jassert (peer != nullptr);
			if (peer != nullptr)
			{
				if (! peer->setAlwaysOnTop (shouldStayOnTop))
				{
					// some kinds of peer can't change their always-on-top status, so
					// for these, we'll need to create a new window
					const int oldFlags = peer->getStyleFlags();
					removeFromDesktop();
					addToDesktop (oldFlags);
				}
			}
		}

		if (shouldStayOnTop && ! checker.shouldBailOut())
			toFront (false);

		if (! checker.shouldBailOut())
			internalHierarchyChanged();
	}
}

bool Component::isAlwaysOnTop() const noexcept
{
	return flags.alwaysOnTopFlag;
}

int Component::proportionOfWidth  (const float proportion) const noexcept   { return roundToInt (proportion * bounds.getWidth()); }
int Component::proportionOfHeight (const float proportion) const noexcept   { return roundToInt (proportion * bounds.getHeight()); }

int Component::getParentWidth() const noexcept
{
	return parentComponent != nullptr ? parentComponent->getWidth()
									  : getParentMonitorArea().getWidth();
}

int Component::getParentHeight() const noexcept
{
	return parentComponent != nullptr ? parentComponent->getHeight()
									  : getParentMonitorArea().getHeight();
}

int Component::getScreenX() const   { return getScreenPosition().x; }
int Component::getScreenY() const   { return getScreenPosition().y; }

Point<int> Component::getScreenPosition() const       { return localPointToGlobal (Point<int>()); }
Rectangle<int> Component::getScreenBounds() const     { return localAreaToGlobal (getLocalBounds()); }

Rectangle<int> Component::getParentMonitorArea() const
{
	return Desktop::getInstance().getDisplays().getDisplayContaining (getScreenBounds().getCentre()).userArea;
}

Point<int> Component::getLocalPoint (const Component* source, const Point<int>& point) const
{
	return ComponentHelpers::convertCoordinate (this, source, point);
}

Rectangle<int> Component::getLocalArea (const Component* source, const Rectangle<int>& area) const
{
	return ComponentHelpers::convertCoordinate (this, source, area);
}

Point<int> Component::localPointToGlobal (const Point<int>& point) const
{
	return ComponentHelpers::convertCoordinate (nullptr, this, point);
}

Rectangle<int> Component::localAreaToGlobal (const Rectangle<int>& area) const
{
	return ComponentHelpers::convertCoordinate (nullptr, this, area);
}

// Deprecated methods...
Point<int> Component::relativePositionToGlobal (const Point<int>& relativePosition) const
{
	return localPointToGlobal (relativePosition);
}

Point<int> Component::globalPositionToRelative (const Point<int>& screenPosition) const
{
	return getLocalPoint (nullptr, screenPosition);
}

Point<int> Component::relativePositionToOtherComponent (const Component* const targetComponent, const Point<int>& positionRelativeToThis) const
{
	return targetComponent == nullptr ? localPointToGlobal (positionRelativeToThis)
									  : targetComponent->getLocalPoint (this, positionRelativeToThis);
}

void Component::setBounds (const int x, const int y, int w, int h)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	if (w < 0) w = 0;
	if (h < 0) h = 0;

	const bool wasResized  = (getWidth() != w || getHeight() != h);
	const bool wasMoved    = (getX() != x || getY() != y);

   #if JUCE_DEBUG
	// It's a very bad idea to try to resize a window during its paint() method!
	jassert (! (flags.isInsidePaintCall && wasResized && isOnDesktop()));
   #endif

	if (wasMoved || wasResized)
	{
		const bool showing = isShowing();
		if (showing)
		{
			// send a fake mouse move to trigger enter/exit messages if needed..
			sendFakeMouseMove();

			if (! flags.hasHeavyweightPeerFlag)
				repaintParent();
		}

		bounds.setBounds (x, y, w, h);

		if (showing)
		{
			if (wasResized)
				repaint();
			else if (! flags.hasHeavyweightPeerFlag)
				repaintParent();
		}
		else if (cachedImage != nullptr)
		{
			cachedImage->invalidateAll();
		}

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
			{
				if (wasMoved && wasResized)
					peer->setBounds (getX(), getY(), getWidth(), getHeight(), false);
				else if (wasMoved)
					peer->setPosition (getX(), getY());
				else if (wasResized)
					peer->setSize (getWidth(), getHeight());
			}
		}

		sendMovedResizedMessages (wasMoved, wasResized);
	}
}

void Component::sendMovedResizedMessages (const bool wasMoved, const bool wasResized)
{
	BailOutChecker checker (this);

	if (wasMoved)
	{
		moved();

		if (checker.shouldBailOut())
			return;
	}

	if (wasResized)
	{
		resized();

		if (checker.shouldBailOut())
			return;

		for (int i = childComponentList.size(); --i >= 0;)
		{
			childComponentList.getUnchecked(i)->parentSizeChanged();

			if (checker.shouldBailOut())
				return;

			i = jmin (i, childComponentList.size());
		}
	}

	if (parentComponent != nullptr)
		parentComponent->childBoundsChanged (this);

	if (! checker.shouldBailOut())
		componentListeners.callChecked (checker, &ComponentListener::componentMovedOrResized,
										*this, wasMoved, wasResized);
}

void Component::setSize (const int w, const int h)
{
	setBounds (getX(), getY(), w, h);
}

void Component::setTopLeftPosition (const int x, const int y)
{
	setBounds (x, y, getWidth(), getHeight());
}

void Component::setTopLeftPosition (const Point<int>& pos)
{
	setBounds (pos.x, pos.y, getWidth(), getHeight());
}

void Component::setTopRightPosition (const int x, const int y)
{
	setTopLeftPosition (x - getWidth(), y);
}

void Component::setBounds (const Rectangle<int>& r)
{
	setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight());
}

void Component::setBounds (const RelativeRectangle& newBounds)
{
	newBounds.applyToComponent (*this);
}

void Component::setBounds (const String& newBoundsExpression)
{
	setBounds (RelativeRectangle (newBoundsExpression));
}

void Component::setBoundsRelative (const float x, const float y,
								   const float w, const float h)
{
	const int pw = getParentWidth();
	const int ph = getParentHeight();

	setBounds (roundToInt (x * pw),
			   roundToInt (y * ph),
			   roundToInt (w * pw),
			   roundToInt (h * ph));
}

void Component::setCentrePosition (const int x, const int y)
{
	setTopLeftPosition (x - getWidth() / 2,
						y - getHeight() / 2);
}

void Component::setCentreRelative (const float x, const float y)
{
	setCentrePosition (roundToInt (getParentWidth() * x),
					   roundToInt (getParentHeight() * y));
}

void Component::centreWithSize (const int width, const int height)
{
	const Rectangle<int> parentArea (ComponentHelpers::getParentOrMainMonitorBounds (*this));

	setBounds (parentArea.getCentreX() - width / 2,
			   parentArea.getCentreY() - height / 2,
			   width, height);
}

void Component::setBoundsInset (const BorderSize<int>& borders)
{
	setBounds (borders.subtractedFrom (ComponentHelpers::getParentOrMainMonitorBounds (*this)));
}

void Component::setBoundsToFit (int x, int y, int width, int height,
								const Justification& justification,
								const bool onlyReduceInSize)
{
	// it's no good calling this method unless both the component and
	// target rectangle have a finite size.
	jassert (getWidth() > 0 && getHeight() > 0 && width > 0 && height > 0);

	if (getWidth() > 0 && getHeight() > 0
		 && width > 0 && height > 0)
	{
		int newW, newH;

		if (onlyReduceInSize && getWidth() <= width && getHeight() <= height)
		{
			newW = getWidth();
			newH = getHeight();
		}
		else
		{
			const double imageRatio = getHeight() / (double) getWidth();
			const double targetRatio = height / (double) width;

			if (imageRatio <= targetRatio)
			{
				newW = width;
				newH = jmin (height, roundToInt (newW * imageRatio));
			}
			else
			{
				newH = height;
				newW = jmin (width, roundToInt (newH / imageRatio));
			}
		}

		if (newW > 0 && newH > 0)
			setBounds (justification.appliedToRectangle (Rectangle<int> (newW, newH),
														 Rectangle<int> (x, y, width, height)));
	}
}

bool Component::isTransformed() const noexcept
{
	return affineTransform != nullptr;
}

void Component::setTransform (const AffineTransform& newTransform)
{
	// If you pass in a transform with no inverse, the component will have no dimensions,
	// and there will be all sorts of maths errors when converting coordinates.
	jassert (! newTransform.isSingularity());

	if (newTransform.isIdentity())
	{
		if (affineTransform != nullptr)
		{
			repaint();
			affineTransform = nullptr;
			repaint();

			sendMovedResizedMessages (false, false);
		}
	}
	else if (affineTransform == nullptr)
	{
		repaint();
		affineTransform = new AffineTransform (newTransform);
		repaint();
		sendMovedResizedMessages (false, false);
	}
	else if (*affineTransform != newTransform)
	{
		repaint();
		*affineTransform = newTransform;
		repaint();
		sendMovedResizedMessages (false, false);
	}
}

AffineTransform Component::getTransform() const
{
	return affineTransform != nullptr ? *affineTransform : AffineTransform::identity;
}

bool Component::hitTest (int x, int y)
{
	if (! flags.ignoresMouseClicksFlag)
		return true;

	if (flags.allowChildMouseClicksFlag)
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			Component& child = *childComponentList.getUnchecked (i);

			if (child.isVisible()
				 && ComponentHelpers::hitTest (child, ComponentHelpers::convertFromParentSpace (child, Point<int> (x, y))))
				return true;
		}
	}

	return false;
}

void Component::setInterceptsMouseClicks (const bool allowClicks,
										  const bool allowClicksOnChildComponents) noexcept
{
	flags.ignoresMouseClicksFlag = ! allowClicks;
	flags.allowChildMouseClicksFlag = allowClicksOnChildComponents;
}

void Component::getInterceptsMouseClicks (bool& allowsClicksOnThisComponent,
										  bool& allowsClicksOnChildComponents) const noexcept
{
	allowsClicksOnThisComponent = ! flags.ignoresMouseClicksFlag;
	allowsClicksOnChildComponents = flags.allowChildMouseClicksFlag;
}

bool Component::contains (const Point<int>& point)
{
	if (ComponentHelpers::hitTest (*this, point))
	{
		if (parentComponent != nullptr)
			return parentComponent->contains (ComponentHelpers::convertToParentSpace (*this, point));

		if (flags.hasHeavyweightPeerFlag)
		{
			const ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				return peer->contains (point, true);
		}
	}

	return false;
}

bool Component::reallyContains (const Point<int>& point, const bool returnTrueIfWithinAChild)
{
	if (! contains (point))
		return false;

	Component* const top = getTopLevelComponent();
	const Component* const compAtPosition = top->getComponentAt (top->getLocalPoint (this, point));

	return (compAtPosition == this) || (returnTrueIfWithinAChild && isParentOf (compAtPosition));
}

Component* Component::getComponentAt (const Point<int>& position)
{
	if (flags.visibleFlag && ComponentHelpers::hitTest (*this, position))
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			Component* child = childComponentList.getUnchecked(i);
			child = child->getComponentAt (ComponentHelpers::convertFromParentSpace (*child, position));

			if (child != nullptr)
				return child;
		}

		return this;
	}

	return nullptr;
}

Component* Component::getComponentAt (const int x, const int y)
{
	return getComponentAt (Point<int> (x, y));
}

void Component::addChildComponent (Component* const child, int zOrder)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager() || ! isShowing());

	if (child != nullptr && child->parentComponent != this)
	{
		if (child->parentComponent != nullptr)
			child->parentComponent->removeChildComponent (child);
		else
			child->removeFromDesktop();

		child->parentComponent = this;

		if (child->isVisible())
			child->repaintParent();

		if (! child->isAlwaysOnTop())
		{
			if (zOrder < 0 || zOrder > childComponentList.size())
				zOrder = childComponentList.size();

			while (zOrder > 0)
			{
				if (! childComponentList.getUnchecked (zOrder - 1)->isAlwaysOnTop())
					break;

				--zOrder;
			}
		}

		childComponentList.insert (zOrder, child);

		child->internalHierarchyChanged();
		internalChildrenChanged();
	}
}

void Component::addAndMakeVisible (Component* const child, int zOrder)
{
	if (child != nullptr)
	{
		child->setVisible (true);
		addChildComponent (child, zOrder);
	}
}

void Component::addChildAndSetID (Component* const child, const String& componentID)
{
	if (child != nullptr)
	{
		child->setComponentID (componentID);
		addAndMakeVisible (child);
	}
}

void Component::removeChildComponent (Component* const child)
{
	removeChildComponent (childComponentList.indexOf (child), true, true);
}

Component* Component::removeChildComponent (const int index)
{
	return removeChildComponent (index, true, true);
}

Component* Component::removeChildComponent (const int index, bool sendParentEvents, const bool sendChildEvents)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED_OR_OFFSCREEN

	Component* const child = childComponentList [index];

	if (child != nullptr)
	{
		sendParentEvents = sendParentEvents && child->isShowing();

		if (sendParentEvents)
		{
			sendFakeMouseMove();

			if (child->isVisible())
				child->repaintParent();
		}

		childComponentList.remove (index);
		child->parentComponent = nullptr;

		if (child->cachedImage != nullptr)
			child->cachedImage->releaseResources();

		// (NB: there are obscure situations where child->isShowing() = false, but it still has the focus)
		if (currentlyFocusedComponent == child || child->isParentOf (currentlyFocusedComponent))
		{
			if (sendParentEvents)
			{
				const WeakReference<Component> thisPointer (this);

				giveAwayFocus (sendChildEvents || currentlyFocusedComponent != child);

				if (thisPointer == nullptr)
					return child;

				grabKeyboardFocus();
			}
			else
			{
				giveAwayFocus (sendChildEvents || currentlyFocusedComponent != child);
			}
		}

		if (sendChildEvents)
			child->internalHierarchyChanged();

		if (sendParentEvents)
			internalChildrenChanged();
	}

	return child;
}

void Component::removeAllChildren()
{
	while (childComponentList.size() > 0)
		removeChildComponent (childComponentList.size() - 1);
}

void Component::deleteAllChildren()
{
	while (childComponentList.size() > 0)
		delete (removeChildComponent (childComponentList.size() - 1));
}

int Component::getNumChildComponents() const noexcept
{
	return childComponentList.size();
}

Component* Component::getChildComponent (const int index) const noexcept
{
	return childComponentList [index];
}

int Component::getIndexOfChildComponent (const Component* const child) const noexcept
{
	return childComponentList.indexOf (const_cast <Component*> (child));
}

Component* Component::findChildWithID (const String& targetID) const noexcept
{
	for (int i = childComponentList.size(); --i >= 0;)
	{
		Component* const c = childComponentList.getUnchecked(i);
		if (c->componentID == targetID)
			return c;
	}

	return nullptr;
}

Component* Component::getTopLevelComponent() const noexcept
{
	const Component* comp = this;

	while (comp->parentComponent != nullptr)
		comp = comp->parentComponent;

	return const_cast <Component*> (comp);
}

bool Component::isParentOf (const Component* possibleChild) const noexcept
{
	while (possibleChild != nullptr)
	{
		possibleChild = possibleChild->parentComponent;

		if (possibleChild == this)
			return true;
	}

	return false;
}

void Component::parentHierarchyChanged() {}
void Component::childrenChanged() {}

void Component::internalChildrenChanged()
{
	if (componentListeners.isEmpty())
	{
		childrenChanged();
	}
	else
	{
		BailOutChecker checker (this);

		childrenChanged();

		if (! checker.shouldBailOut())
			componentListeners.callChecked (checker, &ComponentListener::componentChildrenChanged, *this);
	}
}

void Component::internalHierarchyChanged()
{
	BailOutChecker checker (this);

	parentHierarchyChanged();

	if (checker.shouldBailOut())
		return;

	componentListeners.callChecked (checker, &ComponentListener::componentParentHierarchyChanged, *this);

	if (checker.shouldBailOut())
		return;

	for (int i = childComponentList.size(); --i >= 0;)
	{
		childComponentList.getUnchecked (i)->internalHierarchyChanged();

		if (checker.shouldBailOut())
		{
			// you really shouldn't delete the parent component during a callback telling you
			// that it's changed..
			jassertfalse;
			return;
		}

		i = jmin (i, childComponentList.size());
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
int Component::runModalLoop()
{
	if (! MessageManager::getInstance()->isThisTheMessageThread())
	{
		// use a callback so this can be called from non-gui threads
		return (int) (pointer_sized_int) MessageManager::getInstance()
										   ->callFunctionOnMessageThread (&ComponentHelpers::runModalLoopCallback, this);
	}

	if (! isCurrentlyModal())
		enterModalState (true);

	return ModalComponentManager::getInstance()->runEventLoopForCurrentComponent();
}
#endif

void Component::enterModalState (const bool shouldTakeKeyboardFocus,
								 ModalComponentManager::Callback* callback,
								 const bool deleteWhenDismissed)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	// Check for an attempt to make a component modal when it already is!
	// This can cause nasty problems..
	jassert (! flags.currentlyModalFlag);

	if (! isCurrentlyModal())
	{
		ModalComponentManager* const mcm = ModalComponentManager::getInstance();
		mcm->startModal (this, deleteWhenDismissed);
		mcm->attachCallback (this, callback);

		flags.currentlyModalFlag = true;
		setVisible (true);

		if (shouldTakeKeyboardFocus)
			grabKeyboardFocus();
	}
}

void Component::exitModalState (const int returnValue)
{
	if (flags.currentlyModalFlag)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			ModalComponentManager::getInstance()->endModal (this, returnValue);
			flags.currentlyModalFlag = false;

			ModalComponentManager::getInstance()->bringModalComponentsToFront();
		}
		else
		{
			class ExitModalStateMessage   : public CallbackMessage
			{
			public:
				ExitModalStateMessage (Component* const target_, const int result_)
					: target (target_), result (result_)   {}

				void messageCallback()
				{
					if (target.get() != nullptr) // (get() required for VS2003 bug)
						target->exitModalState (result);
				}

			private:
				WeakReference<Component> target;
				int result;
			};

			(new ExitModalStateMessage (this, returnValue))->post();
		}
	}
}

bool Component::isCurrentlyModal() const noexcept
{
	return flags.currentlyModalFlag
			&& getCurrentlyModalComponent() == this;
}

bool Component::isCurrentlyBlockedByAnotherModalComponent() const
{
	Component* const mc = getCurrentlyModalComponent();

	return ! (mc == nullptr || mc == this || mc->isParentOf (this)
			   || mc->canModalEventBeSentToComponent (this));
}

int JUCE_CALLTYPE Component::getNumCurrentlyModalComponents() noexcept
{
	return ModalComponentManager::getInstance()->getNumModalComponents();
}

Component* JUCE_CALLTYPE Component::getCurrentlyModalComponent (int index) noexcept
{
	return ModalComponentManager::getInstance()->getModalComponent (index);
}

void Component::setBroughtToFrontOnMouseClick (const bool shouldBeBroughtToFront) noexcept
{
	flags.bringToFrontOnClickFlag = shouldBeBroughtToFront;
}

bool Component::isBroughtToFrontOnMouseClick() const noexcept
{
	return flags.bringToFrontOnClickFlag;
}

void Component::setMouseCursor (const MouseCursor& newCursor)
{
	if (cursor != newCursor)
	{
		cursor = newCursor;

		if (flags.visibleFlag)
			updateMouseCursor();
	}
}

MouseCursor Component::getMouseCursor()
{
	return cursor;
}

void Component::updateMouseCursor() const
{
	Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
}

void Component::setRepaintsOnMouseActivity (const bool shouldRepaint) noexcept
{
	flags.repaintOnMouseActivityFlag = shouldRepaint;
}

void Component::setAlpha (const float newAlpha)
{
	const uint8 newIntAlpha = (uint8) (255 - jlimit (0, 255, roundToInt (newAlpha * 255.0)));

	if (componentTransparency != newIntAlpha)
	{
		componentTransparency = newIntAlpha;

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				peer->setAlpha (newAlpha);
		}
		else
		{
			repaint();
		}
	}
}

float Component::getAlpha() const
{
	return (255 - componentTransparency) / 255.0f;
}

void Component::repaint()
{
	internalRepaintUnchecked (getLocalBounds(), true);
}

void Component::repaint (const int x, const int y, const int w, const int h)
{
	internalRepaint (Rectangle<int> (x, y, w, h));
}

void Component::repaint (const Rectangle<int>& area)
{
	internalRepaint (area);
}

void Component::repaintParent()
{
	if (parentComponent != nullptr)
		parentComponent->internalRepaint (ComponentHelpers::convertToParentSpace (*this, getLocalBounds()));
}

void Component::internalRepaint (const Rectangle<int>& area)
{
	const Rectangle<int> r (area.getIntersection (getLocalBounds()));

	if (! r.isEmpty())
		internalRepaintUnchecked (r, false);
}

void Component::internalRepaintUnchecked (const Rectangle<int>& area, const bool isEntireComponent)
{
	if (flags.visibleFlag)
	{
		if (cachedImage != nullptr)
		{
			if (isEntireComponent)
				cachedImage->invalidateAll();
			else
				cachedImage->invalidate (area);
		}

		if (flags.hasHeavyweightPeerFlag)
		{
			// if component methods are being called from threads other than the message
			// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
			CHECK_MESSAGE_MANAGER_IS_LOCKED

			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				peer->repaint (area);
		}
		else
		{
			if (parentComponent != nullptr)
				parentComponent->internalRepaint (ComponentHelpers::convertToParentSpace (*this, area));
		}
	}
}

void Component::paint (Graphics&)
{
	// all painting is done in the subclasses

	jassert (! isOpaque()); // if your component's opaque, you've gotta paint it!
}

void Component::paintOverChildren (Graphics&)
{
	// all painting is done in the subclasses
}

void Component::paintWithinParentContext (Graphics& g)
{
	g.setOrigin (getX(), getY());

	if (cachedImage != nullptr)
		cachedImage->paint (g);
	else
		paintEntireComponent (g, false);
}

void Component::paintComponentAndChildren (Graphics& g)
{
	const Rectangle<int> clipBounds (g.getClipBounds());

	if (flags.dontClipGraphicsFlag)
	{
		paint (g);
	}
	else
	{
		g.saveState();
		ComponentHelpers::clipObscuredRegions (*this, g, clipBounds, Point<int>());

		if (! g.isClipEmpty())
			paint (g);

		g.restoreState();
	}

	for (int i = 0; i < childComponentList.size(); ++i)
	{
		Component& child = *childComponentList.getUnchecked (i);

		if (child.isVisible())
		{
			if (child.affineTransform != nullptr)
			{
				g.saveState();
				g.addTransform (*child.affineTransform);

				if ((child.flags.dontClipGraphicsFlag && ! g.isClipEmpty()) || g.reduceClipRegion (child.getBounds()))
					child.paintWithinParentContext (g);

				g.restoreState();
			}
			else if (clipBounds.intersects (child.getBounds()))
			{
				g.saveState();

				if (child.flags.dontClipGraphicsFlag)
				{
					child.paintWithinParentContext (g);
				}
				else if (g.reduceClipRegion (child.getBounds()))
				{
					bool nothingClipped = true;

					for (int j = i + 1; j < childComponentList.size(); ++j)
					{
						const Component& sibling = *childComponentList.getUnchecked (j);

						if (sibling.flags.opaqueFlag && sibling.isVisible() && sibling.affineTransform == nullptr)
						{
							nothingClipped = false;
							g.excludeClipRegion (sibling.getBounds());
						}
					}

					if (nothingClipped || ! g.isClipEmpty())
						child.paintWithinParentContext (g);
				}

				g.restoreState();
			}
		}
	}

	g.saveState();
	paintOverChildren (g);
	g.restoreState();
}

void Component::paintEntireComponent (Graphics& g, const bool ignoreAlphaLevel)
{
   #if JUCE_DEBUG
	flags.isInsidePaintCall = true;
   #endif

	if (effect != nullptr)
	{
		Image effectImage (flags.opaqueFlag ? Image::RGB : Image::ARGB,
						   getWidth(), getHeight(), ! flags.opaqueFlag);
		{
			Graphics g2 (effectImage);
			paintComponentAndChildren (g2);
		}

		effect->applyEffect (effectImage, g, ignoreAlphaLevel ? 1.0f : getAlpha());
	}
	else if (componentTransparency > 0 && ! ignoreAlphaLevel)
	{
		if (componentTransparency < 255)
		{
			g.beginTransparencyLayer (getAlpha());
			paintComponentAndChildren (g);
			g.endTransparencyLayer();
		}
	}
	else
	{
		paintComponentAndChildren (g);
	}

   #if JUCE_DEBUG
	flags.isInsidePaintCall = false;
   #endif
}

void Component::setPaintingIsUnclipped (const bool shouldPaintWithoutClipping) noexcept
{
	flags.dontClipGraphicsFlag = shouldPaintWithoutClipping;
}

Image Component::createComponentSnapshot (const Rectangle<int>& areaToGrab,
										  const bool clipImageToComponentBounds)
{
	Rectangle<int> r (areaToGrab);

	if (clipImageToComponentBounds)
		r = r.getIntersection (getLocalBounds());

	Image componentImage (flags.opaqueFlag ? Image::RGB : Image::ARGB,
						  jmax (1, r.getWidth()),
						  jmax (1, r.getHeight()),
						  true);

	Graphics imageContext (componentImage);
	imageContext.setOrigin (-r.getX(), -r.getY());
	paintEntireComponent (imageContext, true);

	return componentImage;
}

void Component::setComponentEffect (ImageEffectFilter* const newEffect)
{
	if (effect != newEffect)
	{
		effect = newEffect;
		repaint();
	}
}

LookAndFeel& Component::getLookAndFeel() const noexcept
{
	const Component* c = this;

	do
	{
		if (c->lookAndFeel != nullptr)
			return *(c->lookAndFeel);

		c = c->parentComponent;
	}
	while (c != nullptr);

	return LookAndFeel::getDefaultLookAndFeel();
}

void Component::setLookAndFeel (LookAndFeel* const newLookAndFeel)
{
	if (lookAndFeel != newLookAndFeel)
	{
		lookAndFeel = newLookAndFeel;
		sendLookAndFeelChange();
	}
}

void Component::lookAndFeelChanged() {}
void Component::colourChanged() {}

void Component::sendLookAndFeelChange()
{
	const WeakReference<Component> safePointer (this);
	repaint();
	lookAndFeelChanged();

	if (safePointer != nullptr)
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			childComponentList.getUnchecked (i)->sendLookAndFeelChange();

			if (safePointer == nullptr)
				return;

			i = jmin (i, childComponentList.size());
		}
	}
}

Colour Component::findColour (const int colourId, const bool inheritFromParent) const
{
	const var* const v = properties.getVarPointer (ComponentHelpers::getColourPropertyId (colourId));

	if (v != nullptr)
		return Colour ((uint32) static_cast <int> (*v));

	if (inheritFromParent && parentComponent != nullptr
		 && (lookAndFeel == nullptr || ! lookAndFeel->isColourSpecified (colourId)))
		return parentComponent->findColour (colourId, true);

	return getLookAndFeel().findColour (colourId);
}

bool Component::isColourSpecified (const int colourId) const
{
	return properties.contains (ComponentHelpers::getColourPropertyId (colourId));
}

void Component::removeColour (const int colourId)
{
	if (properties.remove (ComponentHelpers::getColourPropertyId (colourId)))
		colourChanged();
}

void Component::setColour (const int colourId, const Colour& colour)
{
	if (properties.set (ComponentHelpers::getColourPropertyId (colourId), (int) colour.getARGB()))
		colourChanged();
}

void Component::copyAllExplicitColoursTo (Component& target) const
{
	bool changed = false;

	for (int i = properties.size(); --i >= 0;)
	{
		const Identifier name (properties.getName(i));

		if (name.toString().startsWith ("jcclr_"))
			if (target.properties.set (name, properties [name]))
				changed = true;
	}

	if (changed)
		target.colourChanged();
}

MarkerList* Component::getMarkers (bool /*xAxis*/)
{
	return nullptr;
}

Component::Positioner::Positioner (Component& component_) noexcept
	: component (component_)
{
}

Component::Positioner* Component::getPositioner() const noexcept
{
	return positioner;
}

void Component::setPositioner (Positioner* newPositioner)
{
	// You can only assign a positioner to the component that it was created for!
	jassert (newPositioner == nullptr || this == &(newPositioner->getComponent()));
	positioner = newPositioner;
}

Rectangle<int> Component::getLocalBounds() const noexcept
{
	return bounds.withZeroOrigin();
}

Rectangle<int> Component::getBoundsInParent() const noexcept
{
	return affineTransform == nullptr ? bounds
									  : bounds.toFloat().transformed (*affineTransform).getSmallestIntegerContainer();
}

void Component::getVisibleArea (RectangleList& result, const bool includeSiblings) const
{
	result.clear();
	const Rectangle<int> unclipped (ComponentHelpers::getUnclippedArea (*this));

	if (! unclipped.isEmpty())
	{
		result.add (unclipped);

		if (includeSiblings)
		{
			const Component* const c = getTopLevelComponent();

			ComponentHelpers::subtractObscuredRegions (*c, result, getLocalPoint (c, Point<int>()),
													   c->getLocalBounds(), this);
		}

		ComponentHelpers::subtractObscuredRegions (*this, result, Point<int>(), unclipped, nullptr);
		result.consolidate();
	}
}

void Component::mouseEnter (const MouseEvent&)          {}
void Component::mouseExit  (const MouseEvent&)          {}
void Component::mouseDown  (const MouseEvent&)          {}
void Component::mouseUp    (const MouseEvent&)          {}
void Component::mouseDrag  (const MouseEvent&)          {}
void Component::mouseMove  (const MouseEvent&)          {}
void Component::mouseDoubleClick (const MouseEvent&)    {}

void Component::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	// the base class just passes this event up to its parent..
	if (parentComponent != nullptr)
		parentComponent->mouseWheelMove (e.getEventRelativeTo (parentComponent),
										 wheelIncrementX, wheelIncrementY);
}

void Component::resized()                       {}
void Component::moved()                         {}
void Component::childBoundsChanged (Component*) {}
void Component::parentSizeChanged()             {}

void Component::addComponentListener (ComponentListener* const newListener)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	componentListeners.add (newListener);
}

void Component::removeComponentListener (ComponentListener* const listenerToRemove)
{
	componentListeners.remove (listenerToRemove);
}

void Component::inputAttemptWhenModal()
{
	ModalComponentManager::getInstance()->bringModalComponentsToFront();
	getLookAndFeel().playAlertSound();
}

bool Component::canModalEventBeSentToComponent (const Component*)
{
	return false;
}

void Component::internalModalInputAttempt()
{
	Component* const current = getCurrentlyModalComponent();

	if (current != nullptr)
		current->inputAttemptWhenModal();
}

void Component::postCommandMessage (const int commandId)
{
	class CustomCommandMessage   : public CallbackMessage
	{
	public:
		CustomCommandMessage (Component* const target_, const int commandId_)
			: target (target_), commandId (commandId_) {}

		void messageCallback()
		{
			if (target.get() != nullptr)  // (get() required for VS2003 bug)
				target->handleCommandMessage (commandId);
		}

	private:
		WeakReference<Component> target;
		int commandId;
	};

	(new CustomCommandMessage (this, commandId))->post();
}

void Component::handleCommandMessage (int)
{
	// used by subclasses
}

void Component::addMouseListener (MouseListener* const newListener,
								  const bool wantsEventsForAllNestedChildComponents)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	// If you register a component as a mouselistener for itself, it'll receive all the events
	// twice - once via the direct callback that all components get anyway, and then again as a listener!
	jassert ((newListener != this) || wantsEventsForAllNestedChildComponents);

	if (mouseListeners == nullptr)
		mouseListeners = new MouseListenerList();

	mouseListeners->addListener (newListener, wantsEventsForAllNestedChildComponents);
}

void Component::removeMouseListener (MouseListener* const listenerToRemove)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (mouseListeners != nullptr)
		mouseListeners->removeListener (listenerToRemove);
}

void Component::internalMouseEnter (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// if something else is modal, always just show a normal mouse cursor
		source.showMouseCursor (MouseCursor::NormalCursor);
		return;
	}

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);
	mouseEnter (me);

	if (checker.shouldBailOut())
		return;

	Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseEnter, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseEnter, me);
}

void Component::internalMouseExit (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	if (isCurrentlyBlockedByAnotherModalComponent() && source.getComponentUnderMouse() != this)
		return;

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);

	mouseExit (me);

	if (checker.shouldBailOut())
		return;

	Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseExit, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseExit, me);
}

void Component::internalMouseDown (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	Desktop& desktop = Desktop::getInstance();

	BailOutChecker checker (this);

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		internalModalInputAttempt();

		if (checker.shouldBailOut())
			return;

		// If processing the input attempt has exited the modal loop, we'll allow the event
		// to be delivered..
		if (isCurrentlyBlockedByAnotherModalComponent())
		{
			// allow blocked mouse-events to go to global listeners..
			const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
								 this, this, time, relativePos, time,
								 source.getNumberOfMultipleClicks(), false);

			desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseDown, me);
			return;
		}
	}

	for (Component* c = this; c != nullptr; c = c->parentComponent)
	{
		if (c->isBroughtToFrontOnMouseClick())
		{
			c->toFront (true);

			if (checker.shouldBailOut())
				return;
		}
	}

	if (! flags.dontFocusOnMouseClickFlag)
	{
		grabFocusInternal (focusChangedByMouseClick, true);

		if (checker.shouldBailOut())
			return;
	}

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time,
						 source.getNumberOfMultipleClicks(), false);
	mouseDown (me);

	if (checker.shouldBailOut())
		return;

	desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseDown, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDown, me);
}

void Component::internalMouseUp (MouseInputSource& source, const Point<int>& relativePos, const Time& time, const ModifierKeys& oldModifiers)
{
	if (! isCurrentlyBlockedByAnotherModalComponent())
	{
		BailOutChecker checker (this);

		if (flags.repaintOnMouseActivityFlag)
			repaint();

		const MouseEvent me (source, relativePos,
							 oldModifiers, this, this, time,
							 getLocalPoint (nullptr, source.getLastMouseDownPosition()),
							 source.getLastMouseDownTime(),
							 source.getNumberOfMultipleClicks(),
							 source.hasMouseMovedSignificantlySincePressed());
		mouseUp (me);

		if (checker.shouldBailOut())
			return;

		Desktop& desktop = Desktop::getInstance();
		desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseUp, me);

		MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseUp, me);

		if (checker.shouldBailOut())
			return;

		// check for double-click
		if (me.getNumberOfClicks() >= 2)
		{
			mouseDoubleClick (me);

			if (checker.shouldBailOut())
				return;

			desktop.mouseListeners.callChecked (checker, &MouseListener::mouseDoubleClick, me);
			MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDoubleClick, me);
		}
	}
}

void Component::internalMouseDrag (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	if (! isCurrentlyBlockedByAnotherModalComponent())
	{
		BailOutChecker checker (this);

		const MouseEvent me (source, relativePos,
							 source.getCurrentModifiers(), this, this, time,
							 getLocalPoint (nullptr, source.getLastMouseDownPosition()),
							 source.getLastMouseDownTime(),
							 source.getNumberOfMultipleClicks(),
							 source.hasMouseMovedSignificantlySincePressed());
		mouseDrag (me);

		if (checker.shouldBailOut())
			return;

		Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseDrag, me);

		MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDrag, me);
	}
}

void Component::internalMouseMove (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	Desktop& desktop = Desktop::getInstance();

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// allow blocked mouse-events to go to global listeners..
		desktop.sendMouseMove();
	}
	else
	{
		BailOutChecker checker (this);

		const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
							 this, this, time, relativePos, time, 0, false);
		mouseMove (me);

		if (checker.shouldBailOut())
			return;

		desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseMove, me);

		MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseMove, me);
	}
}

void Component::internalMouseWheel (MouseInputSource& source, const Point<int>& relativePos,
									const Time& time, const float amountX, const float amountY)
{
	Desktop& desktop = Desktop::getInstance();
	BailOutChecker checker (this);

	const float wheelIncrementX = amountX / 256.0f;
	const float wheelIncrementY = amountY / 256.0f;

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// allow blocked mouse-events to go to global listeners..
		desktop.mouseListeners.callChecked (checker, &MouseListener::mouseWheelMove, me, wheelIncrementX, wheelIncrementY);
	}
	else
	{
		mouseWheelMove (me, wheelIncrementX, wheelIncrementY);

		if (checker.shouldBailOut())
			return;

		desktop.mouseListeners.callChecked (checker, &MouseListener::mouseWheelMove, me, wheelIncrementX, wheelIncrementY);

		if (! checker.shouldBailOut())
			MouseListenerList::sendWheelEvent (*this, checker, me, wheelIncrementX, wheelIncrementY);
	}
}

void Component::sendFakeMouseMove() const
{
	MouseInputSource& mainMouse = Desktop::getInstance().getMainMouseSource();

	if (! mainMouse.isDragging())
		mainMouse.triggerFakeMove();
}

void JUCE_CALLTYPE Component::beginDragAutoRepeat (const int interval)
{
	Desktop::getInstance().beginDragAutoRepeat (interval);
}

void Component::broughtToFront()
{
}

void Component::internalBroughtToFront()
{
	if (flags.hasHeavyweightPeerFlag)
		Desktop::getInstance().componentBroughtToFront (this);

	BailOutChecker checker (this);
	broughtToFront();

	if (checker.shouldBailOut())
		return;

	componentListeners.callChecked (checker, &ComponentListener::componentBroughtToFront, *this);

	if (checker.shouldBailOut())
		return;

	// When brought to the front and there's a modal component blocking this one,
	// we need to bring the modal one to the front instead..
	Component* const cm = getCurrentlyModalComponent();

	if (cm != nullptr && cm->getTopLevelComponent() != getTopLevelComponent())
		ModalComponentManager::getInstance()->bringModalComponentsToFront (false); // very important that this is false, otherwise in Windows,
																				   // non-front components can't get focus when another modal comp is
																				   // active, and therefore can't receive mouse-clicks
}

void Component::focusGained (FocusChangeType)   {}
void Component::focusLost (FocusChangeType)     {}
void Component::focusOfChildComponentChanged (FocusChangeType) {}

void Component::internalFocusGain (const FocusChangeType cause)
{
	internalFocusGain (cause, WeakReference<Component> (this));
}

void Component::internalFocusGain (const FocusChangeType cause, const WeakReference<Component>& safePointer)
{
	focusGained (cause);

	if (safePointer != nullptr)
		internalChildFocusChange (cause, safePointer);
}

void Component::internalFocusLoss (const FocusChangeType cause)
{
	const WeakReference<Component> safePointer (this);

	focusLost (focusChangedDirectly);

	if (safePointer != nullptr)
		internalChildFocusChange (cause, safePointer);
}

void Component::internalChildFocusChange (FocusChangeType cause, const WeakReference<Component>& safePointer)
{
	const bool childIsNowFocused = hasKeyboardFocus (true);

	if (flags.childCompFocusedFlag != childIsNowFocused)
	{
		flags.childCompFocusedFlag = childIsNowFocused;

		focusOfChildComponentChanged (cause);

		if (safePointer == nullptr)
			return;
	}

	if (parentComponent != nullptr)
		parentComponent->internalChildFocusChange (cause, WeakReference<Component> (parentComponent));
}

void Component::setWantsKeyboardFocus (const bool wantsFocus) noexcept
{
	flags.wantsFocusFlag = wantsFocus;
}

void Component::setMouseClickGrabsKeyboardFocus (const bool shouldGrabFocus)
{
	flags.dontFocusOnMouseClickFlag = ! shouldGrabFocus;
}

bool Component::getMouseClickGrabsKeyboardFocus() const noexcept
{
	return ! flags.dontFocusOnMouseClickFlag;
}

bool Component::getWantsKeyboardFocus() const noexcept
{
	return flags.wantsFocusFlag && ! flags.isDisabledFlag;
}

void Component::setFocusContainer (const bool shouldBeFocusContainer) noexcept
{
	flags.isFocusContainerFlag = shouldBeFocusContainer;
}

bool Component::isFocusContainer() const noexcept
{
	return flags.isFocusContainerFlag;
}

static const Identifier juce_explicitFocusOrderId ("_jexfo");

int Component::getExplicitFocusOrder() const
{
	return properties [juce_explicitFocusOrderId];
}

void Component::setExplicitFocusOrder (const int newFocusOrderIndex)
{
	properties.set (juce_explicitFocusOrderId, newFocusOrderIndex);
}

KeyboardFocusTraverser* Component::createFocusTraverser()
{
	if (flags.isFocusContainerFlag || parentComponent == nullptr)
		return new KeyboardFocusTraverser();

	return parentComponent->createFocusTraverser();
}

void Component::takeKeyboardFocus (const FocusChangeType cause)
{
	// give the focus to this component
	if (currentlyFocusedComponent != this)
	{
		// get the focus onto our desktop window
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			const WeakReference<Component> safePointer (this);
			peer->grabFocus();

			if (peer->isFocused() && currentlyFocusedComponent != this)
			{
				WeakReference<Component> componentLosingFocus (currentlyFocusedComponent);
				currentlyFocusedComponent = this;

				Desktop::getInstance().triggerFocusCallback();

				// call this after setting currentlyFocusedComponent so that the one that's
				// losing it has a chance to see where focus is going
				if (componentLosingFocus != nullptr)
					componentLosingFocus->internalFocusLoss (cause);

				if (currentlyFocusedComponent == this)
					internalFocusGain (cause, safePointer);
			}
		}
	}
}

void Component::grabFocusInternal (const FocusChangeType cause, const bool canTryParent)
{
	if (isShowing())
	{
		if (flags.wantsFocusFlag && (isEnabled() || parentComponent == nullptr))
		{
			takeKeyboardFocus (cause);
		}
		else
		{
			if (isParentOf (currentlyFocusedComponent)
				 && currentlyFocusedComponent->isShowing())
			{
				// do nothing if the focused component is actually a child of ours..
			}
			else
			{
				// find the default child component..
				ScopedPointer <KeyboardFocusTraverser> traverser (createFocusTraverser());

				if (traverser != nullptr)
				{
					Component* const defaultComp = traverser->getDefaultComponent (this);
					traverser = nullptr;

					if (defaultComp != nullptr)
					{
						defaultComp->grabFocusInternal (cause, false);
						return;
					}
				}

				if (canTryParent && parentComponent != nullptr)
				{
					// if no children want it and we're allowed to try our parent comp,
					// then pass up to parent, which will try our siblings.
					parentComponent->grabFocusInternal (cause, true);
				}
			}
		}
	}
}

void Component::grabKeyboardFocus()
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	grabFocusInternal (focusChangedDirectly, true);
}

void Component::moveKeyboardFocusToSibling (const bool moveToNext)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (parentComponent != nullptr)
	{
		ScopedPointer <KeyboardFocusTraverser> traverser (createFocusTraverser());

		if (traverser != nullptr)
		{
			Component* const nextComp = moveToNext ? traverser->getNextComponent (this)
												   : traverser->getPreviousComponent (this);
			traverser = nullptr;

			if (nextComp != nullptr)
			{
				if (nextComp->isCurrentlyBlockedByAnotherModalComponent())
				{
					const WeakReference<Component> nextCompPointer (nextComp);
					internalModalInputAttempt();

					if (nextCompPointer == nullptr || nextComp->isCurrentlyBlockedByAnotherModalComponent())
						return;
				}

				nextComp->grabFocusInternal (focusChangedByTabKey, true);
				return;
			}
		}

		parentComponent->moveKeyboardFocusToSibling (moveToNext);
	}
}

bool Component::hasKeyboardFocus (const bool trueIfChildIsFocused) const
{
	return (currentlyFocusedComponent == this)
			|| (trueIfChildIsFocused && isParentOf (currentlyFocusedComponent));
}

Component* JUCE_CALLTYPE Component::getCurrentlyFocusedComponent() noexcept
{
	return currentlyFocusedComponent;
}

void Component::giveAwayFocus (const bool sendFocusLossEvent)
{
	Component* const componentLosingFocus = currentlyFocusedComponent;
	currentlyFocusedComponent = nullptr;

	if (sendFocusLossEvent && componentLosingFocus != nullptr)
		componentLosingFocus->internalFocusLoss (focusChangedDirectly);

	Desktop::getInstance().triggerFocusCallback();
}

bool Component::isEnabled() const noexcept
{
	return (! flags.isDisabledFlag)
			&& (parentComponent == nullptr || parentComponent->isEnabled());
}

void Component::setEnabled (const bool shouldBeEnabled)
{
	if (flags.isDisabledFlag == shouldBeEnabled)
	{
		flags.isDisabledFlag = ! shouldBeEnabled;

		// if any parent components are disabled, setting our flag won't make a difference,
		// so no need to send a change message
		if (parentComponent == nullptr || parentComponent->isEnabled())
			sendEnablementChangeMessage();
	}
}

void Component::enablementChanged() {}

void Component::sendEnablementChangeMessage()
{
	const WeakReference<Component> safePointer (this);

	enablementChanged();

	if (safePointer == nullptr)
		return;

	for (int i = getNumChildComponents(); --i >= 0;)
	{
		Component* const c = getChildComponent (i);

		if (c != nullptr)
		{
			c->sendEnablementChangeMessage();

			if (safePointer == nullptr)
				return;
		}
	}
}

bool Component::isMouseOver (const bool includeChildren) const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
	{
		const MouseInputSource* const mi = desktop.getMouseSource(i);

		Component* const c = mi->getComponentUnderMouse();

		if ((c == this || (includeChildren && isParentOf (c)))
			  && c->reallyContains (c->getLocalPoint (nullptr, mi->getScreenPosition()), false))
			return true;
	}

	return false;
}

bool Component::isMouseButtonDown() const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
	{
		const MouseInputSource* const mi = desktop.getMouseSource(i);

		if (mi->isDragging() && mi->getComponentUnderMouse() == this)
			return true;
	}

	return false;
}

bool Component::isMouseOverOrDragging() const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
		if (desktop.getMouseSource(i)->getComponentUnderMouse() == this)
			return true;

	return false;
}

bool JUCE_CALLTYPE Component::isMouseButtonDownAnywhere() noexcept
{
	return ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown();
}

Point<int> Component::getMouseXYRelative() const
{
	return getLocalPoint (nullptr, Desktop::getMousePosition());
}

void Component::addKeyListener (KeyListener* const newListener)
{
	if (keyListeners == nullptr)
		keyListeners = new Array <KeyListener*>();

	keyListeners->addIfNotAlreadyThere (newListener);
}

void Component::removeKeyListener (KeyListener* const listenerToRemove)
{
	if (keyListeners != nullptr)
		keyListeners->removeValue (listenerToRemove);
}

bool Component::keyPressed (const KeyPress&)                { return false; }
bool Component::keyStateChanged (const bool /*isKeyDown*/)  { return false; }

void Component::modifierKeysChanged (const ModifierKeys& modifiers)
{
	if (parentComponent != nullptr)
		parentComponent->modifierKeysChanged (modifiers);
}

void Component::internalModifierKeysChanged()
{
	sendFakeMouseMove();
	modifierKeysChanged (ModifierKeys::getCurrentModifiers());
}

Component::BailOutChecker::BailOutChecker (Component* const component)
	: safePointer (component)
{
	jassert (component != nullptr);
}

bool Component::BailOutChecker::shouldBailOut() const noexcept
{
	return safePointer == nullptr;
}

/*** End of inlined file: juce_Component.cpp ***/



/*** Start of inlined file: juce_ComponentListener.cpp ***/
void ComponentListener::componentMovedOrResized (Component&, bool, bool)    {}
void ComponentListener::componentBroughtToFront (Component&)                {}
void ComponentListener::componentVisibilityChanged (Component&)             {}
void ComponentListener::componentChildrenChanged (Component&)               {}
void ComponentListener::componentParentHierarchyChanged (Component&)        {}
void ComponentListener::componentNameChanged (Component&)                   {}
void ComponentListener::componentBeingDeleted (Component&)                  {}

/*** End of inlined file: juce_ComponentListener.cpp ***/


/*** Start of inlined file: juce_Desktop.cpp ***/
Desktop::Desktop()
	: mouseClickCounter (0),
	  kioskModeComponent (nullptr),
	  allowedOrientations (allOrientations)
{
	createMouseInputSources();
}

Desktop::~Desktop()
{
	setScreenSaverEnabled (true);

	jassert (instance == this);
	instance = nullptr;

	// doh! If you don't delete all your windows before exiting, you're going to
	// be leaking memory!
	jassert (desktopComponents.size() == 0);
}

Desktop& JUCE_CALLTYPE Desktop::getInstance()
{
	if (instance == nullptr)
		instance = new Desktop();

	return *instance;
}

Desktop* Desktop::instance = nullptr;

int Desktop::getNumComponents() const noexcept
{
	return desktopComponents.size();
}

Component* Desktop::getComponent (const int index) const noexcept
{
	return desktopComponents [index];
}

Component* Desktop::findComponentAt (const Point<int>& screenPosition) const
{
	for (int i = desktopComponents.size(); --i >= 0;)
	{
		Component* const c = desktopComponents.getUnchecked(i);

		if (c->isVisible())
		{
			const Point<int> relative (c->getLocalPoint (nullptr, screenPosition));

			if (c->contains (relative))
				return c->getComponentAt (relative);
		}
	}

	return nullptr;
}

LookAndFeel& Desktop::getDefaultLookAndFeel() noexcept
{
	if (currentLookAndFeel == nullptr)
	{
		if (defaultLookAndFeel == nullptr)
			defaultLookAndFeel = new LookAndFeel();

		currentLookAndFeel = defaultLookAndFeel;
	}

	return *currentLookAndFeel;
}

void Desktop::setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel)
{
	currentLookAndFeel = newDefaultLookAndFeel;

	for (int i = getNumComponents(); --i >= 0;)
	{
		Component* const c = getComponent (i);

		if (c != nullptr)
			c->sendLookAndFeelChange();
	}
}

void Desktop::addDesktopComponent (Component* const c)
{
	jassert (c != nullptr);
	jassert (! desktopComponents.contains (c));
	desktopComponents.addIfNotAlreadyThere (c);
}

void Desktop::removeDesktopComponent (Component* const c)
{
	desktopComponents.removeValue (c);
}

void Desktop::componentBroughtToFront (Component* const c)
{
	const int index = desktopComponents.indexOf (c);
	jassert (index >= 0);

	if (index >= 0)
	{
		int newIndex = -1;

		if (! c->isAlwaysOnTop())
		{
			newIndex = desktopComponents.size();

			while (newIndex > 0 && desktopComponents.getUnchecked (newIndex - 1)->isAlwaysOnTop())
				--newIndex;

			--newIndex;
		}

		desktopComponents.move (index, newIndex);
	}
}

Point<int> Desktop::getMousePosition()
{
	return getInstance().getMainMouseSource().getScreenPosition();
}

Point<int> Desktop::getLastMouseDownPosition()
{
	return getInstance().getMainMouseSource().getLastMouseDownPosition();
}

int Desktop::getMouseButtonClickCounter()
{
	return getInstance().mouseClickCounter;
}

void Desktop::incrementMouseClickCounter() noexcept
{
	++mouseClickCounter;
}

int Desktop::getNumDraggingMouseSources() const noexcept
{
	int num = 0;
	for (int i = mouseSources.size(); --i >= 0;)
		if (mouseSources.getUnchecked(i)->isDragging())
			++num;

	return num;
}

MouseInputSource* Desktop::getDraggingMouseSource (int index) const noexcept
{
	int num = 0;
	for (int i = mouseSources.size(); --i >= 0;)
	{
		MouseInputSource* const mi = mouseSources.getUnchecked(i);

		if (mi->isDragging())
		{
			if (index == num)
				return mi;

			++num;
		}
	}

	return nullptr;
}

class MouseDragAutoRepeater  : public Timer
{
public:
	MouseDragAutoRepeater() {}

	void timerCallback()
	{
		Desktop& desktop = Desktop::getInstance();
		int numMiceDown = 0;

		for (int i = desktop.getNumMouseSources(); --i >= 0;)
		{
			MouseInputSource* const source = desktop.getMouseSource(i);
			if (source->isDragging())
			{
				source->triggerFakeMove();
				++numMiceDown;
			}
		}

		if (numMiceDown == 0)
			desktop.beginDragAutoRepeat (0);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (MouseDragAutoRepeater);
};

void Desktop::beginDragAutoRepeat (const int interval)
{
	if (interval > 0)
	{
		if (dragRepeater == nullptr)
			dragRepeater = new MouseDragAutoRepeater();

		if (dragRepeater->getTimerInterval() != interval)
			dragRepeater->startTimer (interval);
	}
	else
	{
		dragRepeater = nullptr;
	}
}

void Desktop::addFocusChangeListener (FocusChangeListener* const listener)
{
	focusListeners.add (listener);
}

void Desktop::removeFocusChangeListener (FocusChangeListener* const listener)
{
	focusListeners.remove (listener);
}

void Desktop::triggerFocusCallback()
{
	triggerAsyncUpdate();
}

void Desktop::handleAsyncUpdate()
{
	// The component may be deleted during this operation, but we'll use a SafePointer rather than a
	// BailOutChecker so that any remaining listeners will still get a callback (with a null pointer).
	WeakReference<Component> currentFocus (Component::getCurrentlyFocusedComponent());
	focusListeners.call (&FocusChangeListener::globalFocusChanged, currentFocus);
}

void Desktop::resetTimer()
{
	if (mouseListeners.size() == 0)
		stopTimer();
	else
		startTimer (100);

	lastFakeMouseMove = getMousePosition();
}

ListenerList <MouseListener>& Desktop::getMouseListeners()
{
	resetTimer();
	return mouseListeners;
}

void Desktop::addGlobalMouseListener (MouseListener* const listener)
{
	mouseListeners.add (listener);
	resetTimer();
}

void Desktop::removeGlobalMouseListener (MouseListener* const listener)
{
	mouseListeners.remove (listener);
	resetTimer();
}

void Desktop::timerCallback()
{
	if (lastFakeMouseMove != getMousePosition())
		sendMouseMove();
}

void Desktop::sendMouseMove()
{
	if (! mouseListeners.isEmpty())
	{
		startTimer (20);

		lastFakeMouseMove = getMousePosition();

		Component* const target = findComponentAt (lastFakeMouseMove);

		if (target != nullptr)
		{
			Component::BailOutChecker checker (target);
			const Point<int> pos (target->getLocalPoint (nullptr, lastFakeMouseMove));
			const Time now (Time::getCurrentTime());

			const MouseEvent me (getMainMouseSource(), pos, ModifierKeys::getCurrentModifiers(),
								 target, target, now, pos, now, 0, false);

			if (me.mods.isAnyMouseButtonDown())
				mouseListeners.callChecked (checker, &MouseListener::mouseDrag, me);
			else
				mouseListeners.callChecked (checker, &MouseListener::mouseMove, me);
		}
	}
}

Desktop::Displays::Displays()   { refresh(); }
Desktop::Displays::~Displays()  {}

const Desktop::Displays::Display& Desktop::Displays::getMainDisplay() const noexcept
{
	jassert (displays.getReference(0).isMain);
	return displays.getReference(0);
}

const Desktop::Displays::Display& Desktop::Displays::getDisplayContaining (const Point<int>& position) const noexcept
{
	const Display* best = &displays.getReference(0);
	double bestDistance = 1.0e10;

	for (int i = displays.size(); --i >= 0;)
	{
		const Display& d = displays.getReference(i);

		if (d.totalArea.contains (position))
		{
			best = &d;
			break;
		}

		const double distance = d.totalArea.getCentre().getDistanceFrom (position);

		if (distance < bestDistance)
		{
			bestDistance = distance;
			best = &d;
		}
	}

	return *best;
}

RectangleList Desktop::Displays::getRectangleList (bool userAreasOnly) const
{
	RectangleList rl;

	for (int i = 0; i < displays.size(); ++i)
	{
		const Display& d = displays.getReference(i);
		rl.addWithoutMerging (userAreasOnly ? d.userArea : d.totalArea);
	}

	return rl;
}

Rectangle<int> Desktop::Displays::getTotalBounds (bool userAreasOnly) const
{
	return getRectangleList (userAreasOnly).getBounds();
}

bool operator== (const Desktop::Displays::Display& d1, const Desktop::Displays::Display& d2) noexcept
{
	return d1.userArea == d2.userArea
		&& d1.totalArea == d2.totalArea
		&& d1.scale == d2.scale
		&& d1.isMain == d2.isMain;
}

bool operator!= (const Desktop::Displays::Display& d1, const Desktop::Displays::Display& d2) noexcept
{
	return ! (d1 == d2);
}

void Desktop::Displays::refresh()
{
	Array<Display> oldDisplays;
	oldDisplays.swapWithArray (displays);

	findDisplays();
	jassert (displays.size() > 0);

	if (oldDisplays != displays)
	{
		for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		{
			ComponentPeer* const p = ComponentPeer::getPeer (i);
			if (p != nullptr)
				p->handleScreenSizeChange();
		}
	}
}

void Desktop::setKioskModeComponent (Component* componentToUse, const bool allowMenusAndBars)
{
	if (kioskModeComponent != componentToUse)
	{
		// agh! Don't delete or remove a component from the desktop while it's still the kiosk component!
		jassert (kioskModeComponent == nullptr || ComponentPeer::getPeerFor (kioskModeComponent) != nullptr);

		if (kioskModeComponent != nullptr)
		{
			setKioskComponent (kioskModeComponent, false, allowMenusAndBars);

			kioskModeComponent->setBounds (kioskComponentOriginalBounds);
		}

		kioskModeComponent = componentToUse;

		if (kioskModeComponent != nullptr)
		{
			// Only components that are already on the desktop can be put into kiosk mode!
			jassert (ComponentPeer::getPeerFor (kioskModeComponent) != nullptr);

			kioskComponentOriginalBounds = kioskModeComponent->getBounds();

			setKioskComponent (kioskModeComponent, true, allowMenusAndBars);
		}
	}
}

void Desktop::setOrientationsEnabled (const int newOrientations)
{
	// Dodgy set of flags being passed here! Make sure you specify at least one permitted orientation.
	jassert (newOrientations != 0 && (newOrientations & ~allOrientations) == 0);

	allowedOrientations = newOrientations;
}

bool Desktop::isOrientationEnabled (const DisplayOrientation orientation) const noexcept
{
	// Make sure you only pass one valid flag in here...
	jassert (orientation == upright || orientation == upsideDown || orientation == rotatedClockwise || orientation ==  rotatedAntiClockwise);

	return (allowedOrientations & orientation) != 0;
}

/*** End of inlined file: juce_Desktop.cpp ***/


/*** Start of inlined file: juce_ModalComponentManager.cpp ***/
class ModalComponentManager::ModalItem  : public ComponentMovementWatcher
{
public:
	ModalItem (Component* const comp, const bool autoDelete_)
		: ComponentMovementWatcher (comp),
		  component (comp), returnValue (0),
		  isActive (true), autoDelete (autoDelete_)
	{
		jassert (comp != nullptr);
	}

	void componentMovedOrResized (bool, bool) {}

	void componentPeerChanged()
	{
		if (! component->isShowing())
			cancel();
	}

	void componentVisibilityChanged()
	{
		if (! component->isShowing())
			cancel();
	}

	void componentBeingDeleted (Component& comp)
	{
		ComponentMovementWatcher::componentBeingDeleted (comp);

		if (component == &comp || comp.isParentOf (component))
		{
			autoDelete = false;
			cancel();
		}
	}

	void cancel()
	{
		if (isActive)
		{
			isActive = false;
			ModalComponentManager::getInstance()->triggerAsyncUpdate();
		}
	}

	Component* component;
	OwnedArray<Callback> callbacks;
	int returnValue;
	bool isActive, autoDelete;

private:
	JUCE_DECLARE_NON_COPYABLE (ModalItem);
};

ModalComponentManager::ModalComponentManager()
{
}

ModalComponentManager::~ModalComponentManager()
{
	clearSingletonInstance();
}

juce_ImplementSingleton_SingleThreaded (ModalComponentManager);

void ModalComponentManager::startModal (Component* component, bool autoDelete)
{
	if (component != nullptr)
		stack.add (new ModalItem (component, autoDelete));
}

void ModalComponentManager::attachCallback (Component* component, Callback* callback)
{
	if (callback != nullptr)
	{
		ScopedPointer<Callback> callbackDeleter (callback);

		for (int i = stack.size(); --i >= 0;)
		{
			ModalItem* const item = stack.getUnchecked(i);

			if (item->component == component)
			{
				item->callbacks.add (callback);
				callbackDeleter.release();
				break;
			}
		}
	}
}

void ModalComponentManager::endModal (Component* component)
{
	for (int i = stack.size(); --i >= 0;)
	{
		ModalItem* const item = stack.getUnchecked(i);

		if (item->component == component)
			item->cancel();
	}
}

void ModalComponentManager::endModal (Component* component, int returnValue)
{
	for (int i = stack.size(); --i >= 0;)
	{
		ModalItem* const item = stack.getUnchecked(i);

		if (item->component == component)
		{
			item->returnValue = returnValue;
			item->cancel();
		}
	}
}

int ModalComponentManager::getNumModalComponents() const
{
	int n = 0;
	for (int i = 0; i < stack.size(); ++i)
		if (stack.getUnchecked(i)->isActive)
			++n;

	return n;
}

Component* ModalComponentManager::getModalComponent (const int index) const
{
	int n = 0;
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);
		if (item->isActive)
			if (n++ == index)
				return item->component;
	}

	return nullptr;
}

bool ModalComponentManager::isModal (Component* const comp) const
{
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);
		if (item->isActive && item->component == comp)
			return true;
	}

	return false;
}

bool ModalComponentManager::isFrontModalComponent (Component* const comp) const
{
	return comp == getModalComponent (0);
}

void ModalComponentManager::handleAsyncUpdate()
{
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);

		if (! item->isActive)
		{
			ScopedPointer<ModalItem> deleter (stack.removeAndReturn (i));
			Component::SafePointer<Component> compToDelete (item->autoDelete ? item->component : nullptr);

			for (int j = item->callbacks.size(); --j >= 0;)
				item->callbacks.getUnchecked(j)->modalStateFinished (item->returnValue);

			compToDelete.deleteAndZero();
		}
	}
}

void ModalComponentManager::bringModalComponentsToFront (bool topOneShouldGrabFocus)
{
	ComponentPeer* lastOne = nullptr;

	for (int i = 0; i < getNumModalComponents(); ++i)
	{
		Component* const c = getModalComponent (i);

		if (c == nullptr)
			break;

		ComponentPeer* peer = c->getPeer();

		if (peer != nullptr && peer != lastOne)
		{
			if (lastOne == nullptr)
			{
				peer->toFront (topOneShouldGrabFocus);

				if (topOneShouldGrabFocus)
					peer->grabFocus();
			}
			else
				peer->toBehind (lastOne);

			lastOne = peer;
		}
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
class ModalComponentManager::ReturnValueRetriever     : public ModalComponentManager::Callback
{
public:
	ReturnValueRetriever (int& value_, bool& finished_) : value (value_), finished (finished_) {}

	void modalStateFinished (int returnValue)
	{
		finished = true;
		value = returnValue;
	}

private:
	int& value;
	bool& finished;

	JUCE_DECLARE_NON_COPYABLE (ReturnValueRetriever);
};

int ModalComponentManager::runEventLoopForCurrentComponent()
{
	// This can only be run from the message thread!
	jassert (MessageManager::getInstance()->isThisTheMessageThread());

	Component* currentlyModal = getModalComponent (0);

	if (currentlyModal == nullptr)
		return 0;

	WeakReference<Component> prevFocused (Component::getCurrentlyFocusedComponent());

	int returnValue = 0;
	bool finished = false;
	attachCallback (currentlyModal, new ReturnValueRetriever (returnValue, finished));

	JUCE_TRY
	{
		while (! finished)
		{
			if  (! MessageManager::getInstance()->runDispatchLoopUntil (20))
				break;
		}
	}
	JUCE_CATCH_EXCEPTION

	if (prevFocused != nullptr)
		prevFocused->grabKeyboardFocus();

	return returnValue;
}
#endif

/*** End of inlined file: juce_ModalComponentManager.cpp ***/


/*** Start of inlined file: juce_ComponentDragger.cpp ***/
ComponentDragger::ComponentDragger() {}
ComponentDragger::~ComponentDragger() {}

void ComponentDragger::startDraggingComponent (Component* const componentToDrag, const MouseEvent& e)
{
	jassert (componentToDrag != nullptr);
	jassert (e.mods.isAnyMouseButtonDown()); // The event has to be a drag event!

	if (componentToDrag != nullptr)
		mouseDownWithinTarget = e.getEventRelativeTo (componentToDrag).getMouseDownPosition();
}

void ComponentDragger::dragComponent (Component* const componentToDrag, const MouseEvent& e,
									  ComponentBoundsConstrainer* const constrainer)
{
	jassert (componentToDrag != nullptr);
	jassert (e.mods.isAnyMouseButtonDown()); // The event has to be a drag event!

	if (componentToDrag != nullptr)
	{
		Rectangle<int> bounds (componentToDrag->getBounds());

		// If the component is a window, multiple mouse events can get queued while it's in the same position,
		// so their coordinates become wrong after the first one moves the window, so in that case, we'll use
		// the current mouse position instead of the one that the event contains...
		if (componentToDrag->isOnDesktop())
			bounds += componentToDrag->getMouseXYRelative() - mouseDownWithinTarget;
		else
			bounds += e.getEventRelativeTo (componentToDrag).getPosition() - mouseDownWithinTarget;

		if (constrainer != nullptr)
			constrainer->setBoundsForComponent (componentToDrag, bounds, false, false, false, false);
		else
			componentToDrag->setBounds (bounds);
	}
}

/*** End of inlined file: juce_ComponentDragger.cpp ***/


/*** Start of inlined file: juce_DragAndDropContainer.cpp ***/
bool juce_performDragDropFiles (const StringArray&, const bool copyFiles, bool& shouldStop);
bool juce_performDragDropText (const String&, bool& shouldStop);

class DragImageComponent  : public Component,
							public Timer
{
public:
	DragImageComponent (const Image& im,
						const var& desc,
						Component* const sourceComponent,
						Component* const mouseDragSource_,
						DragAndDropContainer& owner_,
						const Point<int>& imageOffset_)
		: sourceDetails (desc, sourceComponent, Point<int>()),
		  image (im),
		  owner (owner_),
		  mouseDragSource (mouseDragSource_),
		  imageOffset (imageOffset_),
		  hasCheckedForExternalDrag (false),
		  isDoingExternalDrag (false)
	{
		setSize (im.getWidth(), im.getHeight());

		if (mouseDragSource == nullptr)
			mouseDragSource = sourceComponent;

		mouseDragSource->addMouseListener (this, false);

		startTimer (200);

		setInterceptsMouseClicks (false, false);
		setAlwaysOnTop (true);
	}

	~DragImageComponent()
	{
		if (owner.dragImageComponent == this)
			owner.dragImageComponent.release();

		if (mouseDragSource != nullptr)
		{
			mouseDragSource->removeMouseListener (this);

			DragAndDropTarget* const current = getCurrentlyOver();

			if (current != nullptr && current->isInterestedInDragSource (sourceDetails))
				current->itemDragExit (sourceDetails);
		}
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (Colours::white);

		g.setOpacity (1.0f);
		g.drawImageAt (image, 0, 0);
	}

	void mouseUp (const MouseEvent& e)
	{
		if (e.originalComponent != this)
		{
			if (mouseDragSource != nullptr)
				mouseDragSource->removeMouseListener (this);

			// (note: use a local copy of this in case the callback runs
			// a modal loop and deletes this object before the method completes)
			DragAndDropTarget::SourceDetails details (sourceDetails);
			DragAndDropTarget* finalTarget = nullptr;

			if (! isDoingExternalDrag)
			{
				const bool wasVisible = isVisible();
				setVisible (false);
				Component* unused;
				finalTarget = findTarget (e.getScreenPosition(), details.localPosition, unused);

				if (wasVisible) // fade the component and remove it - it'll be deleted later by the timer callback
					dismissWithAnimation (finalTarget == nullptr);
			}

			if (getParentComponent() != nullptr)
				getParentComponent()->removeChildComponent (this);

			if (finalTarget != nullptr)
			{
				currentlyOverComp = nullptr;
				finalTarget->itemDropped (details);
			}

			// careful - this object could now be deleted..
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (e.originalComponent != this)
			updateLocation (true, e.getScreenPosition());
	}

	void updateLocation (const bool canDoExternalDrag, const Point<int>& screenPos)
	{
		DragAndDropTarget::SourceDetails details (sourceDetails);

		setNewScreenPos (screenPos);

		Component* newTargetComp;
		DragAndDropTarget* const newTarget = findTarget (screenPos, details.localPosition, newTargetComp);

		setVisible (newTarget == nullptr || newTarget->shouldDrawDragImageWhenOver());

		if (newTargetComp != currentlyOverComp)
		{
			DragAndDropTarget* const lastTarget = getCurrentlyOver();

			if (lastTarget != nullptr && details.sourceComponent != nullptr
				  && lastTarget->isInterestedInDragSource (details))
				lastTarget->itemDragExit (details);

			currentlyOverComp = newTargetComp;

			if (newTarget != nullptr
				  && newTarget->isInterestedInDragSource (details))
				newTarget->itemDragEnter (details);
		}

		sendDragMove (details);

		if (canDoExternalDrag && getCurrentlyOver() == nullptr)
			checkForExternalDrag (details, screenPos);
	}

	void timerCallback()
	{
		if (sourceDetails.sourceComponent == nullptr)
		{
			delete this;
		}
		else if (! isMouseButtonDownAnywhere())
		{
			if (mouseDragSource != nullptr)
				mouseDragSource->removeMouseListener (this);

			delete this;
		}
	}

private:
	DragAndDropTarget::SourceDetails sourceDetails;
	Image image;
	DragAndDropContainer& owner;
	WeakReference<Component> mouseDragSource, currentlyOverComp;
	const Point<int> imageOffset;
	bool hasCheckedForExternalDrag, isDoingExternalDrag;

	DragAndDropTarget* getCurrentlyOver() const noexcept
	{
		return dynamic_cast <DragAndDropTarget*> (currentlyOverComp.get());
	}

	DragAndDropTarget* findTarget (const Point<int>& screenPos, Point<int>& relativePos,
								   Component*& resultComponent) const
	{
		Component* hit = getParentComponent();

		if (hit == nullptr)
			hit = Desktop::getInstance().findComponentAt (screenPos);
		else
			hit = hit->getComponentAt (hit->getLocalPoint (nullptr, screenPos));

		// (note: use a local copy of this in case the callback runs
		// a modal loop and deletes this object before the method completes)
		const DragAndDropTarget::SourceDetails details (sourceDetails);

		while (hit != nullptr)
		{
			DragAndDropTarget* const ddt = dynamic_cast <DragAndDropTarget*> (hit);

			if (ddt != nullptr && ddt->isInterestedInDragSource (details))
			{
				relativePos = hit->getLocalPoint (nullptr, screenPos);
				resultComponent = hit;
				return ddt;
			}

			hit = hit->getParentComponent();
		}

		resultComponent = nullptr;
		return nullptr;
	}

	void setNewScreenPos (const Point<int>& screenPos)
	{
		Point<int> newPos (screenPos - imageOffset);

		if (getParentComponent() != nullptr)
			newPos = getParentComponent()->getLocalPoint (nullptr, newPos);

		setTopLeftPosition (newPos);
	}

	void sendDragMove (DragAndDropTarget::SourceDetails& details) const
	{
		DragAndDropTarget* const target = getCurrentlyOver();

		if (target != nullptr && target->isInterestedInDragSource (details))
			target->itemDragMove (details);
	}

	void checkForExternalDrag (DragAndDropTarget::SourceDetails& details, const Point<int>& screenPos)
	{
		if (! hasCheckedForExternalDrag)
		{
			if (Desktop::getInstance().findComponentAt (screenPos) == nullptr)
			{
				hasCheckedForExternalDrag = true;
				StringArray files;
				bool canMoveFiles = false;

				if (owner.shouldDropFilesWhenDraggedExternally (details, files, canMoveFiles)
					 && files.size() > 0)
				{
					WeakReference<Component> thisWeakRef (this);
					setVisible (false);
					isDoingExternalDrag = true;

					if (ModifierKeys::getCurrentModifiersRealtime().isAnyMouseButtonDown())
						DragAndDropContainer::performExternalDragDropOfFiles (files, canMoveFiles);

					delete thisWeakRef.get();
					return;
				}
			}
		}
	}

	void dismissWithAnimation (const bool shouldSnapBack)
	{
		setVisible (true);
		ComponentAnimator& animator = Desktop::getInstance().getAnimator();

		if (shouldSnapBack && sourceDetails.sourceComponent != nullptr)
		{
			const Point<int> target (sourceDetails.sourceComponent->localPointToGlobal (sourceDetails.sourceComponent->getLocalBounds().getCentre()));
			const Point<int> ourCentre (localPointToGlobal (getLocalBounds().getCentre()));

			animator.animateComponent (this,
									   getBounds() + (target - ourCentre),
									   0.0f, 120,
									   true, 1.0, 1.0);
		}
		else
		{
			animator.fadeOut (this, 120);
		}
	}

	JUCE_DECLARE_NON_COPYABLE (DragImageComponent);
};

DragAndDropContainer::DragAndDropContainer()
{
}

DragAndDropContainer::~DragAndDropContainer()
{
	dragImageComponent = nullptr;
}

void DragAndDropContainer::startDragging (const var& sourceDescription,
										  Component* sourceComponent,
										  const Image& dragImage_,
										  const bool allowDraggingToExternalWindows,
										  const Point<int>* imageOffsetFromMouse)
{
	Image dragImage (dragImage_);

	if (dragImageComponent == nullptr)
	{
		MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource (0);

		if (draggingSource == nullptr || ! draggingSource->isDragging())
		{
			jassertfalse;   // You must call startDragging() from within a mouseDown or mouseDrag callback!
			return;
		}

		const Point<int> lastMouseDown (Desktop::getLastMouseDownPosition());
		Point<int> imageOffset;

		if (dragImage.isNull())
		{
			dragImage = sourceComponent->createComponentSnapshot (sourceComponent->getLocalBounds())
							.convertedToFormat (Image::ARGB);

			dragImage.multiplyAllAlphas (0.6f);

			const int lo = 150;
			const int hi = 400;

			Point<int> relPos (sourceComponent->getLocalPoint (nullptr, lastMouseDown));
			Point<int> clipped (dragImage.getBounds().getConstrainedPoint (relPos));
			Random random;

			for (int y = dragImage.getHeight(); --y >= 0;)
			{
				const double dy = (y - clipped.getY()) * (y - clipped.getY());

				for (int x = dragImage.getWidth(); --x >= 0;)
				{
					const int dx = x - clipped.getX();
					const int distance = roundToInt (std::sqrt (dx * dx + dy));

					if (distance > lo)
					{
						const float alpha = (distance > hi) ? 0
															: (hi - distance) / (float) (hi - lo)
															   + random.nextFloat() * 0.008f;

						dragImage.multiplyAlphaAt (x, y, alpha);
					}
				}
			}

			imageOffset = clipped;
		}
		else
		{
			if (imageOffsetFromMouse == nullptr)
				imageOffset = dragImage.getBounds().getCentre();
			else
				imageOffset = dragImage.getBounds().getConstrainedPoint (-*imageOffsetFromMouse);
		}

		dragImageComponent = new DragImageComponent (dragImage, sourceDescription, sourceComponent,
													 draggingSource->getComponentUnderMouse(), *this, imageOffset);

		currentDragDesc = sourceDescription;

		if (allowDraggingToExternalWindows)
		{
			if (! Desktop::canUseSemiTransparentWindows())
				dragImageComponent->setOpaque (true);

			dragImageComponent->addToDesktop (ComponentPeer::windowIgnoresMouseClicks
											   | ComponentPeer::windowIsTemporary
											   | ComponentPeer::windowIgnoresKeyPresses);
		}
		else
		{
			Component* const thisComp = dynamic_cast <Component*> (this);

			if (thisComp == nullptr)
			{
				jassertfalse;   // Your DragAndDropContainer needs to be a Component!
				return;
			}

			thisComp->addChildComponent (dragImageComponent);
		}

		static_cast <DragImageComponent*> (dragImageComponent.get())->updateLocation (false, lastMouseDown);
		dragImageComponent->setVisible (true);

	   #if JUCE_WINDOWS
		// Under heavy load, the layered window's paint callback can often be lost by the OS,
		// so forcing a repaint at least once makes sure that the window becomes visible..
		ComponentPeer* const peer = dragImageComponent->getPeer();
		if (peer != nullptr)
			peer->performAnyPendingRepaintsNow();
	   #endif
	}
}

bool DragAndDropContainer::isDragAndDropActive() const
{
	return dragImageComponent != nullptr;
}

String DragAndDropContainer::getCurrentDragDescription() const
{
	return dragImageComponent != nullptr ? currentDragDesc
										 : String::empty;
}

DragAndDropContainer* DragAndDropContainer::findParentDragContainerFor (Component* c)
{
	return c != nullptr ? c->findParentComponentOfClass<DragAndDropContainer>() : nullptr;
}

bool DragAndDropContainer::shouldDropFilesWhenDraggedExternally (const DragAndDropTarget::SourceDetails&, StringArray&, bool&)
{
	return false;
}

DragAndDropTarget::SourceDetails::SourceDetails (const var& description_, Component* sourceComponent_, const Point<int>& localPosition_) noexcept
	: description (description_),
	  sourceComponent (sourceComponent_),
	  localPosition (localPosition_)
{
}

void DragAndDropTarget::itemDragEnter (const SourceDetails&)  {}
void DragAndDropTarget::itemDragMove  (const SourceDetails&)  {}
void DragAndDropTarget::itemDragExit  (const SourceDetails&)  {}
bool DragAndDropTarget::shouldDrawDragImageWhenOver()         { return true; }

void FileDragAndDropTarget::fileDragEnter (const StringArray&, int, int)  {}
void FileDragAndDropTarget::fileDragMove  (const StringArray&, int, int)  {}
void FileDragAndDropTarget::fileDragExit  (const StringArray&)            {}

/*** End of inlined file: juce_DragAndDropContainer.cpp ***/


/*** Start of inlined file: juce_MouseCursor.cpp ***/
class MouseCursor::SharedCursorHandle
{
public:
	explicit SharedCursorHandle (const MouseCursor::StandardCursorType type)
		: handle (createStandardMouseCursor (type)),
		  refCount (1),
		  standardType (type),
		  isStandard (true)
	{
	}

	SharedCursorHandle (const Image& image, const int hotSpotX, const int hotSpotY)
		: handle (createMouseCursorFromImage (image, hotSpotX, hotSpotY)),
		  refCount (1),
		  standardType (MouseCursor::NormalCursor),
		  isStandard (false)
	{
	}

	~SharedCursorHandle()
	{
		deleteMouseCursor (handle, isStandard);
	}

	static SharedCursorHandle* createStandard (const MouseCursor::StandardCursorType type)
	{
		const SpinLock::ScopedLockType sl (lock);

		for (int i = 0; i < getCursors().size(); ++i)
		{
			SharedCursorHandle* const sc = getCursors().getUnchecked(i);

			if (sc->standardType == type)
				return sc->retain();
		}

		SharedCursorHandle* const sc = new SharedCursorHandle (type);
		getCursors().add (sc);
		return sc;
	}

	SharedCursorHandle* retain() noexcept
	{
		++refCount;
		return this;
	}

	void release()
	{
		if (--refCount == 0)
		{
			if (isStandard)
			{
				const SpinLock::ScopedLockType sl (lock);
				getCursors().removeValue (this);
			}

			delete this;
		}
	}

	void* getHandle() const noexcept        { return handle; }

private:

	void* const handle;
	Atomic <int> refCount;
	const MouseCursor::StandardCursorType standardType;
	const bool isStandard;
	static SpinLock lock;

	static Array <SharedCursorHandle*>& getCursors()
	{
		static Array <SharedCursorHandle*> cursors;
		return cursors;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SharedCursorHandle);
};

SpinLock MouseCursor::SharedCursorHandle::lock;

MouseCursor::MouseCursor()
	: cursorHandle (nullptr)
{
}

MouseCursor::MouseCursor (const StandardCursorType type)
	: cursorHandle (type != MouseCursor::NormalCursor ? SharedCursorHandle::createStandard (type) : 0)
{
}

MouseCursor::MouseCursor (const Image& image, const int hotSpotX, const int hotSpotY)
	: cursorHandle (new SharedCursorHandle (image, hotSpotX, hotSpotY))
{
}

MouseCursor::MouseCursor (const MouseCursor& other)
	: cursorHandle (other.cursorHandle == nullptr ? nullptr : other.cursorHandle->retain())
{
}

MouseCursor::~MouseCursor()
{
	if (cursorHandle != nullptr)
		cursorHandle->release();
}

MouseCursor& MouseCursor::operator= (const MouseCursor& other)
{
	if (other.cursorHandle != nullptr)
		other.cursorHandle->retain();

	if (cursorHandle != nullptr)
		cursorHandle->release();

	cursorHandle = other.cursorHandle;
	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
MouseCursor::MouseCursor (MouseCursor&& other) noexcept
	: cursorHandle (other.cursorHandle)
{
	other.cursorHandle = nullptr;
}

MouseCursor& MouseCursor::operator= (MouseCursor&& other) noexcept
{
	std::swap (cursorHandle, other.cursorHandle);
	return *this;
}
#endif

bool MouseCursor::operator== (const MouseCursor& other) const noexcept
{
	return getHandle() == other.getHandle();
}

bool MouseCursor::operator!= (const MouseCursor& other) const noexcept
{
	return getHandle() != other.getHandle();
}

void* MouseCursor::getHandle() const noexcept
{
	return cursorHandle != nullptr ? cursorHandle->getHandle() : nullptr;
}

void MouseCursor::showWaitCursor()
{
	Desktop::getInstance().getMainMouseSource().showMouseCursor (MouseCursor::WaitCursor);
}

void MouseCursor::hideWaitCursor()
{
	Desktop::getInstance().getMainMouseSource().revealCursor();
}

/*** End of inlined file: juce_MouseCursor.cpp ***/


/*** Start of inlined file: juce_MouseEvent.cpp ***/
MouseEvent::MouseEvent (MouseInputSource& source_,
						const Point<int>& position,
						const ModifierKeys& mods_,
						Component* const eventComponent_,
						Component* const originator,
						const Time& eventTime_,
						const Point<int> mouseDownPos_,
						const Time& mouseDownTime_,
						const int numberOfClicks_,
						const bool mouseWasDragged) noexcept
	: x (position.x),
	  y (position.y),
	  mods (mods_),
	  eventComponent (eventComponent_),
	  originalComponent (originator),
	  eventTime (eventTime_),
	  source (source_),
	  mouseDownPos (mouseDownPos_),
	  mouseDownTime (mouseDownTime_),
	  numberOfClicks ((uint8) numberOfClicks_),
	  wasMovedSinceMouseDown ((uint8) (mouseWasDragged ? 1 : 0))
{
}

MouseEvent::~MouseEvent() noexcept
{
}

MouseEvent MouseEvent::getEventRelativeTo (Component* const otherComponent) const noexcept
{
	jassert (otherComponent != nullptr);

	return MouseEvent (source, otherComponent->getLocalPoint (eventComponent, getPosition()),
					   mods, otherComponent, originalComponent, eventTime,
					   otherComponent->getLocalPoint (eventComponent, mouseDownPos),
					   mouseDownTime, numberOfClicks, wasMovedSinceMouseDown != 0);
}

MouseEvent MouseEvent::withNewPosition (const Point<int>& newPosition) const noexcept
{
	return MouseEvent (source, newPosition, mods, eventComponent, originalComponent,
					   eventTime, mouseDownPos, mouseDownTime,
					   numberOfClicks, wasMovedSinceMouseDown != 0);
}

bool MouseEvent::mouseWasClicked() const noexcept
{
	return wasMovedSinceMouseDown == 0;
}

int MouseEvent::getLengthOfMousePress() const noexcept
{
	if (mouseDownTime.toMilliseconds() > 0)
		return jmax (0, (int) (eventTime - mouseDownTime).inMilliseconds());

	return 0;
}

Point<int> MouseEvent::getPosition() const noexcept             { return Point<int> (x, y); }
Point<int> MouseEvent::getScreenPosition() const                { return eventComponent->localPointToGlobal (getPosition()); }

Point<int> MouseEvent::getMouseDownPosition() const noexcept    { return mouseDownPos; }
Point<int> MouseEvent::getMouseDownScreenPosition() const       { return eventComponent->localPointToGlobal (mouseDownPos); }

Point<int> MouseEvent::getOffsetFromDragStart() const noexcept  { return getPosition() - mouseDownPos; }
int MouseEvent::getDistanceFromDragStart() const noexcept       { return mouseDownPos.getDistanceFrom (getPosition()); }

int MouseEvent::getMouseDownX() const noexcept                  { return mouseDownPos.x; }
int MouseEvent::getMouseDownY() const noexcept                  { return mouseDownPos.y; }

int MouseEvent::getDistanceFromDragStartX() const noexcept      { return x - mouseDownPos.x; }
int MouseEvent::getDistanceFromDragStartY() const noexcept      { return y - mouseDownPos.y; }

int MouseEvent::getScreenX() const                              { return getScreenPosition().x; }
int MouseEvent::getScreenY() const                              { return getScreenPosition().y; }

int MouseEvent::getMouseDownScreenX() const                     { return getMouseDownScreenPosition().x; }
int MouseEvent::getMouseDownScreenY() const                     { return getMouseDownScreenPosition().y; }

static int doubleClickTimeOutMs = 400;

int MouseEvent::getDoubleClickTimeout() noexcept                        { return doubleClickTimeOutMs; }
void MouseEvent::setDoubleClickTimeout (const int newTime) noexcept     { doubleClickTimeOutMs = newTime; }

/*** End of inlined file: juce_MouseEvent.cpp ***/


/*** Start of inlined file: juce_MouseInputSource.cpp ***/
class MouseInputSourceInternal   : public AsyncUpdater
{
public:

	MouseInputSourceInternal (MouseInputSource& source_, const int index_, const bool isMouseDevice_)
		: index (index_), isMouseDevice (isMouseDevice_), source (source_), lastPeer (nullptr),
		  isUnboundedMouseModeOn (false), isCursorVisibleUntilOffscreen (false), currentCursorHandle (nullptr),
		  mouseEventCounter (0)
	{
	}

	bool isDragging() const noexcept
	{
		return buttonState.isAnyMouseButtonDown();
	}

	Component* getComponentUnderMouse() const
	{
		return static_cast <Component*> (componentUnderMouse);
	}

	ModifierKeys getCurrentModifiers() const
	{
		return ModifierKeys::getCurrentModifiers().withoutMouseButtons().withFlags (buttonState.getRawFlags());
	}

	ComponentPeer* getPeer()
	{
		if (! ComponentPeer::isValidPeer (lastPeer))
			lastPeer = nullptr;

		return lastPeer;
	}

	Component* findComponentAt (const Point<int>& screenPos)
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			Component* const comp = peer->getComponent();
			const Point<int> relativePos (comp->getLocalPoint (nullptr, screenPos));

			// (the contains() call is needed to test for overlapping desktop windows)
			if (comp->contains (relativePos))
				return comp->getComponentAt (relativePos);
		}

		return nullptr;
	}

	Point<int> getScreenPosition() const
	{
		// This needs to return the live position if possible, but it mustn't update the lastScreenPos
		// value, because that can cause continuity problems.
		return unboundedMouseOffset + (isMouseDevice ? MouseInputSource::getCurrentMousePosition()
													 : lastScreenPos);
	}

	void sendMouseEnter (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " enter: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseEnter (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseExit (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " exit: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseExit (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseMove (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " move: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseMove (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseDown (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " down: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseDown (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseDrag (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " drag: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseDrag (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseUp (Component* const comp, const Point<int>& screenPos, const Time& time, const ModifierKeys& oldMods)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " up: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseUp (source, comp->getLocalPoint (nullptr, screenPos), time, oldMods);
	}

	void sendMouseWheel (Component* const comp, const Point<int>& screenPos, const Time& time, float x, float y)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " wheel: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseWheel (source, comp->getLocalPoint (nullptr, screenPos), time, x, y);
	}

	// (returns true if the button change caused a modal event loop)
	bool setButtons (const Point<int>& screenPos, const Time& time, const ModifierKeys& newButtonState)
	{
		if (buttonState == newButtonState)
			return false;

		// (avoid sending a spurious mouse-drag when we receive a mouse-up)
		if (! (isDragging() && ! newButtonState.isAnyMouseButtonDown()))
			setScreenPos (screenPos, time, false);

		// (ignore secondary clicks when there's already a button down)
		if (buttonState.isAnyMouseButtonDown() == newButtonState.isAnyMouseButtonDown())
		{
			buttonState = newButtonState;
			return false;
		}

		const int lastCounter = mouseEventCounter;

		if (buttonState.isAnyMouseButtonDown())
		{
			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				const ModifierKeys oldMods (getCurrentModifiers());
				buttonState = newButtonState; // must change this before calling sendMouseUp, in case it runs a modal loop

				sendMouseUp (current, screenPos + unboundedMouseOffset, time, oldMods);
			}

			enableUnboundedMouseMovement (false, false);
		}

		buttonState = newButtonState;

		if (buttonState.isAnyMouseButtonDown())
		{
			Desktop::getInstance().incrementMouseClickCounter();

			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				registerMouseDown (screenPos, time, current, buttonState);
				sendMouseDown (current, screenPos, time);
			}
		}

		return lastCounter != mouseEventCounter;
	}

	void setComponentUnderMouse (Component* const newComponent, const Point<int>& screenPos, const Time& time)
	{
		Component* current = getComponentUnderMouse();

		if (newComponent != current)
		{
			WeakReference<Component> safeNewComp (newComponent);
			const ModifierKeys originalButtonState (buttonState);

			if (current != nullptr)
			{
				WeakReference<Component> safeOldComp (current);
				setButtons (screenPos, time, ModifierKeys());

				if (safeOldComp != nullptr)
				{
					componentUnderMouse = safeNewComp;
					sendMouseExit (safeOldComp, screenPos, time);
				}

				buttonState = originalButtonState;
			}

			current = componentUnderMouse = safeNewComp;

			if (current != nullptr)
				sendMouseEnter (current, screenPos, time);

			revealCursor (false);
			setButtons (screenPos, time, originalButtonState);
		}
	}

	void setPeer (ComponentPeer* const newPeer, const Point<int>& screenPos, const Time& time)
	{
		ModifierKeys::updateCurrentModifiers();

		if (newPeer != lastPeer)
		{
			setComponentUnderMouse (nullptr, screenPos, time);
			lastPeer = newPeer;
			setComponentUnderMouse (findComponentAt (screenPos), screenPos, time);
		}
	}

	void setScreenPos (const Point<int>& newScreenPos, const Time& time, const bool forceUpdate)
	{
		if (! isDragging())
			setComponentUnderMouse (findComponentAt (newScreenPos), newScreenPos, time);

		if (newScreenPos != lastScreenPos || forceUpdate)
		{
			cancelPendingUpdate();

			lastScreenPos = newScreenPos;
			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				if (isDragging())
				{
					registerMouseDrag (newScreenPos);
					sendMouseDrag (current, newScreenPos + unboundedMouseOffset, time);

					if (isUnboundedMouseModeOn)
						handleUnboundedDrag (current);
				}
				else
				{
					sendMouseMove (current, newScreenPos, time);
				}
			}

			revealCursor (false);
		}
	}

	void handleEvent (ComponentPeer* const newPeer, const Point<int>& positionWithinPeer, const Time& time, const ModifierKeys& newMods)
	{
		jassert (newPeer != nullptr);
		lastTime = time;
		++mouseEventCounter;
		const Point<int> screenPos (newPeer->localToGlobal (positionWithinPeer));

		if (isDragging() && newMods.isAnyMouseButtonDown())
		{
			setScreenPos (screenPos, time, false);
		}
		else
		{
			setPeer (newPeer, screenPos, time);

			ComponentPeer* peer = getPeer();
			if (peer != nullptr)
			{
				if (setButtons (screenPos, time, newMods))
					return; // some modal events have been dispatched, so the current event is now out-of-date

				peer = getPeer();
				if (peer != nullptr)
					setScreenPos (screenPos, time, false);
			}
		}
	}

	void handleWheel (ComponentPeer* const peer, const Point<int>& positionWithinPeer, const Time& time, float x, float y)
	{
		jassert (peer != nullptr);
		lastTime = time;
		++mouseEventCounter;
		const Point<int> screenPos (peer->localToGlobal (positionWithinPeer));

		setPeer (peer, screenPos, time);
		setScreenPos (screenPos, time, false);
		triggerFakeMove();

		if (! isDragging())
		{
			Component* current = getComponentUnderMouse();
			if (current != nullptr)
				sendMouseWheel (current, screenPos, time, x, y);
		}
	}

	Time getLastMouseDownTime() const noexcept
	{
		return Time (mouseDowns[0].time);
	}

	Point<int> getLastMouseDownPosition() const noexcept
	{
		return mouseDowns[0].position;
	}

	int getNumberOfMultipleClicks() const noexcept
	{
		int numClicks = 0;

		if (mouseDowns[0].time != Time())
		{
			if (! mouseMovedSignificantlySincePressed)
				++numClicks;

			for (int i = 1; i < numElementsInArray (mouseDowns); ++i)
			{
				if (mouseDowns[0].canBePartOfMultipleClickWith (mouseDowns[i], MouseEvent::getDoubleClickTimeout() * jmin (i, 2)))
					++numClicks;
				else
					break;
			}
		}

		return numClicks;
	}

	bool hasMouseMovedSignificantlySincePressed() const noexcept
	{
		return mouseMovedSignificantlySincePressed
				|| lastTime > mouseDowns[0].time + RelativeTime::milliseconds (300);
	}

	void triggerFakeMove()
	{
		triggerAsyncUpdate();
	}

	void handleAsyncUpdate()
	{
		setScreenPos (lastScreenPos, jmax (lastTime, Time::getCurrentTime()), true);
	}

	void enableUnboundedMouseMovement (bool enable, bool keepCursorVisibleUntilOffscreen)
	{
		enable = enable && isDragging();
		isCursorVisibleUntilOffscreen = keepCursorVisibleUntilOffscreen;

		if (enable != isUnboundedMouseModeOn)
		{
			if ((! enable) && ((! isCursorVisibleUntilOffscreen) || ! unboundedMouseOffset.isOrigin()))
			{
				// when released, return the mouse to within the component's bounds
				Component* current = getComponentUnderMouse();
				if (current != nullptr)
					Desktop::setMousePosition (current->getScreenBounds()
												 .getConstrainedPoint (lastScreenPos));
			}

			isUnboundedMouseModeOn = enable;
			unboundedMouseOffset = Point<int>();

			revealCursor (true);
		}
	}

	void handleUnboundedDrag (Component* current)
	{
		const Rectangle<int> screenArea (current->getParentMonitorArea().expanded (-2, -2));

		if (! screenArea.contains (lastScreenPos))
		{
			const Point<int> componentCentre (current->getScreenBounds().getCentre());
			unboundedMouseOffset += (lastScreenPos - componentCentre);
			Desktop::setMousePosition (componentCentre);
		}
		else if (isCursorVisibleUntilOffscreen
				  && (! unboundedMouseOffset.isOrigin())
				  && screenArea.contains (lastScreenPos + unboundedMouseOffset))
		{
			Desktop::setMousePosition (lastScreenPos + unboundedMouseOffset);
			unboundedMouseOffset = Point<int>();
		}
	}

	void showMouseCursor (MouseCursor cursor, bool forcedUpdate)
	{
		if (isUnboundedMouseModeOn && ((! unboundedMouseOffset.isOrigin()) || ! isCursorVisibleUntilOffscreen))
		{
			cursor = MouseCursor::NoCursor;
			forcedUpdate = true;
		}

		if (forcedUpdate || cursor.getHandle() != currentCursorHandle)
		{
			currentCursorHandle = cursor.getHandle();
			cursor.showInWindow (getPeer());
		}
	}

	void hideCursor()
	{
		showMouseCursor (MouseCursor::NoCursor, true);
	}

	void revealCursor (bool forcedUpdate)
	{
		MouseCursor mc (MouseCursor::NormalCursor);

		Component* current = getComponentUnderMouse();
		if (current != nullptr)
			mc = current->getLookAndFeel().getMouseCursorFor (*current);

		showMouseCursor (mc, forcedUpdate);
	}

	const int index;
	const bool isMouseDevice;
	Point<int> lastScreenPos;
	ModifierKeys buttonState;

private:
	MouseInputSource& source;
	WeakReference<Component> componentUnderMouse;
	ComponentPeer* lastPeer;

	Point<int> unboundedMouseOffset;
	bool isUnboundedMouseModeOn, isCursorVisibleUntilOffscreen;
	void* currentCursorHandle;
	int mouseEventCounter;

	struct RecentMouseDown
	{
		RecentMouseDown()  : component (nullptr)
		{
		}

		Point<int> position;
		Time time;
		Component* component;
		ModifierKeys buttons;

		bool canBePartOfMultipleClickWith (const RecentMouseDown& other, const int maxTimeBetweenMs) const
		{
			return time - other.time < RelativeTime::milliseconds (maxTimeBetweenMs)
					&& abs (position.x - other.position.x) < 8
					&& abs (position.y - other.position.y) < 8
					&& buttons == other.buttons;;
		}
	};

	RecentMouseDown mouseDowns[4];
	bool mouseMovedSignificantlySincePressed;
	Time lastTime;

	void registerMouseDown (const Point<int>& screenPos, const Time& time,
							Component* const component, const ModifierKeys& modifiers) noexcept
	{
		for (int i = numElementsInArray (mouseDowns); --i > 0;)
			mouseDowns[i] = mouseDowns[i - 1];

		mouseDowns[0].position = screenPos;
		mouseDowns[0].time = time;
		mouseDowns[0].component = component;
		mouseDowns[0].buttons = modifiers.withOnlyMouseButtons();
		mouseMovedSignificantlySincePressed = false;
	}

	void registerMouseDrag (const Point<int>& screenPos) noexcept
	{
		mouseMovedSignificantlySincePressed = mouseMovedSignificantlySincePressed
			   || mouseDowns[0].position.getDistanceFrom (screenPos) >= 4;
	}

	JUCE_DECLARE_NON_COPYABLE (MouseInputSourceInternal);
};

MouseInputSource::MouseInputSource (const int index, const bool isMouseDevice)
{
	pimpl = new MouseInputSourceInternal (*this, index, isMouseDevice);
}

MouseInputSource::~MouseInputSource()
{
}

bool MouseInputSource::isMouse() const                                  { return pimpl->isMouseDevice; }
bool MouseInputSource::isTouch() const                                  { return ! isMouse(); }
bool MouseInputSource::canHover() const                                 { return isMouse(); }
bool MouseInputSource::hasMouseWheel() const                            { return isMouse(); }
int MouseInputSource::getIndex() const                                  { return pimpl->index; }
bool MouseInputSource::isDragging() const                               { return pimpl->isDragging(); }
Point<int> MouseInputSource::getScreenPosition() const                  { return pimpl->getScreenPosition(); }
ModifierKeys MouseInputSource::getCurrentModifiers() const              { return pimpl->getCurrentModifiers(); }
Component* MouseInputSource::getComponentUnderMouse() const             { return pimpl->getComponentUnderMouse(); }
void MouseInputSource::triggerFakeMove() const                          { pimpl->triggerFakeMove(); }
int MouseInputSource::getNumberOfMultipleClicks() const noexcept        { return pimpl->getNumberOfMultipleClicks(); }
Time MouseInputSource::getLastMouseDownTime() const noexcept            { return pimpl->getLastMouseDownTime(); }
Point<int> MouseInputSource::getLastMouseDownPosition() const noexcept  { return pimpl->getLastMouseDownPosition(); }
bool MouseInputSource::hasMouseMovedSignificantlySincePressed() const noexcept  { return pimpl->hasMouseMovedSignificantlySincePressed(); }
bool MouseInputSource::canDoUnboundedMovement() const noexcept          { return isMouse(); }
void MouseInputSource::enableUnboundedMouseMovement (bool isEnabled, bool keepCursorVisibleUntilOffscreen)    { pimpl->enableUnboundedMouseMovement (isEnabled, keepCursorVisibleUntilOffscreen); }
bool MouseInputSource::hasMouseCursor() const noexcept                  { return isMouse(); }
void MouseInputSource::showMouseCursor (const MouseCursor& cursor)      { pimpl->showMouseCursor (cursor, false); }
void MouseInputSource::hideCursor()                                     { pimpl->hideCursor(); }
void MouseInputSource::revealCursor()                                   { pimpl->revealCursor (false); }
void MouseInputSource::forceMouseCursorUpdate()                         { pimpl->revealCursor (true); }

void MouseInputSource::handleEvent (ComponentPeer* peer, const Point<int>& positionWithinPeer, const int64 time, const ModifierKeys& mods)
{
	pimpl->handleEvent (peer, positionWithinPeer, Time (time), mods.withOnlyMouseButtons());
}

void MouseInputSource::handleWheel (ComponentPeer* const peer, const Point<int>& positionWithinPeer, const int64 time, const float x, const float y)
{
	pimpl->handleWheel (peer, positionWithinPeer, Time (time), x, y);
}

/*** End of inlined file: juce_MouseInputSource.cpp ***/


/*** Start of inlined file: juce_MouseListener.cpp ***/
void MouseListener::mouseEnter (const MouseEvent&) {}
void MouseListener::mouseExit (const MouseEvent&)  {}
void MouseListener::mouseDown (const MouseEvent&)  {}
void MouseListener::mouseUp (const MouseEvent&)    {}
void MouseListener::mouseDrag (const MouseEvent&)  {}
void MouseListener::mouseMove (const MouseEvent&)  {}
void MouseListener::mouseDoubleClick (const MouseEvent&) {}
void MouseListener::mouseWheelMove (const MouseEvent&, float, float) {}

/*** End of inlined file: juce_MouseListener.cpp ***/


/*** Start of inlined file: juce_CaretComponent.cpp ***/
CaretComponent::CaretComponent (Component* const keyFocusOwner)
	: owner (keyFocusOwner)
{
	setAlwaysOnTop (true);
	setInterceptsMouseClicks (false, false);
}

CaretComponent::~CaretComponent()
{
}

void CaretComponent::paint (Graphics& g)
{
	g.fillAll (findColour (caretColourId, true));
}

void CaretComponent::timerCallback()
{
	setVisible (shouldBeShown() && ! isVisible());
}

void CaretComponent::setCaretPosition (const Rectangle<int>& characterArea)
{
	startTimer (380);
	setVisible (shouldBeShown());
	setBounds (characterArea.withWidth (2));
}

bool CaretComponent::shouldBeShown() const
{
	return owner == nullptr || (owner->hasKeyboardFocus (true)
								 && ! owner->isCurrentlyBlockedByAnotherModalComponent());
}

/*** End of inlined file: juce_CaretComponent.cpp ***/


/*** Start of inlined file: juce_KeyboardFocusTraverser.cpp ***/
namespace KeyboardFocusHelpers
{
	// This will sort a set of components, so that they are ordered in terms of
	// left-to-right and then top-to-bottom.
	struct ScreenPositionComparator
	{
		static int compareElements (const Component* const first, const Component* const second)
		{
			const int explicitOrder1 = getOrder (first);
			const int explicitOrder2 = getOrder (second);

			if (explicitOrder1 != explicitOrder2)
				return explicitOrder1 - explicitOrder2;

			const int yDiff = first->getY() - second->getY();

			return yDiff == 0 ? first->getX() - second->getX()
							  : yDiff;
		}

		static int getOrder (const Component* const c)
		{
			const int order = c->getExplicitFocusOrder();
			return order > 0 ? order : (std::numeric_limits<int>::max() / 2);
		}
	};

	static void findAllFocusableComponents (Component* const parent, Array <Component*>& comps)
	{
		if (parent->getNumChildComponents() > 0)
		{
			Array <Component*> localComps;
			ScreenPositionComparator comparator;

			int i;
			for (i = parent->getNumChildComponents(); --i >= 0;)
			{
				Component* const c = parent->getChildComponent (i);

				if (c->isVisible() && c->isEnabled())
					localComps.addSorted (comparator, c);
			}

			for (i = 0; i < localComps.size(); ++i)
			{
				Component* const c = localComps.getUnchecked (i);

				if (c->getWantsKeyboardFocus())
					comps.add (c);

				if (! c->isFocusContainer())
					findAllFocusableComponents (c, comps);
			}
		}
	}

	static Component* findFocusContainer (Component* c)
	{
		c = c->getParentComponent();

		if (c != nullptr)
			while (c->getParentComponent() != nullptr && ! c->isFocusContainer())
				c = c->getParentComponent();

		return c;
	}

	static Component* getIncrementedComponent (Component* const current, const int delta)
	{
		Component* focusContainer = findFocusContainer (current);

		if (focusContainer != nullptr)
		{
			Array <Component*> comps;
			KeyboardFocusHelpers::findAllFocusableComponents (focusContainer, comps);

			if (comps.size() > 0)
			{
				const int index = comps.indexOf (current);
				return comps [(index + comps.size() + delta) % comps.size()];
			}
		}

		return nullptr;
	}
}

KeyboardFocusTraverser::KeyboardFocusTraverser() {}
KeyboardFocusTraverser::~KeyboardFocusTraverser() {}

Component* KeyboardFocusTraverser::getNextComponent (Component* current)
{
	jassert (current != nullptr);
	return KeyboardFocusHelpers::getIncrementedComponent (current, 1);
}

Component* KeyboardFocusTraverser::getPreviousComponent (Component* current)
{
	jassert (current != nullptr);
	return KeyboardFocusHelpers::getIncrementedComponent (current, -1);
}

Component* KeyboardFocusTraverser::getDefaultComponent (Component* parentComponent)
{
	Array <Component*> comps;

	if (parentComponent != nullptr)
		KeyboardFocusHelpers::findAllFocusableComponents (parentComponent, comps);

	return comps.getFirst();
}

/*** End of inlined file: juce_KeyboardFocusTraverser.cpp ***/


/*** Start of inlined file: juce_KeyListener.cpp ***/
bool KeyListener::keyStateChanged (const bool, Component*)
{
	return false;
}

/*** End of inlined file: juce_KeyListener.cpp ***/


/*** Start of inlined file: juce_KeyPress.cpp ***/
KeyPress::KeyPress() noexcept
	: keyCode (0),
	  textCharacter (0)
{
}

KeyPress::KeyPress (const int keyCode_,
					const ModifierKeys& mods_,
					const juce_wchar textCharacter_) noexcept
	: keyCode (keyCode_),
	  mods (mods_),
	  textCharacter (textCharacter_)
{
}

KeyPress::KeyPress (const int keyCode_) noexcept
	: keyCode (keyCode_),
	  textCharacter (0)
{
}

KeyPress::KeyPress (const KeyPress& other) noexcept
	: keyCode (other.keyCode),
	  mods (other.mods),
	  textCharacter (other.textCharacter)
{
}

KeyPress& KeyPress::operator= (const KeyPress& other) noexcept
{
	keyCode = other.keyCode;
	mods = other.mods;
	textCharacter = other.textCharacter;

	return *this;
}

bool KeyPress::operator== (const KeyPress& other) const noexcept
{
	return mods.getRawFlags() == other.mods.getRawFlags()
			&& (textCharacter == other.textCharacter
				 || textCharacter == 0
				 || other.textCharacter == 0)
			&& (keyCode == other.keyCode
				 || (keyCode < 256
					  && other.keyCode < 256
					  && CharacterFunctions::toLowerCase ((juce_wchar) keyCode)
						   == CharacterFunctions::toLowerCase ((juce_wchar) other.keyCode)));
}

bool KeyPress::operator!= (const KeyPress& other) const noexcept
{
	return ! operator== (other);
}

bool KeyPress::isCurrentlyDown() const
{
	return isKeyCurrentlyDown (keyCode)
			&& (ModifierKeys::getCurrentModifiers().getRawFlags() & ModifierKeys::allKeyboardModifiers)
				  == (mods.getRawFlags() & ModifierKeys::allKeyboardModifiers);
}

namespace KeyPressHelpers
{
	struct KeyNameAndCode
	{
		const char* name;
		int code;
	};

	const KeyNameAndCode translations[] =
	{
		{ "spacebar",       KeyPress::spaceKey },
		{ "return",         KeyPress::returnKey },
		{ "escape",         KeyPress::escapeKey },
		{ "backspace",      KeyPress::backspaceKey },
		{ "cursor left",    KeyPress::leftKey },
		{ "cursor right",   KeyPress::rightKey },
		{ "cursor up",      KeyPress::upKey },
		{ "cursor down",    KeyPress::downKey },
		{ "page up",        KeyPress::pageUpKey },
		{ "page down",      KeyPress::pageDownKey },
		{ "home",           KeyPress::homeKey },
		{ "end",            KeyPress::endKey },
		{ "delete",         KeyPress::deleteKey },
		{ "insert",         KeyPress::insertKey },
		{ "tab",            KeyPress::tabKey },
		{ "play",           KeyPress::playKey },
		{ "stop",           KeyPress::stopKey },
		{ "fast forward",   KeyPress::fastForwardKey },
		{ "rewind",         KeyPress::rewindKey }
	};

	struct ModifierDescription
	{
		const char* name;
		int flag;
	};

	static const ModifierDescription modifierNames[] =
	{
		{ "ctrl",      ModifierKeys::ctrlModifier },
		{ "control",   ModifierKeys::ctrlModifier },
		{ "ctl",       ModifierKeys::ctrlModifier },
		{ "shift",     ModifierKeys::shiftModifier },
		{ "shft",      ModifierKeys::shiftModifier },
		{ "alt",       ModifierKeys::altModifier },
		{ "option",    ModifierKeys::altModifier },
		{ "command",   ModifierKeys::commandModifier },
		{ "cmd",       ModifierKeys::commandModifier }
	};

	static const char* numberPadPrefix() noexcept      { return "numpad "; }

	static int getNumpadKeyCode (const String& desc)
	{
		if (desc.containsIgnoreCase (numberPadPrefix()))
		{
			const juce_wchar lastChar = desc.trimEnd().getLastCharacter();

			switch (lastChar)
			{
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
					return (int) (KeyPress::numberPad0 + lastChar - '0');

				case '+':   return KeyPress::numberPadAdd;
				case '-':   return KeyPress::numberPadSubtract;
				case '*':   return KeyPress::numberPadMultiply;
				case '/':   return KeyPress::numberPadDivide;
				case '.':   return KeyPress::numberPadDecimalPoint;
				case '=':   return KeyPress::numberPadEquals;

				default:    break;
			}

			if (desc.endsWith ("separator"))  return KeyPress::numberPadSeparator;
			if (desc.endsWith ("delete"))     return KeyPress::numberPadDelete;
		}

		return 0;
	}

   #if JUCE_MAC
	struct OSXSymbolReplacement
	{
		const char* text;
		juce_wchar symbol;
	};

	const OSXSymbolReplacement osxSymbols[] =
	{
		{ "shift + ",     0x21e7 },
		{ "command + ",   0x2318 },
		{ "option + ",    0x2325 },
		{ "ctrl + ",      0x2303 },
		{ "return",       0x23ce },
		{ "cursor left",  0x2190 },
		{ "cursor right", 0x2192 },
		{ "cursor up",    0x2191 },
		{ "cursor down",  0x2193 },
		{ "backspace",    0x232b },
		{ "delete",       0x2326 }
	};
   #endif
}

KeyPress KeyPress::createFromDescription (const String& desc)
{
	int modifiers = 0;

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::modifierNames); ++i)
		if (desc.containsWholeWordIgnoreCase (KeyPressHelpers::modifierNames[i].name))
			modifiers |= KeyPressHelpers::modifierNames[i].flag;

	int key = 0;

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::translations); ++i)
	{
		if (desc.containsWholeWordIgnoreCase (String (KeyPressHelpers::translations[i].name)))
		{
			key = KeyPressHelpers::translations[i].code;
			break;
		}
	}

	if (key == 0)
		key = KeyPressHelpers::getNumpadKeyCode (desc);

	if (key == 0)
	{
		// see if it's a function key..
		if (! desc.containsChar ('#')) // avoid mistaking hex-codes like "#f1"
			for (int i = 1; i <= 12; ++i)
				if (desc.containsWholeWordIgnoreCase ("f" + String (i)))
					key = F1Key + i - 1;

		if (key == 0)
		{
			// give up and use the hex code..
			const int hexCode = desc.fromFirstOccurrenceOf ("#", false, false)
									.retainCharacters ("0123456789abcdefABCDEF")
									.getHexValue32();

			if (hexCode > 0)
				key = hexCode;
			else
				key = (int) CharacterFunctions::toUpperCase (desc.getLastCharacter());
		}
	}

	return KeyPress (key, ModifierKeys (modifiers), 0);
}

String KeyPress::getTextDescription() const
{
	String desc;

	if (keyCode > 0)
	{
		// some keyboard layouts use a shift-key to get the slash, but in those cases, we
		// want to store it as being a slash, not shift+whatever.
		if (textCharacter == '/')
			return "/";

		if (mods.isCtrlDown())
			desc << "ctrl + ";

		if (mods.isShiftDown())
			desc << "shift + ";

	   #if JUCE_MAC
		if (mods.isAltDown())
			desc << "option + ";

		// only do this on the mac, because on Windows ctrl and command are the same,
		// and this would get confusing
		if (mods.isCommandDown())
			desc << "command + ";
	   #else
		if (mods.isAltDown())
			desc << "alt + ";
	   #endif

		for (int i = 0; i < numElementsInArray (KeyPressHelpers::translations); ++i)
			if (keyCode == KeyPressHelpers::translations[i].code)
				return desc + KeyPressHelpers::translations[i].name;

		if (keyCode >= F1Key && keyCode <= F16Key)                  desc << 'F' << (1 + keyCode - F1Key);
		else if (keyCode >= numberPad0 && keyCode <= numberPad9)    desc << KeyPressHelpers::numberPadPrefix() << (keyCode - numberPad0);
		else if (keyCode >= 33 && keyCode < 176)        desc += CharacterFunctions::toUpperCase ((juce_wchar) keyCode);
		else if (keyCode == numberPadAdd)               desc << KeyPressHelpers::numberPadPrefix() << '+';
		else if (keyCode == numberPadSubtract)          desc << KeyPressHelpers::numberPadPrefix() << '-';
		else if (keyCode == numberPadMultiply)          desc << KeyPressHelpers::numberPadPrefix() << '*';
		else if (keyCode == numberPadDivide)            desc << KeyPressHelpers::numberPadPrefix() << '/';
		else if (keyCode == numberPadSeparator)         desc << KeyPressHelpers::numberPadPrefix() << "separator";
		else if (keyCode == numberPadDecimalPoint)      desc << KeyPressHelpers::numberPadPrefix() << '.';
		else if (keyCode == numberPadDelete)            desc << KeyPressHelpers::numberPadPrefix() << "delete";
		else                                            desc << '#' << String::toHexString (keyCode);
	}

	return desc;
}

String KeyPress::getTextDescriptionWithIcons() const
{
   #if JUCE_MAC
	String s (getTextDescription());

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::osxSymbols); ++i)
		s = s.replace (KeyPressHelpers::osxSymbols[i].text,
					   String::charToString (KeyPressHelpers::osxSymbols[i].symbol));

	return s;
   #else
	return getTextDescription();
   #endif
}

/*** End of inlined file: juce_KeyPress.cpp ***/


/*** Start of inlined file: juce_ModifierKeys.cpp ***/
ModifierKeys::ModifierKeys() noexcept
	: flags (0)
{
}

ModifierKeys::ModifierKeys (const int flags_) noexcept
	: flags (flags_)
{
}

ModifierKeys::ModifierKeys (const ModifierKeys& other) noexcept
	: flags (other.flags)
{
}

ModifierKeys& ModifierKeys::operator= (const ModifierKeys& other) noexcept
{
	flags = other.flags;
	return *this;
}

ModifierKeys ModifierKeys::currentModifiers;

ModifierKeys ModifierKeys::getCurrentModifiers() noexcept
{
	return currentModifiers;
}

int ModifierKeys::getNumMouseButtonsDown() const noexcept
{
	int num = 0;

	if (isLeftButtonDown())     ++num;
	if (isRightButtonDown())    ++num;
	if (isMiddleButtonDown())   ++num;

	return num;
}

/*** End of inlined file: juce_ModifierKeys.cpp ***/


/*** Start of inlined file: juce_ArrowButton.cpp ***/
ArrowButton::ArrowButton (const String& name,
						  float arrowDirectionInRadians,
						  const Colour& arrowColour)
   : Button (name),
	 colour (arrowColour)
{
	path.lineTo (0.0f, 1.0f);
	path.lineTo (1.0f, 0.5f);
	path.closeSubPath();

	path.applyTransform (AffineTransform::rotation (float_Pi * 2.0f * arrowDirectionInRadians,
													0.5f, 0.5f));

	setComponentEffect (&shadow);
	updateShadowAndOffset();
}

ArrowButton::~ArrowButton()
{
}

void ArrowButton::paintButton (Graphics& g,
							   bool /*isMouseOverButton*/,
							   bool /*isButtonDown*/)
{
	g.setColour (colour);

	g.fillPath (path, path.getTransformToScaleToFit ((float) offset,
													 (float) offset,
													 (float) (getWidth() - 3),
													 (float) (getHeight() - 3),
													 false));
}

void ArrowButton::buttonStateChanged()
{
	updateShadowAndOffset();
}

void ArrowButton::updateShadowAndOffset()
{
	offset = (isDown()) ? 1 : 0;

	shadow.setShadowProperties ((isDown()) ? 1.2f : 3.0f,
								0.3f, -1, 0);
}

/*** End of inlined file: juce_ArrowButton.cpp ***/


/*** Start of inlined file: juce_Button.cpp ***/
class Button::RepeatTimer  : public Timer
{
public:
	RepeatTimer (Button& owner_) : owner (owner_)   {}
	void timerCallback()    { owner.repeatTimerCallback(); }

private:
	Button& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RepeatTimer);
};

Button::Button (const String& name)
  : Component (name),
	text (name),
	buttonPressTime (0),
	lastRepeatTime (0),
	commandManagerToUse (nullptr),
	autoRepeatDelay (-1),
	autoRepeatSpeed (0),
	autoRepeatMinimumDelay (-1),
	radioGroupId (0),
	commandID (0),
	connectedEdgeFlags (0),
	buttonState (buttonNormal),
	lastToggleState (false),
	clickTogglesState (false),
	needsToRelease (false),
	needsRepainting (false),
	isKeyDown (false),
	triggerOnMouseDown (false),
	generateTooltip (false)
{
	setWantsKeyboardFocus (true);
	isOn.addListener (this);
}

Button::~Button()
{
	isOn.removeListener (this);

	if (commandManagerToUse != nullptr)
		commandManagerToUse->removeListener (this);

	repeatTimer = nullptr;
	clearShortcuts();
}

void Button::setButtonText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		repaint();
	}
}

void Button::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	generateTooltip = false;
}

String Button::getTooltip()
{
	if (generateTooltip && commandManagerToUse != nullptr && commandID != 0)
	{
		String tt (commandManagerToUse->getDescriptionOfCommand (commandID));

		Array <KeyPress> keyPresses (commandManagerToUse->getKeyMappings()->getKeyPressesAssignedToCommand (commandID));

		for (int i = 0; i < keyPresses.size(); ++i)
		{
			const String key (keyPresses.getReference(i).getTextDescription());

			tt << " [";

			if (key.length() == 1)
				tt << TRANS("shortcut") << ": '" << key << "']";
			else
				tt << key << ']';
		}

		return tt;
	}

	return SettableTooltipClient::getTooltip();
}

void Button::setConnectedEdges (const int connectedEdgeFlags_)
{
	if (connectedEdgeFlags != connectedEdgeFlags_)
	{
		connectedEdgeFlags = connectedEdgeFlags_;
		repaint();
	}
}

void Button::setToggleState (const bool shouldBeOn,
							 const bool sendChangeNotification)
{
	if (shouldBeOn != lastToggleState)
	{
		if (getToggleState() != shouldBeOn)  // this test means that if the value is void rather than explicitly set to
			isOn = shouldBeOn;               // false, it won't be changed unless the required value is true.

		lastToggleState = shouldBeOn;
		repaint();

		WeakReference<Component> deletionWatcher (this);

		if (sendChangeNotification)
		{
			sendClickMessage (ModifierKeys());

			if (deletionWatcher == nullptr)
				return;
		}

		if (lastToggleState)
		{
			turnOffOtherButtonsInGroup (sendChangeNotification);

			if (deletionWatcher == nullptr)
				return;
		}

		sendStateMessage();
	}
}

void Button::setClickingTogglesState (const bool shouldToggle) noexcept
{
	clickTogglesState = shouldToggle;

	// if you've got clickTogglesState turned on, you shouldn't also connect the button
	// up to be a command invoker. Instead, your command handler must flip the state of whatever
	// it is that this button represents, and the button will update its state to reflect this
	// in the applicationCommandListChanged() method.
	jassert (commandManagerToUse == nullptr || ! clickTogglesState);
}

bool Button::getClickingTogglesState() const noexcept
{
	return clickTogglesState;
}

void Button::valueChanged (Value& value)
{
	if (value.refersToSameSourceAs (isOn))
		setToggleState (isOn.getValue(), true);
}

void Button::setRadioGroupId (const int newGroupId)
{
	if (radioGroupId != newGroupId)
	{
		radioGroupId = newGroupId;

		if (lastToggleState)
			turnOffOtherButtonsInGroup (true);
	}
}

void Button::turnOffOtherButtonsInGroup (const bool sendChangeNotification)
{
	Component* const p = getParentComponent();

	if (p != nullptr && radioGroupId != 0)
	{
		WeakReference<Component> deletionWatcher (this);

		for (int i = p->getNumChildComponents(); --i >= 0;)
		{
			Component* const c = p->getChildComponent (i);

			if (c != this)
			{
				Button* const b = dynamic_cast <Button*> (c);

				if (b != nullptr && b->getRadioGroupId() == radioGroupId)
				{
					b->setToggleState (false, sendChangeNotification);

					if (deletionWatcher == nullptr)
						return;
				}
			}
		}
	}
}

void Button::enablementChanged()
{
	updateState();
	repaint();
}

Button::ButtonState Button::updateState()
{
	return updateState (isMouseOver (true), isMouseButtonDown());
}

Button::ButtonState Button::updateState (const bool over, const bool down)
{
	ButtonState newState = buttonNormal;

	if (isEnabled() && isVisible() && ! isCurrentlyBlockedByAnotherModalComponent())
	{
		if ((down && (over || (triggerOnMouseDown && buttonState == buttonDown))) || isKeyDown)
			newState = buttonDown;
		else if (over)
			newState = buttonOver;
	}

	setState (newState);
	return newState;
}

void Button::setState (const ButtonState newState)
{
	if (buttonState != newState)
	{
		buttonState = newState;
		repaint();

		if (buttonState == buttonDown)
		{
			buttonPressTime = Time::getApproximateMillisecondCounter();
			lastRepeatTime = 0;
		}

		sendStateMessage();
	}
}

bool Button::isDown() const noexcept
{
	return buttonState == buttonDown;
}

bool Button::isOver() const noexcept
{
	return buttonState != buttonNormal;
}

void Button::buttonStateChanged()
{
}

uint32 Button::getMillisecondsSinceButtonDown() const noexcept
{
	const uint32 now = Time::getApproximateMillisecondCounter();
	return now > buttonPressTime ? now - buttonPressTime : 0;
}

void Button::setTriggeredOnMouseDown (const bool isTriggeredOnMouseDown) noexcept
{
	triggerOnMouseDown = isTriggeredOnMouseDown;
}

void Button::clicked()
{
}

void Button::clicked (const ModifierKeys& /*modifiers*/)
{
	clicked();
}

enum { clickMessageId = 0x2f3f4f99 };

void Button::triggerClick()
{
	postCommandMessage (clickMessageId);
}

void Button::internalClickCallback (const ModifierKeys& modifiers)
{
	if (clickTogglesState)
		setToggleState ((radioGroupId != 0) || ! lastToggleState, false);

	sendClickMessage (modifiers);
}

void Button::flashButtonState()
{
	if (isEnabled())
	{
		needsToRelease = true;
		setState (buttonDown);
		getRepeatTimer().startTimer (100);
	}
}

void Button::handleCommandMessage (int commandId)
{
	if (commandId == clickMessageId)
	{
		if (isEnabled())
		{
			flashButtonState();
			internalClickCallback (ModifierKeys::getCurrentModifiers());
		}
	}
	else
	{
		Component::handleCommandMessage (commandId);
	}
}

void Button::addListener (ButtonListener* const newListener)
{
	buttonListeners.add (newListener);
}

void Button::removeListener (ButtonListener* const listener)
{
	buttonListeners.remove (listener);
}

void Button::addButtonListener (ButtonListener* l)      { addListener (l); }
void Button::removeButtonListener (ButtonListener* l)   { removeListener (l); }

void Button::sendClickMessage (const ModifierKeys& modifiers)
{
	Component::BailOutChecker checker (this);

	if (commandManagerToUse != nullptr && commandID != 0)
	{
		ApplicationCommandTarget::InvocationInfo info (commandID);
		info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromButton;
		info.originatingComponent = this;

		commandManagerToUse->invoke (info, true);
	}

	clicked (modifiers);

	if (! checker.shouldBailOut())
		buttonListeners.callChecked (checker, &ButtonListener::buttonClicked, this);  // (can't use Button::Listener due to idiotic VC2005 bug)
}

void Button::sendStateMessage()
{
	Component::BailOutChecker checker (this);

	buttonStateChanged();

	if (! checker.shouldBailOut())
		buttonListeners.callChecked (checker, &ButtonListener::buttonStateChanged, this);
}

void Button::paint (Graphics& g)
{
	if (needsToRelease && isEnabled())
	{
		needsToRelease = false;
		needsRepainting = true;
	}

	paintButton (g, isOver(), isDown());
}

void Button::mouseEnter (const MouseEvent&)
{
	updateState (true, false);
}

void Button::mouseExit (const MouseEvent&)
{
	updateState (false, false);
}

void Button::mouseDown (const MouseEvent& e)
{
	updateState (true, true);

	if (isDown())
	{
		if (autoRepeatDelay >= 0)
			getRepeatTimer().startTimer (autoRepeatDelay);

		if (triggerOnMouseDown)
			internalClickCallback (e.mods);
	}
}

void Button::mouseUp (const MouseEvent& e)
{
	const bool wasDown = isDown();
	updateState (isMouseOver(), false);

	if (wasDown && isOver() && ! triggerOnMouseDown)
		internalClickCallback (e.mods);
}

void Button::mouseDrag (const MouseEvent&)
{
	const ButtonState oldState = buttonState;
	updateState (isMouseOver(), true);

	if (autoRepeatDelay >= 0 && buttonState != oldState && isDown())
		getRepeatTimer().startTimer (autoRepeatSpeed);
}

void Button::focusGained (FocusChangeType)
{
	updateState();
	repaint();
}

void Button::focusLost (FocusChangeType)
{
	updateState();
	repaint();
}

void Button::visibilityChanged()
{
	needsToRelease = false;
	updateState();
}

void Button::parentHierarchyChanged()
{
	Component* const newKeySource = (shortcuts.size() == 0) ? nullptr : getTopLevelComponent();

	if (newKeySource != keySource.get())
	{
		if (keySource != nullptr)
			keySource->removeKeyListener (this);

		keySource = newKeySource;

		if (keySource != nullptr)
			keySource->addKeyListener (this);
	}
}

void Button::setCommandToTrigger (ApplicationCommandManager* const commandManagerToUse_,
								  const int commandID_,
								  const bool generateTooltip_)
{
	commandID = commandID_;
	generateTooltip = generateTooltip_;

	if (commandManagerToUse != commandManagerToUse_)
	{
		if (commandManagerToUse != nullptr)
			commandManagerToUse->removeListener (this);

		commandManagerToUse = commandManagerToUse_;

		if (commandManagerToUse != nullptr)
			commandManagerToUse->addListener (this);

		// if you've got clickTogglesState turned on, you shouldn't also connect the button
		// up to be a command invoker. Instead, your command handler must flip the state of whatever
		// it is that this button represents, and the button will update its state to reflect this
		// in the applicationCommandListChanged() method.
		jassert (commandManagerToUse == nullptr || ! clickTogglesState);
	}

	if (commandManagerToUse != nullptr)
		applicationCommandListChanged();
	else
		setEnabled (true);
}

void Button::applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info)
{
	if (info.commandID == commandID
		 && (info.commandFlags & ApplicationCommandInfo::dontTriggerVisualFeedback) == 0)
	{
		flashButtonState();
	}
}

void Button::applicationCommandListChanged()
{
	if (commandManagerToUse != nullptr)
	{
		ApplicationCommandInfo info (0);

		ApplicationCommandTarget* const target = commandManagerToUse->getTargetForCommand (commandID, info);

		setEnabled (target != nullptr && (info.flags & ApplicationCommandInfo::isDisabled) == 0);

		if (target != nullptr)
			setToggleState ((info.flags & ApplicationCommandInfo::isTicked) != 0, false);
	}
}

void Button::addShortcut (const KeyPress& key)
{
	if (key.isValid())
	{
		jassert (! isRegisteredForShortcut (key));  // already registered!

		shortcuts.add (key);
		parentHierarchyChanged();
	}
}

void Button::clearShortcuts()
{
	shortcuts.clear();

	parentHierarchyChanged();
}

bool Button::isShortcutPressed() const
{
	if (! isCurrentlyBlockedByAnotherModalComponent())
	{
		for (int i = shortcuts.size(); --i >= 0;)
			if (shortcuts.getReference(i).isCurrentlyDown())
				return true;
	}

	return false;
}

bool Button::isRegisteredForShortcut (const KeyPress& key) const
{
	for (int i = shortcuts.size(); --i >= 0;)
		if (key == shortcuts.getReference(i))
			return true;

	return false;
}

bool Button::keyStateChanged (const bool, Component*)
{
	if (! isEnabled())
		return false;

	const bool wasDown = isKeyDown;
	isKeyDown = isShortcutPressed();

	if (autoRepeatDelay >= 0 && (isKeyDown && ! wasDown))
		getRepeatTimer().startTimer (autoRepeatDelay);

	updateState();

	if (isEnabled() && wasDown && ! isKeyDown)
	{
		internalClickCallback (ModifierKeys::getCurrentModifiers());

		// (return immediately - this button may now have been deleted)
		return true;
	}

	return wasDown || isKeyDown;
}

bool Button::keyPressed (const KeyPress&, Component*)
{
	// returning true will avoid forwarding events for keys that we're using as shortcuts
	return isShortcutPressed();
}

bool Button::keyPressed (const KeyPress& key)
{
	if (isEnabled() && key.isKeyCode (KeyPress::returnKey))
	{
		triggerClick();
		return true;
	}

	return false;
}

void Button::setRepeatSpeed (const int initialDelayMillisecs,
							 const int repeatMillisecs,
							 const int minimumDelayInMillisecs) noexcept
{
	autoRepeatDelay = initialDelayMillisecs;
	autoRepeatSpeed = repeatMillisecs;
	autoRepeatMinimumDelay = jmin (autoRepeatSpeed, minimumDelayInMillisecs);
}

void Button::repeatTimerCallback()
{
	if (needsRepainting)
	{
		getRepeatTimer().stopTimer();
		updateState();
		needsRepainting = false;
	}
	else if (autoRepeatSpeed > 0 && (isKeyDown || (updateState() == buttonDown)))
	{
		int repeatSpeed = autoRepeatSpeed;

		if (autoRepeatMinimumDelay >= 0)
		{
			double timeHeldDown = jmin (1.0, getMillisecondsSinceButtonDown() / 4000.0);
			timeHeldDown *= timeHeldDown;

			repeatSpeed = repeatSpeed + (int) (timeHeldDown * (autoRepeatMinimumDelay - repeatSpeed));
		}

		repeatSpeed = jmax (1, repeatSpeed);

		const uint32 now = Time::getMillisecondCounter();

		// if we've been blocked from repeating often enough, speed up the repeat timer to compensate..
		if (lastRepeatTime != 0 && (int) (now - lastRepeatTime) > repeatSpeed * 2)
			repeatSpeed = jmax (1, repeatSpeed / 2);

		lastRepeatTime = now;
		getRepeatTimer().startTimer (repeatSpeed);

		internalClickCallback (ModifierKeys::getCurrentModifiers());
	}
	else if (! needsToRelease)
	{
		getRepeatTimer().stopTimer();
	}
}

Button::RepeatTimer& Button::getRepeatTimer()
{
	if (repeatTimer == nullptr)
		repeatTimer = new RepeatTimer (*this);

	return *repeatTimer;
}

const Identifier Button::Ids::text ("text");
const Identifier Button::Ids::radioGroup ("radioGroup");
const Identifier Button::Ids::connectedLeft ("connectedLeft");
const Identifier Button::Ids::connectedRight ("connectedRight");
const Identifier Button::Ids::connectedTop ("connectedTop");
const Identifier Button::Ids::connectedBottom ("connectedBottom");

void Button::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setButtonText (state [Ids::text].toString());
	setRadioGroupId (state [Ids::radioGroup]);
	setConnectedEdges (getConnectedFlags (state));
}

int Button::getConnectedFlags (const ValueTree& state)
{
	int connected = 0;
	if (state [Button::Ids::connectedLeft])    connected |= Button::ConnectedOnLeft;
	if (state [Button::Ids::connectedRight])   connected |= Button::ConnectedOnRight;
	if (state [Button::Ids::connectedTop])     connected |= Button::ConnectedOnTop;
	if (state [Button::Ids::connectedBottom])  connected |= Button::ConnectedOnBottom;
	return connected;
}

/*** End of inlined file: juce_Button.cpp ***/


/*** Start of inlined file: juce_DrawableButton.cpp ***/
DrawableButton::DrawableButton (const String& name,
								const DrawableButton::ButtonStyle buttonStyle)
	: Button (name),
	  style (buttonStyle),
	  currentImage (nullptr),
	  edgeIndent (3)
{
	if (buttonStyle == ImageOnButtonBackground)
	{
		backgroundOff = Colour (0xffbbbbff);
		backgroundOn = Colour (0xff3333ff);
	}
	else
	{
		backgroundOff = Colours::transparentBlack;
		backgroundOn = Colour (0xaabbbbff);
	}
}

DrawableButton::~DrawableButton()
{
}

void DrawableButton::setImages (const Drawable* normal,
								const Drawable* over,
								const Drawable* down,
								const Drawable* disabled,
								const Drawable* normalOn,
								const Drawable* overOn,
								const Drawable* downOn,
								const Drawable* disabledOn)
{
	jassert (normal != nullptr); // you really need to give it at least a normal image..

	if (normal != nullptr)        normalImage = normal->createCopy();
	if (over != nullptr)          overImage = over->createCopy();
	if (down != nullptr)          downImage = down->createCopy();
	if (disabled != nullptr)      disabledImage = disabled->createCopy();
	if (normalOn != nullptr)      normalImageOn = normalOn->createCopy();
	if (overOn != nullptr)        overImageOn = overOn->createCopy();
	if (downOn != nullptr)        downImageOn = downOn->createCopy();
	if (disabledOn != nullptr)    disabledImageOn = disabledOn->createCopy();

	buttonStateChanged();
}

void DrawableButton::setButtonStyle (const DrawableButton::ButtonStyle newStyle)
{
	if (style != newStyle)
	{
		style = newStyle;
		buttonStateChanged();
	}
}

void DrawableButton::setBackgroundColours (const Colour& toggledOffColour,
										   const Colour& toggledOnColour)
{
	if (backgroundOff != toggledOffColour
		 || backgroundOn != toggledOnColour)
	{
		backgroundOff = toggledOffColour;
		backgroundOn = toggledOnColour;

		repaint();
	}
}

const Colour& DrawableButton::getBackgroundColour() const noexcept
{
	return getToggleState() ? backgroundOn
							: backgroundOff;
}

void DrawableButton::setEdgeIndent (const int numPixelsIndent)
{
	edgeIndent = numPixelsIndent;
	repaint();
	resized();
}

void DrawableButton::resized()
{
	Button::resized();

	if (currentImage != nullptr)
	{
		if (style == ImageRaw)
		{
			currentImage->setOriginWithOriginalSize (Point<float>());
		}
		else
		{
			Rectangle<int> imageSpace;

			if (style == ImageOnButtonBackground)
			{
				imageSpace = getLocalBounds().reduced (getWidth() / 4, getHeight() / 4);
			}
			else
			{
				const int textH = (style == ImageAboveTextLabel) ? jmin (16, proportionOfHeight (0.25f)) : 0;

				const int indentX = jmin (edgeIndent, proportionOfWidth (0.3f));
				const int indentY = jmin (edgeIndent, proportionOfHeight (0.3f));

				imageSpace.setBounds (indentX, indentY,
									  getWidth() - indentX * 2,
									  getHeight() - indentY * 2 - textH);
			}

			currentImage->setTransformToFit (imageSpace.toFloat(), RectanglePlacement::centred);
		}
	}
}

void DrawableButton::buttonStateChanged()
{
	repaint();

	Drawable* imageToDraw = nullptr;
	float opacity = 1.0f;

	if (isEnabled())
	{
		imageToDraw = getCurrentImage();
	}
	else
	{
		imageToDraw = getToggleState() ? disabledImageOn
									   : disabledImage;

		if (imageToDraw == nullptr)
		{
			opacity = 0.4f;
			imageToDraw = getNormalImage();
		}
	}

	if (imageToDraw != currentImage)
	{
		removeChildComponent (currentImage);
		currentImage = imageToDraw;

		if (currentImage != nullptr)
		{
			currentImage->setInterceptsMouseClicks (false, false);
			addAndMakeVisible (currentImage);
			DrawableButton::resized();
		}
	}

	if (currentImage != nullptr)
		currentImage->setAlpha (opacity);
}

void DrawableButton::enablementChanged()
{
	Button::enablementChanged();
	buttonStateChanged();
}

void DrawableButton::paintButton (Graphics& g,
								  bool isMouseOverButton,
								  bool isButtonDown)
{
	if (style == ImageOnButtonBackground)
	{
		getLookAndFeel().drawButtonBackground (g, *this,
											   getBackgroundColour(),
											   isMouseOverButton,
											   isButtonDown);
	}
	else
	{
		g.fillAll (getBackgroundColour());

		const int textH = (style == ImageAboveTextLabel)
							? jmin (16, proportionOfHeight (0.25f))
							: 0;

		if (textH > 0)
		{
			g.setFont ((float) textH);

			g.setColour (findColour (DrawableButton::textColourId)
							.withMultipliedAlpha (isEnabled() ? 1.0f : 0.4f));

			g.drawFittedText (getButtonText(),
							  2, getHeight() - textH - 1,
							  getWidth() - 4, textH,
							  Justification::centred, 1);
		}
	}
}

Drawable* DrawableButton::getCurrentImage() const noexcept
{
	if (isDown())
		return getDownImage();

	if (isOver())
		return getOverImage();

	return getNormalImage();
}

Drawable* DrawableButton::getNormalImage() const noexcept
{
	return (getToggleState() && normalImageOn != nullptr) ? normalImageOn
														  : normalImage;
}

Drawable* DrawableButton::getOverImage() const noexcept
{
	Drawable* d = normalImage;

	if (getToggleState())
	{
		if (overImageOn != nullptr)
			d = overImageOn;
		else if (normalImageOn != nullptr)
			d = normalImageOn;
		else if (overImage != nullptr)
			d = overImage;
	}
	else
	{
		if (overImage != nullptr)
			d = overImage;
	}

	return d;
}

Drawable* DrawableButton::getDownImage() const noexcept
{
	Drawable* d = normalImage;

	if (getToggleState())
	{
		if (downImageOn != nullptr)
			d = downImageOn;
		else if (overImageOn != nullptr)
			d = overImageOn;
		else if (normalImageOn != nullptr)
			d = normalImageOn;
		else if (downImage != nullptr)
			d = downImage;
		else
			d = getOverImage();
	}
	else
	{
		if (downImage != nullptr)
			d = downImage;
		else
			d = getOverImage();
	}

	return d;
}

/*** End of inlined file: juce_DrawableButton.cpp ***/


/*** Start of inlined file: juce_HyperlinkButton.cpp ***/
HyperlinkButton::HyperlinkButton (const String& linkText,
								  const URL& linkURL)
   : Button (linkText),
	 url (linkURL),
	 font (14.0f, Font::underlined),
	 resizeFont (true),
	 justification (Justification::centred)
{
	setMouseCursor (MouseCursor::PointingHandCursor);
	setTooltip (linkURL.toString (false));
}

HyperlinkButton::HyperlinkButton ()
   : Button (String::empty),
	 font (14.0f, Font::underlined),
	 resizeFont (true),
	 justification (Justification::centred)
{
	setMouseCursor (MouseCursor::PointingHandCursor);
}

HyperlinkButton::~HyperlinkButton()
{
}

void HyperlinkButton::setFont (const Font& newFont,
							   const bool resizeToMatchComponentHeight,
							   const Justification& justificationType)
{
	font = newFont;
	resizeFont = resizeToMatchComponentHeight;
	justification = justificationType;
	repaint();
}

void HyperlinkButton::setURL (const URL& newURL) noexcept
{
	url = newURL;
	setTooltip (newURL.toString (false));
}

Font HyperlinkButton::getFontToUse() const
{
	if (resizeFont)
		return font.withHeight (getHeight() * 0.7f);

	return font;
}

void HyperlinkButton::changeWidthToFitText()
{
	setSize (getFontToUse().getStringWidth (getName()) + 6, getHeight());
}

void HyperlinkButton::colourChanged()
{
	repaint();
}

void HyperlinkButton::clicked()
{
	if (url.isWellFormed())
		url.launchInDefaultBrowser();
}

void HyperlinkButton::paintButton (Graphics& g,
								   bool isMouseOverButton,
								   bool isButtonDown)
{
	const Colour textColour (findColour (textColourId));

	if (isEnabled())
		g.setColour ((isMouseOverButton) ? textColour.darker ((isButtonDown) ? 1.3f : 0.4f)
										 : textColour);
	else
		g.setColour (textColour.withMultipliedAlpha (0.4f));

	g.setFont (getFontToUse());

	g.drawText (getButtonText(),
				2, 0, getWidth() - 2, getHeight(),
				justification.getOnlyHorizontalFlags() | Justification::verticallyCentred,
				true);
}

const Identifier HyperlinkButton::Ids::tagType ("HYPERLINKBUTTON");
const Identifier HyperlinkButton::Ids::text ("text");
const Identifier HyperlinkButton::Ids::url ("url");

void HyperlinkButton::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setButtonText (state [Ids::text].toString());
	setURL (URL (state [Ids::url].toString()));
}

/*** End of inlined file: juce_HyperlinkButton.cpp ***/


/*** Start of inlined file: juce_ImageButton.cpp ***/
ImageButton::ImageButton (const String& text_)
	: Button (text_),
	  scaleImageToFit (true),
	  preserveProportions (true),
	  alphaThreshold (0)
{
}

ImageButton::~ImageButton()
{
}

void ImageButton::setImages (const bool resizeButtonNowToFitThisImage,
							 const bool rescaleImagesWhenButtonSizeChanges,
							 const bool preserveImageProportions,
							 const Image& normalImage_,
							 const float imageOpacityWhenNormal,
							 const Colour& overlayColourWhenNormal,
							 const Image& overImage_,
							 const float imageOpacityWhenOver,
							 const Colour& overlayColourWhenOver,
							 const Image& downImage_,
							 const float imageOpacityWhenDown,
							 const Colour& overlayColourWhenDown,
							 const float hitTestAlphaThreshold)
{
	normalImage = normalImage_;
	overImage = overImage_;
	downImage = downImage_;

	if (resizeButtonNowToFitThisImage && normalImage.isValid())
	{
		imageBounds.setSize (normalImage.getWidth(),
							 normalImage.getHeight());

		setSize (imageBounds.getWidth(), imageBounds.getHeight());
	}

	scaleImageToFit = rescaleImagesWhenButtonSizeChanges;
	preserveProportions = preserveImageProportions;

	normalOpacity = imageOpacityWhenNormal;
	normalOverlay = overlayColourWhenNormal;
	overOpacity   = imageOpacityWhenOver;
	overOverlay   = overlayColourWhenOver;
	downOpacity   = imageOpacityWhenDown;
	downOverlay   = overlayColourWhenDown;

	alphaThreshold = (uint8) jlimit (0, 0xff, roundToInt (255.0f * hitTestAlphaThreshold));

	repaint();
}

Image ImageButton::getCurrentImage() const
{
	if (isDown() || getToggleState())
		return getDownImage();

	if (isOver())
		return getOverImage();

	return getNormalImage();
}

Image ImageButton::getNormalImage() const
{
	return normalImage;
}

Image ImageButton::getOverImage() const
{
	return overImage.isValid() ? overImage
							   : normalImage;
}

Image ImageButton::getDownImage() const
{
	return downImage.isValid() ? downImage
							   : getOverImage();
}

void ImageButton::paintButton (Graphics& g,
							   bool isMouseOverButton,
							   bool isButtonDown)
{
	if (! isEnabled())
	{
		isMouseOverButton = false;
		isButtonDown = false;
	}

	Image im (getCurrentImage());

	if (im.isValid())
	{
		const int iw = im.getWidth();
		const int ih = im.getHeight();
		int w = getWidth();
		int h = getHeight();
		int x = (w - iw) / 2;
		int y = (h - ih) / 2;

		if (scaleImageToFit)
		{
			if (preserveProportions)
			{
				int newW, newH;
				const float imRatio = ih / (float) iw;
				const float destRatio = h / (float) w;

				if (imRatio > destRatio)
				{
					newW = roundToInt (h / imRatio);
					newH = h;
				}
				else
				{
					newW = w;
					newH = roundToInt (w * imRatio);
				}

				x = (w - newW) / 2;
				y = (h - newH) / 2;
				w = newW;
				h = newH;
			}
			else
			{
				x = 0;
				y = 0;
			}
		}

		if (! scaleImageToFit)
		{
			w = iw;
			h = ih;
		}

		imageBounds.setBounds (x, y, w, h);

		const bool useDownImage = isButtonDown || getToggleState();

		getLookAndFeel().drawImageButton (g, &im, x, y, w, h,
										  useDownImage ? downOverlay
													   : (isMouseOverButton ? overOverlay
																			: normalOverlay),
										  useDownImage ? downOpacity
													   : (isMouseOverButton ? overOpacity
																			: normalOpacity),
										  *this);
	}
}

bool ImageButton::hitTest (int x, int y)
{
	if (alphaThreshold == 0)
		return true;

	Image im (getCurrentImage());

	return im.isNull() || ((! imageBounds.isEmpty())
							&& alphaThreshold < im.getPixelAt (((x - imageBounds.getX()) * im.getWidth()) / imageBounds.getWidth(),
															   ((y - imageBounds.getY()) * im.getHeight()) / imageBounds.getHeight()).getAlpha());
}

const Identifier ImageButton::Ids::tagType     ("IMAGEBUTTON");
const Identifier ImageButton::Ids::upImage     ("upImage");
const Identifier ImageButton::Ids::overImage   ("overImage");
const Identifier ImageButton::Ids::downImage   ("downImage");
const Identifier ImageButton::Ids::upOverlay   ("upOverlay");
const Identifier ImageButton::Ids::overOverlay ("overOverlay");
const Identifier ImageButton::Ids::downOverlay ("downOverlay");
const Identifier ImageButton::Ids::upOpacity   ("upOpacity");
const Identifier ImageButton::Ids::overOpacity ("overOpacity");
const Identifier ImageButton::Ids::downOpacity ("downOpacity");

namespace ImageButtonHelpers
{
	static Colour getColourFromVar (const var& col)
	{
		return col.isString() ? Colour::fromString (col.toString())
							  : Colours::transparentBlack;
	}

	static float getOpacityFromVar (const var& v)
	{
		return v.isVoid() ? 1.0f : static_cast<float> (v);
	}
}

void ImageButton::refreshFromValueTree (const ValueTree& state, ComponentBuilder& builder)
{
	Button::refreshFromValueTree (state, builder);

	const var upImageIdentifier (state [Ids::upImage]),
			  overImageIdentifier (state [Ids::overImage]),
			  downImageIdentifier (state [Ids::downImage]);

	ComponentBuilder::ImageProvider* const imageProvider = builder.getImageProvider();
	jassert (imageProvider != nullptr || upImageIdentifier.isVoid());

	Image newUpImage, newOverImage, newDownImage;

	if (imageProvider != nullptr)
	{
		newUpImage   = imageProvider->getImageForIdentifier (upImageIdentifier);
		newOverImage = imageProvider->getImageForIdentifier (overImageIdentifier);
		newDownImage = imageProvider->getImageForIdentifier (downImageIdentifier);
	}

	using namespace ImageButtonHelpers;

	setImages (false, true, true,
			   newUpImage,   getOpacityFromVar (state[Ids::upOpacity]),   getColourFromVar (state[Ids::upOverlay]),
			   newOverImage, getOpacityFromVar (state[Ids::overOpacity]), getColourFromVar (state[Ids::overOverlay]),
			   newDownImage, getOpacityFromVar (state[Ids::downOpacity]), getColourFromVar (state[Ids::downOverlay]));
}

/*** End of inlined file: juce_ImageButton.cpp ***/


/*** Start of inlined file: juce_ShapeButton.cpp ***/
ShapeButton::ShapeButton (const String& text_,
						  const Colour& normalColour_,
						  const Colour& overColour_,
						  const Colour& downColour_)
  : Button (text_),
	normalColour (normalColour_),
	overColour (overColour_),
	downColour (downColour_),
	maintainShapeProportions (false),
	outlineWidth (0.0f)
{
}

ShapeButton::~ShapeButton()
{
}

void ShapeButton::setColours (const Colour& newNormalColour,
							  const Colour& newOverColour,
							  const Colour& newDownColour)
{
	normalColour = newNormalColour;
	overColour = newOverColour;
	downColour = newDownColour;
}

void ShapeButton::setOutline (const Colour& newOutlineColour,
							  const float newOutlineWidth)
{
	outlineColour = newOutlineColour;
	outlineWidth = newOutlineWidth;
}

void ShapeButton::setShape (const Path& newShape,
							const bool resizeNowToFitThisShape,
							const bool maintainShapeProportions_,
							const bool hasShadow)
{
	shape = newShape;
	maintainShapeProportions = maintainShapeProportions_;

	shadow.setShadowProperties (3.0f, 0.5f, 0, 0);
	setComponentEffect ((hasShadow) ? &shadow : 0);

	if (resizeNowToFitThisShape)
	{
		Rectangle<float> newBounds (shape.getBounds());

		if (hasShadow)
			newBounds.expand (4.0f, 4.0f);

		shape.applyTransform (AffineTransform::translation (-newBounds.getX(), -newBounds.getY()));

		setSize (1 + (int) (newBounds.getWidth() + outlineWidth),
				 1 + (int) (newBounds.getHeight() + outlineWidth));
	}
}

void ShapeButton::paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown)
{
	if (! isEnabled())
	{
		isMouseOverButton = false;
		isButtonDown = false;
	}

	g.setColour ((isButtonDown) ? downColour
								: (isMouseOverButton) ? overColour
													  : normalColour);

	int w = getWidth();
	int h = getHeight();

	if (getComponentEffect() != nullptr)
	{
		w -= 4;
		h -= 4;
	}

	const float offset = (outlineWidth * 0.5f) + (isButtonDown ? 1.5f : 0.0f);

	const AffineTransform trans (shape.getTransformToScaleToFit (offset, offset,
																 w - offset - outlineWidth,
																 h - offset - outlineWidth,
																 maintainShapeProportions));
	g.fillPath (shape, trans);

	if (outlineWidth > 0.0f)
	{
		g.setColour (outlineColour);
		g.strokePath (shape, PathStrokeType (outlineWidth), trans);
	}
}

/*** End of inlined file: juce_ShapeButton.cpp ***/


/*** Start of inlined file: juce_TextButton.cpp ***/
TextButton::TextButton (const String& name,
						const String& toolTip)
	: Button (name)
{
	setTooltip (toolTip);
}

TextButton::~TextButton()
{
}

void TextButton::paintButton (Graphics& g,
							  bool isMouseOverButton,
							  bool isButtonDown)
{
	getLookAndFeel().drawButtonBackground (g, *this,
										   findColour (getToggleState() ? buttonOnColourId
																		: buttonColourId),
										   isMouseOverButton,
										   isButtonDown);

	getLookAndFeel().drawButtonText (g, *this,
									 isMouseOverButton,
									 isButtonDown);
}

void TextButton::colourChanged()
{
	repaint();
}

Font TextButton::getFont()
{
	return Font (jmin (15.0f, getHeight() * 0.6f));
}

void TextButton::changeWidthToFitText (const int newHeight)
{
	if (newHeight >= 0)
		setSize (jmax (1, getWidth()), newHeight);

	setSize (getFont().getStringWidth (getButtonText()) + getHeight(),
			 getHeight());
}

const Identifier TextButton::Ids::tagType ("TEXTBUTTON");

/*** End of inlined file: juce_TextButton.cpp ***/


/*** Start of inlined file: juce_ToggleButton.cpp ***/
ToggleButton::ToggleButton (const String& buttonText)
	: Button (buttonText)
{
	setClickingTogglesState (true);
}

ToggleButton::~ToggleButton()
{
}

void ToggleButton::paintButton (Graphics& g,
								bool isMouseOverButton,
								bool isButtonDown)
{
	getLookAndFeel().drawToggleButton (g, *this,
									   isMouseOverButton,
									   isButtonDown);
}

void ToggleButton::changeWidthToFitText()
{
	getLookAndFeel().changeToggleButtonWidthToFitText (*this);
}

void ToggleButton::colourChanged()
{
	repaint();
}

const Identifier ToggleButton::Ids::tagType ("TOGGLEBUTTON");

/*** End of inlined file: juce_ToggleButton.cpp ***/


/*** Start of inlined file: juce_ToolbarButton.cpp ***/
ToolbarButton::ToolbarButton (const int itemId_, const String& buttonText,
							  Drawable* const normalImage_, Drawable* const toggledOnImage_)
   : ToolbarItemComponent (itemId_, buttonText, true),
	 normalImage (normalImage_),
	 toggledOnImage (toggledOnImage_),
	 currentImage (nullptr)
{
	jassert (normalImage_ != nullptr);
}

ToolbarButton::~ToolbarButton()
{
}

bool ToolbarButton::getToolbarItemSizes (int toolbarDepth, bool /*isToolbarVertical*/, int& preferredSize, int& minSize, int& maxSize)
{
	preferredSize = minSize = maxSize = toolbarDepth;
	return true;
}

void ToolbarButton::paintButtonArea (Graphics&, int /*width*/, int /*height*/, bool /*isMouseOver*/, bool /*isMouseDown*/)
{
}

void ToolbarButton::contentAreaChanged (const Rectangle<int>&)
{
	buttonStateChanged();
}

void ToolbarButton::setCurrentImage (Drawable* const newImage)
{
	if (newImage != currentImage)
	{
		removeChildComponent (currentImage);
		currentImage = newImage;

		if (currentImage != nullptr)
		{
			enablementChanged();
			addAndMakeVisible (currentImage);
			updateDrawable();
		}
	}
}

void ToolbarButton::updateDrawable()
{
	if (currentImage != nullptr)
	{
		currentImage->setTransformToFit (getContentArea().toFloat(), RectanglePlacement::centred);
		currentImage->setAlpha (isEnabled() ? 1.0f : 0.5f);
	}
}

void ToolbarButton::resized()
{
	ToolbarItemComponent::resized();
	updateDrawable();
}

void ToolbarButton::enablementChanged()
{
	ToolbarItemComponent::enablementChanged();
	updateDrawable();
}

Drawable* ToolbarButton::getImageToUse() const
{
	if (getStyle() == Toolbar::textOnly)
		return nullptr;

	if (getToggleState() && toggledOnImage != nullptr)
		return toggledOnImage;

	return normalImage;
}

void ToolbarButton::buttonStateChanged()
{
	setCurrentImage (getImageToUse());
}

/*** End of inlined file: juce_ToolbarButton.cpp ***/


/*** Start of inlined file: juce_Drawable.cpp ***/
Drawable::Drawable()
{
	setInterceptsMouseClicks (false, false);
	setPaintingIsUnclipped (true);
}

Drawable::Drawable (const Drawable& other)
{
	setName (other.getName());
	setComponentID (other.getComponentID());
}

Drawable::~Drawable()
{
}

void Drawable::draw (Graphics& g, float opacity, const AffineTransform& transform) const
{
	const_cast <Drawable*> (this)->nonConstDraw (g, opacity, transform);
}

void Drawable::nonConstDraw (Graphics& g, float opacity, const AffineTransform& transform)
{
	Graphics::ScopedSaveState ss (g);

	g.addTransform (AffineTransform::translation ((float) -(originRelativeToComponent.x),
												  (float) -(originRelativeToComponent.y))
						.followedBy (getTransform())
						.followedBy (transform));

	if (! g.isClipEmpty())
	{
		if (opacity < 1.0f)
		{
			g.beginTransparencyLayer (opacity);
			paintEntireComponent (g, true);
			g.endTransparencyLayer();
		}
		else
		{
			paintEntireComponent (g, true);
		}
	}
}

void Drawable::drawAt (Graphics& g, float x, float y, float opacity) const
{
	draw (g, opacity, AffineTransform::translation (x, y));
}

void Drawable::drawWithin (Graphics& g, const Rectangle<float>& destArea, const RectanglePlacement& placement, float opacity) const
{
	draw (g, opacity, placement.getTransformToFit (getDrawableBounds(), destArea));
}

DrawableComposite* Drawable::getParent() const
{
	return dynamic_cast <DrawableComposite*> (getParentComponent());
}

void Drawable::transformContextToCorrectOrigin (Graphics& g)
{
	g.setOrigin (originRelativeToComponent.x,
				 originRelativeToComponent.y);
}

void Drawable::parentHierarchyChanged()
{
	setBoundsToEnclose (getDrawableBounds());
}

void Drawable::setBoundsToEnclose (const Rectangle<float>& area)
{
	Drawable* const parent = getParent();
	Point<int> parentOrigin;
	if (parent != nullptr)
		parentOrigin = parent->originRelativeToComponent;

	const Rectangle<int> newBounds (area.getSmallestIntegerContainer() + parentOrigin);
	originRelativeToComponent = parentOrigin - newBounds.getPosition();
	setBounds (newBounds);
}

void Drawable::setOriginWithOriginalSize (const Point<float>& originWithinParent)
{
	setTransform (AffineTransform::translation (originWithinParent.x, originWithinParent.y));
}

void Drawable::setTransformToFit (const Rectangle<float>& area, const RectanglePlacement& placement)
{
	if (! area.isEmpty())
		setTransform (placement.getTransformToFit (getDrawableBounds(), area));
}

Drawable* Drawable::createFromImageData (const void* data, const size_t numBytes)
{
	Drawable* result = nullptr;

	Image image (ImageFileFormat::loadFrom (data, numBytes));

	if (image.isValid())
	{
		DrawableImage* const di = new DrawableImage();
		di->setImage (image);
		result = di;
	}
	else
	{
		const String asString (String::createStringFromData (data, (int) numBytes));

		XmlDocument doc (asString);
		ScopedPointer <XmlElement> outer (doc.getDocumentElement (true));

		if (outer != nullptr && outer->hasTagName ("svg"))
		{
			ScopedPointer <XmlElement> svg (doc.getDocumentElement());

			if (svg != nullptr)
				result = Drawable::createFromSVG (*svg);
		}
	}

	return result;
}

Drawable* Drawable::createFromImageDataStream (InputStream& dataSource)
{
	MemoryOutputStream mo;
	mo << dataSource;

	return createFromImageData (mo.getData(), mo.getDataSize());
}

Drawable* Drawable::createFromImageFile (const File& file)
{
	FileInputStream fin (file);

	return fin.openedOk() ? createFromImageDataStream (fin) : nullptr;
}

template <class DrawableClass>
class DrawableTypeHandler  : public ComponentBuilder::TypeHandler
{
public:
	DrawableTypeHandler()
		: ComponentBuilder::TypeHandler (DrawableClass::valueTreeType)
	{
	}

	Component* addNewComponentFromState (const ValueTree& state, Component* parent)
	{
		DrawableClass* const d = new DrawableClass();

		if (parent != nullptr)
			parent->addAndMakeVisible (d);

		updateComponentFromState (d, state);
		return d;
	}

	void updateComponentFromState (Component* component, const ValueTree& state)
	{
		DrawableClass* const d = dynamic_cast <DrawableClass*> (component);
		jassert (d != nullptr);
		d->refreshFromValueTree (state, *this->getBuilder());
	}
};

void Drawable::registerDrawableTypeHandlers (ComponentBuilder& builder)
{
	builder.registerTypeHandler (new DrawableTypeHandler <DrawablePath>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableComposite>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableRectangle>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableImage>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableText>());
}

Drawable* Drawable::createFromValueTree (const ValueTree& tree, ComponentBuilder::ImageProvider* imageProvider)
{
	ComponentBuilder builder (tree);
	builder.setImageProvider (imageProvider);
	registerDrawableTypeHandlers (builder);

	ScopedPointer<Component> comp (builder.createComponent());
	Drawable* const d = dynamic_cast<Drawable*> (static_cast <Component*> (comp));

	if (d != nullptr)
		comp.release();

	return d;
}

Drawable::ValueTreeWrapperBase::ValueTreeWrapperBase (const ValueTree& state_)
	: state (state_)
{
}

String Drawable::ValueTreeWrapperBase::getID() const
{
	return state [ComponentBuilder::idProperty];
}

void Drawable::ValueTreeWrapperBase::setID (const String& newID)
{
	if (newID.isEmpty())
		state.removeProperty (ComponentBuilder::idProperty, nullptr);
	else
		state.setProperty (ComponentBuilder::idProperty, newID, nullptr);
}

/*** End of inlined file: juce_Drawable.cpp ***/


/*** Start of inlined file: juce_DrawableComposite.cpp ***/
DrawableComposite::DrawableComposite()
	: bounds (Point<float>(), Point<float> (100.0f, 0.0f), Point<float> (0.0f, 100.0f)),
	  updateBoundsReentrant (false)
{
	setContentArea (RelativeRectangle (RelativeCoordinate (0.0),
									   RelativeCoordinate (100.0),
									   RelativeCoordinate (0.0),
									   RelativeCoordinate (100.0)));
}

DrawableComposite::DrawableComposite (const DrawableComposite& other)
	: Drawable (other),
	  bounds (other.bounds),
	  markersX (other.markersX),
	  markersY (other.markersY),
	  updateBoundsReentrant (false)
{
	for (int i = 0; i < other.getNumChildComponents(); ++i)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (other.getChildComponent(i));

		if (d != nullptr)
			addAndMakeVisible (d->createCopy());
	}
}

DrawableComposite::~DrawableComposite()
{
	deleteAllChildren();
}

Drawable* DrawableComposite::createCopy() const
{
	return new DrawableComposite (*this);
}

Rectangle<float> DrawableComposite::getDrawableBounds() const
{
	Rectangle<float> r;

	for (int i = getNumChildComponents(); --i >= 0;)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (getChildComponent(i));

		if (d != nullptr)
			r = r.getUnion (d->isTransformed() ? d->getDrawableBounds().transformed (d->getTransform())
											   : d->getDrawableBounds());
	}

	return r;
}

MarkerList* DrawableComposite::getMarkers (bool xAxis)
{
	return xAxis ? &markersX : &markersY;
}

RelativeRectangle DrawableComposite::getContentArea() const
{
	jassert (markersX.getNumMarkers() >= 2 && markersX.getMarker (0)->name == contentLeftMarkerName && markersX.getMarker (1)->name == contentRightMarkerName);
	jassert (markersY.getNumMarkers() >= 2 && markersY.getMarker (0)->name == contentTopMarkerName && markersY.getMarker (1)->name == contentBottomMarkerName);

	return RelativeRectangle (markersX.getMarker(0)->position, markersX.getMarker(1)->position,
							  markersY.getMarker(0)->position, markersY.getMarker(1)->position);
}

void DrawableComposite::setContentArea (const RelativeRectangle& newArea)
{
	markersX.setMarker (contentLeftMarkerName, newArea.left);
	markersX.setMarker (contentRightMarkerName, newArea.right);
	markersY.setMarker (contentTopMarkerName, newArea.top);
	markersY.setMarker (contentBottomMarkerName, newArea.bottom);
}

void DrawableComposite::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;

		if (bounds.isDynamic())
		{
			Drawable::Positioner<DrawableComposite>* const p = new Drawable::Positioner<DrawableComposite> (*this);
			setPositioner (p);
			p->apply();
		}
		else
		{
			setPositioner (nullptr);
			recalculateCoordinates (nullptr);
		}
	}
}

void DrawableComposite::resetBoundingBoxToContentArea()
{
	const RelativeRectangle content (getContentArea());

	setBoundingBox (RelativeParallelogram (RelativePoint (content.left, content.top),
										   RelativePoint (content.right, content.top),
										   RelativePoint (content.left, content.bottom)));
}

void DrawableComposite::resetContentAreaAndBoundingBoxToFitChildren()
{
	const Rectangle<float> activeArea (getDrawableBounds());

	setContentArea (RelativeRectangle (RelativeCoordinate (activeArea.getX()),
									   RelativeCoordinate (activeArea.getRight()),
									   RelativeCoordinate (activeArea.getY()),
									   RelativeCoordinate (activeArea.getBottom())));
	resetBoundingBoxToContentArea();
}

bool DrawableComposite::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	return pos.addPoint (bounds.bottomLeft) && ok;
}

void DrawableComposite::recalculateCoordinates (Expression::Scope* scope)
{
	Point<float> resolved[3];
	bounds.resolveThreePoints (resolved, scope);

	const Rectangle<float> content (getContentArea().resolve (scope));

	AffineTransform t (AffineTransform::fromTargetPoints (content.getX(),     content.getY(),      resolved[0].x, resolved[0].y,
														  content.getRight(), content.getY(),      resolved[1].x, resolved[1].y,
														  content.getX(),     content.getBottom(), resolved[2].x, resolved[2].y));

	if (t.isSingularity())
		t = AffineTransform::identity;

	setTransform (t);
}

void DrawableComposite::parentHierarchyChanged()
{
	DrawableComposite* parent = getParent();
	if (parent != nullptr)
		originRelativeToComponent = parent->originRelativeToComponent - getPosition();
}

void DrawableComposite::childBoundsChanged (Component*)
{
	updateBoundsToFitChildren();
}

void DrawableComposite::childrenChanged()
{
	updateBoundsToFitChildren();
}

void DrawableComposite::updateBoundsToFitChildren()
{
	if (! updateBoundsReentrant)
	{
		const ScopedValueSetter<bool> setter (updateBoundsReentrant, true, false);

		Rectangle<int> childArea;

		for (int i = getNumChildComponents(); --i >= 0;)
			childArea = childArea.getUnion (getChildComponent(i)->getBoundsInParent());

		const Point<int> delta (childArea.getPosition());
		childArea += getPosition();

		if (childArea != getBounds())
		{
			if (! delta.isOrigin())
			{
				originRelativeToComponent -= delta;

				for (int i = getNumChildComponents(); --i >= 0;)
				{
					Component* const c = getChildComponent(i);

					if (c != nullptr)
						c->setBounds (c->getBounds() - delta);
				}
			}

			setBounds (childArea);
		}
	}
}

const char* const DrawableComposite::contentLeftMarkerName = "left";
const char* const DrawableComposite::contentRightMarkerName = "right";
const char* const DrawableComposite::contentTopMarkerName = "top";
const char* const DrawableComposite::contentBottomMarkerName = "bottom";

const Identifier DrawableComposite::valueTreeType ("Group");

const Identifier DrawableComposite::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableComposite::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableComposite::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableComposite::ValueTreeWrapper::childGroupTag ("Drawables");
const Identifier DrawableComposite::ValueTreeWrapper::markerGroupTagX ("MarkersX");
const Identifier DrawableComposite::ValueTreeWrapper::markerGroupTagY ("MarkersY");

DrawableComposite::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

ValueTree DrawableComposite::ValueTreeWrapper::getChildList() const
{
	return state.getChildWithName (childGroupTag);
}

ValueTree DrawableComposite::ValueTreeWrapper::getChildListCreating (UndoManager* undoManager)
{
	return state.getOrCreateChildWithName (childGroupTag, undoManager);
}

RelativeParallelogram DrawableComposite::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableComposite::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableComposite::ValueTreeWrapper::resetBoundingBoxToContentArea (UndoManager* undoManager)
{
	const RelativeRectangle content (getContentArea());

	setBoundingBox (RelativeParallelogram (RelativePoint (content.left, content.top),
										   RelativePoint (content.right, content.top),
										   RelativePoint (content.left, content.bottom)), undoManager);
}

RelativeRectangle DrawableComposite::ValueTreeWrapper::getContentArea() const
{
	MarkerList::ValueTreeWrapper markersX (getMarkerList (true));
	MarkerList::ValueTreeWrapper markersY (getMarkerList (false));

	return RelativeRectangle (markersX.getMarker (markersX.getMarkerState (0)).position,
							  markersX.getMarker (markersX.getMarkerState (1)).position,
							  markersY.getMarker (markersY.getMarkerState (0)).position,
							  markersY.getMarker (markersY.getMarkerState (1)).position);
}

void DrawableComposite::ValueTreeWrapper::setContentArea (const RelativeRectangle& newArea, UndoManager* undoManager)
{
	MarkerList::ValueTreeWrapper markersX (getMarkerListCreating (true, nullptr));
	MarkerList::ValueTreeWrapper markersY (getMarkerListCreating (false, nullptr));

	markersX.setMarker (MarkerList::Marker (contentLeftMarkerName, newArea.left), undoManager);
	markersX.setMarker (MarkerList::Marker (contentRightMarkerName, newArea.right), undoManager);
	markersY.setMarker (MarkerList::Marker (contentTopMarkerName, newArea.top), undoManager);
	markersY.setMarker (MarkerList::Marker (contentBottomMarkerName, newArea.bottom), undoManager);
}

MarkerList::ValueTreeWrapper DrawableComposite::ValueTreeWrapper::getMarkerList (bool xAxis) const
{
	return state.getChildWithName (xAxis ? markerGroupTagX : markerGroupTagY);
}

MarkerList::ValueTreeWrapper DrawableComposite::ValueTreeWrapper::getMarkerListCreating (bool xAxis, UndoManager* undoManager)
{
	return state.getOrCreateChildWithName (xAxis ? markerGroupTagX : markerGroupTagY, undoManager);
}

void DrawableComposite::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	const ValueTreeWrapper wrapper (tree);
	setComponentID (wrapper.getID());

	wrapper.getMarkerList (true).applyTo (markersX);
	wrapper.getMarkerList (false).applyTo (markersY);

	setBoundingBox (wrapper.getBoundingBox());

	builder.updateChildComponents (*this, wrapper.getChildList());
}

ValueTree DrawableComposite::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setBoundingBox (bounds, nullptr);

	ValueTree childList (v.getChildListCreating (nullptr));

	for (int i = 0; i < getNumChildComponents(); ++i)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (getChildComponent(i));
		jassert (d != nullptr); // You can't save a mix of Drawables and normal components!

		childList.addChild (d->createValueTree (imageProvider), -1, nullptr);
	}

	v.getMarkerListCreating (true, nullptr).readFrom (markersX, nullptr);
	v.getMarkerListCreating (false, nullptr).readFrom (markersY, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableComposite.cpp ***/


/*** Start of inlined file: juce_DrawableImage.cpp ***/
DrawableImage::DrawableImage()
	: opacity (1.0f),
	  overlayColour (0x00000000)
{
	bounds.topRight = RelativePoint (Point<float> (1.0f, 0.0f));
	bounds.bottomLeft = RelativePoint (Point<float> (0.0f, 1.0f));
}

DrawableImage::DrawableImage (const DrawableImage& other)
	: Drawable (other),
	  image (other.image),
	  opacity (other.opacity),
	  overlayColour (other.overlayColour),
	  bounds (other.bounds)
{
}

DrawableImage::~DrawableImage()
{
}

void DrawableImage::setImage (const Image& imageToUse)
{
	image = imageToUse;
	setBounds (imageToUse.getBounds());

	bounds.topLeft = RelativePoint (Point<float> (0.0f, 0.0f));
	bounds.topRight = RelativePoint (Point<float> ((float) image.getWidth(), 0.0f));
	bounds.bottomLeft = RelativePoint (Point<float> (0.0f, (float) image.getHeight()));
	recalculateCoordinates (nullptr);

	repaint();
}

void DrawableImage::setOpacity (const float newOpacity)
{
	opacity = newOpacity;
}

void DrawableImage::setOverlayColour (const Colour& newOverlayColour)
{
	overlayColour = newOverlayColour;
}

void DrawableImage::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;

		if (bounds.isDynamic())
		{
			Drawable::Positioner<DrawableImage>* const p = new Drawable::Positioner<DrawableImage> (*this);
			setPositioner (p);
			p->apply();
		}
		else
		{
			setPositioner (nullptr);
			recalculateCoordinates (nullptr);
		}
	}
}

bool DrawableImage::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	return pos.addPoint (bounds.bottomLeft) && ok;
}

void DrawableImage::recalculateCoordinates (Expression::Scope* scope)
{
	if (image.isValid())
	{
		Point<float> resolved[3];
		bounds.resolveThreePoints (resolved, scope);

		const Point<float> tr (resolved[0] + (resolved[1] - resolved[0]) / (float) image.getWidth());
		const Point<float> bl (resolved[0] + (resolved[2] - resolved[0]) / (float) image.getHeight());

		AffineTransform t (AffineTransform::fromTargetPoints (resolved[0].x, resolved[0].y,
															  tr.x, tr.y,
															  bl.x, bl.y));

		if (t.isSingularity())
			t = AffineTransform::identity;

		setTransform (t);
	}
}

void DrawableImage::paint (Graphics& g)
{
	if (image.isValid())
	{
		if (opacity > 0.0f && ! overlayColour.isOpaque())
		{
			g.setOpacity (opacity);
			g.drawImageAt (image, 0, 0, false);
		}

		if (! overlayColour.isTransparent())
		{
			g.setColour (overlayColour.withMultipliedAlpha (opacity));
			g.drawImageAt (image, 0, 0, true);
		}
	}
}

Rectangle<float> DrawableImage::getDrawableBounds() const
{
	return image.getBounds().toFloat();
}

bool DrawableImage::hitTest (int x, int y)
{
	return Drawable::hitTest (x, y) && image.isValid() && image.getPixelAt (x, y).getAlpha() >= 127;
}

Drawable* DrawableImage::createCopy() const
{
	return new DrawableImage (*this);
}

const Identifier DrawableImage::valueTreeType ("Image");

const Identifier DrawableImage::ValueTreeWrapper::opacity ("opacity");
const Identifier DrawableImage::ValueTreeWrapper::overlay ("overlay");
const Identifier DrawableImage::ValueTreeWrapper::image ("image");
const Identifier DrawableImage::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableImage::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableImage::ValueTreeWrapper::bottomLeft ("bottomLeft");

DrawableImage::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

var DrawableImage::ValueTreeWrapper::getImageIdentifier() const
{
	return state [image];
}

Value DrawableImage::ValueTreeWrapper::getImageIdentifierValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (image, undoManager);
}

void DrawableImage::ValueTreeWrapper::setImageIdentifier (const var& newIdentifier, UndoManager* undoManager)
{
	state.setProperty (image, newIdentifier, undoManager);
}

float DrawableImage::ValueTreeWrapper::getOpacity() const
{
	return (float) state.getProperty (opacity, 1.0);
}

Value DrawableImage::ValueTreeWrapper::getOpacityValue (UndoManager* undoManager)
{
	if (! state.hasProperty (opacity))
		state.setProperty (opacity, 1.0, undoManager);

	return state.getPropertyAsValue (opacity, undoManager);
}

void DrawableImage::ValueTreeWrapper::setOpacity (float newOpacity, UndoManager* undoManager)
{
	state.setProperty (opacity, newOpacity, undoManager);
}

Colour DrawableImage::ValueTreeWrapper::getOverlayColour() const
{
	return Colour::fromString (state [overlay].toString());
}

void DrawableImage::ValueTreeWrapper::setOverlayColour (const Colour& newColour, UndoManager* undoManager)
{
	if (newColour.isTransparent())
		state.removeProperty (overlay, undoManager);
	else
		state.setProperty (overlay, String::toHexString ((int) newColour.getARGB()), undoManager);
}

Value DrawableImage::ValueTreeWrapper::getOverlayColourValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (overlay, undoManager);
}

RelativeParallelogram DrawableImage::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableImage::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableImage::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	const ValueTreeWrapper controller (tree);
	setComponentID (controller.getID());

	const float newOpacity = controller.getOpacity();
	const Colour newOverlayColour (controller.getOverlayColour());

	Image newImage;
	const var imageIdentifier (controller.getImageIdentifier());

	jassert (builder.getImageProvider() != 0 || imageIdentifier.isVoid()); // if you're using images, you need to provide something that can load and save them!

	if (builder.getImageProvider() != nullptr)
		newImage = builder.getImageProvider()->getImageForIdentifier (imageIdentifier);

	const RelativeParallelogram newBounds (controller.getBoundingBox());

	if (bounds != newBounds || newOpacity != opacity
		 || overlayColour != newOverlayColour || image != newImage)
	{
		repaint();
		opacity = newOpacity;
		overlayColour = newOverlayColour;

		if (image != newImage)
			setImage (newImage);

		setBoundingBox (newBounds);
	}
}

ValueTree DrawableImage::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setOpacity (opacity, nullptr);
	v.setOverlayColour (overlayColour, nullptr);
	v.setBoundingBox (bounds, nullptr);

	if (image.isValid())
	{
		jassert (imageProvider != nullptr); // if you're using images, you need to provide something that can load and save them!

		if (imageProvider != nullptr)
			v.setImageIdentifier (imageProvider->getIdentifierForImage (image), nullptr);
	}

	return tree;
}

/*** End of inlined file: juce_DrawableImage.cpp ***/


/*** Start of inlined file: juce_DrawablePath.cpp ***/
DrawablePath::DrawablePath()
{
}

DrawablePath::DrawablePath (const DrawablePath& other)
	: DrawableShape (other)
{
	if (other.relativePath != nullptr)
		setPath (*other.relativePath);
	else
		setPath (other.path);
}

DrawablePath::~DrawablePath()
{
}

Drawable* DrawablePath::createCopy() const
{
	return new DrawablePath (*this);
}

void DrawablePath::setPath (const Path& newPath)
{
	path = newPath;
	pathChanged();
}

const Path& DrawablePath::getPath() const
{
	return path;
}

const Path& DrawablePath::getStrokePath() const
{
	return strokePath;
}

void DrawablePath::applyRelativePath (const RelativePointPath& newRelativePath, Expression::Scope* scope)
{
	Path newPath;
	newRelativePath.createPath (newPath, scope);

	if (path != newPath)
	{
		path.swapWithPath (newPath);
		pathChanged();
	}
}

class DrawablePath::RelativePositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativePositioner (DrawablePath& component_)
		: RelativeCoordinatePositionerBase (component_),
		  owner (component_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = true;

		jassert (owner.relativePath != nullptr);
		const RelativePointPath& path = *owner.relativePath;

		for (int i = 0; i < path.elements.size(); ++i)
		{
			RelativePointPath::ElementBase* const e = path.elements.getUnchecked(i);

			int numPoints;
			RelativePoint* const points = e->getControlPoints (numPoints);

			for (int j = numPoints; --j >= 0;)
				ok = addPoint (points[j]) && ok;
		}

		return ok;
	}

	void applyToComponentBounds()
	{
		jassert (owner.relativePath != nullptr);

		ComponentScope scope (getComponent());
		owner.applyRelativePath (*owner.relativePath, &scope);
	}

	void applyNewBounds (const Rectangle<int>&)
	{
		jassertfalse; // drawables can't be resized directly!
	}

private:
	DrawablePath& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativePositioner);
};

void DrawablePath::setPath (const RelativePointPath& newRelativePath)
{
	if (newRelativePath.containsAnyDynamicPoints())
	{
		if (relativePath == nullptr || newRelativePath != *relativePath)
		{
			relativePath = new RelativePointPath (newRelativePath);

			RelativePositioner* const p = new RelativePositioner (*this);
			setPositioner (p);
			p->apply();
		}
	}
	else
	{
		relativePath = nullptr;
		applyRelativePath (newRelativePath, nullptr);
	}
}

const Identifier DrawablePath::valueTreeType ("Path");

const Identifier DrawablePath::ValueTreeWrapper::nonZeroWinding ("nonZeroWinding");
const Identifier DrawablePath::ValueTreeWrapper::point1 ("p1");
const Identifier DrawablePath::ValueTreeWrapper::point2 ("p2");
const Identifier DrawablePath::ValueTreeWrapper::point3 ("p3");

DrawablePath::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: FillAndStrokeState (state_)
{
	jassert (state.hasType (valueTreeType));
}

ValueTree DrawablePath::ValueTreeWrapper::getPathState()
{
	return state.getOrCreateChildWithName (path, nullptr);
}

bool DrawablePath::ValueTreeWrapper::usesNonZeroWinding() const
{
	return state [nonZeroWinding];
}

void DrawablePath::ValueTreeWrapper::setUsesNonZeroWinding (bool b, UndoManager* undoManager)
{
	state.setProperty (nonZeroWinding, b, undoManager);
}

void DrawablePath::ValueTreeWrapper::readFrom (const RelativePointPath& relativePath, UndoManager* undoManager)
{
	setUsesNonZeroWinding (relativePath.usesNonZeroWinding, undoManager);

	ValueTree pathTree (getPathState());
	pathTree.removeAllChildren (undoManager);

	for (int i = 0; i < relativePath.elements.size(); ++i)
		pathTree.addChild (relativePath.elements.getUnchecked(i)->createTree(), -1, undoManager);
}

void DrawablePath::ValueTreeWrapper::writeTo (RelativePointPath& relativePath) const
{
	relativePath.usesNonZeroWinding = usesNonZeroWinding();
	RelativePoint points[3];

	const ValueTree pathTree (state.getChildWithName (path));
	const int num = pathTree.getNumChildren();
	for (int i = 0; i < num; ++i)
	{
		const Element e (pathTree.getChild(i));

		const int numCps = e.getNumControlPoints();
		for (int j = 0; j < numCps; ++j)
			points[j] = e.getControlPoint (j);

		RelativePointPath::ElementBase* newElement = nullptr;
		const Identifier t (e.getType());

		if      (t == Element::startSubPathElement)  newElement = new RelativePointPath::StartSubPath (points[0]);
		else if (t == Element::closeSubPathElement)  newElement = new RelativePointPath::CloseSubPath();
		else if (t == Element::lineToElement)        newElement = new RelativePointPath::LineTo (points[0]);
		else if (t == Element::quadraticToElement)   newElement = new RelativePointPath::QuadraticTo (points[0], points[1]);
		else if (t == Element::cubicToElement)       newElement = new RelativePointPath::CubicTo (points[0], points[1], points[2]);
		else                                         jassertfalse;

		relativePath.addElement (newElement);
	}
}

const Identifier DrawablePath::ValueTreeWrapper::Element::mode ("mode");
const Identifier DrawablePath::ValueTreeWrapper::Element::startSubPathElement ("Move");
const Identifier DrawablePath::ValueTreeWrapper::Element::closeSubPathElement ("Close");
const Identifier DrawablePath::ValueTreeWrapper::Element::lineToElement ("Line");
const Identifier DrawablePath::ValueTreeWrapper::Element::quadraticToElement ("Quad");
const Identifier DrawablePath::ValueTreeWrapper::Element::cubicToElement ("Cubic");

const char* DrawablePath::ValueTreeWrapper::Element::cornerMode = "corner";
const char* DrawablePath::ValueTreeWrapper::Element::roundedMode = "round";
const char* DrawablePath::ValueTreeWrapper::Element::symmetricMode = "symm";

DrawablePath::ValueTreeWrapper::Element::Element (const ValueTree& state_)
	: state (state_)
{
}

DrawablePath::ValueTreeWrapper::Element::~Element()
{
}

DrawablePath::ValueTreeWrapper DrawablePath::ValueTreeWrapper::Element::getParent() const
{
	return ValueTreeWrapper (state.getParent().getParent());
}

DrawablePath::ValueTreeWrapper::Element DrawablePath::ValueTreeWrapper::Element::getPreviousElement() const
{
	return Element (state.getSibling (-1));
}

int DrawablePath::ValueTreeWrapper::Element::getNumControlPoints() const noexcept
{
	const Identifier i (state.getType());
	if (i == startSubPathElement || i == lineToElement) return 1;
	if (i == quadraticToElement) return 2;
	if (i == cubicToElement) return 3;
	return 0;
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getControlPoint (const int index) const
{
	jassert (index >= 0 && index < getNumControlPoints());
	return RelativePoint (state [index == 0 ? point1 : (index == 1 ? point2 : point3)].toString());
}

Value DrawablePath::ValueTreeWrapper::Element::getControlPointValue (int index, UndoManager* undoManager)
{
	jassert (index >= 0 && index < getNumControlPoints());
	return state.getPropertyAsValue (index == 0 ? point1 : (index == 1 ? point2 : point3), undoManager);
}

void DrawablePath::ValueTreeWrapper::Element::setControlPoint (const int index, const RelativePoint& point, UndoManager* undoManager)
{
	jassert (index >= 0 && index < getNumControlPoints());
	state.setProperty (index == 0 ? point1 : (index == 1 ? point2 : point3), point.toString(), undoManager);
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getStartPoint() const
{
	const Identifier i (state.getType());

	if (i == startSubPathElement)
		return getControlPoint (0);

	jassert (i == lineToElement || i == quadraticToElement || i == cubicToElement || i == closeSubPathElement);

	return getPreviousElement().getEndPoint();
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getEndPoint() const
{
	const Identifier i (state.getType());
	if (i == startSubPathElement || i == lineToElement)  return getControlPoint (0);
	if (i == quadraticToElement)                         return getControlPoint (1);
	if (i == cubicToElement)                             return getControlPoint (2);

	jassert (i == closeSubPathElement);
	return RelativePoint();
}

float DrawablePath::ValueTreeWrapper::Element::getLength (Expression::Scope* scope) const
{
	const Identifier i (state.getType());

	if (i == lineToElement || i == closeSubPathElement)
		return getEndPoint().resolve (scope).getDistanceFrom (getStartPoint().resolve (scope));

	if (i == cubicToElement)
	{
		Path p;
		p.startNewSubPath (getStartPoint().resolve (scope));
		p.cubicTo (getControlPoint (0).resolve (scope), getControlPoint (1).resolve (scope), getControlPoint (2).resolve (scope));
		return p.getLength();
	}

	if (i == quadraticToElement)
	{
		Path p;
		p.startNewSubPath (getStartPoint().resolve (scope));
		p.quadraticTo (getControlPoint (0).resolve (scope), getControlPoint (1).resolve (scope));
		return p.getLength();
	}

	jassert (i == startSubPathElement);
	return 0;
}

String DrawablePath::ValueTreeWrapper::Element::getModeOfEndPoint() const
{
	return state [mode].toString();
}

void DrawablePath::ValueTreeWrapper::Element::setModeOfEndPoint (const String& newMode, UndoManager* undoManager)
{
	if (state.hasType (cubicToElement))
		state.setProperty (mode, newMode, undoManager);
}

void DrawablePath::ValueTreeWrapper::Element::convertToLine (UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i == quadraticToElement || i == cubicToElement)
	{
		ValueTree newState (lineToElement);
		Element e (newState);
		e.setControlPoint (0, getEndPoint(), undoManager);
		state = newState;
	}
}

void DrawablePath::ValueTreeWrapper::Element::convertToCubic (Expression::Scope* scope, UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i == lineToElement || i == quadraticToElement)
	{
		ValueTree newState (cubicToElement);
		Element e (newState);

		const RelativePoint start (getStartPoint());
		const RelativePoint end (getEndPoint());
		const Point<float> startResolved (start.resolve (scope));
		const Point<float> endResolved (end.resolve (scope));
		e.setControlPoint (0, startResolved + (endResolved - startResolved) * 0.3f, undoManager);
		e.setControlPoint (1, startResolved + (endResolved - startResolved) * 0.7f, undoManager);
		e.setControlPoint (2, end, undoManager);

		state = newState;
	}
}

void DrawablePath::ValueTreeWrapper::Element::convertToPathBreak (UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i != startSubPathElement)
	{
		ValueTree newState (startSubPathElement);
		Element e (newState);
		e.setControlPoint (0, getEndPoint(), undoManager);
		state = newState;
	}
}

namespace DrawablePathHelpers
{
	static Point<float> findCubicSubdivisionPoint (float proportion, const Point<float> points[4])
	{
		const Point<float> mid1 (points[0] + (points[1] - points[0]) * proportion),
						   mid2 (points[1] + (points[2] - points[1]) * proportion),
						   mid3 (points[2] + (points[3] - points[2]) * proportion);

		const Point<float> newCp1 (mid1 + (mid2 - mid1) * proportion),
						   newCp2 (mid2 + (mid3 - mid2) * proportion);

		return newCp1 + (newCp2 - newCp1) * proportion;
	}

	static Point<float> findQuadraticSubdivisionPoint (float proportion, const Point<float> points[3])
	{
		const Point<float> mid1 (points[0] + (points[1] - points[0]) * proportion),
						   mid2 (points[1] + (points[2] - points[1]) * proportion);

		return mid1 + (mid2 - mid1) * proportion;
	}
}

float DrawablePath::ValueTreeWrapper::Element::findProportionAlongLine (const Point<float>& targetPoint, Expression::Scope* scope) const
{
	using namespace DrawablePathHelpers;
	const Identifier type (state.getType());
	float bestProp = 0;

	if (type == cubicToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getControlPoint (1)), rp4 (getEndPoint());

		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope), rp4.resolve (scope) };

		float bestDistance = std::numeric_limits<float>::max();

		for (int i = 110; --i >= 0;)
		{
			float prop = i > 10 ? ((i - 10) / 100.0f) : (bestProp + ((i - 5) / 1000.0f));
			const Point<float> centre (findCubicSubdivisionPoint (prop, points));
			const float distance = centre.getDistanceFrom (targetPoint);

			if (distance < bestDistance)
			{
				bestProp = prop;
				bestDistance = distance;
			}
		}
	}
	else if (type == quadraticToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope) };

		float bestDistance = std::numeric_limits<float>::max();

		for (int i = 110; --i >= 0;)
		{
			float prop = i > 10 ? ((i - 10) / 100.0f) : (bestProp + ((i - 5) / 1000.0f));
			const Point<float> centre (findQuadraticSubdivisionPoint ((float) prop, points));
			const float distance = centre.getDistanceFrom (targetPoint);

			if (distance < bestDistance)
			{
				bestProp = prop;
				bestDistance = distance;
			}
		}
	}
	else if (type == lineToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getEndPoint());
		const Line<float> line (rp1.resolve (scope), rp2.resolve (scope));
		bestProp = line.findNearestProportionalPositionTo (targetPoint);
	}

	return bestProp;
}

ValueTree DrawablePath::ValueTreeWrapper::Element::insertPoint (const Point<float>& targetPoint, Expression::Scope* scope, UndoManager* undoManager)
{
	ValueTree newTree;
	const Identifier type (state.getType());

	if (type == cubicToElement)
	{
		float bestProp = findProportionAlongLine (targetPoint, scope);

		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getControlPoint (1)), rp4 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope), rp4.resolve (scope) };

		const Point<float> mid1 (points[0] + (points[1] - points[0]) * bestProp),
						   mid2 (points[1] + (points[2] - points[1]) * bestProp),
						   mid3 (points[2] + (points[3] - points[2]) * bestProp);

		const Point<float> newCp1 (mid1 + (mid2 - mid1) * bestProp),
						   newCp2 (mid2 + (mid3 - mid2) * bestProp);

		const Point<float> newCentre (newCp1 + (newCp2 - newCp1) * bestProp);

		setControlPoint (0, mid1, undoManager);
		setControlPoint (1, newCp1, undoManager);
		setControlPoint (2, newCentre, undoManager);
		setModeOfEndPoint (roundedMode, undoManager);

		Element newElement (newTree = ValueTree (cubicToElement));
		newElement.setControlPoint (0, newCp2, nullptr);
		newElement.setControlPoint (1, mid3, nullptr);
		newElement.setControlPoint (2, rp4, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == quadraticToElement)
	{
		float bestProp = findProportionAlongLine (targetPoint, scope);

		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope) };

		const Point<float> mid1 (points[0] + (points[1] - points[0]) * bestProp),
						   mid2 (points[1] + (points[2] - points[1]) * bestProp);

		const Point<float> newCentre (mid1 + (mid2 - mid1) * bestProp);

		setControlPoint (0, mid1, undoManager);
		setControlPoint (1, newCentre, undoManager);
		setModeOfEndPoint (roundedMode, undoManager);

		Element newElement (newTree = ValueTree (quadraticToElement));
		newElement.setControlPoint (0, mid2, nullptr);
		newElement.setControlPoint (1, rp3, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == lineToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getEndPoint());
		const Line<float> line (rp1.resolve (scope), rp2.resolve (scope));
		const Point<float> newPoint (line.findNearestPointTo (targetPoint));

		setControlPoint (0, newPoint, undoManager);

		Element newElement (newTree = ValueTree (lineToElement));
		newElement.setControlPoint (0, rp2, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == closeSubPathElement)
	{
	}

	return newTree;
}

void DrawablePath::ValueTreeWrapper::Element::removePoint (UndoManager* undoManager)
{
	state.getParent().removeChild (state, undoManager);
}

void DrawablePath::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	refreshFillTypes (v, builder.getImageProvider());
	setStrokeType (v.getStrokeType());

	RelativePointPath newRelativePath;
	v.writeTo (newRelativePath);
	setPath (newRelativePath);
}

ValueTree DrawablePath::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	writeTo (v, imageProvider, nullptr);

	if (relativePath != nullptr)
		v.readFrom (*relativePath, nullptr);
	else
		v.readFrom (RelativePointPath (path), nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawablePath.cpp ***/


/*** Start of inlined file: juce_DrawableRectangle.cpp ***/
DrawableRectangle::DrawableRectangle()
{
}

DrawableRectangle::DrawableRectangle (const DrawableRectangle& other)
	: DrawableShape (other),
	  bounds (other.bounds),
	  cornerSize (other.cornerSize)
{
}

DrawableRectangle::~DrawableRectangle()
{
}

Drawable* DrawableRectangle::createCopy() const
{
	return new DrawableRectangle (*this);
}

void DrawableRectangle::setRectangle (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;
		rebuildPath();
	}
}

void DrawableRectangle::setCornerSize (const RelativePoint& newSize)
{
	if (cornerSize != newSize)
	{
		cornerSize = newSize;
		rebuildPath();
	}
}

void DrawableRectangle::rebuildPath()
{
	if (bounds.isDynamic() || cornerSize.isDynamic())
	{
		Drawable::Positioner<DrawableRectangle>* const p = new Drawable::Positioner<DrawableRectangle> (*this);
		setPositioner (p);
		p->apply();
	}
	else
	{
		setPositioner (0);
		recalculateCoordinates (0);
	}
}

bool DrawableRectangle::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	ok = pos.addPoint (bounds.bottomLeft) && ok;
	return pos.addPoint (cornerSize) && ok;
}

void DrawableRectangle::recalculateCoordinates (Expression::Scope* scope)
{
	Point<float> points[3];
	bounds.resolveThreePoints (points, scope);

	const float cornerSizeX = (float) cornerSize.x.resolve (scope);
	const float cornerSizeY = (float) cornerSize.y.resolve (scope);

	const float w = Line<float> (points[0], points[1]).getLength();
	const float h = Line<float> (points[0], points[2]).getLength();

	Path newPath;

	if (cornerSizeX > 0 && cornerSizeY > 0)
		newPath.addRoundedRectangle (0, 0, w, h, cornerSizeX, cornerSizeY);
	else
		newPath.addRectangle (0, 0, w, h);

	newPath.applyTransform (AffineTransform::fromTargetPoints (0, 0, points[0].x, points[0].y,
															   w, 0, points[1].x, points[1].y,
															   0, h, points[2].x, points[2].y));

	if (path != newPath)
	{
		path.swapWithPath (newPath);
		pathChanged();
	}
}

const Identifier DrawableRectangle::valueTreeType ("Rectangle");
const Identifier DrawableRectangle::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableRectangle::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableRectangle::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableRectangle::ValueTreeWrapper::cornerSize ("cornerSize");

DrawableRectangle::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: FillAndStrokeState (state_)
{
	jassert (state.hasType (valueTreeType));
}

RelativeParallelogram DrawableRectangle::ValueTreeWrapper::getRectangle() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableRectangle::ValueTreeWrapper::setRectangle (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableRectangle::ValueTreeWrapper::setCornerSize (const RelativePoint& newSize, UndoManager* undoManager)
{
	state.setProperty (cornerSize, newSize.toString(), undoManager);
}

RelativePoint DrawableRectangle::ValueTreeWrapper::getCornerSize() const
{
	return RelativePoint (state [cornerSize]);
}

Value DrawableRectangle::ValueTreeWrapper::getCornerSizeValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (cornerSize, undoManager);
}

void DrawableRectangle::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	refreshFillTypes (v, builder.getImageProvider());
	setStrokeType (v.getStrokeType());
	setRectangle (v.getRectangle());
	setCornerSize (v.getCornerSize());
}

ValueTree DrawableRectangle::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	writeTo (v, imageProvider, nullptr);
	v.setRectangle (bounds, nullptr);
	v.setCornerSize (cornerSize, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableRectangle.cpp ***/


/*** Start of inlined file: juce_DrawableShape.cpp ***/
DrawableShape::DrawableShape()
	: strokeType (0.0f),
	  mainFill (Colours::black),
	  strokeFill (Colours::black)
{
}

DrawableShape::DrawableShape (const DrawableShape& other)
	: Drawable (other),
	  strokeType (other.strokeType),
	  mainFill (other.mainFill),
	  strokeFill (other.strokeFill)
{
}

DrawableShape::~DrawableShape()
{
}

class DrawableShape::RelativePositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativePositioner (DrawableShape& component_, const DrawableShape::RelativeFillType& fill_, bool isMainFill_)
		: RelativeCoordinatePositionerBase (component_),
		  owner (component_),
		  fill (fill_),
		  isMainFill (isMainFill_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = addPoint (fill.gradientPoint1);
		ok = addPoint (fill.gradientPoint2) && ok;
		return addPoint (fill.gradientPoint3) && ok;
	}

	void applyToComponentBounds()
	{
		ComponentScope scope (owner);
		if (isMainFill ? owner.mainFill.recalculateCoords (&scope)
					   : owner.strokeFill.recalculateCoords (&scope))
			owner.repaint();
	}

	void applyNewBounds (const Rectangle<int>&)
	{
		jassertfalse; // drawables can't be resized directly!
	}

private:
	DrawableShape& owner;
	const DrawableShape::RelativeFillType fill;
	const bool isMainFill;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativePositioner);
};

void DrawableShape::setFill (const FillType& newFill)
{
	setFill (RelativeFillType (newFill));
}

void DrawableShape::setStrokeFill (const FillType& newFill)
{
	setStrokeFill (RelativeFillType (newFill));
}

void DrawableShape::setFillInternal (RelativeFillType& fill, const RelativeFillType& newFill,
									 ScopedPointer<RelativeCoordinatePositionerBase>& pos)
{
	if (fill != newFill)
	{
		fill = newFill;
		pos = nullptr;

		if (fill.isDynamic())
		{
			pos = new RelativePositioner (*this, fill, true);
			pos->apply();
		}
		else
		{
			fill.recalculateCoords (nullptr);
		}

		repaint();
	}
}

void DrawableShape::setFill (const RelativeFillType& newFill)
{
	setFillInternal (mainFill, newFill, mainFillPositioner);
}

void DrawableShape::setStrokeFill (const RelativeFillType& newFill)
{
	setFillInternal (strokeFill, newFill, strokeFillPositioner);
}

void DrawableShape::setStrokeType (const PathStrokeType& newStrokeType)
{
	if (strokeType != newStrokeType)
	{
		strokeType = newStrokeType;
		strokeChanged();
	}
}

void DrawableShape::setStrokeThickness (const float newThickness)
{
	setStrokeType (PathStrokeType (newThickness, strokeType.getJointStyle(), strokeType.getEndStyle()));
}

bool DrawableShape::isStrokeVisible() const noexcept
{
	return strokeType.getStrokeThickness() > 0.0f && ! strokeFill.fill.isInvisible();
}

void DrawableShape::refreshFillTypes (const FillAndStrokeState& newState, ComponentBuilder::ImageProvider* imageProvider)
{
	setFill (newState.getFill (FillAndStrokeState::fill, imageProvider));
	setStrokeFill (newState.getFill (FillAndStrokeState::stroke, imageProvider));
}

void DrawableShape::writeTo (FillAndStrokeState& state, ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager) const
{
	state.setFill (FillAndStrokeState::fill, mainFill, imageProvider, undoManager);
	state.setFill (FillAndStrokeState::stroke, strokeFill, imageProvider, undoManager);
	state.setStrokeType (strokeType, undoManager);
}

void DrawableShape::paint (Graphics& g)
{
	transformContextToCorrectOrigin (g);

	g.setFillType (mainFill.fill);
	g.fillPath (path);

	if (isStrokeVisible())
	{
		g.setFillType (strokeFill.fill);
		g.fillPath (strokePath);
	}
}

void DrawableShape::pathChanged()
{
	strokeChanged();
}

void DrawableShape::strokeChanged()
{
	strokePath.clear();
	strokeType.createStrokedPath (strokePath, path, AffineTransform::identity, 4.0f);

	setBoundsToEnclose (getDrawableBounds());
	repaint();
}

Rectangle<float> DrawableShape::getDrawableBounds() const
{
	if (isStrokeVisible())
		return strokePath.getBounds();
	else
		return path.getBounds();
}

bool DrawableShape::hitTest (int x, int y)
{
	bool allowsClicksOnThisComponent, allowsClicksOnChildComponents;
	getInterceptsMouseClicks (allowsClicksOnThisComponent, allowsClicksOnChildComponents);

	if (! allowsClicksOnThisComponent)
		return false;

	const float globalX = (float) (x - originRelativeToComponent.x);
	const float globalY = (float) (y - originRelativeToComponent.y);

	return path.contains (globalX, globalY)
			|| (isStrokeVisible() && strokePath.contains (globalX, globalY));
}

DrawableShape::RelativeFillType::RelativeFillType()
{
}

DrawableShape::RelativeFillType::RelativeFillType (const FillType& fill_)
	: fill (fill_)
{
	if (fill.isGradient())
	{
		const ColourGradient& g = *fill.gradient;

		gradientPoint1 = g.point1.transformedBy (fill.transform);
		gradientPoint2 = g.point2.transformedBy (fill.transform);
		gradientPoint3 = Point<float> (g.point1.x + g.point2.y - g.point1.y,
									   g.point1.y + g.point1.x - g.point2.x)
							.transformedBy (fill.transform);
		fill.transform = AffineTransform::identity;
	}
}

DrawableShape::RelativeFillType::RelativeFillType (const RelativeFillType& other)
	: fill (other.fill),
	  gradientPoint1 (other.gradientPoint1),
	  gradientPoint2 (other.gradientPoint2),
	  gradientPoint3 (other.gradientPoint3)
{
}

DrawableShape::RelativeFillType& DrawableShape::RelativeFillType::operator= (const RelativeFillType& other)
{
	fill = other.fill;
	gradientPoint1 = other.gradientPoint1;
	gradientPoint2 = other.gradientPoint2;
	gradientPoint3 = other.gradientPoint3;
	return *this;
}

bool DrawableShape::RelativeFillType::operator== (const RelativeFillType& other) const
{
	return fill == other.fill
		&& ((! fill.isGradient())
			 || (gradientPoint1 == other.gradientPoint1
				 && gradientPoint2 == other.gradientPoint2
				 && gradientPoint3 == other.gradientPoint3));
}

bool DrawableShape::RelativeFillType::operator!= (const RelativeFillType& other) const
{
	return ! operator== (other);
}

bool DrawableShape::RelativeFillType::recalculateCoords (Expression::Scope* scope)
{
	if (fill.isGradient())
	{
		const Point<float> g1 (gradientPoint1.resolve (scope));
		const Point<float> g2 (gradientPoint2.resolve (scope));
		AffineTransform t;

		ColourGradient& g = *fill.gradient;

		if (g.isRadial)
		{
			const Point<float> g3 (gradientPoint3.resolve (scope));
			const Point<float> g3Source (g1.x + g2.y - g1.y,
										 g1.y + g1.x - g2.x);

			t = AffineTransform::fromTargetPoints (g1.x, g1.y, g1.x, g1.y,
												   g2.x, g2.y, g2.x, g2.y,
												   g3Source.x, g3Source.y, g3.x, g3.y);
		}

		if (g.point1 != g1 || g.point2 != g2 || fill.transform != t)
		{
			g.point1 = g1;
			g.point2 = g2;
			fill.transform = t;
			return true;
		}
	}

	return false;
}

bool DrawableShape::RelativeFillType::isDynamic() const
{
	return gradientPoint1.isDynamic() || gradientPoint2.isDynamic() || gradientPoint3.isDynamic();
}

void DrawableShape::RelativeFillType::writeTo (ValueTree& v, ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager) const
{
	if (fill.isColour())
	{
		v.setProperty (FillAndStrokeState::type, "solid", undoManager);
		v.setProperty (FillAndStrokeState::colour, String::toHexString ((int) fill.colour.getARGB()), undoManager);
	}
	else if (fill.isGradient())
	{
		v.setProperty (FillAndStrokeState::type, "gradient", undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint1, gradientPoint1.toString(), undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint2, gradientPoint2.toString(), undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint3, gradientPoint3.toString(), undoManager);

		const ColourGradient& cg = *fill.gradient;
		v.setProperty (FillAndStrokeState::radial, cg.isRadial, undoManager);

		String s;
		for (int i = 0; i < cg.getNumColours(); ++i)
			s << ' ' << cg.getColourPosition (i)
			  << ' ' << String::toHexString ((int) cg.getColour(i).getARGB());

		v.setProperty (FillAndStrokeState::colours, s.trimStart(), undoManager);
	}
	else if (fill.isTiledImage())
	{
		v.setProperty (FillAndStrokeState::type, "image", undoManager);

		if (imageProvider != nullptr)
			v.setProperty (FillAndStrokeState::imageId, imageProvider->getIdentifierForImage (fill.image), undoManager);

		if (fill.getOpacity() < 1.0f)
			v.setProperty (FillAndStrokeState::imageOpacity, fill.getOpacity(), undoManager);
		else
			v.removeProperty (FillAndStrokeState::imageOpacity, undoManager);
	}
	else
	{
		jassertfalse;
	}
}

bool DrawableShape::RelativeFillType::readFrom (const ValueTree& v, ComponentBuilder::ImageProvider* imageProvider)
{
	const String newType (v [FillAndStrokeState::type].toString());

	if (newType == "solid")
	{
		const String colourString (v [FillAndStrokeState::colour].toString());
		fill.setColour (colourString.isEmpty() ? Colours::black
											   : Colour::fromString (colourString));
		return true;
	}
	else if (newType == "gradient")
	{
		ColourGradient g;
		g.isRadial = v [FillAndStrokeState::radial];

		StringArray colourSteps;
		colourSteps.addTokens (v [FillAndStrokeState::colours].toString(), false);

		for (int i = 0; i < colourSteps.size() / 2; ++i)
			g.addColour (colourSteps[i * 2].getDoubleValue(),
						 Colour::fromString (colourSteps[i * 2 + 1]));

		fill.setGradient (g);

		gradientPoint1 = RelativePoint (v [FillAndStrokeState::gradientPoint1]);
		gradientPoint2 = RelativePoint (v [FillAndStrokeState::gradientPoint2]);
		gradientPoint3 = RelativePoint (v [FillAndStrokeState::gradientPoint3]);
		return true;
	}
	else if (newType == "image")
	{
		Image im;
		if (imageProvider != nullptr)
			im = imageProvider->getImageForIdentifier (v [FillAndStrokeState::imageId]);

		fill.setTiledImage (im, AffineTransform::identity);
		fill.setOpacity ((float) v.getProperty (FillAndStrokeState::imageOpacity, 1.0f));
		return true;
	}

	jassertfalse;
	return false;
}

const Identifier DrawableShape::FillAndStrokeState::type ("type");
const Identifier DrawableShape::FillAndStrokeState::colour ("colour");
const Identifier DrawableShape::FillAndStrokeState::colours ("colours");
const Identifier DrawableShape::FillAndStrokeState::fill ("Fill");
const Identifier DrawableShape::FillAndStrokeState::stroke ("Stroke");
const Identifier DrawableShape::FillAndStrokeState::path ("Path");
const Identifier DrawableShape::FillAndStrokeState::jointStyle ("jointStyle");
const Identifier DrawableShape::FillAndStrokeState::capStyle ("capStyle");
const Identifier DrawableShape::FillAndStrokeState::strokeWidth ("strokeWidth");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint1 ("point1");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint2 ("point2");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint3 ("point3");
const Identifier DrawableShape::FillAndStrokeState::radial ("radial");
const Identifier DrawableShape::FillAndStrokeState::imageId ("imageId");
const Identifier DrawableShape::FillAndStrokeState::imageOpacity ("imageOpacity");

DrawableShape::FillAndStrokeState::FillAndStrokeState (const ValueTree& state_)
	: Drawable::ValueTreeWrapperBase (state_)
{
}

DrawableShape::RelativeFillType DrawableShape::FillAndStrokeState::getFill (const Identifier& fillOrStrokeType, ComponentBuilder::ImageProvider* imageProvider) const
{
	DrawableShape::RelativeFillType f;
	f.readFrom (state.getChildWithName (fillOrStrokeType), imageProvider);
	return f;
}

ValueTree DrawableShape::FillAndStrokeState::getFillState (const Identifier& fillOrStrokeType)
{
	ValueTree v (state.getChildWithName (fillOrStrokeType));
	if (v.isValid())
		return v;

	setFill (fillOrStrokeType, FillType (Colours::black), nullptr, nullptr);
	return getFillState (fillOrStrokeType);
}

void DrawableShape::FillAndStrokeState::setFill (const Identifier& fillOrStrokeType, const RelativeFillType& newFill,
												 ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager)
{
	ValueTree v (state.getOrCreateChildWithName (fillOrStrokeType, undoManager));
	newFill.writeTo (v, imageProvider, undoManager);
}

PathStrokeType DrawableShape::FillAndStrokeState::getStrokeType() const
{
	const String jointStyleString (state [jointStyle].toString());
	const String capStyleString (state [capStyle].toString());

	return PathStrokeType (state [strokeWidth],
						   jointStyleString == "curved" ? PathStrokeType::curved
														: (jointStyleString == "bevel" ? PathStrokeType::beveled
																					   : PathStrokeType::mitered),
						   capStyleString == "square" ? PathStrokeType::square
													  : (capStyleString == "round" ? PathStrokeType::rounded
																				   : PathStrokeType::butt));
}

void DrawableShape::FillAndStrokeState::setStrokeType (const PathStrokeType& newStrokeType, UndoManager* undoManager)
{
	state.setProperty (strokeWidth, (double) newStrokeType.getStrokeThickness(), undoManager);
	state.setProperty (jointStyle, newStrokeType.getJointStyle() == PathStrokeType::mitered
									 ? "miter" : (newStrokeType.getJointStyle() == PathStrokeType::curved ? "curved" : "bevel"), undoManager);
	state.setProperty (capStyle, newStrokeType.getEndStyle() == PathStrokeType::butt
									 ? "butt" : (newStrokeType.getEndStyle() == PathStrokeType::square ? "square" : "round"), undoManager);
}

/*** End of inlined file: juce_DrawableShape.cpp ***/


/*** Start of inlined file: juce_DrawableText.cpp ***/
DrawableText::DrawableText()
	: colour (Colours::black),
	  justification (Justification::centredLeft)
{
	setBoundingBox (RelativeParallelogram (RelativePoint (0.0f, 0.0f),
										   RelativePoint (50.0f, 0.0f),
										   RelativePoint (0.0f, 20.0f)));
	setFont (Font (15.0f), true);
}

DrawableText::DrawableText (const DrawableText& other)
	: Drawable (other),
	  bounds (other.bounds),
	  fontHeight (other.fontHeight),
	  fontHScale (other.fontHScale),
	  font (other.font),
	  text (other.text),
	  colour (other.colour),
	  justification (other.justification)
{
}

DrawableText::~DrawableText()
{
}

void DrawableText::setText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		refreshBounds();
	}
}

void DrawableText::setColour (const Colour& newColour)
{
	if (colour != newColour)
	{
		colour = newColour;
		repaint();
	}
}

void DrawableText::setFont (const Font& newFont, bool applySizeAndScale)
{
	if (font != newFont)
	{
		font = newFont;

		if (applySizeAndScale)
		{
			fontHeight = font.getHeight();
			fontHScale = font.getHorizontalScale();
		}

		refreshBounds();
	}
}

void DrawableText::setJustification (const Justification& newJustification)
{
	justification = newJustification;
	repaint();
}

void DrawableText::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;
		refreshBounds();
	}
}

void DrawableText::setFontHeight (const RelativeCoordinate& newHeight)
{
	if (fontHeight != newHeight)
	{
		fontHeight = newHeight;
		refreshBounds();
	}
}

void DrawableText::setFontHorizontalScale (const RelativeCoordinate& newScale)
{
	if (fontHScale != newScale)
	{
		fontHScale = newScale;
		refreshBounds();
	}
}

void DrawableText::refreshBounds()
{
	if (bounds.isDynamic() || fontHeight.isDynamic() || fontHScale.isDynamic())
	{
		Drawable::Positioner<DrawableText>* const p = new Drawable::Positioner<DrawableText> (*this);
		setPositioner (p);
		p->apply();
	}
	else
	{
		setPositioner (0);
		recalculateCoordinates (0);
	}
}

bool DrawableText::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	ok = pos.addPoint (bounds.bottomLeft) && ok;
	ok = pos.addCoordinate (fontHeight) && ok;
	return pos.addCoordinate (fontHScale) && ok;
}

void DrawableText::recalculateCoordinates (Expression::Scope* scope)
{
	bounds.resolveThreePoints (resolvedPoints, scope);

	const float w = Line<float> (resolvedPoints[0], resolvedPoints[1]).getLength();
	const float h = Line<float> (resolvedPoints[0], resolvedPoints[2]).getLength();

	const float height = jlimit (0.01f, jmax (0.01f, h), (float) fontHeight.resolve (scope));
	const float hscale = jlimit (0.01f, jmax (0.01f, w), (float) fontHScale.resolve (scope));

	scaledFont = font;
	scaledFont.setHeight (height);
	scaledFont.setHorizontalScale (hscale);

	setBoundsToEnclose (getDrawableBounds());
	repaint();
}

const AffineTransform DrawableText::getArrangementAndTransform (GlyphArrangement& glyphs) const
{
	const float w = Line<float> (resolvedPoints[0], resolvedPoints[1]).getLength();
	const float h = Line<float> (resolvedPoints[0], resolvedPoints[2]).getLength();

	glyphs.addFittedText (scaledFont, text, 0, 0, w, h, justification, 0x100000);

	return AffineTransform::fromTargetPoints (0, 0, resolvedPoints[0].x, resolvedPoints[0].y,
											  w, 0, resolvedPoints[1].x, resolvedPoints[1].y,
											  0, h, resolvedPoints[2].x, resolvedPoints[2].y);
}

void DrawableText::paint (Graphics& g)
{
	transformContextToCorrectOrigin (g);

	g.setColour (colour);

	GlyphArrangement ga;
	const AffineTransform transform (getArrangementAndTransform (ga));
	ga.draw (g, transform);
}

Rectangle<float> DrawableText::getDrawableBounds() const
{
	return RelativeParallelogram::getBoundingBox (resolvedPoints);
}

Drawable* DrawableText::createCopy() const
{
	return new DrawableText (*this);
}

const Identifier DrawableText::valueTreeType ("Text");

const Identifier DrawableText::ValueTreeWrapper::text ("text");
const Identifier DrawableText::ValueTreeWrapper::colour ("colour");
const Identifier DrawableText::ValueTreeWrapper::font ("font");
const Identifier DrawableText::ValueTreeWrapper::justification ("justification");
const Identifier DrawableText::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableText::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableText::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableText::ValueTreeWrapper::fontHeight ("fontHeight");
const Identifier DrawableText::ValueTreeWrapper::fontHScale ("fontHScale");

DrawableText::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

String DrawableText::ValueTreeWrapper::getText() const
{
	return state [text].toString();
}

void DrawableText::ValueTreeWrapper::setText (const String& newText, UndoManager* undoManager)
{
	state.setProperty (text, newText, undoManager);
}

Value DrawableText::ValueTreeWrapper::getTextValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (text, undoManager);
}

Colour DrawableText::ValueTreeWrapper::getColour() const
{
	return Colour::fromString (state [colour].toString());
}

void DrawableText::ValueTreeWrapper::setColour (const Colour& newColour, UndoManager* undoManager)
{
	state.setProperty (colour, newColour.toString(), undoManager);
}

Justification DrawableText::ValueTreeWrapper::getJustification() const
{
	return Justification ((int) state [justification]);
}

void DrawableText::ValueTreeWrapper::setJustification (const Justification& newJustification, UndoManager* undoManager)
{
	state.setProperty (justification, newJustification.getFlags(), undoManager);
}

Font DrawableText::ValueTreeWrapper::getFont() const
{
	return Font::fromString (state [font]);
}

void DrawableText::ValueTreeWrapper::setFont (const Font& newFont, UndoManager* undoManager)
{
	state.setProperty (font, newFont.toString(), undoManager);
}

Value DrawableText::ValueTreeWrapper::getFontValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (font, undoManager);
}

RelativeParallelogram DrawableText::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state [topLeft].toString(), state [topRight].toString(), state [bottomLeft].toString());
}

void DrawableText::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

RelativeCoordinate DrawableText::ValueTreeWrapper::getFontHeight() const
{
	return state [fontHeight].toString();
}

void DrawableText::ValueTreeWrapper::setFontHeight (const RelativeCoordinate& coord, UndoManager* undoManager)
{
	state.setProperty (fontHeight, coord.toString(), undoManager);
}

RelativeCoordinate DrawableText::ValueTreeWrapper::getFontHorizontalScale() const
{
	return state [fontHScale].toString();
}

void DrawableText::ValueTreeWrapper::setFontHorizontalScale (const RelativeCoordinate& coord, UndoManager* undoManager)
{
	state.setProperty (fontHScale, coord.toString(), undoManager);
}

void DrawableText::refreshFromValueTree (const ValueTree& tree, ComponentBuilder&)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	const RelativeParallelogram newBounds (v.getBoundingBox());
	const RelativeCoordinate newFontHeight (v.getFontHeight());
	const RelativeCoordinate newFontHScale (v.getFontHorizontalScale());
	const Colour newColour (v.getColour());
	const Justification newJustification (v.getJustification());
	const String newText (v.getText());
	const Font newFont (v.getFont());

	if (text != newText || font != newFont || justification != newJustification
		 || colour != newColour || bounds != newBounds
		 || newFontHeight != fontHeight || newFontHScale != fontHScale)
	{
		setBoundingBox (newBounds);
		setFontHeight (newFontHeight);
		setFontHorizontalScale (newFontHScale);
		setColour (newColour);
		setFont (newFont, false);
		setJustification (newJustification);
		setText (newText);
	}
}

ValueTree DrawableText::createValueTree (ComponentBuilder::ImageProvider*) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setText (text, nullptr);
	v.setFont (font, nullptr);
	v.setJustification (justification, nullptr);
	v.setColour (colour, nullptr);
	v.setBoundingBox (bounds, nullptr);
	v.setFontHeight (fontHeight, nullptr);
	v.setFontHorizontalScale (fontHScale, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableText.cpp ***/


/*** Start of inlined file: juce_SVGParser.cpp ***/
class SVGState
{
public:

	SVGState (const XmlElement* const topLevel)
		: topLevelXml (topLevel),
		  elementX (0), elementY (0),
		  width (512), height (512),
		  viewBoxW (0), viewBoxH (0)
	{
	}

	Drawable* parseSVGElement (const XmlElement& xml)
	{
		if (! xml.hasTagName ("svg"))
			return nullptr;

		DrawableComposite* const drawable = new DrawableComposite();

		drawable->setName (xml.getStringAttribute ("id"));

		SVGState newState (*this);

		if (xml.hasAttribute ("transform"))
			newState.addTransform (xml);

		newState.elementX = getCoordLength (xml.getStringAttribute ("x", String (newState.elementX)), viewBoxW);
		newState.elementY = getCoordLength (xml.getStringAttribute ("y", String (newState.elementY)), viewBoxH);
		newState.width    = getCoordLength (xml.getStringAttribute ("width", String (newState.width)), viewBoxW);
		newState.height   = getCoordLength (xml.getStringAttribute ("height", String (newState.height)), viewBoxH);

		if (newState.width <= 0)  newState.width  = 100;
		if (newState.height <= 0) newState.height = 100;

		if (xml.hasAttribute ("viewBox"))
		{
			const String viewBoxAtt (xml.getStringAttribute ("viewBox"));
			String::CharPointerType viewParams (viewBoxAtt.getCharPointer());
			float vx, vy, vw, vh;

			if (parseCoords (viewParams, vx, vy, true)
				 && parseCoords (viewParams, vw, vh, true)
				 && vw > 0
				 && vh > 0)
			{
				newState.viewBoxW = vw;
				newState.viewBoxH = vh;

				int placementFlags = 0;

				const String aspect (xml.getStringAttribute ("preserveAspectRatio"));

				if (aspect.containsIgnoreCase ("none"))
				{
					placementFlags = RectanglePlacement::stretchToFit;
				}
				else
				{
					if (aspect.containsIgnoreCase ("slice"))
						placementFlags |= RectanglePlacement::fillDestination;

					if (aspect.containsIgnoreCase ("xMin"))
						placementFlags |= RectanglePlacement::xLeft;
					else if (aspect.containsIgnoreCase ("xMax"))
						placementFlags |= RectanglePlacement::xRight;
					else
						placementFlags |= RectanglePlacement::xMid;

					if (aspect.containsIgnoreCase ("yMin"))
						placementFlags |= RectanglePlacement::yTop;
					else if (aspect.containsIgnoreCase ("yMax"))
						placementFlags |= RectanglePlacement::yBottom;
					else
						placementFlags |= RectanglePlacement::yMid;
				}

				const RectanglePlacement placement (placementFlags);

				newState.transform
					= placement.getTransformToFit (Rectangle<float> (vx, vy, vw, vh),
												   Rectangle<float> (0.0f, 0.0f, newState.width, newState.height))
							   .followedBy (newState.transform);
			}
		}
		else
		{
			if (viewBoxW == 0)
				newState.viewBoxW = newState.width;

			if (viewBoxH == 0)
				newState.viewBoxH = newState.height;
		}

		newState.parseSubElements (xml, drawable);

		drawable->resetContentAreaAndBoundingBoxToFitChildren();
		return drawable;
	}

private:

	const XmlElement* const topLevelXml;
	float elementX, elementY, width, height, viewBoxW, viewBoxH;
	AffineTransform transform;
	String cssStyleText;

	void parseSubElements (const XmlElement& xml, DrawableComposite* const parentDrawable)
	{
		forEachXmlChildElement (xml, e)
		{
			Drawable* d = nullptr;

			if (e->hasTagName ("g"))                d = parseGroupElement (*e);
			else if (e->hasTagName ("svg"))         d = parseSVGElement (*e);
			else if (e->hasTagName ("path"))        d = parsePath (*e);
			else if (e->hasTagName ("rect"))        d = parseRect (*e);
			else if (e->hasTagName ("circle"))      d = parseCircle (*e);
			else if (e->hasTagName ("ellipse"))     d = parseEllipse (*e);
			else if (e->hasTagName ("line"))        d = parseLine (*e);
			else if (e->hasTagName ("polyline"))    d = parsePolygon (*e, true);
			else if (e->hasTagName ("polygon"))     d = parsePolygon (*e, false);
			else if (e->hasTagName ("text"))        d = parseText (*e);
			else if (e->hasTagName ("switch"))      d = parseSwitch (*e);
			else if (e->hasTagName ("style"))       parseCSSStyle (*e);

			parentDrawable->addAndMakeVisible (d);
		}
	}

	DrawableComposite* parseSwitch (const XmlElement& xml)
	{
		const XmlElement* const group = xml.getChildByName ("g");

		if (group != nullptr)
			return parseGroupElement (*group);

		return nullptr;
	}

	DrawableComposite* parseGroupElement (const XmlElement& xml)
	{
		DrawableComposite* const drawable = new DrawableComposite();

		drawable->setName (xml.getStringAttribute ("id"));

		if (xml.hasAttribute ("transform"))
		{
			SVGState newState (*this);
			newState.addTransform (xml);

			newState.parseSubElements (xml, drawable);
		}
		else
		{
			parseSubElements (xml, drawable);
		}

		drawable->resetContentAreaAndBoundingBoxToFitChildren();
		return drawable;
	}

	Drawable* parsePath (const XmlElement& xml) const
	{
		const String dAttribute (xml.getStringAttribute ("d").trimStart());
		String::CharPointerType d (dAttribute.getCharPointer());
		Path path;

		if (getStyleAttribute (&xml, "fill-rule").trim().equalsIgnoreCase ("evenodd"))
			path.setUsingNonZeroWinding (false);

		float lastX = 0, lastY = 0;
		float lastX2 = 0, lastY2 = 0;
		juce_wchar lastCommandChar = 0;
		bool isRelative = true;
		bool carryOn = true;

		const CharPointer_ASCII validCommandChars ("MmLlHhVvCcSsQqTtAaZz");

		while (! d.isEmpty())
		{
			float x, y, x2, y2, x3, y3;

			if (validCommandChars.indexOf (*d) >= 0)
			{
				lastCommandChar = d.getAndAdvance();
				isRelative = (lastCommandChar >= 'a' && lastCommandChar <= 'z');
			}

			switch (lastCommandChar)
			{
			case 'M':
			case 'm':
			case 'L':
			case 'l':
				if (parseCoords (d, x, y, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
					}

					if (lastCommandChar == 'M' || lastCommandChar == 'm')
					{
						path.startNewSubPath (x, y);
						lastCommandChar = 'l';
					}
					else
						path.lineTo (x, y);

					lastX2 = lastX;
					lastY2 = lastY;
					lastX = x;
					lastY = y;
				}
				else
				{
					++d;
				}

				break;

			case 'H':
			case 'h':
				if (parseCoord (d, x, false, true))
				{
					if (isRelative)
						x += lastX;

					path.lineTo (x, lastY);

					lastX2 = lastX;
					lastX = x;
				}
				else
				{
					++d;
				}
				break;

			case 'V':
			case 'v':
				if (parseCoord (d, y, false, false))
				{
					if (isRelative)
						y += lastY;

					path.lineTo (lastX, y);

					lastY2 = lastY;
					lastY = y;
				}
				else
				{
					++d;
				}
				break;

			case 'C':
			case 'c':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x2, y2, false)
					 && parseCoords (d, x3, y3, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x2 += lastX;
						y2 += lastY;
						x3 += lastX;
						y3 += lastY;
					}

					path.cubicTo (x, y, x2, y2, x3, y3);

					lastX2 = x2;
					lastY2 = y2;
					lastX = x3;
					lastY = y3;
				}
				else
				{
					++d;
				}
				break;

			case 'S':
			case 's':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x3, y3, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x3 += lastX;
						y3 += lastY;
					}

					x2 = lastX + (lastX - lastX2);
					y2 = lastY + (lastY - lastY2);
					path.cubicTo (x2, y2, x, y, x3, y3);

					lastX2 = x;
					lastY2 = y;
					lastX = x3;
					lastY = y3;
				}
				else
				{
					++d;
				}
				break;

			case 'Q':
			case 'q':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x2, y2, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x2 += lastX;
						y2 += lastY;
					}

					path.quadraticTo (x, y, x2, y2);

					lastX2 = x;
					lastY2 = y;
					lastX = x2;
					lastY = y2;
				}
				else
				{
					++d;
				}
				break;

			case 'T':
			case 't':
				if (parseCoords (d, x, y, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
					}

					x2 = lastX + (lastX - lastX2);
					y2 = lastY + (lastY - lastY2);
					path.quadraticTo (x2, y2, x, y);

					lastX2 = x2;
					lastY2 = y2;
					lastX = x;
					lastY = y;
				}
				else
				{
					++d;
				}
				break;

			case 'A':
			case 'a':
				if (parseCoords (d, x, y, false))
				{
					String num;

					if (parseNextNumber (d, num, false))
					{
						const float angle = num.getFloatValue() * (180.0f / float_Pi);

						if (parseNextNumber (d, num, false))
						{
							const bool largeArc = num.getIntValue() != 0;

							if (parseNextNumber (d, num, false))
							{
								const bool sweep = num.getIntValue() != 0;

								if (parseCoords (d, x2, y2, false))
								{
									if (isRelative)
									{
										x2 += lastX;
										y2 += lastY;
									}

									if (lastX != x2 || lastY != y2)
									{
										double centreX, centreY, startAngle, deltaAngle;
										double rx = x, ry = y;

										endpointToCentreParameters (lastX, lastY, x2, y2,
																	angle, largeArc, sweep,
																	rx, ry, centreX, centreY,
																	startAngle, deltaAngle);

										path.addCentredArc ((float) centreX, (float) centreY,
															(float) rx, (float) ry,
															angle, (float) startAngle, (float) (startAngle + deltaAngle),
															false);

										path.lineTo (x2, y2);
									}

									lastX2 = lastX;
									lastY2 = lastY;
									lastX = x2;
									lastY = y2;
								}
							}
						}
					}
				}
				else
				{
					++d;
				}

				break;

			case 'Z':
			case 'z':
				path.closeSubPath();
				d = d.findEndOfWhitespace();
				break;

			default:
				carryOn = false;
				break;
			}

			if (! carryOn)
				break;
		}

		return parseShape (xml, path);
	}

	Drawable* parseRect (const XmlElement& xml) const
	{
		Path rect;

		const bool hasRX = xml.hasAttribute ("rx");
		const bool hasRY = xml.hasAttribute ("ry");

		if (hasRX || hasRY)
		{
			float rx = getCoordLength (xml.getStringAttribute ("rx"), viewBoxW);
			float ry = getCoordLength (xml.getStringAttribute ("ry"), viewBoxH);

			if (! hasRX)
				rx = ry;
			else if (! hasRY)
				ry = rx;

			rect.addRoundedRectangle (getCoordLength (xml.getStringAttribute ("x"), viewBoxW),
									  getCoordLength (xml.getStringAttribute ("y"), viewBoxH),
									  getCoordLength (xml.getStringAttribute ("width"), viewBoxW),
									  getCoordLength (xml.getStringAttribute ("height"), viewBoxH),
									  rx, ry);
		}
		else
		{
			rect.addRectangle (getCoordLength (xml.getStringAttribute ("x"), viewBoxW),
							   getCoordLength (xml.getStringAttribute ("y"), viewBoxH),
							   getCoordLength (xml.getStringAttribute ("width"), viewBoxW),
							   getCoordLength (xml.getStringAttribute ("height"), viewBoxH));
		}

		return parseShape (xml, rect);
	}

	Drawable* parseCircle (const XmlElement& xml) const
	{
		Path circle;

		const float cx = getCoordLength (xml.getStringAttribute ("cx"), viewBoxW);
		const float cy = getCoordLength (xml.getStringAttribute ("cy"), viewBoxH);
		const float radius = getCoordLength (xml.getStringAttribute ("r"), viewBoxW);

		circle.addEllipse (cx - radius, cy - radius, radius * 2.0f, radius * 2.0f);

		return parseShape (xml, circle);
	}

	Drawable* parseEllipse (const XmlElement& xml) const
	{
		Path ellipse;

		const float cx      = getCoordLength (xml.getStringAttribute ("cx"), viewBoxW);
		const float cy      = getCoordLength (xml.getStringAttribute ("cy"), viewBoxH);
		const float radiusX = getCoordLength (xml.getStringAttribute ("rx"), viewBoxW);
		const float radiusY = getCoordLength (xml.getStringAttribute ("ry"), viewBoxH);

		ellipse.addEllipse (cx - radiusX, cy - radiusY, radiusX * 2.0f, radiusY * 2.0f);

		return parseShape (xml, ellipse);
	}

	Drawable* parseLine (const XmlElement& xml) const
	{
		Path line;

		const float x1 = getCoordLength (xml.getStringAttribute ("x1"), viewBoxW);
		const float y1 = getCoordLength (xml.getStringAttribute ("y1"), viewBoxH);
		const float x2 = getCoordLength (xml.getStringAttribute ("x2"), viewBoxW);
		const float y2 = getCoordLength (xml.getStringAttribute ("y2"), viewBoxH);

		line.startNewSubPath (x1, y1);
		line.lineTo (x2, y2);

		return parseShape (xml, line);
	}

	Drawable* parsePolygon (const XmlElement& xml, const bool isPolyline) const
	{
		const String pointsAtt (xml.getStringAttribute ("points"));
		String::CharPointerType points (pointsAtt.getCharPointer());
		Path path;
		float x, y;

		if (parseCoords (points, x, y, true))
		{
			float firstX = x;
			float firstY = y;
			float lastX = 0, lastY = 0;

			path.startNewSubPath (x, y);

			while (parseCoords (points, x, y, true))
			{
				lastX = x;
				lastY = y;
				path.lineTo (x, y);
			}

			if ((! isPolyline) || (firstX == lastX && firstY == lastY))
				path.closeSubPath();
		}

		return parseShape (xml, path);
	}

	Drawable* parseShape (const XmlElement& xml, Path& path,
						  const bool shouldParseTransform = true) const
	{
		if (shouldParseTransform && xml.hasAttribute ("transform"))
		{
			SVGState newState (*this);
			newState.addTransform (xml);

			return newState.parseShape (xml, path, false);
		}

		DrawablePath* dp = new DrawablePath();
		dp->setName (xml.getStringAttribute ("id"));
		dp->setFill (Colours::transparentBlack);

		path.applyTransform (transform);
		dp->setPath (path);

		Path::Iterator iter (path);

		bool containsClosedSubPath = false;
		while (iter.next())
		{
			if (iter.elementType == Path::Iterator::closePath)
			{
				containsClosedSubPath = true;
				break;
			}
		}

		dp->setFill (getPathFillType (path,
									  getStyleAttribute (&xml, "fill"),
									  getStyleAttribute (&xml, "fill-opacity"),
									  getStyleAttribute (&xml, "opacity"),
									  containsClosedSubPath ? Colours::black
															: Colours::transparentBlack));

		const String strokeType (getStyleAttribute (&xml, "stroke"));

		if (strokeType.isNotEmpty() && ! strokeType.equalsIgnoreCase ("none"))
		{
			dp->setStrokeFill (getPathFillType (path, strokeType,
												getStyleAttribute (&xml, "stroke-opacity"),
												getStyleAttribute (&xml, "opacity"),
												Colours::transparentBlack));

			dp->setStrokeType (getStrokeFor (&xml));
		}

		return dp;
	}

	const XmlElement* findLinkedElement (const XmlElement* e) const
	{
		const String id (e->getStringAttribute ("xlink:href"));

		if (! id.startsWithChar ('#'))
			return nullptr;

		return findElementForId (topLevelXml, id.substring (1));
	}

	void addGradientStopsIn (ColourGradient& cg, const XmlElement* const fillXml) const
	{
		if (fillXml == 0)
			return;

		forEachXmlChildElementWithTagName (*fillXml, e, "stop")
		{
			int index = 0;
			Colour col (parseColour (getStyleAttribute  (e, "stop-color"), index, Colours::black));

			const String opacity (getStyleAttribute (e, "stop-opacity", "1"));
			col = col.withMultipliedAlpha (jlimit (0.0f, 1.0f, opacity.getFloatValue()));

			double offset = e->getDoubleAttribute ("offset");

			if (e->getStringAttribute ("offset").containsChar ('%'))
				offset *= 0.01;

			cg.addColour (jlimit (0.0, 1.0, offset), col);
		}
	}

	FillType getPathFillType (const Path& path,
							  const String& fill,
							  const String& fillOpacity,
							  const String& overallOpacity,
							  const Colour& defaultColour) const
	{
		float opacity = 1.0f;

		if (overallOpacity.isNotEmpty())
			opacity = jlimit (0.0f, 1.0f, overallOpacity.getFloatValue());

		if (fillOpacity.isNotEmpty())
			opacity *= (jlimit (0.0f, 1.0f, fillOpacity.getFloatValue()));

		if (fill.startsWithIgnoreCase ("url"))
		{
			const String id (fill.fromFirstOccurrenceOf ("#", false, false)
								 .upToLastOccurrenceOf (")", false, false).trim());

			const XmlElement* const fillXml = findElementForId (topLevelXml, id);

			if (fillXml != nullptr
				 && (fillXml->hasTagName ("linearGradient")
					  || fillXml->hasTagName ("radialGradient")))
			{
				const XmlElement* inheritedFrom = findLinkedElement (fillXml);

				ColourGradient gradient;

				addGradientStopsIn (gradient, inheritedFrom);
				addGradientStopsIn (gradient, fillXml);

				if (gradient.getNumColours() > 0)
				{
					gradient.addColour (0.0, gradient.getColour (0));
					gradient.addColour (1.0, gradient.getColour (gradient.getNumColours() - 1));
				}
				else
				{
					gradient.addColour (0.0, Colours::black);
					gradient.addColour (1.0, Colours::black);
				}

				if (overallOpacity.isNotEmpty())
					gradient.multiplyOpacity (overallOpacity.getFloatValue());

				jassert (gradient.getNumColours() > 0);

				gradient.isRadial = fillXml->hasTagName ("radialGradient");

				float gradientWidth = viewBoxW;
				float gradientHeight = viewBoxH;
				float dx = 0.0f;
				float dy = 0.0f;

				const bool userSpace = fillXml->getStringAttribute ("gradientUnits").equalsIgnoreCase ("userSpaceOnUse");

				if (! userSpace)
				{
					const Rectangle<float> bounds (path.getBounds());
					dx = bounds.getX();
					dy = bounds.getY();
					gradientWidth = bounds.getWidth();
					gradientHeight = bounds.getHeight();
				}

				if (gradient.isRadial)
				{
					if (userSpace)
						gradient.point1.setXY (dx + getCoordLength (fillXml->getStringAttribute ("cx", "50%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("cy", "50%"), gradientHeight));
					else
						gradient.point1.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("cx", "50%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("cy", "50%"), 1.0f));

					const float radius = getCoordLength (fillXml->getStringAttribute ("r", "50%"), gradientWidth);
					gradient.point2 = gradient.point1 + Point<float> (radius, 0.0f);

					//xxx (the fx, fy focal point isn't handled properly here..)
				}
				else
				{
					if (userSpace)
					{
						gradient.point1.setXY (dx + getCoordLength (fillXml->getStringAttribute ("x1", "0%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("y1", "0%"), gradientHeight));

						gradient.point2.setXY (dx + getCoordLength (fillXml->getStringAttribute ("x2", "100%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("y2", "0%"), gradientHeight));
					}
					else
					{
						gradient.point1.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("x1", "0%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("y1", "0%"), 1.0f));

						gradient.point2.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("x2", "100%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("y2", "0%"), 1.0f));
					}

					if (gradient.point1 == gradient.point2)
						return Colour (gradient.getColour (gradient.getNumColours() - 1));
				}

				FillType type (gradient);
				type.transform = parseTransform (fillXml->getStringAttribute ("gradientTransform"))
								   .followedBy (transform);
				return type;
			}
		}

		if (fill.equalsIgnoreCase ("none"))
			return Colours::transparentBlack;

		int i = 0;
		const Colour colour (parseColour (fill, i, defaultColour));
		return colour.withMultipliedAlpha (opacity);
	}

	PathStrokeType getStrokeFor (const XmlElement* const xml) const
	{
		const String strokeWidth (getStyleAttribute (xml, "stroke-width"));
		const String cap (getStyleAttribute (xml, "stroke-linecap"));
		const String join (getStyleAttribute (xml, "stroke-linejoin"));

		//const String mitreLimit (getStyleAttribute (xml, "stroke-miterlimit"));
		//const String dashArray (getStyleAttribute (xml, "stroke-dasharray"));
		//const String dashOffset (getStyleAttribute (xml, "stroke-dashoffset"));

		PathStrokeType::JointStyle joinStyle = PathStrokeType::mitered;
		PathStrokeType::EndCapStyle capStyle = PathStrokeType::butt;

		if (join.equalsIgnoreCase ("round"))
			joinStyle = PathStrokeType::curved;
		else if (join.equalsIgnoreCase ("bevel"))
			joinStyle = PathStrokeType::beveled;

		if (cap.equalsIgnoreCase ("round"))
			capStyle = PathStrokeType::rounded;
		else if (cap.equalsIgnoreCase ("square"))
			capStyle = PathStrokeType::square;

		float ox = 0.0f, oy = 0.0f;
		float x = getCoordLength (strokeWidth, viewBoxW), y = 0.0f;
		transform.transformPoints (ox, oy, x, y);

		return PathStrokeType (strokeWidth.isNotEmpty() ? juce_hypot (x - ox, y - oy) : 1.0f,
							   joinStyle, capStyle);
	}

	Drawable* parseText (const XmlElement& xml)
	{
		Array <float> xCoords, yCoords, dxCoords, dyCoords;

		getCoordList (xCoords, getInheritedAttribute (&xml, "x"), true, true);
		getCoordList (yCoords, getInheritedAttribute (&xml, "y"), true, false);
		getCoordList (dxCoords, getInheritedAttribute (&xml, "dx"), true, true);
		getCoordList (dyCoords, getInheritedAttribute (&xml, "dy"), true, false);

		//xxx not done text yet!

		forEachXmlChildElement (xml, e)
		{
			if (e->isTextElement())
			{
				const String text (e->getText());

				Path path;
				Drawable* s = parseShape (*e, path);
				delete s;  // xxx not finished!
			}
			else if (e->hasTagName ("tspan"))
			{
				Drawable* s = parseText (*e);
				delete s;  // xxx not finished!
			}
		}

		return nullptr;
	}

	void addTransform (const XmlElement& xml)
	{
		transform = parseTransform (xml.getStringAttribute ("transform"))
						.followedBy (transform);
	}

	bool parseCoord (String::CharPointerType& s, float& value, const bool allowUnits, const bool isX) const
	{
		String number;

		if (! parseNextNumber (s, number, allowUnits))
		{
			value = 0;
			return false;
		}

		value = getCoordLength (number, isX ? viewBoxW : viewBoxH);
		return true;
	}

	bool parseCoords (String::CharPointerType& s, float& x, float& y, const bool allowUnits) const
	{
		return parseCoord (s, x, allowUnits, true)
			&& parseCoord (s, y, allowUnits, false);
	}

	float getCoordLength (const String& s, const float sizeForProportions) const
	{
		float n = s.getFloatValue();
		const int len = s.length();

		if (len > 2)
		{
			const float dpi = 96.0f;

			const juce_wchar n1 = s [len - 2];
			const juce_wchar n2 = s [len - 1];

			if (n1 == 'i' && n2 == 'n')         n *= dpi;
			else if (n1 == 'm' && n2 == 'm')    n *= dpi / 25.4f;
			else if (n1 == 'c' && n2 == 'm')    n *= dpi / 2.54f;
			else if (n1 == 'p' && n2 == 'c')    n *= 15.0f;
			else if (n2 == '%')                 n *= 0.01f * sizeForProportions;
		}

		return n;
	}

	void getCoordList (Array <float>& coords, const String& list,
					   const bool allowUnits, const bool isX) const
	{
		String::CharPointerType text (list.getCharPointer());
		float value;

		while (parseCoord (text, value, allowUnits, isX))
			coords.add (value);
	}

	void parseCSSStyle (const XmlElement& xml)
	{
		cssStyleText = xml.getAllSubText() + "\n" + cssStyleText;
	}

	String getStyleAttribute (const XmlElement* xml, const String& attributeName,
							  const String& defaultValue = String::empty) const
	{
		if (xml->hasAttribute (attributeName))
			return xml->getStringAttribute (attributeName, defaultValue);

		const String styleAtt (xml->getStringAttribute ("style"));

		if (styleAtt.isNotEmpty())
		{
			const String value (getAttributeFromStyleList (styleAtt, attributeName, String::empty));

			if (value.isNotEmpty())
				return value;
		}
		else if (xml->hasAttribute ("class"))
		{
			const String className ("." + xml->getStringAttribute ("class"));

			int index = cssStyleText.indexOfIgnoreCase (className + " ");

			if (index < 0)
				index = cssStyleText.indexOfIgnoreCase (className + "{");

			if (index >= 0)
			{
				const int openBracket = cssStyleText.indexOfChar (index, '{');

				if (openBracket > index)
				{
					const int closeBracket = cssStyleText.indexOfChar (openBracket, '}');

					if (closeBracket > openBracket)
					{
						const String value (getAttributeFromStyleList (cssStyleText.substring (openBracket + 1, closeBracket), attributeName, defaultValue));

						if (value.isNotEmpty())
							return value;
					}
				}
			}
		}

		xml = const_cast <XmlElement*> (topLevelXml)->findParentElementOf (xml);

		if (xml != nullptr)
			return getStyleAttribute (xml, attributeName, defaultValue);

		return defaultValue;
	}

	String getInheritedAttribute (const XmlElement* xml, const String& attributeName) const
	{
		if (xml->hasAttribute (attributeName))
			return xml->getStringAttribute (attributeName);

		xml = const_cast <XmlElement*> (topLevelXml)->findParentElementOf (xml);

		if (xml != nullptr)
			return getInheritedAttribute  (xml, attributeName);

		return String::empty;
	}

	static bool isIdentifierChar (const juce_wchar c)
	{
		return CharacterFunctions::isLetter (c) || c == '-';
	}

	static String getAttributeFromStyleList (const String& list, const String& attributeName, const String& defaultValue)
	{
		int i = 0;

		for (;;)
		{
			i = list.indexOf (i, attributeName);

			if (i < 0)
				break;

			if ((i == 0 || (i > 0 && ! isIdentifierChar (list [i - 1])))
				 && ! isIdentifierChar (list [i + attributeName.length()]))
			{
				i = list.indexOfChar (i, ':');

				if (i < 0)
					break;

				int end = list.indexOfChar (i, ';');

				if (end < 0)
					end = 0x7ffff;

				return list.substring (i + 1, end).trim();
			}

			++i;
		}

		return defaultValue;
	}

	static bool parseNextNumber (String::CharPointerType& s, String& value, const bool allowUnits)
	{
		while (s.isWhitespace() || *s == ',')
			++s;

		String::CharPointerType start (s);
		int numChars = 0;

		if (s.isDigit() || *s == '.' || *s == '-')
		{
			++numChars;
			++s;
		}

		while (s.isDigit() || *s == '.')
		{
			++numChars;
			++s;
		}

		if ((*s == 'e' || *s == 'E')
			 && ((s + 1).isDigit() || s[1] == '-' || s[1] == '+'))
		{
			s += 2;
			numChars += 2;

			while (s.isDigit())
			{
				++numChars;
				++s;
			}
		}

		if (allowUnits)
		{
			while (s.isLetter())
			{
				++numChars;
				++s;
			}
		}

		if (numChars == 0)
			return false;

		value = String (start, (size_t) numChars);

		while (s.isWhitespace() || *s == ',')
			++s;

		return true;
	}

	static Colour parseColour (const String& s, int& index, const Colour& defaultColour)
	{
		if (s [index] == '#')
		{
			uint32 hex[6] = { 0 };
			int numChars = 0;

			for (int i = 6; --i >= 0;)
			{
				const int hexValue = CharacterFunctions::getHexDigitValue (s [++index]);

				if (hexValue >= 0)
					hex [numChars++] = (uint32) hexValue;
				else
					break;
			}

			if (numChars <= 3)
				return Colour ((uint8) (hex [0] * 0x11),
							   (uint8) (hex [1] * 0x11),
							   (uint8) (hex [2] * 0x11));
			else
				return Colour ((uint8) ((hex [0] << 4) + hex [1]),
							   (uint8) ((hex [2] << 4) + hex [3]),
							   (uint8) ((hex [4] << 4) + hex [5]));
		}
		else if (s [index] == 'r'
				  && s [index + 1] == 'g'
				  && s [index + 2] == 'b')
		{
			const int openBracket = s.indexOfChar (index, '(');
			const int closeBracket = s.indexOfChar (openBracket, ')');

			if (openBracket >= 3 && closeBracket > openBracket)
			{
				index = closeBracket;

				StringArray tokens;
				tokens.addTokens (s.substring (openBracket + 1, closeBracket), ",", "");
				tokens.trim();
				tokens.removeEmptyStrings();

				if (tokens[0].containsChar ('%'))
					return Colour ((uint8) roundToInt (2.55 * tokens[0].getDoubleValue()),
								   (uint8) roundToInt (2.55 * tokens[1].getDoubleValue()),
								   (uint8) roundToInt (2.55 * tokens[2].getDoubleValue()));
				else
					return Colour ((uint8) tokens[0].getIntValue(),
								   (uint8) tokens[1].getIntValue(),
								   (uint8) tokens[2].getIntValue());
			}
		}

		return Colours::findColourForName (s, defaultColour);
	}

	static const AffineTransform parseTransform (String t)
	{
		AffineTransform result;

		while (t.isNotEmpty())
		{
			StringArray tokens;
			tokens.addTokens (t.fromFirstOccurrenceOf ("(", false, false)
							   .upToFirstOccurrenceOf (")", false, false),
							  ", ", String::empty);

			tokens.removeEmptyStrings (true);

			float numbers [6];

			for (int i = 0; i < 6; ++i)
				numbers[i] = tokens[i].getFloatValue();

			AffineTransform trans;

			if (t.startsWithIgnoreCase ("matrix"))
			{
				trans = AffineTransform (numbers[0], numbers[2], numbers[4],
										 numbers[1], numbers[3], numbers[5]);
			}
			else if (t.startsWithIgnoreCase ("translate"))
			{
				jassert (tokens.size() == 2);
				trans = AffineTransform::translation (numbers[0], numbers[1]);
			}
			else if (t.startsWithIgnoreCase ("scale"))
			{
				if (tokens.size() == 1)
					trans = AffineTransform::scale (numbers[0], numbers[0]);
				else
					trans = AffineTransform::scale (numbers[0], numbers[1]);
			}
			else if (t.startsWithIgnoreCase ("rotate"))
			{
				if (tokens.size() != 3)
					trans = AffineTransform::rotation (numbers[0] / (180.0f / float_Pi));
				else
					trans = AffineTransform::rotation (numbers[0] / (180.0f / float_Pi),
													   numbers[1], numbers[2]);
			}
			else if (t.startsWithIgnoreCase ("skewX"))
			{
				trans = AffineTransform (1.0f, std::tan (numbers[0] * (float_Pi / 180.0f)), 0.0f,
										 0.0f, 1.0f, 0.0f);
			}
			else if (t.startsWithIgnoreCase ("skewY"))
			{
				trans = AffineTransform (1.0f, 0.0f, 0.0f,
										 std::tan (numbers[0] * (float_Pi / 180.0f)), 1.0f, 0.0f);
			}

			result = trans.followedBy (result);
			t = t.fromFirstOccurrenceOf (")", false, false).trimStart();
		}

		return result;
	}

	static void endpointToCentreParameters (const double x1, const double y1,
											const double x2, const double y2,
											const double angle,
											const bool largeArc, const bool sweep,
											double& rx, double& ry,
											double& centreX, double& centreY,
											double& startAngle, double& deltaAngle)
	{
		const double midX = (x1 - x2) * 0.5;
		const double midY = (y1 - y2) * 0.5;

		const double cosAngle = cos (angle);
		const double sinAngle = sin (angle);
		const double xp = cosAngle * midX + sinAngle * midY;
		const double yp = cosAngle * midY - sinAngle * midX;
		const double xp2 = xp * xp;
		const double yp2 = yp * yp;

		double rx2 = rx * rx;
		double ry2 = ry * ry;

		const double s = (xp2 / rx2) + (yp2 / ry2);
		double c;

		if (s <= 1.0)
		{
			c = std::sqrt (jmax (0.0, ((rx2 * ry2) - (rx2 * yp2) - (ry2 * xp2))
										 / (( rx2 * yp2) + (ry2 * xp2))));

			if (largeArc == sweep)
				c = -c;
		}
		else
		{
			const double s2 = std::sqrt (s);
			rx *= s2;
			ry *= s2;
			rx2 = rx * rx;
			ry2 = ry * ry;
			c = 0;
		}

		const double cpx = ((rx * yp) / ry) * c;
		const double cpy = ((-ry * xp) / rx) * c;

		centreX = ((x1 + x2) * 0.5) + (cosAngle * cpx) - (sinAngle * cpy);
		centreY = ((y1 + y2) * 0.5) + (sinAngle * cpx) + (cosAngle * cpy);

		const double ux = (xp - cpx) / rx;
		const double uy = (yp - cpy) / ry;
		const double vx = (-xp - cpx) / rx;
		const double vy = (-yp - cpy) / ry;

		const double length = juce_hypot (ux, uy);

		startAngle = acos (jlimit (-1.0, 1.0, ux / length));

		if (uy < 0)
			startAngle = -startAngle;

		startAngle += double_Pi * 0.5;

		deltaAngle = acos (jlimit (-1.0, 1.0, ((ux * vx) + (uy * vy))
												/ (length * juce_hypot (vx, vy))));

		if ((ux * vy) - (uy * vx) < 0)
			deltaAngle = -deltaAngle;

		if (sweep)
		{
			if (deltaAngle < 0)
				deltaAngle += double_Pi * 2.0;
		}
		else
		{
			if (deltaAngle > 0)
				deltaAngle -= double_Pi * 2.0;
		}

		deltaAngle = fmod (deltaAngle, double_Pi * 2.0);
	}

	static const XmlElement* findElementForId (const XmlElement* const parent, const String& id)
	{
		forEachXmlChildElement (*parent, e)
		{
			if (e->compareAttribute ("id", id))
				return e;

			const XmlElement* const found = findElementForId (e, id);

			if (found != nullptr)
				return found;
		}

		return nullptr;
	}

	SVGState& operator= (const SVGState&);
};

Drawable* Drawable::createFromSVG (const XmlElement& svgDocument)
{
	SVGState state (&svgDocument);
	return state.parseSVGElement (svgDocument);
}

/*** End of inlined file: juce_SVGParser.cpp ***/


/*** Start of inlined file: juce_DirectoryContentsDisplayComponent.cpp ***/
DirectoryContentsDisplayComponent::DirectoryContentsDisplayComponent (DirectoryContentsList& listToShow)
	: fileList (listToShow)
{
}

DirectoryContentsDisplayComponent::~DirectoryContentsDisplayComponent()
{
}

FileBrowserListener::~FileBrowserListener()
{
}

void DirectoryContentsDisplayComponent::addListener (FileBrowserListener* const listener)
{
	listeners.add (listener);
}

void DirectoryContentsDisplayComponent::removeListener (FileBrowserListener* const listener)
{
	listeners.remove (listener);
}

void DirectoryContentsDisplayComponent::sendSelectionChangeMessage()
{
	Component::BailOutChecker checker (dynamic_cast <Component*> (this));
	listeners.callChecked (checker, &FileBrowserListener::selectionChanged);
}

void DirectoryContentsDisplayComponent::sendMouseClickMessage (const File& file, const MouseEvent& e)
{
	if (fileList.getDirectory().exists())
	{
		Component::BailOutChecker checker (dynamic_cast <Component*> (this));
		listeners.callChecked (checker, &FileBrowserListener::fileClicked, file, e);
	}
}

void DirectoryContentsDisplayComponent::sendDoubleClickMessage (const File& file)
{
	if (fileList.getDirectory().exists())
	{
		Component::BailOutChecker checker (dynamic_cast <Component*> (this));
		listeners.callChecked (checker, &FileBrowserListener::fileDoubleClicked, file);
	}
}

/*** End of inlined file: juce_DirectoryContentsDisplayComponent.cpp ***/


/*** Start of inlined file: juce_DirectoryContentsList.cpp ***/
DirectoryContentsList::DirectoryContentsList (const FileFilter* const fileFilter_,
											  TimeSliceThread& thread_)
   : fileFilter (fileFilter_),
	 thread (thread_),
	 fileTypeFlags (File::ignoreHiddenFiles | File::findFiles),
	 shouldStop (true)
{
}

DirectoryContentsList::~DirectoryContentsList()
{
	stopSearching();
}

void DirectoryContentsList::setIgnoresHiddenFiles (const bool shouldIgnoreHiddenFiles)
{
	setTypeFlags (shouldIgnoreHiddenFiles ? (fileTypeFlags | File::ignoreHiddenFiles)
										  : (fileTypeFlags & ~File::ignoreHiddenFiles));
}

bool DirectoryContentsList::ignoresHiddenFiles() const
{
	return (fileTypeFlags & File::ignoreHiddenFiles) != 0;
}

const File& DirectoryContentsList::getDirectory() const
{
	return root;
}

void DirectoryContentsList::setDirectory (const File& directory,
										  const bool includeDirectories,
										  const bool includeFiles)
{
	jassert (includeDirectories || includeFiles); // you have to speciify at least one of these!

	if (directory != root)
	{
		clear();
		root = directory;

		// (this forces a refresh when setTypeFlags() is called, rather than triggering two refreshes)
		fileTypeFlags &= ~(File::findDirectories | File::findFiles);
	}

	int newFlags = fileTypeFlags;
	if (includeDirectories) newFlags |= File::findDirectories;  else newFlags &= ~File::findDirectories;
	if (includeFiles)       newFlags |= File::findFiles;        else newFlags &= ~File::findFiles;

	setTypeFlags (newFlags);
}

void DirectoryContentsList::setTypeFlags (const int newFlags)
{
	if (fileTypeFlags != newFlags)
	{
		fileTypeFlags = newFlags;
		refresh();
	}
}

void DirectoryContentsList::stopSearching()
{
	shouldStop = true;
	thread.removeTimeSliceClient (this);
	fileFindHandle = nullptr;
}

void DirectoryContentsList::clear()
{
	stopSearching();

	if (files.size() > 0)
	{
		files.clear();
		changed();
	}
}

void DirectoryContentsList::refresh()
{
	clear();

	if (root.isDirectory())
	{
		fileFindHandle = new DirectoryIterator (root, false, "*", fileTypeFlags);
		shouldStop = false;
		thread.addTimeSliceClient (this);
	}
}

int DirectoryContentsList::getNumFiles() const
{
	return files.size();
}

bool DirectoryContentsList::getFileInfo (const int index,
										 FileInfo& result) const
{
	const ScopedLock sl (fileListLock);
	const FileInfo* const info = files [index];

	if (info != nullptr)
	{
		result = *info;
		return true;
	}

	return false;
}

File DirectoryContentsList::getFile (const int index) const
{
	const ScopedLock sl (fileListLock);
	const FileInfo* const info = files [index];

	if (info != nullptr)
		return root.getChildFile (info->filename);

	return File::nonexistent;
}

bool DirectoryContentsList::contains (const File& targetFile) const
{
	const ScopedLock sl (fileListLock);

	for (int i = files.size(); --i >= 0;)
		if (root.getChildFile (files.getUnchecked(i)->filename) == targetFile)
			return true;

	return false;
}

bool DirectoryContentsList::isStillLoading() const
{
	return fileFindHandle != nullptr;
}

void DirectoryContentsList::changed()
{
	sendChangeMessage();
}

int DirectoryContentsList::useTimeSlice()
{
	const uint32 startTime = Time::getApproximateMillisecondCounter();
	bool hasChanged = false;

	for (int i = 100; --i >= 0;)
	{
		if (! checkNextFile (hasChanged))
		{
			if (hasChanged)
				changed();

			return 500;
		}

		if (shouldStop || (Time::getApproximateMillisecondCounter() > startTime + 150))
			break;
	}

	if (hasChanged)
		changed();

	return 0;
}

bool DirectoryContentsList::checkNextFile (bool& hasChanged)
{
	if (fileFindHandle != nullptr)
	{
		bool fileFoundIsDir, isHidden, isReadOnly;
		int64 fileSize;
		Time modTime, creationTime;

		if (fileFindHandle->next (&fileFoundIsDir, &isHidden, &fileSize,
								  &modTime, &creationTime, &isReadOnly))
		{
			if (addFile (fileFindHandle->getFile(), fileFoundIsDir,
						 fileSize, modTime, creationTime, isReadOnly))
			{
				hasChanged = true;
			}

			return true;
		}
		else
		{
			fileFindHandle = nullptr;
		}
	}

	return false;
}

int DirectoryContentsList::compareElements (const DirectoryContentsList::FileInfo* const first,
											const DirectoryContentsList::FileInfo* const second)
{
   #if JUCE_WINDOWS
	if (first->isDirectory != second->isDirectory)
		return first->isDirectory ? -1 : 1;
   #endif

	return first->filename.compareIgnoreCase (second->filename);
}

bool DirectoryContentsList::addFile (const File& file,
									 const bool isDir,
									 const int64 fileSize,
									 const Time& modTime,
									 const Time& creationTime,
									 const bool isReadOnly)
{
	if (fileFilter == nullptr
		 || ((! isDir) && fileFilter->isFileSuitable (file))
		 || (isDir && fileFilter->isDirectorySuitable (file)))
	{
		ScopedPointer <FileInfo> info (new FileInfo());

		info->filename = file.getFileName();
		info->fileSize = fileSize;
		info->modificationTime = modTime;
		info->creationTime = creationTime;
		info->isDirectory = isDir;
		info->isReadOnly = isReadOnly;

		const ScopedLock sl (fileListLock);

		for (int i = files.size(); --i >= 0;)
			if (files.getUnchecked(i)->filename == info->filename)
				return false;

		files.addSorted (*this, info.release());
		return true;
	}

	return false;
}

/*** End of inlined file: juce_DirectoryContentsList.cpp ***/


/*** Start of inlined file: juce_FileBrowserComponent.cpp ***/
FileBrowserComponent::FileBrowserComponent (int flags_,
											const File& initialFileOrDirectory,
											const FileFilter* fileFilter_,
											FilePreviewComponent* previewComp_)
   : FileFilter (String::empty),
	 fileFilter (fileFilter_),
	 flags (flags_),
	 previewComp (previewComp_),
	 currentPathBox ("path"),
	 fileLabel ("f", TRANS ("file:")),
	 thread ("Juce FileBrowser")
{
	// You need to specify one or other of the open/save flags..
	jassert ((flags & (saveMode | openMode)) != 0);
	jassert ((flags & (saveMode | openMode)) != (saveMode | openMode));

	// You need to specify at least one of these flags..
	jassert ((flags & (canSelectFiles | canSelectDirectories)) != 0);

	String filename;

	if (initialFileOrDirectory == File::nonexistent)
	{
		currentRoot = File::getCurrentWorkingDirectory();
	}
	else if (initialFileOrDirectory.isDirectory())
	{
		currentRoot = initialFileOrDirectory;
	}
	else
	{
		chosenFiles.add (initialFileOrDirectory);
		currentRoot = initialFileOrDirectory.getParentDirectory();
		filename = initialFileOrDirectory.getFileName();
	}

	fileList = new DirectoryContentsList (this, thread);

	if ((flags & useTreeView) != 0)
	{
		FileTreeComponent* const tree = new FileTreeComponent (*fileList);
		fileListComponent = tree;

		if ((flags & canSelectMultipleItems) != 0)
			tree->setMultiSelectEnabled (true);

		addAndMakeVisible (tree);
	}
	else
	{
		FileListComponent* const list = new FileListComponent (*fileList);
		fileListComponent = list;
		list->setOutlineThickness (1);

		if ((flags & canSelectMultipleItems) != 0)
			list->setMultipleSelectionEnabled (true);

		addAndMakeVisible (list);
	}

	fileListComponent->addListener (this);

	addAndMakeVisible (&currentPathBox);
	currentPathBox.setEditableText (true);
	resetRecentPaths();
	currentPathBox.addListener (this);

	addAndMakeVisible (&filenameBox);
	filenameBox.setMultiLine (false);
	filenameBox.setSelectAllWhenFocused (true);
	filenameBox.setText (filename, false);
	filenameBox.addListener (this);
	filenameBox.setReadOnly ((flags & (filenameBoxIsReadOnly | canSelectMultipleItems)) != 0);

	addAndMakeVisible (&fileLabel);
	fileLabel.attachToComponent (&filenameBox, true);

	addAndMakeVisible (goUpButton = getLookAndFeel().createFileBrowserGoUpButton());
	goUpButton->addListener (this);
	goUpButton->setTooltip (TRANS ("go up to parent directory"));

	if (previewComp != nullptr)
		addAndMakeVisible (previewComp);

	setRoot (currentRoot);

	thread.startThread (4);
}

FileBrowserComponent::~FileBrowserComponent()
{
	fileListComponent = nullptr;
	fileList = nullptr;
	thread.stopThread (10000);
}

void FileBrowserComponent::addListener (FileBrowserListener* const newListener)
{
	listeners.add (newListener);
}

void FileBrowserComponent::removeListener (FileBrowserListener* const listener)
{
	listeners.remove (listener);
}

bool FileBrowserComponent::isSaveMode() const noexcept
{
	return (flags & saveMode) != 0;
}

int FileBrowserComponent::getNumSelectedFiles() const noexcept
{
	if (chosenFiles.size() == 0 && currentFileIsValid())
		return 1;

	return chosenFiles.size();
}

File FileBrowserComponent::getSelectedFile (int index) const noexcept
{
	if ((flags & canSelectDirectories) != 0 && filenameBox.getText().isEmpty())
		return currentRoot;

	if (! filenameBox.isReadOnly())
		return currentRoot.getChildFile (filenameBox.getText());

	return chosenFiles[index];
}

bool FileBrowserComponent::currentFileIsValid() const
{
	if (isSaveMode())
		return ! getSelectedFile (0).isDirectory();
	else
		return getSelectedFile (0).exists();
}

File FileBrowserComponent::getHighlightedFile() const noexcept
{
	return fileListComponent->getSelectedFile (0);
}

void FileBrowserComponent::deselectAllFiles()
{
	fileListComponent->deselectAllFiles();
}

bool FileBrowserComponent::isFileSuitable (const File& file) const
{
	return (flags & canSelectFiles) != 0 && (fileFilter == nullptr || fileFilter->isFileSuitable (file));
}

bool FileBrowserComponent::isDirectorySuitable (const File&) const
{
	return true;
}

bool FileBrowserComponent::isFileOrDirSuitable (const File& f) const
{
	if (f.isDirectory())
		return (flags & canSelectDirectories) != 0
				&& (fileFilter == nullptr || fileFilter->isDirectorySuitable (f));

	return (flags & canSelectFiles) != 0 && f.exists()
			&& (fileFilter == nullptr || fileFilter->isFileSuitable (f));
}

const File& FileBrowserComponent::getRoot() const
{
	return currentRoot;
}

void FileBrowserComponent::setRoot (const File& newRootDirectory)
{
	bool callListeners = false;

	if (currentRoot != newRootDirectory)
	{
		callListeners = true;
		fileListComponent->scrollToTop();

		String path (newRootDirectory.getFullPathName());

		if (path.isEmpty())
			path = File::separatorString;

		StringArray rootNames, rootPaths;
		getRoots (rootNames, rootPaths);

		if (! rootPaths.contains (path, true))
		{
			bool alreadyListed = false;

			for (int i = currentPathBox.getNumItems(); --i >= 0;)
			{
				if (currentPathBox.getItemText (i).equalsIgnoreCase (path))
				{
					alreadyListed = true;
					break;
				}
			}

			if (! alreadyListed)
				currentPathBox.addItem (path, currentPathBox.getNumItems() + 2);
		}
	}

	currentRoot = newRootDirectory;
	fileList->setDirectory (currentRoot, true, true);

	String currentRootName (currentRoot.getFullPathName());
	if (currentRootName.isEmpty())
		currentRootName = File::separatorString;

	currentPathBox.setText (currentRootName, true);

	goUpButton->setEnabled (currentRoot.getParentDirectory().isDirectory()
							 && currentRoot.getParentDirectory() != currentRoot);

	if (callListeners)
	{
		Component::BailOutChecker checker (this);
		listeners.callChecked (checker, &FileBrowserListener::browserRootChanged, currentRoot);
	}
}

void FileBrowserComponent::setFileName (const String& newName)
{
	filenameBox.setText (newName, true);

	fileListComponent->setSelectedFile (currentRoot.getChildFile (newName));
}

void FileBrowserComponent::resetRecentPaths()
{
	currentPathBox.clear();

	StringArray rootNames, rootPaths;
	getRoots (rootNames, rootPaths);

	for (int i = 0; i < rootNames.size(); ++i)
	{
		if (rootNames[i].isEmpty())
			currentPathBox.addSeparator();
		else
			currentPathBox.addItem (rootNames[i], i + 1);
	}

	currentPathBox.addSeparator();
}

void FileBrowserComponent::goUp()
{
	setRoot (getRoot().getParentDirectory());
}

void FileBrowserComponent::refresh()
{
	fileList->refresh();
}

void FileBrowserComponent::setFileFilter (const FileFilter* const newFileFilter)
{
	if (fileFilter != newFileFilter)
	{
		fileFilter = newFileFilter;
		refresh();
	}
}

String FileBrowserComponent::getActionVerb() const
{
	return isSaveMode() ? TRANS("Save") : TRANS("Open");
}

void FileBrowserComponent::setFilenameBoxLabel (const String& name)
{
	fileLabel.setText (name, false);
}

FilePreviewComponent* FileBrowserComponent::getPreviewComponent() const noexcept
{
	return previewComp;
}

DirectoryContentsDisplayComponent* FileBrowserComponent::getDisplayComponent() const noexcept
{
	return fileListComponent;
}

void FileBrowserComponent::resized()
{
	getLookAndFeel()
		.layoutFileBrowserComponent (*this, fileListComponent, previewComp,
									 &currentPathBox, &filenameBox, goUpButton);
}

void FileBrowserComponent::sendListenerChangeMessage()
{
	Component::BailOutChecker checker (this);

	if (previewComp != nullptr)
		previewComp->selectedFileChanged (getSelectedFile (0));

	// You shouldn't delete the browser when the file gets changed!
	jassert (! checker.shouldBailOut());

	listeners.callChecked (checker, &FileBrowserListener::selectionChanged);
}

void FileBrowserComponent::selectionChanged()
{
	StringArray newFilenames;
	bool resetChosenFiles = true;

	for (int i = 0; i < fileListComponent->getNumSelectedFiles(); ++i)
	{
		const File f (fileListComponent->getSelectedFile (i));

		if (isFileOrDirSuitable (f))
		{
			if (resetChosenFiles)
			{
				chosenFiles.clear();
				resetChosenFiles = false;
			}

			chosenFiles.add (f);
			newFilenames.add (f.getRelativePathFrom (getRoot()));
		}
	}

	if (newFilenames.size() > 0)
		filenameBox.setText (newFilenames.joinIntoString (", "), false);

	sendListenerChangeMessage();
}

void FileBrowserComponent::fileClicked (const File& f, const MouseEvent& e)
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &FileBrowserListener::fileClicked, f, e);
}

void FileBrowserComponent::fileDoubleClicked (const File& f)
{
	if (f.isDirectory())
	{
		setRoot (f);

		if ((flags & canSelectDirectories) != 0)
			filenameBox.setText (String::empty);
	}
	else
	{
		Component::BailOutChecker checker (this);
		listeners.callChecked (checker, &FileBrowserListener::fileDoubleClicked, f);
	}
}

void FileBrowserComponent::browserRootChanged (const File&) {}

bool FileBrowserComponent::keyPressed (const KeyPress& key)
{
	(void) key;

#if JUCE_LINUX || JUCE_WINDOWS
	if (key.getModifiers().isCommandDown()
		 && (key.getKeyCode() == 'H' || key.getKeyCode() == 'h'))
	{
		fileList->setIgnoresHiddenFiles (! fileList->ignoresHiddenFiles());
		fileList->refresh();
		return true;
	}
#endif

	return false;
}

void FileBrowserComponent::textEditorTextChanged (TextEditor&)
{
	sendListenerChangeMessage();
}

void FileBrowserComponent::textEditorReturnKeyPressed (TextEditor&)
{
	if (filenameBox.getText().containsChar (File::separator))
	{
		const File f (currentRoot.getChildFile (filenameBox.getText()));

		if (f.isDirectory())
		{
			setRoot (f);
			chosenFiles.clear();
			filenameBox.setText (String::empty);
		}
		else
		{
			setRoot (f.getParentDirectory());
			chosenFiles.clear();
			chosenFiles.add (f);
			filenameBox.setText (f.getFileName());
		}
	}
	else
	{
		fileDoubleClicked (getSelectedFile (0));
	}
}

void FileBrowserComponent::textEditorEscapeKeyPressed (TextEditor&)
{
}

void FileBrowserComponent::textEditorFocusLost (TextEditor&)
{
	if (! isSaveMode())
		selectionChanged();
}

void FileBrowserComponent::buttonClicked (Button*)
{
	goUp();
}

void FileBrowserComponent::comboBoxChanged (ComboBox*)
{
	const String newText (currentPathBox.getText().trim().unquoted());

	if (newText.isNotEmpty())
	{
		const int index = currentPathBox.getSelectedId() - 1;

		StringArray rootNames, rootPaths;
		getRoots (rootNames, rootPaths);

		if (rootPaths [index].isNotEmpty())
		{
			setRoot (File (rootPaths [index]));
		}
		else
		{
			File f (newText);

			for (;;)
			{
				if (f.isDirectory())
				{
					setRoot (f);
					break;
				}

				if (f.getParentDirectory() == f)
					break;

				f = f.getParentDirectory();
			}
		}
	}
}

void FileBrowserComponent::getRoots (StringArray& rootNames, StringArray& rootPaths)
{
   #if JUCE_WINDOWS
	Array<File> roots;
	File::findFileSystemRoots (roots);
	rootPaths.clear();

	for (int i = 0; i < roots.size(); ++i)
	{
		const File& drive = roots.getReference(i);

		String name (drive.getFullPathName());
		rootPaths.add (name);

		if (drive.isOnHardDisk())
		{
			String volume (drive.getVolumeLabel());

			if (volume.isEmpty())
				volume = TRANS("Hard Drive");

			name << " [" << volume << ']';
		}
		else if (drive.isOnCDRomDrive())
		{
			name << TRANS(" [CD/DVD drive]");
		}

		rootNames.add (name);
	}

	rootPaths.add (String::empty);
	rootNames.add (String::empty);

	rootPaths.add (File::getSpecialLocation (File::userDocumentsDirectory).getFullPathName());
	rootNames.add ("Documents");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");

   #elif JUCE_MAC
	rootPaths.add (File::getSpecialLocation (File::userHomeDirectory).getFullPathName());
	rootNames.add ("Home folder");
	rootPaths.add (File::getSpecialLocation (File::userDocumentsDirectory).getFullPathName());
	rootNames.add ("Documents");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");

	rootPaths.add (String::empty);
	rootNames.add (String::empty);

	Array <File> volumes;
	File vol ("/Volumes");
	vol.findChildFiles (volumes, File::findDirectories, false);

	for (int i = 0; i < volumes.size(); ++i)
	{
		const File& volume = volumes.getReference(i);

		if (volume.isDirectory() && ! volume.getFileName().startsWithChar ('.'))
		{
			rootPaths.add (volume.getFullPathName());
			rootNames.add (volume.getFileName());
		}
	}

   #else
	rootPaths.add ("/");
	rootNames.add ("/");
	rootPaths.add (File::getSpecialLocation (File::userHomeDirectory).getFullPathName());
	rootNames.add ("Home folder");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");
   #endif
}

/*** End of inlined file: juce_FileBrowserComponent.cpp ***/


/*** Start of inlined file: juce_FileChooser.cpp ***/
FileChooser::FileChooser (const String& chooserBoxTitle,
						  const File& currentFileOrDirectory,
						  const String& fileFilters,
						  const bool useNativeDialogBox_)
	: title (chooserBoxTitle),
	  filters (fileFilters),
	  startingFile (currentFileOrDirectory),
	  useNativeDialogBox (useNativeDialogBox_)
{
	if (useNativeDialogBox)
	{
		static bool canUseNativeBox = isPlatformDialogAvailable();
		if (! canUseNativeBox)
			useNativeDialogBox = false;
	}

	if (! fileFilters.containsNonWhitespaceChars())
		filters = "*";
}

FileChooser::~FileChooser()
{
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool FileChooser::browseForFileToOpen (FilePreviewComponent* previewComponent)
{
	return showDialog (false, true, false, false, false, previewComponent);
}

bool FileChooser::browseForMultipleFilesToOpen (FilePreviewComponent* previewComponent)
{
	return showDialog (false, true, false, false, true, previewComponent);
}

bool FileChooser::browseForMultipleFilesOrDirectories (FilePreviewComponent* previewComponent)
{
	return showDialog (true, true, false, false, true, previewComponent);
}

bool FileChooser::browseForFileToSave (const bool warnAboutOverwritingExistingFiles)
{
	return showDialog (false, true, true, warnAboutOverwritingExistingFiles, false, nullptr);
}

bool FileChooser::browseForDirectory()
{
	return showDialog (true, false, false, false, false, nullptr);
}

bool FileChooser::showDialog (const bool selectsDirectories,
							  const bool selectsFiles,
							  const bool isSave,
							  const bool warnAboutOverwritingExistingFiles,
							  const bool selectMultipleFiles,
							  FilePreviewComponent* const previewComponent)
{
	WeakReference<Component> previouslyFocused (Component::getCurrentlyFocusedComponent());

	results.clear();

	// the preview component needs to be the right size before you pass it in here..
	jassert (previewComponent == nullptr || (previewComponent->getWidth() > 10
											   && previewComponent->getHeight() > 10));

   #if JUCE_WINDOWS
	if (useNativeDialogBox && ! (selectsFiles && selectsDirectories))
   #elif JUCE_MAC || JUCE_LINUX
	if (useNativeDialogBox && (previewComponent == nullptr))
   #else
	if (false)
   #endif
	{
		showPlatformDialog (results, title, startingFile, filters,
							selectsDirectories, selectsFiles, isSave,
							warnAboutOverwritingExistingFiles,
							selectMultipleFiles,
							previewComponent);
	}
	else
	{
		WildcardFileFilter wildcard (selectsFiles ? filters : String::empty,
									 selectsDirectories ? "*" : String::empty,
									 String::empty);

		int flags = isSave ? FileBrowserComponent::saveMode
						   : FileBrowserComponent::openMode;

		if (selectsFiles)
			flags |= FileBrowserComponent::canSelectFiles;

		if (selectsDirectories)
		{
			flags |= FileBrowserComponent::canSelectDirectories;

			if (! isSave)
				flags |= FileBrowserComponent::filenameBoxIsReadOnly;
		}

		if (selectMultipleFiles)
			flags |= FileBrowserComponent::canSelectMultipleItems;

		FileBrowserComponent browserComponent (flags, startingFile, &wildcard, previewComponent);

		FileChooserDialogBox box (title, String::empty,
								  browserComponent,
								  warnAboutOverwritingExistingFiles,
								  browserComponent.findColour (AlertWindow::backgroundColourId));

		if (box.show())
		{
			for (int i = 0; i < browserComponent.getNumSelectedFiles(); ++i)
				results.add (browserComponent.getSelectedFile (i));
		}
	}

	if (previouslyFocused != nullptr)
		previouslyFocused->grabKeyboardFocus();

	return results.size() > 0;
}
#endif

File FileChooser::getResult() const
{
	// if you've used a multiple-file select, you should use the getResults() method
	// to retrieve all the files that were chosen.
	jassert (results.size() <= 1);

	return results.getFirst();
}

const Array<File>& FileChooser::getResults() const
{
	return results;
}

FilePreviewComponent::FilePreviewComponent()
{
}

FilePreviewComponent::~FilePreviewComponent()
{
}

/*** End of inlined file: juce_FileChooser.cpp ***/


/*** Start of inlined file: juce_FileChooserDialogBox.cpp ***/
class FileChooserDialogBox::ContentComponent  : public Component
{
public:

	ContentComponent (const String& name, const String& instructions_, FileBrowserComponent& chooserComponent_)
		: Component (name),
		  chooserComponent (chooserComponent_),
		  okButton (chooserComponent_.getActionVerb()),
		  cancelButton (TRANS ("Cancel")),
		  newFolderButton (TRANS ("New Folder")),
		  instructions (instructions_)
	{
		addAndMakeVisible (&chooserComponent);

		addAndMakeVisible (&okButton);
		okButton.addShortcut (KeyPress::returnKey);

		addAndMakeVisible (&cancelButton);
		cancelButton.addShortcut (KeyPress::escapeKey);

		addChildComponent (&newFolderButton);

		setInterceptsMouseClicks (false, true);
	}

	void paint (Graphics& g)
	{
		g.setColour (getLookAndFeel().findColour (FileChooserDialogBox::titleTextColourId));
		text.draw (g);
	}

	void resized()
	{
		const int buttonHeight = 26;

		Rectangle<int> area (getLocalBounds());

		getLookAndFeel().createFileChooserHeaderText (getName(), instructions, text, getWidth());
		const Rectangle<float> bb (text.getBoundingBox (0, text.getNumGlyphs(), false));
		area.removeFromTop (roundToInt (bb.getBottom()) + 10);

		chooserComponent.setBounds (area.removeFromTop (area.getHeight() - buttonHeight - 20));
		Rectangle<int> buttonArea (area.reduced (16, 10));

		okButton.changeWidthToFitText (buttonHeight);
		okButton.setBounds (buttonArea.removeFromRight (okButton.getWidth() + 16));

		buttonArea.removeFromRight (16);

		cancelButton.changeWidthToFitText (buttonHeight);
		cancelButton.setBounds (buttonArea.removeFromRight (cancelButton.getWidth()));

		newFolderButton.changeWidthToFitText (buttonHeight);
		newFolderButton.setBounds (buttonArea.removeFromLeft (newFolderButton.getWidth()));
	}

	FileBrowserComponent& chooserComponent;
	TextButton okButton, cancelButton, newFolderButton;

private:
	String instructions;
	GlyphArrangement text;
};

FileChooserDialogBox::FileChooserDialogBox (const String& name,
											const String& instructions,
											FileBrowserComponent& chooserComponent,
											const bool warnAboutOverwritingExistingFiles_,
											const Colour& backgroundColour)
	: ResizableWindow (name, backgroundColour, true),
	  warnAboutOverwritingExistingFiles (warnAboutOverwritingExistingFiles_)
{
	content = new ContentComponent (name, instructions, chooserComponent);
	setContentOwned (content, false);

	setResizable (true, true);
	setResizeLimits (300, 300, 1200, 1000);

	content->okButton.addListener (this);
	content->cancelButton.addListener (this);
	content->newFolderButton.addListener (this);
	content->chooserComponent.addListener (this);

	FileChooserDialogBox::selectionChanged();
}

FileChooserDialogBox::~FileChooserDialogBox()
{
	content->chooserComponent.removeListener (this);
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool FileChooserDialogBox::show (int w, int h)
{
	return showAt (-1, -1, w, h);
}

bool FileChooserDialogBox::showAt (int x, int y, int w, int h)
{
	if (w <= 0)
	{
		Component* const previewComp = content->chooserComponent.getPreviewComponent();

		if (previewComp != nullptr)
			w = 400 + previewComp->getWidth();
		else
			w = 600;
	}

	if (h <= 0)
		h = 500;

	if (x < 0 || y < 0)
		centreWithSize (w, h);
	else
		setBounds (x, y, w, h);

	const bool ok = (runModalLoop() != 0);
	setVisible (false);
	return ok;
}
#endif

void FileChooserDialogBox::centreWithDefaultSize (Component* componentToCentreAround)
{
	Component* const previewComp = content->chooserComponent.getPreviewComponent();

	centreAroundComponent (componentToCentreAround,
						   previewComp != nullptr ? 400 + previewComp->getWidth() : 600,
						   500);
}

void FileChooserDialogBox::buttonClicked (Button* button)
{
	if (button == &(content->okButton))
	{
		okButtonPressed();
	}
	else if (button == &(content->cancelButton))
	{
		closeButtonPressed();
	}
	else if (button == &(content->newFolderButton))
	{
		createNewFolder();
	}
}

void FileChooserDialogBox::closeButtonPressed()
{
	setVisible (false);
}

void FileChooserDialogBox::selectionChanged()
{
	content->okButton.setEnabled (content->chooserComponent.currentFileIsValid());

	content->newFolderButton.setVisible (content->chooserComponent.isSaveMode()
										  && content->chooserComponent.getRoot().isDirectory());
}

void FileChooserDialogBox::fileDoubleClicked (const File&)
{
	selectionChanged();
	content->okButton.triggerClick();
}

void FileChooserDialogBox::fileClicked (const File&, const MouseEvent&) {}
void FileChooserDialogBox::browserRootChanged (const File&) {}

void FileChooserDialogBox::okToOverwriteFileCallback (int result, FileChooserDialogBox* box)
{
	if (result != 0 && box != nullptr)
		box->exitModalState (1);
}

void FileChooserDialogBox::okButtonPressed()
{
	if (warnAboutOverwritingExistingFiles
		 && content->chooserComponent.isSaveMode()
		 && content->chooserComponent.getSelectedFile(0).exists())
	{
		AlertWindow::showOkCancelBox (AlertWindow::WarningIcon,
										 TRANS("File already exists"),
										 TRANS("There's already a file called:")
										   + "\n\n" + content->chooserComponent.getSelectedFile(0).getFullPathName()
										   + "\n\n" + TRANS("Are you sure you want to overwrite it?"),
										 TRANS("overwrite"),
										 TRANS("cancel"),
									  this,
									  ModalCallbackFunction::forComponent (okToOverwriteFileCallback, this));
	}
	else
	{
		exitModalState (1);
	}
}

void FileChooserDialogBox::createNewFolderCallback (int result, FileChooserDialogBox* box,
													Component::SafePointer<AlertWindow> alert)
{
	if (result != 0 && alert != nullptr && box != nullptr)
	{
		alert->setVisible (false);
		box->createNewFolderConfirmed (alert->getTextEditorContents ("name"));
	}
}

void FileChooserDialogBox::createNewFolder()
{
	File parent (content->chooserComponent.getRoot());

	if (parent.isDirectory())
	{
		AlertWindow* aw = new AlertWindow (TRANS("New Folder"),
										   TRANS("Please enter the name for the folder"),
										   AlertWindow::NoIcon, this);

		aw->addTextEditor ("name", String::empty, String::empty, false);
		aw->addButton (TRANS("ok"), 1, KeyPress::returnKey);
		aw->addButton (TRANS("cancel"), KeyPress::escapeKey);

		aw->enterModalState (true,
							 ModalCallbackFunction::forComponent (createNewFolderCallback, this,
																  Component::SafePointer<AlertWindow> (aw)),
							 true);
	}
}

void FileChooserDialogBox::createNewFolderConfirmed (const String& nameFromDialog)
{
	const String name (File::createLegalFileName (nameFromDialog));

	if (! name.isEmpty())
	{
		const File parent (content->chooserComponent.getRoot());

		if (! parent.getChildFile (name).createDirectory())
		{
			AlertWindow::showMessageBoxAsync (AlertWindow::WarningIcon,
											  TRANS ("New Folder"),
											  TRANS ("Couldn't create the folder!"));
		}

		content->chooserComponent.refresh();
	}
}

/*** End of inlined file: juce_FileChooserDialogBox.cpp ***/


/*** Start of inlined file: juce_FileFilter.cpp ***/
FileFilter::FileFilter (const String& filterDescription)
	: description (filterDescription)
{
}

FileFilter::~FileFilter()
{
}

const String& FileFilter::getDescription() const noexcept
{
	return description;
}

/*** End of inlined file: juce_FileFilter.cpp ***/


/*** Start of inlined file: juce_FileListComponent.cpp ***/
Image juce_createIconForFile (const File& file);

FileListComponent::FileListComponent (DirectoryContentsList& listToShow)
	: ListBox (String::empty, nullptr),
	  DirectoryContentsDisplayComponent (listToShow)
{
	setModel (this);
	fileList.addChangeListener (this);
}

FileListComponent::~FileListComponent()
{
	fileList.removeChangeListener (this);
}

int FileListComponent::getNumSelectedFiles() const
{
	return getNumSelectedRows();
}

File FileListComponent::getSelectedFile (int index) const
{
	return fileList.getFile (getSelectedRow (index));
}

void FileListComponent::deselectAllFiles()
{
	deselectAllRows();
}

void FileListComponent::scrollToTop()
{
	getVerticalScrollBar()->setCurrentRangeStart (0);
}

void FileListComponent::setSelectedFile (const File& f)
{
	for (int i = fileList.getNumFiles(); --i >= 0;)
	{
		if (fileList.getFile(i) == f)
		{
			selectRow (i);
			return;
		}
	}

	deselectAllRows();
}

void FileListComponent::changeListenerCallback (ChangeBroadcaster*)
{
	updateContent();

	if (lastDirectory != fileList.getDirectory())
	{
		lastDirectory = fileList.getDirectory();
		deselectAllRows();
	}
}

class FileListItemComponent  : public Component,
							   public TimeSliceClient,
							   public AsyncUpdater
{
public:
	FileListItemComponent (FileListComponent& owner_, TimeSliceThread& thread_)
		: owner (owner_), thread (thread_), index (0), highlighted (false)
	{
	}

	~FileListItemComponent()
	{
		thread.removeTimeSliceClient (this);
	}

	void paint (Graphics& g)
	{
		getLookAndFeel().drawFileBrowserRow (g, getWidth(), getHeight(),
											 file.getFileName(),
											 &icon, fileSize, modTime,
											 isDirectory, highlighted,
											 index, owner);
	}

	void mouseDown (const MouseEvent& e)
	{
		owner.selectRowsBasedOnModifierKeys (index, e.mods, false);
		owner.sendMouseClickMessage (file, e);
	}

	void mouseDoubleClick (const MouseEvent&)
	{
		owner.sendDoubleClickMessage (file);
	}

	void update (const File& root,
				 const DirectoryContentsList::FileInfo* const fileInfo,
				 const int index_,
				 const bool highlighted_)
	{
		thread.removeTimeSliceClient (this);

		if (highlighted_ != highlighted || index_ != index)
		{
			index = index_;
			highlighted = highlighted_;
			repaint();
		}

		File newFile;
		String newFileSize, newModTime;

		if (fileInfo != nullptr)
		{
			newFile = root.getChildFile (fileInfo->filename);
			newFileSize = File::descriptionOfSizeInBytes (fileInfo->fileSize);
			newModTime = fileInfo->modificationTime.formatted ("%d %b '%y %H:%M");
		}

		if (newFile != file
			 || fileSize != newFileSize
			 || modTime != newModTime)
		{
			file = newFile;
			fileSize = newFileSize;
			modTime = newModTime;
			icon = Image::null;
			isDirectory = fileInfo != nullptr && fileInfo->isDirectory;

			repaint();
		}

		if (file != File::nonexistent && icon.isNull() && ! isDirectory)
		{
			updateIcon (true);

			if (! icon.isValid())
				thread.addTimeSliceClient (this);
		}
	}

	int useTimeSlice()
	{
		updateIcon (false);
		return -1;
	}

	void handleAsyncUpdate()
	{
		repaint();
	}

private:

	FileListComponent& owner;
	TimeSliceThread& thread;
	File file;
	String fileSize, modTime;
	Image icon;
	int index;
	bool highlighted, isDirectory;

	void updateIcon (const bool onlyUpdateIfCached)
	{
		if (icon.isNull())
		{
			const int hashCode = (file.getFullPathName() + "_iconCacheSalt").hashCode();
			Image im (ImageCache::getFromHashCode (hashCode));

			if (im.isNull() && ! onlyUpdateIfCached)
			{
				im = juce_createIconForFile (file);

				if (im.isValid())
					ImageCache::addImageToCache (im, hashCode);
			}

			if (im.isValid())
			{
				icon = im;
				triggerAsyncUpdate();
			}
		}
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileListItemComponent);
};

int FileListComponent::getNumRows()
{
	return fileList.getNumFiles();
}

void FileListComponent::paintListBoxItem (int, Graphics&, int, int, bool)
{
}

Component* FileListComponent::refreshComponentForRow (int row, bool isSelected, Component* existingComponentToUpdate)
{
	jassert (existingComponentToUpdate == nullptr || dynamic_cast <FileListItemComponent*> (existingComponentToUpdate) != nullptr);

	FileListItemComponent* comp = static_cast <FileListItemComponent*> (existingComponentToUpdate);

	if (comp == nullptr)
		comp = new FileListItemComponent (*this, fileList.getTimeSliceThread());

	DirectoryContentsList::FileInfo fileInfo;
	comp->update (fileList.getDirectory(),
				  fileList.getFileInfo (row, fileInfo) ? &fileInfo : nullptr,
				  row, isSelected);

	return comp;
}

void FileListComponent::selectedRowsChanged (int /*lastRowSelected*/)
{
	sendSelectionChangeMessage();
}

void FileListComponent::deleteKeyPressed (int /*currentSelectedRow*/)
{
}

void FileListComponent::returnKeyPressed (int currentSelectedRow)
{
	sendDoubleClickMessage (fileList.getFile (currentSelectedRow));
}

/*** End of inlined file: juce_FileListComponent.cpp ***/


/*** Start of inlined file: juce_FilenameComponent.cpp ***/
FilenameComponent::FilenameComponent (const String& name,
									  const File& currentFile,
									  const bool canEditFilename,
									  const bool isDirectory,
									  const bool isForSaving,
									  const String& fileBrowserWildcard,
									  const String& enforcedSuffix_,
									  const String& textWhenNothingSelected)
	: Component (name),
	  maxRecentFiles (30),
	  isDir (isDirectory),
	  isSaving (isForSaving),
	  isFileDragOver (false),
	  wildcard (fileBrowserWildcard),
	  enforcedSuffix (enforcedSuffix_)
{
	addAndMakeVisible (&filenameBox);
	filenameBox.setEditableText (canEditFilename);
	filenameBox.addListener (this);
	filenameBox.setTextWhenNothingSelected (textWhenNothingSelected);
	filenameBox.setTextWhenNoChoicesAvailable (TRANS ("(no recently selected files)"));

	setBrowseButtonText ("...");

	setCurrentFile (currentFile, true);
}

FilenameComponent::~FilenameComponent()
{
}

void FilenameComponent::paintOverChildren (Graphics& g)
{
	if (isFileDragOver)
	{
		g.setColour (Colours::red.withAlpha (0.2f));
		g.drawRect (0, 0, getWidth(), getHeight(), 3);
	}
}

void FilenameComponent::resized()
{
	getLookAndFeel().layoutFilenameComponent (*this, &filenameBox, browseButton);
}

void FilenameComponent::setBrowseButtonText (const String& newBrowseButtonText)
{
	browseButtonText = newBrowseButtonText;
	lookAndFeelChanged();
}

void FilenameComponent::lookAndFeelChanged()
{
	browseButton = nullptr;

	addAndMakeVisible (browseButton = getLookAndFeel().createFilenameComponentBrowseButton (browseButtonText));
	browseButton->setConnectedEdges (Button::ConnectedOnLeft);
	resized();

	browseButton->addListener (this);
}

void FilenameComponent::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	filenameBox.setTooltip (newTooltip);
}

void FilenameComponent::setDefaultBrowseTarget (const File& newDefaultDirectory)
{
	defaultBrowseFile = newDefaultDirectory;
}

void FilenameComponent::buttonClicked (Button*)
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	FileChooser fc (TRANS("Choose a new file"),
					getCurrentFile() == File::nonexistent ? defaultBrowseFile
														  : getCurrentFile(),
					wildcard);

	if (isDir ? fc.browseForDirectory()
			  : (isSaving ? fc.browseForFileToSave (false)
						  : fc.browseForFileToOpen()))
	{
		setCurrentFile (fc.getResult(), true);
	}
   #else
	jassertfalse; // needs rewriting to deal with non-modal environments
   #endif
}

void FilenameComponent::comboBoxChanged (ComboBox*)
{
	setCurrentFile (getCurrentFile(), true);
}

bool FilenameComponent::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void FilenameComponent::filesDropped (const StringArray& filenames, int, int)
{
	isFileDragOver = false;
	repaint();

	const File f (filenames[0]);

	if (f.exists() && (f.isDirectory() == isDir))
		setCurrentFile (f, true);
}

void FilenameComponent::fileDragEnter (const StringArray&, int, int)
{
	isFileDragOver = true;
	repaint();
}

void FilenameComponent::fileDragExit (const StringArray&)
{
	isFileDragOver = false;
	repaint();
}

File FilenameComponent::getCurrentFile() const
{
	File f (filenameBox.getText());

	if (enforcedSuffix.isNotEmpty())
		f = f.withFileExtension (enforcedSuffix);

	return f;
}

void FilenameComponent::setCurrentFile (File newFile,
										const bool addToRecentlyUsedList,
										const bool sendChangeNotification)
{
	if (enforcedSuffix.isNotEmpty())
		newFile = newFile.withFileExtension (enforcedSuffix);

	if (newFile.getFullPathName() != lastFilename)
	{
		lastFilename = newFile.getFullPathName();

		if (addToRecentlyUsedList)
			addRecentlyUsedFile (newFile);

		filenameBox.setText (lastFilename, true);

		if (sendChangeNotification)
			triggerAsyncUpdate();
	}
}

void FilenameComponent::setFilenameIsEditable (const bool shouldBeEditable)
{
	filenameBox.setEditableText (shouldBeEditable);
}

StringArray FilenameComponent::getRecentlyUsedFilenames() const
{
	StringArray names;

	for (int i = 0; i < filenameBox.getNumItems(); ++i)
		names.add (filenameBox.getItemText (i));

	return names;
}

void FilenameComponent::setRecentlyUsedFilenames (const StringArray& filenames)
{
	if (filenames != getRecentlyUsedFilenames())
	{
		filenameBox.clear();

		for (int i = 0; i < jmin (filenames.size(), maxRecentFiles); ++i)
			filenameBox.addItem (filenames[i], i + 1);
	}
}

void FilenameComponent::setMaxNumberOfRecentFiles (const int newMaximum)
{
	maxRecentFiles = jmax (1, newMaximum);

	setRecentlyUsedFilenames (getRecentlyUsedFilenames());
}

void FilenameComponent::addRecentlyUsedFile (const File& file)
{
	StringArray files (getRecentlyUsedFilenames());

	if (file.getFullPathName().isNotEmpty())
	{
		files.removeString (file.getFullPathName(), true);
		files.insert (0, file.getFullPathName());

		setRecentlyUsedFilenames (files);
	}
}

void FilenameComponent::addListener (FilenameComponentListener* const listener)
{
	listeners.add (listener);
}

void FilenameComponent::removeListener (FilenameComponentListener* const listener)
{
	listeners.remove (listener);
}

void FilenameComponent::handleAsyncUpdate()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &FilenameComponentListener::filenameComponentChanged, this);
}

/*** End of inlined file: juce_FilenameComponent.cpp ***/


/*** Start of inlined file: juce_FileSearchPathListComponent.cpp ***/
FileSearchPathListComponent::FileSearchPathListComponent()
	: addButton ("+"),
	  removeButton ("-"),
	  changeButton (TRANS ("change...")),
	  upButton (String::empty, DrawableButton::ImageOnButtonBackground),
	  downButton (String::empty, DrawableButton::ImageOnButtonBackground)
{
	listBox.setModel (this);
	addAndMakeVisible (&listBox);
	listBox.setColour (ListBox::backgroundColourId, Colours::black.withAlpha (0.02f));
	listBox.setColour (ListBox::outlineColourId, Colours::black.withAlpha (0.1f));
	listBox.setOutlineThickness (1);

	addAndMakeVisible (&addButton);
	addButton.addListener (this);
	addButton.setConnectedEdges (Button::ConnectedOnLeft | Button::ConnectedOnRight | Button::ConnectedOnBottom | Button::ConnectedOnTop);

	addAndMakeVisible (&removeButton);
	removeButton.addListener (this);
	removeButton.setConnectedEdges (Button::ConnectedOnLeft | Button::ConnectedOnRight | Button::ConnectedOnBottom | Button::ConnectedOnTop);

	addAndMakeVisible (&changeButton);
	changeButton.addListener (this);

	addAndMakeVisible (&upButton);
	upButton.addListener (this);

	{
		Path arrowPath;
		arrowPath.addArrow (Line<float> (50.0f, 100.0f, 50.0f, 0.0f), 40.0f, 100.0f, 50.0f);
		DrawablePath arrowImage;
		arrowImage.setFill (Colours::black.withAlpha (0.4f));
		arrowImage.setPath (arrowPath);

		upButton.setImages (&arrowImage);
	}

	addAndMakeVisible (&downButton);
	downButton.addListener (this);

	{
		Path arrowPath;
		arrowPath.addArrow (Line<float> (50.0f, 0.0f, 50.0f, 100.0f), 40.0f, 100.0f, 50.0f);
		DrawablePath arrowImage;
		arrowImage.setFill (Colours::black.withAlpha (0.4f));
		arrowImage.setPath (arrowPath);

		downButton.setImages (&arrowImage);
	}

	updateButtons();
}

FileSearchPathListComponent::~FileSearchPathListComponent()
{
}

void FileSearchPathListComponent::updateButtons()
{
	const bool anythingSelected = listBox.getNumSelectedRows() > 0;

	removeButton.setEnabled (anythingSelected);
	changeButton.setEnabled (anythingSelected);
	upButton.setEnabled (anythingSelected);
	downButton.setEnabled (anythingSelected);
}

void FileSearchPathListComponent::changed()
{
	listBox.updateContent();
	listBox.repaint();
	updateButtons();
}

void FileSearchPathListComponent::setPath (const FileSearchPath& newPath)
{
	if (newPath.toString() != path.toString())
	{
		path = newPath;
		changed();
	}
}

void FileSearchPathListComponent::setDefaultBrowseTarget (const File& newDefaultDirectory)
{
	defaultBrowseTarget = newDefaultDirectory;
}

int FileSearchPathListComponent::getNumRows()
{
	return path.getNumPaths();
}

void FileSearchPathListComponent::paintListBoxItem (int rowNumber, Graphics& g, int width, int height, bool rowIsSelected)
{
	if (rowIsSelected)
		g.fillAll (findColour (TextEditor::highlightColourId));

	g.setColour (findColour (ListBox::textColourId));
	Font f (height * 0.7f);
	f.setHorizontalScale (0.9f);
	g.setFont (f);

	g.drawText (path [rowNumber].getFullPathName(),
				4, 0, width - 6, height,
				Justification::centredLeft, true);
}

void FileSearchPathListComponent::deleteKeyPressed (int row)
{
	if (isPositiveAndBelow (row, path.getNumPaths()))
	{
		path.remove (row);
		changed();
	}
}

void FileSearchPathListComponent::returnKeyPressed (int row)
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	FileChooser chooser (TRANS("Change folder..."), path [row], "*");

	if (chooser.browseForDirectory())
	{
		path.remove (row);
		path.add (chooser.getResult(), row);
		changed();
	}
   #endif
}

void FileSearchPathListComponent::listBoxItemDoubleClicked (int row, const MouseEvent&)
{
	returnKeyPressed (row);
}

void FileSearchPathListComponent::selectedRowsChanged (int)
{
	updateButtons();
}

void FileSearchPathListComponent::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));
}

void FileSearchPathListComponent::resized()
{
	const int buttonH = 22;
	const int buttonY = getHeight() - buttonH - 4;
	listBox.setBounds (2, 2, getWidth() - 4, buttonY - 5);

	addButton.setBounds (2, buttonY, buttonH, buttonH);
	removeButton.setBounds (addButton.getRight(), buttonY, buttonH, buttonH);

	changeButton.changeWidthToFitText (buttonH);
	downButton.setSize (buttonH * 2, buttonH);
	upButton.setSize (buttonH * 2, buttonH);

	downButton.setTopRightPosition (getWidth() - 2, buttonY);
	upButton.setTopRightPosition (downButton.getX() - 4, buttonY);
	changeButton.setTopRightPosition (upButton.getX() - 8, buttonY);
}

bool FileSearchPathListComponent::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void FileSearchPathListComponent::filesDropped (const StringArray& filenames, int, int mouseY)
{
	for (int i = filenames.size(); --i >= 0;)
	{
		const File f (filenames[i]);

		if (f.isDirectory())
		{
			const int row = listBox.getRowContainingPosition (0, mouseY - listBox.getY());
			path.add (f, row);
			changed();
		}
	}
}

void FileSearchPathListComponent::buttonClicked (Button* button)
{
	const int currentRow = listBox.getSelectedRow();

	if (button == &removeButton)
	{
		deleteKeyPressed (currentRow);
	}
	else if (button == &addButton)
	{
		File start (defaultBrowseTarget);

		if (start == File::nonexistent)
			start = path [0];

		if (start == File::nonexistent)
			start = File::getCurrentWorkingDirectory();

	   #if JUCE_MODAL_LOOPS_PERMITTED
		FileChooser chooser (TRANS("Add a folder..."), start, "*");

		if (chooser.browseForDirectory())
			path.add (chooser.getResult(), currentRow);
	   #else
		jassertfalse; // needs rewriting to deal with non-modal environments
	   #endif
	}
	else if (button == &changeButton)
	{
		returnKeyPressed (currentRow);
	}
	else if (button == &upButton)
	{
		if (currentRow > 0 && currentRow < path.getNumPaths())
		{
			const File f (path[currentRow]);
			path.remove (currentRow);
			path.add (f, currentRow - 1);
			listBox.selectRow (currentRow - 1);
		}
	}
	else if (button == &downButton)
	{
		if (currentRow >= 0 && currentRow < path.getNumPaths() - 1)
		{
			const File f (path[currentRow]);
			path.remove (currentRow);
			path.add (f, currentRow + 1);
			listBox.selectRow (currentRow + 1);
		}
	}

	changed();
}

/*** End of inlined file: juce_FileSearchPathListComponent.cpp ***/


/*** Start of inlined file: juce_FileTreeComponent.cpp ***/
Image juce_createIconForFile (const File& file);

class FileListTreeItem   : public TreeViewItem,
						   public TimeSliceClient,
						   public AsyncUpdater,
						   public ChangeListener
{
public:
	FileListTreeItem (FileTreeComponent& owner_,
					  DirectoryContentsList* const parentContentsList_,
					  const int indexInContentsList_,
					  const File& file_,
					  TimeSliceThread& thread_)
		: file (file_),
		  owner (owner_),
		  parentContentsList (parentContentsList_),
		  indexInContentsList (indexInContentsList_),
		  subContentsList (nullptr, false),
		  thread (thread_)
	{
		DirectoryContentsList::FileInfo fileInfo;

		if (parentContentsList_ != nullptr
			 && parentContentsList_->getFileInfo (indexInContentsList_, fileInfo))
		{
			fileSize = File::descriptionOfSizeInBytes (fileInfo.fileSize);
			modTime = fileInfo.modificationTime.formatted ("%d %b '%y %H:%M");
			isDirectory = fileInfo.isDirectory;
		}
		else
		{
			isDirectory = true;
		}
	}

	~FileListTreeItem()
	{
		thread.removeTimeSliceClient (this);
		clearSubItems();
	}

	bool mightContainSubItems()                 { return isDirectory; }
	String getUniqueName() const                { return file.getFullPathName(); }
	int getItemHeight() const                   { return 22; }

	var getDragSourceDescription()              { return owner.getDragAndDropDescription(); }

	void itemOpennessChanged (bool isNowOpen)
	{
		if (isNowOpen)
		{
			clearSubItems();

			isDirectory = file.isDirectory();

			if (isDirectory)
			{
				if (subContentsList == nullptr)
				{
					jassert (parentContentsList != nullptr);

					DirectoryContentsList* const l = new DirectoryContentsList (parentContentsList->getFilter(), thread);
					l->setDirectory (file, true, true);

					setSubContentsList (l, true);
				}

				changeListenerCallback (nullptr);
			}
		}
	}

	void setSubContentsList (DirectoryContentsList* newList, const bool canDeleteList)
	{
		OptionalScopedPointer<DirectoryContentsList> newPointer (newList, canDeleteList);
		subContentsList = newPointer;
		newList->addChangeListener (this);
	}

	void changeListenerCallback (ChangeBroadcaster*)
	{
		clearSubItems();

		if (isOpen() && subContentsList != nullptr)
		{
			for (int i = 0; i < subContentsList->getNumFiles(); ++i)
			{
				FileListTreeItem* const item
					= new FileListTreeItem (owner, subContentsList, i, subContentsList->getFile(i), thread);

				addSubItem (item);
			}
		}
	}

	void paintItem (Graphics& g, int width, int height)
	{
		if (file != File::nonexistent)
		{
			updateIcon (true);

			if (icon.isNull())
				thread.addTimeSliceClient (this);
		}

		owner.getLookAndFeel().drawFileBrowserRow (g, width, height,
												   file.getFileName(),
												   &icon, fileSize, modTime,
												   isDirectory, isSelected(),
												   indexInContentsList, owner);
	}

	void itemClicked (const MouseEvent& e)
	{
		owner.sendMouseClickMessage (file, e);
	}

	void itemDoubleClicked (const MouseEvent& e)
	{
		TreeViewItem::itemDoubleClicked (e);

		owner.sendDoubleClickMessage (file);
	}

	void itemSelectionChanged (bool)
	{
		owner.sendSelectionChangeMessage();
	}

	int useTimeSlice()
	{
		updateIcon (false);
		return -1;
	}

	void handleAsyncUpdate()
	{
		owner.repaint();
	}

	const File file;

private:
	FileTreeComponent& owner;
	DirectoryContentsList* parentContentsList;
	int indexInContentsList;
	OptionalScopedPointer<DirectoryContentsList> subContentsList;
	bool isDirectory;
	TimeSliceThread& thread;
	Image icon;
	String fileSize, modTime;

	void updateIcon (const bool onlyUpdateIfCached)
	{
		if (icon.isNull())
		{
			const int hashCode = (file.getFullPathName() + "_iconCacheSalt").hashCode();
			Image im (ImageCache::getFromHashCode (hashCode));

			if (im.isNull() && ! onlyUpdateIfCached)
			{
				im = juce_createIconForFile (file);

				if (im.isValid())
					ImageCache::addImageToCache (im, hashCode);
			}

			if (im.isValid())
			{
				icon = im;
				triggerAsyncUpdate();
			}
		}
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileListTreeItem);
};

FileTreeComponent::FileTreeComponent (DirectoryContentsList& listToShow)
	: DirectoryContentsDisplayComponent (listToShow)
{
	setRootItemVisible (false);
	refresh();
}

FileTreeComponent::~FileTreeComponent()
{
	deleteRootItem();
}

void FileTreeComponent::refresh()
{
	deleteRootItem();

	FileListTreeItem* const root
		= new FileListTreeItem (*this, nullptr, 0, fileList.getDirectory(),
								fileList.getTimeSliceThread());

	root->setSubContentsList (&fileList, false);
	setRootItem (root);
}

File FileTreeComponent::getSelectedFile (const int index) const
{
	const FileListTreeItem* const item = dynamic_cast <const FileListTreeItem*> (getSelectedItem (index));

	return item != nullptr ? item->file
						   : File::nonexistent;
}

void FileTreeComponent::deselectAllFiles()
{
	clearSelectedItems();
}

void FileTreeComponent::scrollToTop()
{
	getViewport()->getVerticalScrollBar()->setCurrentRangeStart (0);
}

void FileTreeComponent::setDragAndDropDescription (const String& description)
{
	dragAndDropDescription = description;
}

void FileTreeComponent::setSelectedFile (const File& target)
{
	for (int i = getNumSelectedItems(); --i >= 0;)
	{
		FileListTreeItem* t = dynamic_cast <FileListTreeItem*> (getSelectedItem (i));

		if (t != nullptr && t->file == target)
		{
			t->setSelected (true, true);
			return;
		}
	}

	clearSelectedItems();
}

/*** End of inlined file: juce_FileTreeComponent.cpp ***/


/*** Start of inlined file: juce_ImagePreviewComponent.cpp ***/
ImagePreviewComponent::ImagePreviewComponent()
{
}

ImagePreviewComponent::~ImagePreviewComponent()
{
}

void ImagePreviewComponent::getThumbSize (int& w, int& h) const
{
	const int availableW = proportionOfWidth (0.97f);
	const int availableH = getHeight() - 13 * 4;

	const double scale = jmin (1.0,
							   availableW / (double) w,
							   availableH / (double) h);

	w = roundToInt (scale * w);
	h = roundToInt (scale * h);
}

void ImagePreviewComponent::selectedFileChanged (const File& file)
{
	if (fileToLoad != file)
	{
		fileToLoad = file;
		startTimer (100);
	}
}

void ImagePreviewComponent::timerCallback()
{
	stopTimer();

	currentThumbnail = Image::null;
	currentDetails = String::empty;
	repaint();

	ScopedPointer <FileInputStream> in (fileToLoad.createInputStream());

	if (in != nullptr)
	{
		ImageFileFormat* const format = ImageFileFormat::findImageFormatForStream (*in);

		if (format != nullptr)
		{
			currentThumbnail = format->decodeImage (*in);

			if (currentThumbnail.isValid())
			{
				int w = currentThumbnail.getWidth();
				int h = currentThumbnail.getHeight();

				currentDetails
					<< fileToLoad.getFileName() << "\n"
					<< format->getFormatName() << "\n"
					<< w << " x " << h << " pixels\n"
					<< File::descriptionOfSizeInBytes (fileToLoad.getSize());

				getThumbSize (w, h);

				currentThumbnail = currentThumbnail.rescaled (w, h);
			}
		}
	}
}

void ImagePreviewComponent::paint (Graphics& g)
{
	if (currentThumbnail.isValid())
	{
		g.setFont (13.0f);

		int w = currentThumbnail.getWidth();
		int h = currentThumbnail.getHeight();
		getThumbSize (w, h);

		const int numLines = 4;
		const int totalH = 13 * numLines + h + 4;
		const int y = (getHeight() - totalH) / 2;

		g.drawImageWithin (currentThumbnail,
						   (getWidth() - w) / 2, y, w, h,
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize,
						   false);

		g.drawFittedText (currentDetails,
						  0, y + h + 4, getWidth(), 100,
						  Justification::centredTop, numLines);
	}
}

/*** End of inlined file: juce_ImagePreviewComponent.cpp ***/


/*** Start of inlined file: juce_WildcardFileFilter.cpp ***/
WildcardFileFilter::WildcardFileFilter (const String& fileWildcardPatterns,
										const String& directoryWildcardPatterns,
										const String& description_)
	: FileFilter (description_.isEmpty() ? fileWildcardPatterns
										 : (description_ + " (" + fileWildcardPatterns + ")"))
{
	parse (fileWildcardPatterns, fileWildcards);
	parse (directoryWildcardPatterns, directoryWildcards);
}

WildcardFileFilter::~WildcardFileFilter()
{
}

bool WildcardFileFilter::isFileSuitable (const File& file) const
{
	return match (file, fileWildcards);
}

bool WildcardFileFilter::isDirectorySuitable (const File& file) const
{
	return match (file, directoryWildcards);
}

void WildcardFileFilter::parse (const String& pattern, StringArray& result)
{
	result.addTokens (pattern.toLowerCase(), ";,", "\"'");

	result.trim();
	result.removeEmptyStrings();

	// special case for *.*, because people use it to mean "any file", but it
	// would actually ignore files with no extension.
	for (int i = result.size(); --i >= 0;)
		if (result[i] == "*.*")
			result.set (i, "*");
}

bool WildcardFileFilter::match (const File& file, const StringArray& wildcards)
{
	const String filename (file.getFileName());

	for (int i = wildcards.size(); --i >= 0;)
		if (filename.matchesWildcard (wildcards[i], true))
			return true;

	return false;
}

/*** End of inlined file: juce_WildcardFileFilter.cpp ***/


/*** Start of inlined file: juce_ComponentAnimator.cpp ***/
class ComponentAnimator::AnimationTask
{
public:
	AnimationTask (Component* const comp)
		: component (comp)
	{
	}

	void reset (const Rectangle<int>& finalBounds,
				float finalAlpha,
				int millisecondsToSpendMoving,
				bool useProxyComponent,
				double startSpeed_, double endSpeed_)
	{
		msElapsed = 0;
		msTotal = jmax (1, millisecondsToSpendMoving);
		lastProgress = 0;
		destination = finalBounds;
		destAlpha = finalAlpha;

		isMoving = (finalBounds != component->getBounds());
		isChangingAlpha = (finalAlpha != component->getAlpha());

		left = component->getX();
		top = component->getY();
		right = component->getRight();
		bottom = component->getBottom();
		alpha = component->getAlpha();

		const double invTotalDistance = 4.0 / (startSpeed_ + endSpeed_ + 2.0);
		startSpeed = jmax (0.0, startSpeed_ * invTotalDistance);
		midSpeed = invTotalDistance;
		endSpeed = jmax (0.0, endSpeed_ * invTotalDistance);

		if (useProxyComponent)
			proxy = new ProxyComponent (*component);
		else
			proxy = nullptr;

		component->setVisible (! useProxyComponent);
	}

	bool useTimeslice (const int elapsed)
	{
		Component* const c = proxy != nullptr ? static_cast <Component*> (proxy)
											  : static_cast <Component*> (component);

		if (c != nullptr)
		{
			msElapsed += elapsed;
			double newProgress = msElapsed / (double) msTotal;

			if (newProgress >= 0 && newProgress < 1.0)
			{
				newProgress = timeToDistance (newProgress);
				const double delta = (newProgress - lastProgress) / (1.0 - lastProgress);
				jassert (newProgress >= lastProgress);
				lastProgress = newProgress;

				if (delta < 1.0)
				{
					bool stillBusy = false;

					if (isMoving)
					{
						left   += (destination.getX()      - left)   * delta;
						top    += (destination.getY()      - top)    * delta;
						right  += (destination.getRight()  - right)  * delta;
						bottom += (destination.getBottom() - bottom) * delta;

						const Rectangle<int> newBounds (roundToInt (left),
														roundToInt (top),
														roundToInt (right - left),
														roundToInt (bottom - top));

						if (newBounds != destination)
						{
							c->setBounds (newBounds);
							stillBusy = true;
						}
					}

					if (isChangingAlpha)
					{
						alpha += (destAlpha - alpha) * delta;
						c->setAlpha ((float) alpha);
						stillBusy = true;
					}

					if (stillBusy)
						return true;
				}
			}
		}

		moveToFinalDestination();
		return false;
	}

	void moveToFinalDestination()
	{
		if (component != nullptr)
		{
			component->setAlpha ((float) destAlpha);
			component->setBounds (destination);

			if (proxy != nullptr)
				component->setVisible (destAlpha > 0);
		}
	}

	class ProxyComponent  : public Component
	{
	public:
		ProxyComponent (Component& component)
			: image (component.createComponentSnapshot (component.getLocalBounds()))
		{
			setBounds (component.getBounds());
			setTransform (component.getTransform());
			setAlpha (component.getAlpha());
			setInterceptsMouseClicks (false, false);

			Component* const parent = component.getParentComponent();

			if (parent != nullptr)
				parent->addAndMakeVisible (this);
			else if (component.isOnDesktop() && component.getPeer() != nullptr)
				addToDesktop (component.getPeer()->getStyleFlags() | ComponentPeer::windowIgnoresKeyPresses);
			else
				jassertfalse; // seem to be trying to animate a component that's not visible..

			setVisible (true);
			toBehind (&component);
		}

		void paint (Graphics& g)
		{
			g.setOpacity (1.0f);
			g.drawImage (image, 0, 0, getWidth(), getHeight(),
						 0, 0, image.getWidth(), image.getHeight());
		}

	private:
		Image image;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ProxyComponent);
	};

	WeakReference<Component> component;
	ScopedPointer<Component> proxy;

	Rectangle<int> destination;
	double destAlpha;

	int msElapsed, msTotal;
	double startSpeed, midSpeed, endSpeed, lastProgress;
	double left, top, right, bottom, alpha;
	bool isMoving, isChangingAlpha;

private:
	double timeToDistance (const double time) const noexcept
	{
		return (time < 0.5) ? time * (startSpeed + time * (midSpeed - startSpeed))
							: 0.5 * (startSpeed + 0.5 * (midSpeed - startSpeed))
								+ (time - 0.5) * (midSpeed + (time - 0.5) * (endSpeed - midSpeed));
	}
};

ComponentAnimator::ComponentAnimator()
	: lastTime (0)
{
}

ComponentAnimator::~ComponentAnimator()
{
}

ComponentAnimator::AnimationTask* ComponentAnimator::findTaskFor (Component* const component) const noexcept
{
	for (int i = tasks.size(); --i >= 0;)
		if (component == tasks.getUnchecked(i)->component.get())
			return tasks.getUnchecked(i);

	return nullptr;
}

void ComponentAnimator::animateComponent (Component* const component,
										  const Rectangle<int>& finalBounds,
										  const float finalAlpha,
										  const int millisecondsToSpendMoving,
										  const bool useProxyComponent,
										  const double startSpeed,
										  const double endSpeed)
{
	// the speeds must be 0 or greater!
	jassert (startSpeed >= 0 && endSpeed >= 0)

	if (component != nullptr)
	{
		AnimationTask* at = findTaskFor (component);

		if (at == nullptr)
		{
			at = new AnimationTask (component);
			tasks.add (at);
			sendChangeMessage();
		}

		at->reset (finalBounds, finalAlpha, millisecondsToSpendMoving,
				   useProxyComponent, startSpeed, endSpeed);

		if (! isTimerRunning())
		{
			lastTime = Time::getMillisecondCounter();
			startTimer (1000 / 50);
		}
	}
}

void ComponentAnimator::fadeOut (Component* component, int millisecondsToTake)
{
	if (component != nullptr)
	{
		if (component->isShowing() && millisecondsToTake > 0)
			animateComponent (component, component->getBounds(), 0.0f, millisecondsToTake, true, 1.0, 1.0);

		component->setVisible (false);
	}
}

void ComponentAnimator::fadeIn (Component* component, int millisecondsToTake)
{
	if (component != nullptr && ! (component->isVisible() && component->getAlpha() == 1.0f))
	{
		component->setAlpha (0.0f);
		component->setVisible (true);
		animateComponent (component, component->getBounds(), 1.0f, millisecondsToTake, false, 1.0, 1.0);
	}
}

void ComponentAnimator::cancelAllAnimations (const bool moveComponentsToTheirFinalPositions)
{
	if (tasks.size() > 0)
	{
		if (moveComponentsToTheirFinalPositions)
			for (int i = tasks.size(); --i >= 0;)
				tasks.getUnchecked(i)->moveToFinalDestination();

		tasks.clear();
		sendChangeMessage();
	}
}

void ComponentAnimator::cancelAnimation (Component* const component,
										 const bool moveComponentToItsFinalPosition)
{
	AnimationTask* const at = findTaskFor (component);

	if (at != nullptr)
	{
		if (moveComponentToItsFinalPosition)
			at->moveToFinalDestination();

		tasks.removeObject (at);
		sendChangeMessage();
	}
}

Rectangle<int> ComponentAnimator::getComponentDestination (Component* const component)
{
	jassert (component != nullptr);
	AnimationTask* const at = findTaskFor (component);

	if (at != nullptr)
		return at->destination;

	return component->getBounds();
}

bool ComponentAnimator::isAnimating (Component* component) const noexcept
{
	return findTaskFor (component) != nullptr;
}

bool ComponentAnimator::isAnimating() const noexcept
{
	return tasks.size() != 0;
}

void ComponentAnimator::timerCallback()
{
	const uint32 timeNow = Time::getMillisecondCounter();

	if (lastTime == 0 || lastTime == timeNow)
		lastTime = timeNow;

	const int elapsed = (int) (timeNow - lastTime);

	for (int i = tasks.size(); --i >= 0;)
	{
		if (! tasks.getUnchecked(i)->useTimeslice (elapsed))
		{
			tasks.remove (i);
			sendChangeMessage();
		}
	}

	lastTime = timeNow;

	if (tasks.size() == 0)
		stopTimer();
}

/*** End of inlined file: juce_ComponentAnimator.cpp ***/


/*** Start of inlined file: juce_ComponentBoundsConstrainer.cpp ***/
ComponentBoundsConstrainer::ComponentBoundsConstrainer() noexcept
	: minW (0),
	  maxW (0x3fffffff),
	  minH (0),
	  maxH (0x3fffffff),
	  minOffTop (0),
	  minOffLeft (0),
	  minOffBottom (0),
	  minOffRight (0),
	  aspectRatio (0.0)
{
}

ComponentBoundsConstrainer::~ComponentBoundsConstrainer()
{
}

void ComponentBoundsConstrainer::setMinimumWidth (const int minimumWidth) noexcept
{
	minW = minimumWidth;
}

void ComponentBoundsConstrainer::setMaximumWidth (const int maximumWidth) noexcept
{
	maxW = maximumWidth;
}

void ComponentBoundsConstrainer::setMinimumHeight (const int minimumHeight) noexcept
{
	minH = minimumHeight;
}

void ComponentBoundsConstrainer::setMaximumHeight (const int maximumHeight) noexcept
{
	maxH = maximumHeight;
}

void ComponentBoundsConstrainer::setMinimumSize (const int minimumWidth, const int minimumHeight) noexcept
{
	jassert (maxW >= minimumWidth);
	jassert (maxH >= minimumHeight);
	jassert (minimumWidth > 0 && minimumHeight > 0);

	minW = minimumWidth;
	minH = minimumHeight;

	if (minW > maxW)
		maxW = minW;

	if (minH > maxH)
		maxH = minH;
}

void ComponentBoundsConstrainer::setMaximumSize (const int maximumWidth, const int maximumHeight) noexcept
{
	jassert (maximumWidth >= minW);
	jassert (maximumHeight >= minH);
	jassert (maximumWidth > 0 && maximumHeight > 0);

	maxW = jmax (minW, maximumWidth);
	maxH = jmax (minH, maximumHeight);
}

void ComponentBoundsConstrainer::setSizeLimits (const int minimumWidth,
												const int minimumHeight,
												const int maximumWidth,
												const int maximumHeight) noexcept
{
	jassert (maximumWidth >= minimumWidth);
	jassert (maximumHeight >= minimumHeight);
	jassert (maximumWidth > 0 && maximumHeight > 0);
	jassert (minimumWidth > 0 && minimumHeight > 0);

	minW = jmax (0, minimumWidth);
	minH = jmax (0, minimumHeight);
	maxW = jmax (minW, maximumWidth);
	maxH = jmax (minH, maximumHeight);
}

void ComponentBoundsConstrainer::setMinimumOnscreenAmounts (const int minimumWhenOffTheTop,
															const int minimumWhenOffTheLeft,
															const int minimumWhenOffTheBottom,
															const int minimumWhenOffTheRight) noexcept
{
	minOffTop = minimumWhenOffTheTop;
	minOffLeft = minimumWhenOffTheLeft;
	minOffBottom = minimumWhenOffTheBottom;
	minOffRight = minimumWhenOffTheRight;
}

void ComponentBoundsConstrainer::setFixedAspectRatio (const double widthOverHeight) noexcept
{
	aspectRatio = jmax (0.0, widthOverHeight);
}

double ComponentBoundsConstrainer::getFixedAspectRatio() const noexcept
{
	return aspectRatio;
}

void ComponentBoundsConstrainer::setBoundsForComponent (Component* const component,
														const Rectangle<int>& targetBounds,
														const bool isStretchingTop,
														const bool isStretchingLeft,
														const bool isStretchingBottom,
														const bool isStretchingRight)
{
	jassert (component != nullptr);

	Rectangle<int> limits, bounds (targetBounds);
	BorderSize<int> border;

	Component* const parent = component->getParentComponent();

	if (parent == nullptr)
	{
		ComponentPeer* peer = component->getPeer();
		if (peer != nullptr)
			border = peer->getFrameSize();

		limits = Desktop::getInstance().getDisplays().getDisplayContaining (bounds.getCentre()).userArea;
	}
	else
	{
		limits.setSize (parent->getWidth(), parent->getHeight());
	}

	border.addTo (bounds);

	checkBounds (bounds,
				 border.addedTo (component->getBounds()), limits,
				 isStretchingTop, isStretchingLeft,
				 isStretchingBottom, isStretchingRight);

	border.subtractFrom (bounds);

	applyBoundsToComponent (component, bounds);
}

void ComponentBoundsConstrainer::checkComponentBounds (Component* component)
{
	setBoundsForComponent (component, component->getBounds(),
						   false, false, false, false);
}

void ComponentBoundsConstrainer::applyBoundsToComponent (Component* component,
														 const Rectangle<int>& bounds)
{
	Component::Positioner* const positioner = component->getPositioner();

	if (positioner != nullptr)
		positioner->applyNewBounds (bounds);
	else
		component->setBounds (bounds);
}

void ComponentBoundsConstrainer::resizeStart()
{
}

void ComponentBoundsConstrainer::resizeEnd()
{
}

void ComponentBoundsConstrainer::checkBounds (Rectangle<int>& bounds,
											  const Rectangle<int>& old,
											  const Rectangle<int>& limits,
											  const bool isStretchingTop,
											  const bool isStretchingLeft,
											  const bool isStretchingBottom,
											  const bool isStretchingRight)
{
	if (isStretchingLeft)
		bounds.setLeft (jlimit (old.getRight() - maxW, old.getRight() - minW, bounds.getX()));
	else
		bounds.setWidth (jlimit (minW, maxW, bounds.getWidth()));

	if (isStretchingTop)
		bounds.setTop (jlimit (old.getBottom() - maxH, old.getBottom() - minH, bounds.getY()));
	else
		bounds.setHeight (jlimit (minH, maxH, bounds.getHeight()));

	if (bounds.isEmpty())
		return;

	if (minOffTop > 0)
	{
		const int limit = limits.getY() + jmin (minOffTop - bounds.getHeight(), 0);

		if (bounds.getY() < limit)
		{
			if (isStretchingTop)
				bounds.setTop (limits.getY());
			else
				bounds.setY (limit);
		}
	}

	if (minOffLeft > 0)
	{
		const int limit = limits.getX() + jmin (minOffLeft - bounds.getWidth(), 0);

		if (bounds.getX() < limit)
		{
			if (isStretchingLeft)
				bounds.setLeft (limits.getX());
			else
				bounds.setX (limit);
		}
	}

	if (minOffBottom > 0)
	{
		const int limit = limits.getBottom() - jmin (minOffBottom, bounds.getHeight());

		if (bounds.getY() > limit)
		{
			if (isStretchingBottom)
				bounds.setBottom (limits.getBottom());
			else
				bounds.setY (limit);
		}
	}

	if (minOffRight > 0)
	{
		const int limit = limits.getRight() - jmin (minOffRight, bounds.getWidth());

		if (bounds.getX() > limit)
		{
			if (isStretchingRight)
				bounds.setRight (limits.getRight());
			else
				bounds.setX (limit);
		}
	}

	// constrain the aspect ratio if one has been specified..
	if (aspectRatio > 0.0)
	{
		bool adjustWidth;

		if ((isStretchingTop || isStretchingBottom) && ! (isStretchingLeft || isStretchingRight))
		{
			adjustWidth = true;
		}
		else if ((isStretchingLeft || isStretchingRight) && ! (isStretchingTop || isStretchingBottom))
		{
			adjustWidth = false;
		}
		else
		{
			const double oldRatio = (old.getHeight() > 0) ? std::abs (old.getWidth() / (double) old.getHeight()) : 0.0;
			const double newRatio = std::abs (bounds.getWidth() / (double) bounds.getHeight());

			adjustWidth = (oldRatio > newRatio);
		}

		if (adjustWidth)
		{
			bounds.setWidth (roundToInt (bounds.getHeight() * aspectRatio));

			if (bounds.getWidth() > maxW || bounds.getWidth() < minW)
			{
				bounds.setWidth (jlimit (minW, maxW, bounds.getWidth()));
				bounds.setHeight (roundToInt (bounds.getWidth() / aspectRatio));
			}
		}
		else
		{
			bounds.setHeight (roundToInt (bounds.getWidth() / aspectRatio));

			if (bounds.getHeight() > maxH || bounds.getHeight() < minH)
			{
				bounds.setHeight (jlimit (minH, maxH, bounds.getHeight()));
				bounds.setWidth (roundToInt (bounds.getHeight() * aspectRatio));
			}
		}

		if ((isStretchingTop || isStretchingBottom) && ! (isStretchingLeft || isStretchingRight))
		{
			bounds.setX (old.getX() + (old.getWidth() - bounds.getWidth()) / 2);
		}
		else if ((isStretchingLeft || isStretchingRight) && ! (isStretchingTop || isStretchingBottom))
		{
			bounds.setY (old.getY() + (old.getHeight() - bounds.getHeight()) / 2);
		}
		else
		{
			if (isStretchingLeft)
				bounds.setX (old.getRight() - bounds.getWidth());

			if (isStretchingTop)
				bounds.setY (old.getBottom() - bounds.getHeight());
		}
	}

	jassert (! bounds.isEmpty());
}

/*** End of inlined file: juce_ComponentBoundsConstrainer.cpp ***/


/*** Start of inlined file: juce_ComponentBuilder.cpp ***/
namespace ComponentBuilderHelpers
{
	static String getStateId (const ValueTree& state)
	{
		return state [ComponentBuilder::idProperty].toString();
	}

	static Component* removeComponentWithID (OwnedArray<Component>& components, const String& compId)
	{
		jassert (compId.isNotEmpty());

		for (int i = components.size(); --i >= 0;)
		{
			Component* const c = components.getUnchecked (i);

			if (c->getComponentID() == compId)
				return components.removeAndReturn (i);
		}

		return nullptr;
	}

	static Component* findComponentWithID (Component& c, const String& compId)
	{
		jassert (compId.isNotEmpty());
		if (c.getComponentID() == compId)
			return &c;

		for (int i = c.getNumChildComponents(); --i >= 0;)
		{
			Component* const child = findComponentWithID (*c.getChildComponent (i), compId);

			if (child != nullptr)
				return child;
		}

		return nullptr;
	}

	static Component* createNewComponent (ComponentBuilder::TypeHandler& type,
										  const ValueTree& state, Component* parent)
	{
		Component* const c = type.addNewComponentFromState (state, parent);
		jassert (c != nullptr && c->getParentComponent() == parent);
		c->setComponentID (getStateId (state));
		return c;
	}

	static void updateComponent (ComponentBuilder& builder, const ValueTree& state)
	{
		Component* topLevelComp = builder.getManagedComponent();

		if (topLevelComp != nullptr)
		{
			ComponentBuilder::TypeHandler* const type = builder.getHandlerForState (state);
			const String uid (getStateId (state));

			if (type == nullptr || uid.isEmpty())
			{
				// ..handle the case where a child of the actual state node has changed.
				if (state.getParent().isValid())
					updateComponent (builder, state.getParent());
			}
			else
			{
				Component* const changedComp = findComponentWithID (*topLevelComp, uid);

				if (changedComp != nullptr)
					type->updateComponentFromState (changedComp, state);
			}
		}
	}

	static void updateComponentColours (Component& component, const ValueTree& colourState)
	{
		NamedValueSet& properties = component.getProperties();

		for (int i = properties.size(); --i >= 0;)
		{
			const Identifier name (properties.getName (i));

			if (name.toString().startsWith ("jcclr_"))
			{
				const String colourName (name.toString().substring (6));

				if (colourState [colourName].isVoid())
					component.removeColour (colourName.getHexValue32());
			}
		}

		for (int i = 0; i < colourState.getNumProperties(); ++i)
		{
			const Identifier colourName (colourState.getPropertyName (i));
			const String colour (colourState [colourName].toString());

			if (colour.isNotEmpty())
				component.setColour (colourName.toString().getHexValue32(), Colour::fromString (colour));
		}
	}

	template <class ComponentClass>
	class StandardTypeHandler  : public ComponentBuilder::TypeHandler
	{
	public:
		StandardTypeHandler()  : ComponentBuilder::TypeHandler (ComponentClass::Ids::tagType)
		{}

		Component* addNewComponentFromState (const ValueTree& state, Component* parent)
		{
			ComponentClass* const c = new ComponentClass();

			if (parent != nullptr)
				parent->addAndMakeVisible (c);

			updateComponentFromState (c, state);
			return c;
		}

		void updateComponentFromState (Component* component, const ValueTree& state)
		{
			ComponentClass* const c = dynamic_cast <ComponentClass*> (component);
			jassert (c != nullptr);

			c->setComponentID (state [ComponentBuilder::idProperty]);
			c->refreshFromValueTree (state, *this->getBuilder());
		}
	};
}

const Identifier ComponentBuilder::idProperty ("id");
const Identifier ComponentBuilder::positionID ("position");

ComponentBuilder::ComponentBuilder()
	: imageProvider (nullptr)
{
}

ComponentBuilder::ComponentBuilder (const ValueTree& state_)
	: state (state_), imageProvider (nullptr)
{
	state.addListener (this);
}

ComponentBuilder::~ComponentBuilder()
{
	state.removeListener (this);

   #if JUCE_DEBUG
	// Don't delete the managed component!! The builder owns that component, and will delete
	// it automatically when it gets deleted.
	jassert (componentRef.get() == static_cast <Component*> (component));
   #endif
}

Component* ComponentBuilder::getManagedComponent()
{
	if (component == nullptr)
	{
		component = createComponent();

	   #if JUCE_DEBUG
		componentRef = component;
	   #endif
	}

	return component;
}

Component* ComponentBuilder::createComponent()
{
	jassert (types.size() > 0);  // You need to register all the necessary types before you can load a component!

	TypeHandler* const type = getHandlerForState (state);
	jassert (type != nullptr); // trying to create a component from an unknown type of ValueTree

	return type != nullptr ? ComponentBuilderHelpers::createNewComponent (*type, state, nullptr) : nullptr;
}

void ComponentBuilder::registerTypeHandler (ComponentBuilder::TypeHandler* const type)
{
	jassert (type != nullptr);

	// Don't try to move your types around! Once a type has been added to a builder, the
	// builder owns it, and you should leave it alone!
	jassert (type->builder == nullptr);

	types.add (type);
	type->builder = this;
}

ComponentBuilder::TypeHandler* ComponentBuilder::getHandlerForState (const ValueTree& s) const
{
	const Identifier targetType (s.getType());

	for (int i = 0; i < types.size(); ++i)
	{
		TypeHandler* const t = types.getUnchecked(i);

		if (t->type == targetType)
			return t;
	}

	return nullptr;
}

int ComponentBuilder::getNumHandlers() const noexcept
{
	return types.size();
}

ComponentBuilder::TypeHandler* ComponentBuilder::getHandler (const int index) const noexcept
{
	return types [index];
}

void ComponentBuilder::registerStandardComponentTypes()
{
	Drawable::registerDrawableTypeHandlers (*this);

	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ComboBox>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Slider>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Label>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Slider>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <TextEditor>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <GroupComponent>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <TextButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ToggleButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ImageButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ImageComponent>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <HyperlinkButton>());
}

void ComponentBuilder::setImageProvider (ImageProvider* newImageProvider) noexcept
{
	imageProvider = newImageProvider;
}

ComponentBuilder::ImageProvider* ComponentBuilder::getImageProvider() const noexcept
{
	return imageProvider;
}

void ComponentBuilder::valueTreePropertyChanged (ValueTree& tree, const Identifier&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildAdded (ValueTree& tree, ValueTree&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildRemoved (ValueTree& tree, ValueTree&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildOrderChanged (ValueTree& tree)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeParentChanged (ValueTree& tree)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

ComponentBuilder::TypeHandler::TypeHandler (const Identifier& valueTreeType)
   : type (valueTreeType), builder (nullptr)
{
}

ComponentBuilder::TypeHandler::~TypeHandler()
{
}

ComponentBuilder* ComponentBuilder::TypeHandler::getBuilder() const noexcept
{
	// A type handler needs to be registered with a ComponentBuilder before using it!
	jassert (builder != nullptr);
	return builder;
}

void ComponentBuilder::updateChildComponents (Component& parent, const ValueTree& children)
{
	using namespace ComponentBuilderHelpers;

	const int numExistingChildComps = parent.getNumChildComponents();

	Array <Component*> componentsInOrder;
	componentsInOrder.ensureStorageAllocated (numExistingChildComps);

	{
		OwnedArray<Component> existingComponents;
		existingComponents.ensureStorageAllocated (numExistingChildComps);

		int i;
		for (i = 0; i < numExistingChildComps; ++i)
			existingComponents.add (parent.getChildComponent (i));

		const int newNumChildren = children.getNumChildren();
		for (i = 0; i < newNumChildren; ++i)
		{
			const ValueTree childState (children.getChild (i));
			Component* c = removeComponentWithID (existingComponents, getStateId (childState));

			if (c == nullptr)
			{
				TypeHandler* const type = getHandlerForState (childState);
				jassert (type != nullptr);

				if (type != nullptr)
					c = ComponentBuilderHelpers::createNewComponent (*type, childState, &parent);
			}

			if (c != nullptr)
				componentsInOrder.add (c);
		}

		// (remaining unused items in existingComponents get deleted here as it goes out of scope)
	}

	// Make sure the z-order is correct..
	if (componentsInOrder.size() > 0)
	{
		componentsInOrder.getLast()->toFront (false);

		for (int i = componentsInOrder.size() - 1; --i >= 0;)
			componentsInOrder.getUnchecked(i)->toBehind (componentsInOrder.getUnchecked (i + 1));
	}
}

static void updateMarkers (MarkerList* const list, const ValueTree& state)
{
	if (list != nullptr)
		MarkerList::ValueTreeWrapper (state).applyTo (*list);
}

void ComponentBuilder::initialiseRecursively (Component& comp, const ValueTree& state)
{
	refreshBasicComponentProperties (comp, state);

	updateMarkers (comp.getMarkers (true),  state.getChildWithName ("MARKERS_X"));
	updateMarkers (comp.getMarkers (false), state.getChildWithName ("MARKERS_Y"));

	const ValueTree childList (state.getChildWithName ("COMPONENTS"));

	if (childList.isValid())
	{
		updateChildComponents (comp, childList);

		for (int i = 0; i < childList.getNumChildren(); ++i)
		{
			const ValueTree childState (childList.getChild(i));
			Component* const c = ComponentBuilderHelpers::findComponentWithID (comp, ComponentBuilderHelpers::getStateId (childState));

			if (c != nullptr)
			{
				ComponentBuilder::TypeHandler* const type = getHandlerForState (childState);

				if (type != nullptr)
					type->updateComponentFromState (c, childState);
				else
					initialiseRecursively (*c, childState);
			}
		}
	}
}

void ComponentBuilder::initialiseFromValueTree (Component& comp,
												const ValueTree& state,
												ImageProvider* const imageProvider)
{
	ComponentBuilder builder;
	builder.setImageProvider (imageProvider);
	builder.registerStandardComponentTypes();
	builder.initialiseRecursively (comp, state);
}

RelativeRectangle ComponentBuilder::getComponentBounds (const ValueTree& state)
{
	try
	{
		return RelativeRectangle (state [positionID].toString());
	}
	catch (Expression::ParseError&)
	{}

	return RelativeRectangle();
}

void ComponentBuilder::refreshBasicComponentProperties (Component& comp, const ValueTree& state)
{
	static const Identifier focusOrderID ("focusOrder");
	static const Identifier tooltipID ("tooltip");
	static const Identifier nameID ("name");

	comp.setName (state [nameID].toString());

	if (state.hasProperty (positionID))
		getComponentBounds (state).applyToComponent (comp);

	comp.setExplicitFocusOrder (state [focusOrderID]);
	const var tip (state [tooltipID]);

	if (! tip.isVoid())
	{
		SettableTooltipClient* tooltipClient = dynamic_cast <SettableTooltipClient*> (&comp);
		if (tooltipClient != nullptr)
			tooltipClient->setTooltip (tip.toString());
	}

	ComponentBuilderHelpers::updateComponentColours (comp, state.getChildWithName ("COLOURS"));
}

/*** End of inlined file: juce_ComponentBuilder.cpp ***/


/*** Start of inlined file: juce_ComponentMovementWatcher.cpp ***/
ComponentMovementWatcher::ComponentMovementWatcher (Component* const component_)
	: component (component_),
	  lastPeerID (0),
	  reentrant (false),
	  wasShowing (component_->isShowing())
{
	jassert (component != nullptr); // can't use this with a null pointer..

	component->addComponentListener (this);

	registerWithParentComps();
}

ComponentMovementWatcher::~ComponentMovementWatcher()
{
	if (component != nullptr)
		component->removeComponentListener (this);

	unregister();
}

void ComponentMovementWatcher::componentParentHierarchyChanged (Component&)
{
	if (component != nullptr && ! reentrant)
	{
		const ScopedValueSetter<bool> setter (reentrant, true);

		ComponentPeer* const peer = component->getPeer();
		const uint32 peerID = peer != nullptr ? peer->getUniqueID() : 0;

		if (peerID != lastPeerID)
		{
			componentPeerChanged();

			if (component == nullptr)
				return;

			lastPeerID = peerID;
		}

		unregister();
		registerWithParentComps();

		componentMovedOrResized (*component, true, true);

		if (component != nullptr)
			componentVisibilityChanged (*component);
	}
}

void ComponentMovementWatcher::componentMovedOrResized (Component&, bool wasMoved, bool wasResized)
{
	if (component != nullptr)
	{
		if (wasMoved)
		{
			const Point<int> pos (component->getTopLevelComponent()->getLocalPoint (component, Point<int>()));

			wasMoved = lastBounds.getPosition() != pos;
			lastBounds.setPosition (pos);
		}

		wasResized = (lastBounds.getWidth() != component->getWidth() || lastBounds.getHeight() != component->getHeight());
		lastBounds.setSize (component->getWidth(), component->getHeight());

		if (wasMoved || wasResized)
			componentMovedOrResized (wasMoved, wasResized);
	}
}

void ComponentMovementWatcher::componentBeingDeleted (Component& comp)
{
	registeredParentComps.removeValue (&comp);

	if (component == &comp)
		unregister();
}

void ComponentMovementWatcher::componentVisibilityChanged (Component&)
{
	if (component != nullptr)
	{
		const bool isShowingNow = component->isShowing();

		if (wasShowing != isShowingNow)
		{
			wasShowing = isShowingNow;
			componentVisibilityChanged();
		}
	}
}

void ComponentMovementWatcher::registerWithParentComps()
{
	Component* p = component->getParentComponent();

	while (p != nullptr)
	{
		p->addComponentListener (this);
		registeredParentComps.add (p);
		p = p->getParentComponent();
	}
}

void ComponentMovementWatcher::unregister()
{
	for (int i = registeredParentComps.size(); --i >= 0;)
		registeredParentComps.getUnchecked(i)->removeComponentListener (this);

	registeredParentComps.clear();
}

/*** End of inlined file: juce_ComponentMovementWatcher.cpp ***/


/*** Start of inlined file: juce_GroupComponent.cpp ***/
GroupComponent::GroupComponent (const String& name,
								const String& labelText)
	: Component (name),
	  text (labelText),
	  justification (Justification::left)
{
	setInterceptsMouseClicks  (false, true);
}

GroupComponent::~GroupComponent()
{
}

void GroupComponent::setText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		repaint();
	}
}

String GroupComponent::getText() const
{
	return text;
}

void GroupComponent::setTextLabelPosition (const Justification& newJustification)
{
	if (justification != newJustification)
	{
		justification = newJustification;
		repaint();
	}
}

void GroupComponent::paint (Graphics& g)
{
	getLookAndFeel()
		.drawGroupComponentOutline (g, getWidth(), getHeight(),
									text, justification,
									*this);
}

void GroupComponent::enablementChanged()
{
	repaint();
}

void GroupComponent::colourChanged()
{
	repaint();
}

const Identifier GroupComponent::Ids::tagType ("GROUPCOMPONENT");
const Identifier GroupComponent::Ids::text ("text");
const Identifier GroupComponent::Ids::justification ("justification");

void GroupComponent::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setText (state [Ids::text].toString());
	setTextLabelPosition (static_cast <int> (state [Ids::justification]));
}

/*** End of inlined file: juce_GroupComponent.cpp ***/


/*** Start of inlined file: juce_MultiDocumentPanel.cpp ***/
MultiDocumentPanelWindow::MultiDocumentPanelWindow (const Colour& backgroundColour)
	: DocumentWindow (String::empty, backgroundColour,
					  DocumentWindow::maximiseButton | DocumentWindow::closeButton, false)
{
}

MultiDocumentPanelWindow::~MultiDocumentPanelWindow()
{
}

void MultiDocumentPanelWindow::maximiseButtonPressed()
{
	MultiDocumentPanel* const owner = getOwner();

	jassert (owner != nullptr); // these windows are only designed to be used inside a MultiDocumentPanel!
	if (owner != nullptr)
		owner->setLayoutMode (MultiDocumentPanel::MaximisedWindowsWithTabs);
}

void MultiDocumentPanelWindow::closeButtonPressed()
{
	MultiDocumentPanel* const owner = getOwner();

	jassert (owner != nullptr); // these windows are only designed to be used inside a MultiDocumentPanel!
	if (owner != nullptr)
		owner->closeDocument (getContentComponent(), true);
}

void MultiDocumentPanelWindow::activeWindowStatusChanged()
{
	DocumentWindow::activeWindowStatusChanged();
	updateOrder();
}

void MultiDocumentPanelWindow::broughtToFront()
{
	DocumentWindow::broughtToFront();
	updateOrder();
}

void MultiDocumentPanelWindow::updateOrder()
{
	MultiDocumentPanel* const owner = getOwner();

	if (owner != nullptr)
		owner->updateOrder();
}

MultiDocumentPanel* MultiDocumentPanelWindow::getOwner() const noexcept
{
	return findParentComponentOfClass<MultiDocumentPanel>();
}

class MDITabbedComponentInternal   : public TabbedComponent
{
public:
	MDITabbedComponentInternal()
		: TabbedComponent (TabbedButtonBar::TabsAtTop)
	{
	}

	void currentTabChanged (int, const String&)
	{
		MultiDocumentPanel* const owner = findParentComponentOfClass<MultiDocumentPanel>();

		if (owner != nullptr)
			owner->updateOrder();
	}
};

MultiDocumentPanel::MultiDocumentPanel()
	: mode (MaximisedWindowsWithTabs),
	  backgroundColour (Colours::lightblue),
	  maximumNumDocuments (0),
	  numDocsBeforeTabsUsed (0)
{
	setOpaque (true);
}

MultiDocumentPanel::~MultiDocumentPanel()
{
	closeAllDocuments (false);
}

namespace MultiDocHelpers
{
	static bool shouldDeleteComp (Component* const c)
	{
		return c->getProperties() ["mdiDocumentDelete_"];
	}
}

bool MultiDocumentPanel::closeAllDocuments (const bool checkItsOkToCloseFirst)
{
	while (components.size() > 0)
		if (! closeDocument (components.getLast(), checkItsOkToCloseFirst))
			return false;

	return true;
}

MultiDocumentPanelWindow* MultiDocumentPanel::createNewDocumentWindow()
{
	return new MultiDocumentPanelWindow (backgroundColour);
}

void MultiDocumentPanel::addWindow (Component* component)
{
	MultiDocumentPanelWindow* const dw = createNewDocumentWindow();

	dw->setResizable (true, false);
	dw->setContentNonOwned (component, true);
	dw->setName (component->getName());

	const var bkg (component->getProperties() ["mdiDocumentBkg_"]);
	dw->setBackgroundColour (bkg.isVoid() ? backgroundColour : Colour ((uint32) static_cast <int> (bkg)));

	int x = 4;
	Component* const topComp = getChildComponent (getNumChildComponents() - 1);

	if (topComp != nullptr && topComp->getX() == x && topComp->getY() == x)
		x += 16;

	dw->setTopLeftPosition (x, x);

	const var pos (component->getProperties() ["mdiDocumentPos_"]);
	if (pos.toString().isNotEmpty())
		dw->restoreWindowStateFromString (pos.toString());

	addAndMakeVisible (dw);
	dw->toFront (true);
}

bool MultiDocumentPanel::addDocument (Component* const component,
									  const Colour& docColour,
									  const bool deleteWhenRemoved)
{
	// If you try passing a full DocumentWindow or ResizableWindow in here, you'll end up
	// with a frame-within-a-frame! Just pass in the bare content component.
	jassert (dynamic_cast <ResizableWindow*> (component) == nullptr);

	if (component == nullptr || (maximumNumDocuments > 0 && components.size() >= maximumNumDocuments))
		return false;

	components.add (component);
	component->getProperties().set ("mdiDocumentDelete_", deleteWhenRemoved);
	component->getProperties().set ("mdiDocumentBkg_", (int) docColour.getARGB());
	component->addComponentListener (this);

	if (mode == FloatingWindows)
	{
		if (isFullscreenWhenOneDocument())
		{
			if (components.size() == 1)
			{
				addAndMakeVisible (component);
			}
			else
			{
				if (components.size() == 2)
					addWindow (components.getFirst());

				addWindow (component);
			}
		}
		else
		{
		   addWindow (component);
		}
	}
	else
	{
		if (tabComponent == nullptr && components.size() > numDocsBeforeTabsUsed)
		{
			addAndMakeVisible (tabComponent = new MDITabbedComponentInternal());

			Array <Component*> temp (components);

			for (int i = 0; i < temp.size(); ++i)
				tabComponent->addTab (temp[i]->getName(), docColour, temp[i], false);

			resized();
		}
		else
		{
			if (tabComponent != nullptr)
				tabComponent->addTab (component->getName(), docColour, component, false);
			else
				addAndMakeVisible (component);
		}

		setActiveDocument (component);
	}

	resized();
	activeDocumentChanged();
	return true;
}

bool MultiDocumentPanel::closeDocument (Component* component,
										const bool checkItsOkToCloseFirst)
{
	if (components.contains (component))
	{
		if (checkItsOkToCloseFirst && ! tryToCloseDocument (component))
			return false;

		component->removeComponentListener (this);

		const bool shouldDelete = MultiDocHelpers::shouldDeleteComp (component);
		component->getProperties().remove ("mdiDocumentDelete_");
		component->getProperties().remove ("mdiDocumentBkg_");

		if (mode == FloatingWindows)
		{
			for (int i = getNumChildComponents(); --i >= 0;)
			{
				MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

				if (dw != nullptr && dw->getContentComponent() == component)
				{
					ScopedPointer<MultiDocumentPanelWindow> (dw)->clearContentComponent();
					break;
				}
			}

			if (shouldDelete)
				delete component;

			components.removeValue (component);

			if (isFullscreenWhenOneDocument() && components.size() == 1)
			{
				for (int i = getNumChildComponents(); --i >= 0;)
				{
					ScopedPointer<MultiDocumentPanelWindow> dw (dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i)));

					if (dw != nullptr)
						dw->clearContentComponent();
				}

				addAndMakeVisible (components.getFirst());
			}
		}
		else
		{
			jassert (components.indexOf (component) >= 0);

			if (tabComponent != nullptr)
			{
				for (int i = tabComponent->getNumTabs(); --i >= 0;)
					if (tabComponent->getTabContentComponent (i) == component)
						tabComponent->removeTab (i);
			}
			else
			{
				removeChildComponent (component);
			}

			if (shouldDelete)
				delete component;

			if (tabComponent != nullptr && tabComponent->getNumTabs() <= numDocsBeforeTabsUsed)
				tabComponent = nullptr;

			components.removeValue (component);

			if (components.size() > 0 && tabComponent == nullptr)
				addAndMakeVisible (components.getFirst());
		}

		resized();
		activeDocumentChanged();
	}
	else
	{
		jassertfalse;
	}

	return true;
}

int MultiDocumentPanel::getNumDocuments() const noexcept
{
	return components.size();
}

Component* MultiDocumentPanel::getDocument (const int index) const noexcept
{
	return components [index];
}

Component* MultiDocumentPanel::getActiveDocument() const noexcept
{
	if (mode == FloatingWindows)
	{
		for (int i = getNumChildComponents(); --i >= 0;)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr && dw->isActiveWindow())
				return dw->getContentComponent();
		}
	}

	return components.getLast();
}

void MultiDocumentPanel::setActiveDocument (Component* component)
{
	if (mode == FloatingWindows)
	{
		component = getContainerComp (component);

		if (component != nullptr)
			component->toFront (true);
	}
	else if (tabComponent != nullptr)
	{
		jassert (components.indexOf (component) >= 0);

		for (int i = tabComponent->getNumTabs(); --i >= 0;)
		{
			if (tabComponent->getTabContentComponent (i) == component)
			{
				tabComponent->setCurrentTabIndex (i);
				break;
			}
		}
	}
	else
	{
		component->grabKeyboardFocus();
	}
}

void MultiDocumentPanel::activeDocumentChanged()
{
}

void MultiDocumentPanel::setMaximumNumDocuments (const int newNumber)
{
	maximumNumDocuments = newNumber;
}

void MultiDocumentPanel::useFullscreenWhenOneDocument (const bool shouldUseTabs)
{
	numDocsBeforeTabsUsed = shouldUseTabs ? 1 : 0;
}

bool MultiDocumentPanel::isFullscreenWhenOneDocument() const noexcept
{
	return numDocsBeforeTabsUsed != 0;
}

void MultiDocumentPanel::setLayoutMode (const LayoutMode newLayoutMode)
{
	if (mode != newLayoutMode)
	{
		mode = newLayoutMode;

		if (mode == FloatingWindows)
		{
			tabComponent = nullptr;
		}
		else
		{
			for (int i = getNumChildComponents(); --i >= 0;)
			{
				MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

				if (dw != nullptr)
				{
					dw->getContentComponent()->getProperties().set ("mdiDocumentPos_", dw->getWindowStateAsString());
					dw->clearContentComponent();
					delete dw;
				}
			}
		}

		resized();

		const Array <Component*> tempComps (components);
		components.clear();

		for (int i = 0; i < tempComps.size(); ++i)
		{
			Component* const c = tempComps.getUnchecked(i);

			addDocument (c,
						 Colour ((uint32) static_cast <int> (c->getProperties().getWithDefault ("mdiDocumentBkg_", (int) Colours::white.getARGB()))),
						 MultiDocHelpers::shouldDeleteComp (c));
		}
	}
}

void MultiDocumentPanel::setBackgroundColour (const Colour& newBackgroundColour)
{
	if (backgroundColour != newBackgroundColour)
	{
		backgroundColour = newBackgroundColour;
		setOpaque (newBackgroundColour.isOpaque());
		repaint();
	}
}

void MultiDocumentPanel::paint (Graphics& g)
{
	g.fillAll (backgroundColour);
}

void MultiDocumentPanel::resized()
{
	if (mode == MaximisedWindowsWithTabs || components.size() == numDocsBeforeTabsUsed)
	{
		for (int i = getNumChildComponents(); --i >= 0;)
			getChildComponent (i)->setBounds (getLocalBounds());
	}

	setWantsKeyboardFocus (components.size() == 0);
}

Component* MultiDocumentPanel::getContainerComp (Component* c) const
{
	if (mode == FloatingWindows)
	{
		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr && dw->getContentComponent() == c)
			{
				c = dw;
				break;
			}
		}
	}

	return c;
}

void MultiDocumentPanel::componentNameChanged (Component&)
{
	if (mode == FloatingWindows)
	{
		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr)
				dw->setName (dw->getContentComponent()->getName());
		}
	}
	else if (tabComponent != nullptr)
	{
		for (int i = tabComponent->getNumTabs(); --i >= 0;)
			tabComponent->setTabName (i, tabComponent->getTabContentComponent (i)->getName());
	}
}

void MultiDocumentPanel::updateOrder()
{
	const Array <Component*> oldList (components);

	if (mode == FloatingWindows)
	{
		components.clear();

		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr)
				components.add (dw->getContentComponent());
		}
	}
	else
	{
		if (tabComponent != nullptr)
		{
			Component* const current = tabComponent->getCurrentContentComponent();

			if (current != nullptr)
			{
				components.removeValue (current);
				components.add (current);
			}
		}
	}

	if (components != oldList)
		activeDocumentChanged();
}

/*** End of inlined file: juce_MultiDocumentPanel.cpp ***/


/*** Start of inlined file: juce_ResizableBorderComponent.cpp ***/
ResizableBorderComponent::Zone::Zone (const int zoneFlags) noexcept
	: zone (zoneFlags)
{}

ResizableBorderComponent::Zone::Zone (const ResizableBorderComponent::Zone& other) noexcept
	: zone (other.zone)
{}

ResizableBorderComponent::Zone& ResizableBorderComponent::Zone::operator= (const ResizableBorderComponent::Zone& other) noexcept
{
	zone = other.zone;
	return *this;
}

bool ResizableBorderComponent::Zone::operator== (const ResizableBorderComponent::Zone& other) const noexcept      { return zone == other.zone; }
bool ResizableBorderComponent::Zone::operator!= (const ResizableBorderComponent::Zone& other) const noexcept      { return zone != other.zone; }

const ResizableBorderComponent::Zone ResizableBorderComponent::Zone::fromPositionOnBorder (const Rectangle<int>& totalSize,
																						   const BorderSize<int>& border,
																						   const Point<int>& position)
{
	int z = 0;

	if (totalSize.contains (position)
		 && ! border.subtractedFrom (totalSize).contains (position))
	{
		const int minW = jmax (totalSize.getWidth() / 10, jmin (10, totalSize.getWidth() / 3));
		if (position.x < jmax (border.getLeft(), minW) && border.getLeft() > 0)
			z |= left;
		else if (position.x >= totalSize.getWidth() - jmax (border.getRight(), minW) && border.getRight() > 0)
			z |= right;

		const int minH = jmax (totalSize.getHeight() / 10, jmin (10, totalSize.getHeight() / 3));
		if (position.y < jmax (border.getTop(), minH) && border.getTop() > 0)
			z |= top;
		else if (position.y >= totalSize.getHeight() - jmax (border.getBottom(), minH) && border.getBottom() > 0)
			z |= bottom;
	}

	return Zone (z);
}

MouseCursor ResizableBorderComponent::Zone::getMouseCursor() const noexcept
{
	MouseCursor::StandardCursorType mc = MouseCursor::NormalCursor;

	switch (zone)
	{
		case (left | top):      mc = MouseCursor::TopLeftCornerResizeCursor; break;
		case top:               mc = MouseCursor::TopEdgeResizeCursor; break;
		case (right | top):     mc = MouseCursor::TopRightCornerResizeCursor; break;
		case left:              mc = MouseCursor::LeftEdgeResizeCursor; break;
		case right:             mc = MouseCursor::RightEdgeResizeCursor; break;
		case (left | bottom):   mc = MouseCursor::BottomLeftCornerResizeCursor; break;
		case bottom:            mc = MouseCursor::BottomEdgeResizeCursor; break;
		case (right | bottom):  mc = MouseCursor::BottomRightCornerResizeCursor; break;
		default:                break;
	}

	return mc;
}

ResizableBorderComponent::ResizableBorderComponent (Component* const componentToResize,
													ComponentBoundsConstrainer* const constrainer_)
   : component (componentToResize),
	 constrainer (constrainer_),
	 borderSize (5),
	 mouseZone (0)
{
}

ResizableBorderComponent::~ResizableBorderComponent()
{
}

void ResizableBorderComponent::paint (Graphics& g)
{
	getLookAndFeel().drawResizableFrame (g, getWidth(), getHeight(), borderSize);
}

void ResizableBorderComponent::mouseEnter (const MouseEvent& e)
{
	updateMouseZone (e);
}

void ResizableBorderComponent::mouseMove (const MouseEvent& e)
{
	updateMouseZone (e);
}

void ResizableBorderComponent::mouseDown (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	updateMouseZone (e);

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableBorderComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	const Rectangle<int> newBounds (mouseZone.resizeRectangleBy (originalBounds, e.getOffsetFromDragStart()));

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, newBounds,
											mouseZone.isDraggingTopEdge(),
											mouseZone.isDraggingLeftEdge(),
											mouseZone.isDraggingBottomEdge(),
											mouseZone.isDraggingRightEdge());
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (newBounds);
		else
			component->setBounds (newBounds);
	}
}

void ResizableBorderComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

bool ResizableBorderComponent::hitTest (int x, int y)
{
	return x < borderSize.getLeft()
			|| x >= getWidth() - borderSize.getRight()
			|| y < borderSize.getTop()
			|| y >= getHeight() - borderSize.getBottom();
}

void ResizableBorderComponent::setBorderThickness (const BorderSize<int>& newBorderSize)
{
	if (borderSize != newBorderSize)
	{
		borderSize = newBorderSize;
		repaint();
	}
}

BorderSize<int> ResizableBorderComponent::getBorderThickness() const
{
	return borderSize;
}

void ResizableBorderComponent::updateMouseZone (const MouseEvent& e)
{
	Zone newZone (Zone::fromPositionOnBorder (getLocalBounds(), borderSize, e.getPosition()));

	if (mouseZone != newZone)
	{
		mouseZone = newZone;
		setMouseCursor (newZone.getMouseCursor());
	}
}

/*** End of inlined file: juce_ResizableBorderComponent.cpp ***/


/*** Start of inlined file: juce_ResizableCornerComponent.cpp ***/
ResizableCornerComponent::ResizableCornerComponent (Component* const componentToResize,
													ComponentBoundsConstrainer* const constrainer_)
   : component (componentToResize),
	 constrainer (constrainer_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor::BottomRightCornerResizeCursor);
}

ResizableCornerComponent::~ResizableCornerComponent()
{
}

void ResizableCornerComponent::paint (Graphics& g)
{
	getLookAndFeel()
		.drawCornerResizer (g, getWidth(), getHeight(),
							isMouseOverOrDragging(),
							isMouseButtonDown());
}

void ResizableCornerComponent::mouseDown (const MouseEvent&)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer is supposed to be controlling!
		return;
	}

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableCornerComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer is supposed to be controlling!
		return;
	}

	Rectangle<int> r (originalBounds.withSize (originalBounds.getWidth() + e.getDistanceFromDragStartX(),
											   originalBounds.getHeight() + e.getDistanceFromDragStartY()));

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, r, false, false, true, true);
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (r);
		else
			component->setBounds (r);
	}
}

void ResizableCornerComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

bool ResizableCornerComponent::hitTest (int x, int y)
{
	if (getWidth() <= 0)
		return false;

	const int yAtX = getHeight() - (getHeight() * x / getWidth());

	return y >= yAtX - getHeight() / 4;
}

/*** End of inlined file: juce_ResizableCornerComponent.cpp ***/


/*** Start of inlined file: juce_ResizableEdgeComponent.cpp ***/
ResizableEdgeComponent::ResizableEdgeComponent (Component* const componentToResize,
												ComponentBoundsConstrainer* const constrainer_,
												Edge edge_)
   : component (componentToResize),
	 constrainer (constrainer_),
	 edge (edge_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor (isVertical() ? MouseCursor::LeftRightResizeCursor
											  : MouseCursor::UpDownResizeCursor));
}

ResizableEdgeComponent::~ResizableEdgeComponent()
{
}

bool ResizableEdgeComponent::isVertical() const noexcept
{
	return edge == leftEdge || edge == rightEdge;
}

void ResizableEdgeComponent::paint (Graphics& g)
{
	getLookAndFeel().drawStretchableLayoutResizerBar (g, getWidth(), getHeight(), isVertical(),
													  isMouseOver(), isMouseButtonDown());
}

void ResizableEdgeComponent::mouseDown (const MouseEvent&)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableEdgeComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	Rectangle<int> newBounds (originalBounds);

	switch (edge)
	{
		case leftEdge:      newBounds.setLeft (jmin (newBounds.getRight(), newBounds.getX() + e.getDistanceFromDragStartX())); break;
		case rightEdge:     newBounds.setWidth (jmax (0, newBounds.getWidth() + e.getDistanceFromDragStartX())); break;
		case topEdge:       newBounds.setTop (jmin (newBounds.getBottom(), newBounds.getY() + e.getDistanceFromDragStartY())); break;
		case bottomEdge:    newBounds.setHeight (jmax (0, newBounds.getHeight() + e.getDistanceFromDragStartY())); break;
		default:            jassertfalse; break;
	}

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, newBounds,
											edge == topEdge,
											edge == leftEdge,
											edge == bottomEdge,
											edge == rightEdge);
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (newBounds);
		else
			component->setBounds (newBounds);
	}
}

void ResizableEdgeComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

/*** End of inlined file: juce_ResizableEdgeComponent.cpp ***/


/*** Start of inlined file: juce_ScrollBar.cpp ***/
class ScrollBar::ScrollbarButton  : public Button
{
public:
	ScrollbarButton (const int direction_, ScrollBar& owner_)
		: Button (String::empty),
		  direction (direction_),
		  owner (owner_)
	{
		setWantsKeyboardFocus (false);
	}

	void paintButton (Graphics& g, bool over, bool down)
	{
		getLookAndFeel()
			.drawScrollbarButton (g, owner,
								  getWidth(), getHeight(),
								  direction,
								  owner.isVertical(),
								  over, down);
	}

	void clicked()
	{
		owner.moveScrollbarInSteps ((direction == 1 || direction == 2) ? 1 : -1);
	}

	int direction;

private:
	ScrollBar& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ScrollbarButton);
};

ScrollBar::ScrollBar (const bool vertical_,
					  const bool buttonsAreVisible)
	: totalRange (0.0, 1.0),
	  visibleRange (0.0, 0.1),
	  singleStepSize (0.1),
	  thumbAreaStart (0),
	  thumbAreaSize (0),
	  thumbStart (0),
	  thumbSize (0),
	  initialDelayInMillisecs (100),
	  repeatDelayInMillisecs (50),
	  minimumDelayInMillisecs (10),
	  vertical (vertical_),
	  isDraggingThumb (false),
	  autohides (true)
{
	setButtonVisibility (buttonsAreVisible);

	setRepaintsOnMouseActivity (true);
	setFocusContainer (true);
}

ScrollBar::~ScrollBar()
{
	upButton = nullptr;
	downButton = nullptr;
}

void ScrollBar::setRangeLimits (const Range<double>& newRangeLimit)
{
	if (totalRange != newRangeLimit)
	{
		totalRange = newRangeLimit;
		setCurrentRange (visibleRange);
		updateThumbPosition();
	}
}

void ScrollBar::setRangeLimits (const double newMinimum, const double newMaximum)
{
	jassert (newMaximum >= newMinimum); // these can't be the wrong way round!
	setRangeLimits (Range<double> (newMinimum, newMaximum));
}

void ScrollBar::setCurrentRange (const Range<double>& newRange)
{
	const Range<double> constrainedRange (totalRange.constrainRange (newRange));

	if (visibleRange != constrainedRange)
	{
		visibleRange = constrainedRange;

		updateThumbPosition();
		triggerAsyncUpdate();
	}
}

void ScrollBar::setCurrentRange (const double newStart, const double newSize)
{
	setCurrentRange (Range<double> (newStart, newStart + newSize));
}

void ScrollBar::setCurrentRangeStart (const double newStart)
{
	setCurrentRange (visibleRange.movedToStartAt (newStart));
}

void ScrollBar::setSingleStepSize (const double newSingleStepSize)
{
	singleStepSize = newSingleStepSize;
}

void ScrollBar::moveScrollbarInSteps (const int howManySteps)
{
	setCurrentRange (visibleRange + howManySteps * singleStepSize);
}

void ScrollBar::moveScrollbarInPages (const int howManyPages)
{
	setCurrentRange (visibleRange + howManyPages * visibleRange.getLength());
}

void ScrollBar::scrollToTop()
{
	setCurrentRange (visibleRange.movedToStartAt (getMinimumRangeLimit()));
}

void ScrollBar::scrollToBottom()
{
	setCurrentRange (visibleRange.movedToEndAt (getMaximumRangeLimit()));
}

void ScrollBar::setButtonRepeatSpeed (const int initialDelayInMillisecs_,
									  const int repeatDelayInMillisecs_,
									  const int minimumDelayInMillisecs_)
{
	initialDelayInMillisecs = initialDelayInMillisecs_;
	repeatDelayInMillisecs = repeatDelayInMillisecs_;
	minimumDelayInMillisecs = minimumDelayInMillisecs_;

	if (upButton != nullptr)
	{
		upButton->setRepeatSpeed (initialDelayInMillisecs,  repeatDelayInMillisecs,  minimumDelayInMillisecs);
		downButton->setRepeatSpeed (initialDelayInMillisecs,  repeatDelayInMillisecs,  minimumDelayInMillisecs);
	}
}

void ScrollBar::addListener (Listener* const listener)
{
	listeners.add (listener);
}

void ScrollBar::removeListener (Listener* const listener)
{
	listeners.remove (listener);
}

void ScrollBar::handleAsyncUpdate()
{
	double start = visibleRange.getStart(); // (need to use a temp variable for VC7 compatibility)
	listeners.call (&ScrollBar::Listener::scrollBarMoved, this, start);
}

void ScrollBar::updateThumbPosition()
{
	int newThumbSize = roundToInt (totalRange.getLength() > 0 ? (visibleRange.getLength() * thumbAreaSize) / totalRange.getLength()
															  : thumbAreaSize);

	if (newThumbSize < getLookAndFeel().getMinimumScrollbarThumbSize (*this))
		newThumbSize = jmin (getLookAndFeel().getMinimumScrollbarThumbSize (*this), thumbAreaSize - 1);

	if (newThumbSize > thumbAreaSize)
		newThumbSize = thumbAreaSize;

	int newThumbStart = thumbAreaStart;

	if (totalRange.getLength() > visibleRange.getLength())
		newThumbStart += roundToInt (((visibleRange.getStart() - totalRange.getStart()) * (thumbAreaSize - newThumbSize))
										 / (totalRange.getLength() - visibleRange.getLength()));

	setVisible ((! autohides) || (totalRange.getLength() > visibleRange.getLength() && visibleRange.getLength() > 0.0));

	if (thumbStart != newThumbStart  || thumbSize != newThumbSize)
	{
		const int repaintStart = jmin (thumbStart, newThumbStart) - 4;
		const int repaintSize = jmax (thumbStart + thumbSize, newThumbStart + newThumbSize) + 8 - repaintStart;

		if (vertical)
			repaint (0, repaintStart, getWidth(), repaintSize);
		else
			repaint (repaintStart, 0, repaintSize, getHeight());

		thumbStart = newThumbStart;
		thumbSize = newThumbSize;
	}
}

void ScrollBar::setOrientation (const bool shouldBeVertical)
{
	if (vertical != shouldBeVertical)
	{
		vertical = shouldBeVertical;

		if (upButton != nullptr)
		{
			upButton->direction    = vertical ? 0 : 3;
			downButton->direction  = vertical ? 2 : 1;
		}

		updateThumbPosition();
	}
}

void ScrollBar::setButtonVisibility (const bool buttonsAreVisible)
{
	upButton = nullptr;
	downButton = nullptr;

	if (buttonsAreVisible)
	{
		addAndMakeVisible (upButton   = new ScrollbarButton (vertical ? 0 : 3, *this));
		addAndMakeVisible (downButton = new ScrollbarButton (vertical ? 2 : 1, *this));

		setButtonRepeatSpeed (initialDelayInMillisecs, repeatDelayInMillisecs, minimumDelayInMillisecs);
	}

	updateThumbPosition();
}

void ScrollBar::setAutoHide (const bool shouldHideWhenFullRange)
{
	autohides = shouldHideWhenFullRange;
	updateThumbPosition();
}

bool ScrollBar::autoHides() const noexcept
{
	return autohides;
}

void ScrollBar::paint (Graphics& g)
{
	if (thumbAreaSize > 0)
	{
		LookAndFeel& lf = getLookAndFeel();

		const int thumb = (thumbAreaSize > lf.getMinimumScrollbarThumbSize (*this))
								? thumbSize : 0;

		if (vertical)
		{
			lf.drawScrollbar (g, *this,
							  0, thumbAreaStart,
							  getWidth(), thumbAreaSize,
							  vertical,
							  thumbStart, thumb,
							  isMouseOver(), isMouseButtonDown());
		}
		else
		{
			lf.drawScrollbar (g, *this,
							  thumbAreaStart, 0,
							  thumbAreaSize, getHeight(),
							  vertical,
							  thumbStart, thumb,
							  isMouseOver(), isMouseButtonDown());
		}
	}
}

void ScrollBar::lookAndFeelChanged()
{
	setComponentEffect (getLookAndFeel().getScrollbarEffect());
}

void ScrollBar::resized()
{
	const int length = vertical ? getHeight() : getWidth();

	const int buttonSize = upButton != nullptr ? jmin (getLookAndFeel().getScrollbarButtonSize (*this), length / 2)
											   : 0;

	if (length < 32 + getLookAndFeel().getMinimumScrollbarThumbSize (*this))
	{
		thumbAreaStart = length / 2;
		thumbAreaSize = 0;
	}
	else
	{
		thumbAreaStart = buttonSize;
		thumbAreaSize = length - (buttonSize << 1);
	}

	if (upButton != nullptr)
	{
		if (vertical)
		{
			upButton->setBounds (0, 0, getWidth(), buttonSize);
			downButton->setBounds (0, thumbAreaStart + thumbAreaSize, getWidth(), buttonSize);
		}
		else
		{
			upButton->setBounds (0, 0, buttonSize, getHeight());
			downButton->setBounds (thumbAreaStart + thumbAreaSize, 0, buttonSize, getHeight());
		}
	}

	updateThumbPosition();
}

void ScrollBar::mouseDown (const MouseEvent& e)
{
	isDraggingThumb = false;
	lastMousePos = vertical ? e.y : e.x;
	dragStartMousePos = lastMousePos;
	dragStartRange = visibleRange.getStart();

	if (dragStartMousePos < thumbStart)
	{
		moveScrollbarInPages (-1);
		startTimer (400);
	}
	else if (dragStartMousePos >= thumbStart + thumbSize)
	{
		moveScrollbarInPages (1);
		startTimer (400);
	}
	else
	{
		isDraggingThumb = (thumbAreaSize > getLookAndFeel().getMinimumScrollbarThumbSize (*this))
							&& (thumbAreaSize > thumbSize);
	}
}

void ScrollBar::mouseDrag (const MouseEvent& e)
{
	const int mousePos = vertical ? e.y : e.x;

	if (isDraggingThumb && lastMousePos != mousePos)
	{
		const int deltaPixels = mousePos - dragStartMousePos;

		setCurrentRangeStart (dragStartRange
								+ deltaPixels * (totalRange.getLength() - visibleRange.getLength())
									/ (thumbAreaSize - thumbSize));
	}

	lastMousePos = mousePos;
}

void ScrollBar::mouseUp (const MouseEvent&)
{
	isDraggingThumb = false;
	stopTimer();
	repaint();
}

void ScrollBar::mouseWheelMove (const MouseEvent&,
								float wheelIncrementX,
								float wheelIncrementY)
{
	float increment = 10.0f * (vertical ? wheelIncrementY : wheelIncrementX);

	if (increment < 0)
		increment = jmin (increment, -1.0f);
	else if (increment > 0)
		increment = jmax (increment, 1.0f);

	setCurrentRange (visibleRange - singleStepSize * increment);
}

void ScrollBar::timerCallback()
{
	if (isMouseButtonDown())
	{
		startTimer (40);

		if (lastMousePos < thumbStart)
			setCurrentRange (visibleRange - visibleRange.getLength());
		else if (lastMousePos > thumbStart + thumbSize)
			setCurrentRangeStart (visibleRange.getEnd());
	}
	else
	{
		stopTimer();
	}
}

bool ScrollBar::keyPressed (const KeyPress& key)
{
	if (! isVisible())
		return false;

	if (key.isKeyCode (KeyPress::upKey)
		 || key.isKeyCode (KeyPress::leftKey))          moveScrollbarInSteps (-1);
	else if (key.isKeyCode (KeyPress::downKey)
			  || key.isKeyCode (KeyPress::rightKey))    moveScrollbarInSteps (1);
	else if (key.isKeyCode (KeyPress::pageUpKey))       moveScrollbarInPages (-1);
	else if (key.isKeyCode (KeyPress::pageDownKey))     moveScrollbarInPages (1);
	else if (key.isKeyCode (KeyPress::homeKey))         scrollToTop();
	else if (key.isKeyCode (KeyPress::endKey))          scrollToBottom();
	else                                                return false;

	return true;
}

/*** End of inlined file: juce_ScrollBar.cpp ***/


/*** Start of inlined file: juce_StretchableLayoutManager.cpp ***/
StretchableLayoutManager::StretchableLayoutManager()
	: totalSize (0)
{
}

StretchableLayoutManager::~StretchableLayoutManager()
{
}

void StretchableLayoutManager::clearAllItems()
{
	items.clear();
	totalSize = 0;
}

void StretchableLayoutManager::setItemLayout (const int itemIndex,
											  const double minimumSize,
											  const double maximumSize,
											  const double preferredSize)
{
	ItemLayoutProperties* layout = getInfoFor (itemIndex);

	if (layout == nullptr)
	{
		layout = new ItemLayoutProperties();
		layout->itemIndex = itemIndex;

		int i;
		for (i = 0; i < items.size(); ++i)
			if (items.getUnchecked (i)->itemIndex > itemIndex)
				break;

		items.insert (i, layout);
	}

	layout->minSize = minimumSize;
	layout->maxSize = maximumSize;
	layout->preferredSize = preferredSize;
	layout->currentSize = 0;
}

bool StretchableLayoutManager::getItemLayout (const int itemIndex,
											  double& minimumSize,
											  double& maximumSize,
											  double& preferredSize) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
	{
		minimumSize = layout->minSize;
		maximumSize = layout->maxSize;
		preferredSize = layout->preferredSize;
		return true;
	}

	return false;
}

void StretchableLayoutManager::setTotalSize (const int newTotalSize)
{
	totalSize = newTotalSize;

	fitComponentsIntoSpace (0, items.size(), totalSize, 0);
}

int StretchableLayoutManager::getItemCurrentPosition (const int itemIndex) const
{
	int pos = 0;

	for (int i = 0; i < itemIndex; ++i)
	{
		const ItemLayoutProperties* const layout = getInfoFor (i);

		if (layout != nullptr)
			pos += layout->currentSize;
	}

	return pos;
}

int StretchableLayoutManager::getItemCurrentAbsoluteSize (const int itemIndex) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
		return layout->currentSize;

	return 0;
}

double StretchableLayoutManager::getItemCurrentRelativeSize (const int itemIndex) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
		return -layout->currentSize / (double) totalSize;

	return 0;
}

void StretchableLayoutManager::setItemPosition (const int itemIndex,
												int newPosition)
{
	for (int i = items.size(); --i >= 0;)
	{
		const ItemLayoutProperties* const layout = items.getUnchecked(i);

		if (layout->itemIndex == itemIndex)
		{
			int realTotalSize = jmax (totalSize, getMinimumSizeOfItems (0, items.size()));
			const int minSizeAfterThisComp = getMinimumSizeOfItems (i, items.size());
			const int maxSizeAfterThisComp = getMaximumSizeOfItems (i + 1, items.size());

			newPosition = jmax (newPosition, totalSize - maxSizeAfterThisComp - layout->currentSize);
			newPosition = jmin (newPosition, realTotalSize - minSizeAfterThisComp);

			int endPos = fitComponentsIntoSpace (0, i, newPosition, 0);

			endPos += layout->currentSize;

			fitComponentsIntoSpace (i + 1, items.size(), totalSize - endPos, endPos);
			updatePrefSizesToMatchCurrentPositions();
			break;
		}
	}
}

void StretchableLayoutManager::layOutComponents (Component** const components,
												 int numComponents,
												 int x, int y, int w, int h,
												 const bool vertically,
												 const bool resizeOtherDimension)
{
	setTotalSize (vertically ? h : w);
	int pos = vertically ? y : x;

	for (int i = 0; i < numComponents; ++i)
	{
		const ItemLayoutProperties* const layout = getInfoFor (i);

		if (layout != nullptr)
		{
			Component* const c = components[i];

			if (c != nullptr)
			{
				if (i == numComponents - 1)
				{
					// if it's the last item, crop it to exactly fit the available space..
					if (resizeOtherDimension)
					{
						if (vertically)
							c->setBounds (x, pos, w, jmax (layout->currentSize, h - pos));
						else
							c->setBounds (pos, y, jmax (layout->currentSize, w - pos), h);
					}
					else
					{
						if (vertically)
							c->setBounds (c->getX(), pos, c->getWidth(), jmax (layout->currentSize, h - pos));
						else
							c->setBounds (pos, c->getY(), jmax (layout->currentSize, w - pos), c->getHeight());
					}
				}
				else
				{
					if (resizeOtherDimension)
					{
						if (vertically)
							c->setBounds (x, pos, w, layout->currentSize);
						else
							c->setBounds (pos, y, layout->currentSize, h);
					}
					else
					{
						if (vertically)
							c->setBounds (c->getX(), pos, c->getWidth(), layout->currentSize);
						else
							c->setBounds (pos, c->getY(), layout->currentSize, c->getHeight());
					}
				}
			}

			pos += layout->currentSize;
		}
	}
}

StretchableLayoutManager::ItemLayoutProperties* StretchableLayoutManager::getInfoFor (const int itemIndex) const
{
	for (int i = items.size(); --i >= 0;)
		if (items.getUnchecked(i)->itemIndex == itemIndex)
			return items.getUnchecked(i);

	return nullptr;
}

int StretchableLayoutManager::fitComponentsIntoSpace (const int startIndex,
													  const int endIndex,
													  const int availableSpace,
													  int startPos)
{
	// calculate the total sizes
	int i;
	double totalIdealSize = 0.0;
	int totalMinimums = 0;

	for (i = startIndex; i < endIndex; ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked (i);

		layout->currentSize = sizeToRealSize (layout->minSize, totalSize);

		totalMinimums += layout->currentSize;
		totalIdealSize += sizeToRealSize (layout->preferredSize, totalSize);
   }

	if (totalIdealSize <= 0)
		totalIdealSize = 1.0;

	// now calc the best sizes..
	int extraSpace = availableSpace - totalMinimums;

	while (extraSpace > 0)
	{
		int numWantingMoreSpace = 0;
		int numHavingTakenExtraSpace = 0;

		// first figure out how many comps want a slice of the extra space..
		for (i = startIndex; i < endIndex; ++i)
		{
			ItemLayoutProperties* const layout = items.getUnchecked (i);

			double sizeWanted = sizeToRealSize (layout->preferredSize, totalSize);

			const int bestSize = jlimit (layout->currentSize,
										 jmax (layout->currentSize,
											   sizeToRealSize (layout->maxSize, totalSize)),
										 roundToInt (sizeWanted * availableSpace / totalIdealSize));

			if (bestSize > layout->currentSize)
				++numWantingMoreSpace;
		}

		// ..share out the extra space..
		for (i = startIndex; i < endIndex; ++i)
		{
			ItemLayoutProperties* const layout = items.getUnchecked (i);

			double sizeWanted = sizeToRealSize (layout->preferredSize, totalSize);

			int bestSize = jlimit (layout->currentSize,
								   jmax (layout->currentSize, sizeToRealSize (layout->maxSize, totalSize)),
								   roundToInt (sizeWanted * availableSpace / totalIdealSize));

			const int extraWanted = bestSize - layout->currentSize;

			if (extraWanted > 0)
			{
				const int extraAllowed = jmin (extraWanted,
												extraSpace / jmax (1, numWantingMoreSpace));

				if (extraAllowed > 0)
				{
					++numHavingTakenExtraSpace;
					--numWantingMoreSpace;

					layout->currentSize += extraAllowed;
					extraSpace -= extraAllowed;
				}
			}
		}

		if (numHavingTakenExtraSpace <= 0)
			break;
	}

	// ..and calculate the end position
	for (i = startIndex; i < endIndex; ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked(i);
		startPos += layout->currentSize;
	}

	return startPos;
}

int StretchableLayoutManager::getMinimumSizeOfItems (const int startIndex,
													 const int endIndex) const
{
	int totalMinimums = 0;

	for (int i = startIndex; i < endIndex; ++i)
		totalMinimums += sizeToRealSize (items.getUnchecked (i)->minSize, totalSize);

	return totalMinimums;
}

int StretchableLayoutManager::getMaximumSizeOfItems (const int startIndex, const int endIndex) const
{
	int totalMaximums = 0;

	for (int i = startIndex; i < endIndex; ++i)
		totalMaximums += sizeToRealSize (items.getUnchecked (i)->maxSize, totalSize);

	return totalMaximums;
}

void StretchableLayoutManager::updatePrefSizesToMatchCurrentPositions()
{
	for (int i = 0; i < items.size(); ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked (i);

		layout->preferredSize
			= (layout->preferredSize < 0) ? getItemCurrentRelativeSize (i)
										  : getItemCurrentAbsoluteSize (i);
	}
}

int StretchableLayoutManager::sizeToRealSize (double size, int totalSpace)
{
	if (size < 0)
		size *= -totalSpace;

	return roundToInt (size);
}

/*** End of inlined file: juce_StretchableLayoutManager.cpp ***/


/*** Start of inlined file: juce_StretchableLayoutResizerBar.cpp ***/
StretchableLayoutResizerBar::StretchableLayoutResizerBar (StretchableLayoutManager* layout_,
														  const int itemIndex_,
														  const bool isVertical_)
	: layout (layout_),
	  itemIndex (itemIndex_),
	  isVertical (isVertical_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor (isVertical_ ? MouseCursor::LeftRightResizeCursor
											 : MouseCursor::UpDownResizeCursor));
}

StretchableLayoutResizerBar::~StretchableLayoutResizerBar()
{
}

void StretchableLayoutResizerBar::paint (Graphics& g)
{
	getLookAndFeel().drawStretchableLayoutResizerBar (g,
													  getWidth(), getHeight(),
													  isVertical,
													  isMouseOver(),
													  isMouseButtonDown());
}

void StretchableLayoutResizerBar::mouseDown (const MouseEvent&)
{
	mouseDownPos = layout->getItemCurrentPosition (itemIndex);
}

void StretchableLayoutResizerBar::mouseDrag (const MouseEvent& e)
{
	const int desiredPos = mouseDownPos + (isVertical ? e.getDistanceFromDragStartX()
													  : e.getDistanceFromDragStartY());

	if (layout->getItemCurrentPosition (itemIndex) != desiredPos)
	{
		layout->setItemPosition (itemIndex, desiredPos);
		hasBeenMoved();
	}
}

void StretchableLayoutResizerBar::hasBeenMoved()
{
	if (getParentComponent() != nullptr)
		getParentComponent()->resized();
}

/*** End of inlined file: juce_StretchableLayoutResizerBar.cpp ***/


/*** Start of inlined file: juce_StretchableObjectResizer.cpp ***/
StretchableObjectResizer::StretchableObjectResizer()
{
}

StretchableObjectResizer::~StretchableObjectResizer()
{
}

void StretchableObjectResizer::addItem (const double size,
										const double minSize, const double maxSize,
										const int order)
{
	// the order must be >= 0 but less than the maximum integer value.
	jassert (order >= 0 && order < std::numeric_limits<int>::max());

	Item* const item = new Item();
	item->size = size;
	item->minSize = minSize;
	item->maxSize = maxSize;
	item->order = order;
	items.add (item);
}

double StretchableObjectResizer::getItemSize (const int index) const noexcept
{
	const Item* const it = items [index];
	return it != nullptr ? it->size : 0;
}

void StretchableObjectResizer::resizeToFit (const double targetSize)
{
	int order = 0;

	for (;;)
	{
		double currentSize = 0;
		double minSize = 0;
		double maxSize = 0;

		int nextHighestOrder = std::numeric_limits<int>::max();

		for (int i = 0; i < items.size(); ++i)
		{
			const Item* const it = items.getUnchecked(i);
			currentSize += it->size;

			if (it->order <= order)
			{
				minSize += it->minSize;
				maxSize += it->maxSize;
			}
			else
			{
				minSize += it->size;
				maxSize += it->size;
				nextHighestOrder = jmin (nextHighestOrder, it->order);
			}
		}

		const double thisIterationTarget = jlimit (minSize, maxSize, targetSize);

		if (thisIterationTarget >= currentSize)
		{
			const double availableExtraSpace = maxSize - currentSize;
			const double targetAmountOfExtraSpace = thisIterationTarget - currentSize;
			const double scale = targetAmountOfExtraSpace / availableExtraSpace;

			for (int i = 0; i < items.size(); ++i)
			{
				Item* const it = items.getUnchecked(i);

				if (it->order <= order)
					it->size = jmin (it->maxSize, it->size + (it->maxSize - it->size) * scale);
			}
		}
		else
		{
			const double amountOfSlack = currentSize - minSize;
			const double targetAmountOfSlack = thisIterationTarget - minSize;
			const double scale = targetAmountOfSlack / amountOfSlack;

			for (int i = 0; i < items.size(); ++i)
			{
				Item* const it = items.getUnchecked(i);

				if (it->order <= order)
					it->size = jmax (it->minSize, it->minSize + (it->size - it->minSize) * scale);
			}
		}

		if (nextHighestOrder < std::numeric_limits<int>::max())
			order = nextHighestOrder;
		else
			break;
	}
}

/*** End of inlined file: juce_StretchableObjectResizer.cpp ***/


/*** Start of inlined file: juce_TabbedButtonBar.cpp ***/
TabBarButton::TabBarButton (const String& name, TabbedButtonBar& owner_)
	: Button (name),
	  owner (owner_),
	  overlapPixels (0)
{
	shadow.setShadowProperties (2.2f, 0.7f, 0, 0);
	setComponentEffect (&shadow);
	setWantsKeyboardFocus (false);
}

TabBarButton::~TabBarButton()
{
}

int TabBarButton::getIndex() const
{
	return owner.indexOfTabButton (this);
}

void TabBarButton::paintButton (Graphics& g,
								bool isMouseOverButton,
								bool isButtonDown)
{
	const Rectangle<int> area (getActiveArea());
	g.setOrigin (area.getX(), area.getY());

	getLookAndFeel()
		.drawTabButton (g, area.getWidth(), area.getHeight(),
						owner.getTabBackgroundColour (getIndex()),
						getIndex(), getButtonText(), *this,
						owner.getOrientation(),
						isMouseOverButton, isButtonDown,
						getToggleState());
}

void TabBarButton::clicked (const ModifierKeys& mods)
{
	if (mods.isPopupMenu())
		owner.popupMenuClickOnTab (getIndex(), getButtonText());
	else
		owner.setCurrentTabIndex (getIndex());
}

bool TabBarButton::hitTest (int mx, int my)
{
	const Rectangle<int> area (getActiveArea());

	if (owner.getOrientation() == TabbedButtonBar::TabsAtLeft
		 || owner.getOrientation() == TabbedButtonBar::TabsAtRight)
	{
		if (isPositiveAndBelow (mx, getWidth())
			 && my >= area.getY() + overlapPixels
			 && my < area.getBottom() - overlapPixels)
			return true;
	}
	else
	{
		if (mx >= area.getX() + overlapPixels && mx < area.getRight() - overlapPixels
			 && isPositiveAndBelow (my, getHeight()))
			return true;
	}

	Path p;
	getLookAndFeel()
		.createTabButtonShape (p, area.getWidth(), area.getHeight(), getIndex(), getButtonText(), *this,
							   owner.getOrientation(), false, false, getToggleState());

	return p.contains ((float) (mx - area.getX()),
					   (float) (my - area.getY()));
}

int TabBarButton::getBestTabLength (const int depth)
{
	return jlimit (depth * 2,
				   depth * 7,
				   getLookAndFeel().getTabButtonBestWidth (getIndex(), getButtonText(), depth, *this));
}

Rectangle<int> TabBarButton::getActiveArea()
{
	Rectangle<int> r (getLocalBounds());
	const int spaceAroundImage = getLookAndFeel().getTabButtonSpaceAroundImage();

	if (owner.getOrientation() != TabbedButtonBar::TabsAtLeft)      r.removeFromRight (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtRight)     r.removeFromLeft (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtBottom)    r.removeFromTop (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtTop)       r.removeFromBottom (spaceAroundImage);

	return r;
}

class TabbedButtonBar::BehindFrontTabComp  : public Component,
											 public ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:
	BehindFrontTabComp (TabbedButtonBar& owner_)
		: owner (owner_)
	{
		setInterceptsMouseClicks (false, false);
	}

	void paint (Graphics& g)
	{
		getLookAndFeel().drawTabAreaBehindFrontButton (g, getWidth(), getHeight(),
													   owner, owner.getOrientation());
	}

	void enablementChanged()
	{
		repaint();
	}

	void buttonClicked (Button*)
	{
		owner.showExtraItemsMenu();
	}

private:
	TabbedButtonBar& owner;

	JUCE_DECLARE_NON_COPYABLE (BehindFrontTabComp);
};

TabbedButtonBar::TabbedButtonBar (const Orientation orientation_)
	: orientation (orientation_),
	  minimumScale (0.7),
	  currentTabIndex (-1)
{
	setInterceptsMouseClicks (false, true);
	addAndMakeVisible (behindFrontTab = new BehindFrontTabComp (*this));
	setFocusContainer (true);
}

TabbedButtonBar::~TabbedButtonBar()
{
	tabs.clear();
	extraTabsButton = nullptr;
}

void TabbedButtonBar::setOrientation (const Orientation newOrientation)
{
	orientation = newOrientation;

	for (int i = getNumChildComponents(); --i >= 0;)
		getChildComponent (i)->resized();

	resized();
}

TabBarButton* TabbedButtonBar::createTabButton (const String& name, const int /*index*/)
{
	return new TabBarButton (name, *this);
}

void TabbedButtonBar::setMinimumTabScaleFactor (double newMinimumScale)
{
	minimumScale = newMinimumScale;
	resized();
}

void TabbedButtonBar::clearTabs()
{
	tabs.clear();
	extraTabsButton = nullptr;
	setCurrentTabIndex (-1);
}

void TabbedButtonBar::addTab (const String& tabName,
							  const Colour& tabBackgroundColour,
							  int insertIndex)
{
	jassert (tabName.isNotEmpty()); // you have to give them all a name..

	if (tabName.isNotEmpty())
	{
		if (! isPositiveAndBelow (insertIndex, tabs.size()))
			insertIndex = tabs.size();

		TabInfo* const currentTab = tabs [currentTabIndex];

		TabInfo* newTab = new TabInfo();
		newTab->name = tabName;
		newTab->colour = tabBackgroundColour;
		newTab->component = createTabButton (tabName, insertIndex);
		jassert (newTab->component != nullptr);

		tabs.insert (insertIndex, newTab);
		currentTabIndex = tabs.indexOf (currentTab);
		addAndMakeVisible (newTab->component, insertIndex);

		resized();

		if (currentTabIndex < 0)
			setCurrentTabIndex (0);
	}
}

void TabbedButtonBar::setTabName (const int tabIndex, const String& newName)
{
	TabInfo* const tab = tabs [tabIndex];

	if (tab != nullptr && tab->name != newName)
	{
		tab->name = newName;
		tab->component->setButtonText (newName);
		resized();
	}
}

void TabbedButtonBar::removeTab (const int tabIndex)
{
	if (tabIndex == currentTabIndex)
		setCurrentTabIndex (-1);

	TabInfo* const currentTab = tabs [currentTabIndex];
	tabs.remove (tabIndex);
	currentTabIndex = tabs.indexOf (currentTab);
	resized();
}

void TabbedButtonBar::moveTab (const int currentIndex, const int newIndex)
{
	TabInfo* const currentTab = tabs [currentTabIndex];
	tabs.move (currentIndex, newIndex);
	currentTabIndex = tabs.indexOf (currentTab);
	resized();
}

int TabbedButtonBar::getNumTabs() const
{
	return tabs.size();
}

String TabbedButtonBar::getCurrentTabName() const
{
	TabInfo* tab = tabs [currentTabIndex];
	return tab == nullptr ? String::empty : tab->name;
}

StringArray TabbedButtonBar::getTabNames() const
{
	StringArray names;

	for (int i = 0; i < tabs.size(); ++i)
		names.add (tabs.getUnchecked(i)->name);

	return names;
}

void TabbedButtonBar::setCurrentTabIndex (int newIndex, const bool sendChangeMessage_)
{
	if (currentTabIndex != newIndex)
	{
		if (! isPositiveAndBelow (newIndex, tabs.size()))
			newIndex = -1;

		currentTabIndex = newIndex;

		for (int i = 0; i < tabs.size(); ++i)
		{
			TabBarButton* tb = tabs.getUnchecked(i)->component;
			tb->setToggleState (i == newIndex, false);
		}

		resized();

		if (sendChangeMessage_)
			sendChangeMessage();

		currentTabChanged (newIndex, getCurrentTabName());
	}
}

TabBarButton* TabbedButtonBar::getTabButton (const int index) const
{
	TabInfo* const tab = tabs[index];
	return tab == nullptr ? nullptr : static_cast <TabBarButton*> (tab->component);
}

int TabbedButtonBar::indexOfTabButton (const TabBarButton* button) const
{
	for (int i = tabs.size(); --i >= 0;)
		if (tabs.getUnchecked(i)->component == button)
			return i;

	return -1;
}

void TabbedButtonBar::lookAndFeelChanged()
{
	extraTabsButton = nullptr;
	resized();
}

void TabbedButtonBar::resized()
{
	int depth = getWidth();
	int length = getHeight();

	if (orientation == TabsAtTop || orientation == TabsAtBottom)
		std::swap (depth, length);

	const int overlap = getLookAndFeel().getTabButtonOverlap (depth)
							+ getLookAndFeel().getTabButtonSpaceAroundImage() * 2;

	int i, totalLength = overlap;
	int numVisibleButtons = tabs.size();

	for (i = 0; i < tabs.size(); ++i)
	{
		TabBarButton* const tb = tabs.getUnchecked(i)->component;

		totalLength += tb->getBestTabLength (depth) - overlap;
		tb->overlapPixels = overlap / 2;
	}

	double scale = 1.0;

	if (totalLength > length)
		scale = jmax (minimumScale, length / (double) totalLength);

	const bool isTooBig = totalLength * scale > length;
	int tabsButtonPos = 0;

	if (isTooBig)
	{
		if (extraTabsButton == nullptr)
		{
			addAndMakeVisible (extraTabsButton = getLookAndFeel().createTabBarExtrasButton());
			extraTabsButton->addListener (behindFrontTab);
			extraTabsButton->setAlwaysOnTop (true);
			extraTabsButton->setTriggeredOnMouseDown (true);
		}

		const int buttonSize = jmin (proportionOfWidth (0.7f), proportionOfHeight (0.7f));
		extraTabsButton->setSize (buttonSize, buttonSize);

		if (orientation == TabsAtTop || orientation == TabsAtBottom)
		{
			tabsButtonPos = getWidth() - buttonSize / 2 - 1;
			extraTabsButton->setCentrePosition (tabsButtonPos, getHeight() / 2);
		}
		else
		{
			tabsButtonPos = getHeight() - buttonSize / 2 - 1;
			extraTabsButton->setCentrePosition (getWidth() / 2, tabsButtonPos);
		}

		totalLength = 0;

		for (i = 0; i < tabs.size(); ++i)
		{
			TabBarButton* const tb = tabs.getUnchecked(i)->component;

			const int newLength = totalLength + tb->getBestTabLength (depth);

			if (i > 0 && newLength * minimumScale > tabsButtonPos)
			{
				totalLength += overlap;
				break;
			}

			numVisibleButtons = i + 1;
			totalLength = newLength - overlap;
		}

		scale = jmax (minimumScale, tabsButtonPos / (double) totalLength);
	}
	else
	{
		extraTabsButton = nullptr;
	}

	int pos = 0;

	TabBarButton* frontTab = nullptr;

	for (i = 0; i < tabs.size(); ++i)
	{
		TabBarButton* const tb = getTabButton (i);

		if (tb != nullptr)
		{
			const int bestLength = roundToInt (scale * tb->getBestTabLength (depth));

			if (i < numVisibleButtons)
			{
				if (orientation == TabsAtTop || orientation == TabsAtBottom)
					tb->setBounds (pos, 0, bestLength, getHeight());
				else
					tb->setBounds (0, pos, getWidth(), bestLength);

				tb->toBack();

				if (i == currentTabIndex)
					frontTab = tb;

				tb->setVisible (true);
			}
			else
			{
				tb->setVisible (false);
			}

			pos += bestLength - overlap;
		}
	}

	behindFrontTab->setBounds (getLocalBounds());

	if (frontTab != nullptr)
	{
		frontTab->toFront (false);
		behindFrontTab->toBehind (frontTab);
	}
}

Colour TabbedButtonBar::getTabBackgroundColour (const int tabIndex)
{
	TabInfo* const tab = tabs [tabIndex];
	return tab == nullptr ? Colours::white : tab->colour;
}

void TabbedButtonBar::setTabBackgroundColour (const int tabIndex, const Colour& newColour)
{
	TabInfo* const tab = tabs [tabIndex];

	if (tab != nullptr && tab->colour != newColour)
	{
		tab->colour = newColour;
		repaint();
	}
}

void TabbedButtonBar::extraItemsMenuCallback (int result, TabbedButtonBar* bar)
{
	if (bar != nullptr && result > 0)
		bar->setCurrentTabIndex (result - 1);
}

void TabbedButtonBar::showExtraItemsMenu()
{
	PopupMenu m;

	for (int i = 0; i < tabs.size(); ++i)
	{
		const TabInfo* const tab = tabs.getUnchecked(i);

		if (! tab->component->isVisible())
			m.addItem (i + 1, tab->name, true, i == currentTabIndex);
	}

	m.showMenuAsync (PopupMenu::Options().withTargetComponent (extraTabsButton),
					 ModalCallbackFunction::forComponent (extraItemsMenuCallback, this));
}

void TabbedButtonBar::currentTabChanged (const int, const String&)
{
}

void TabbedButtonBar::popupMenuClickOnTab (const int, const String&)
{
}

/*** End of inlined file: juce_TabbedButtonBar.cpp ***/


/*** Start of inlined file: juce_TabbedComponent.cpp ***/
namespace TabbedComponentHelpers
{
	const Identifier deleteComponentId ("deleteByTabComp_");

	static void deleteIfNecessary (Component* const comp)
	{
		if (comp != nullptr && (bool) comp->getProperties() [deleteComponentId])
			delete comp;
	}

	static Rectangle<int> getTabArea (Rectangle<int>& content, BorderSize<int>& outline,
									  const TabbedButtonBar::Orientation orientation, const int tabDepth)
	{
		switch (orientation)
		{
			case TabbedButtonBar::TabsAtTop:    outline.setTop (0);     return content.removeFromTop (tabDepth);
			case TabbedButtonBar::TabsAtBottom: outline.setBottom (0);  return content.removeFromBottom (tabDepth);
			case TabbedButtonBar::TabsAtLeft:   outline.setLeft (0);    return content.removeFromLeft (tabDepth);
			case TabbedButtonBar::TabsAtRight:  outline.setRight (0);   return content.removeFromRight (tabDepth);
			default: jassertfalse; break;
		}

		return Rectangle<int>();
	}
}

class TabbedComponent::ButtonBar  : public TabbedButtonBar
{
public:
	ButtonBar (TabbedComponent& owner_, const TabbedButtonBar::Orientation orientation_)
		: TabbedButtonBar (orientation_),
		  owner (owner_)
	{
	}

	void currentTabChanged (int newCurrentTabIndex, const String& newTabName)
	{
		owner.changeCallback (newCurrentTabIndex, newTabName);
	}

	void popupMenuClickOnTab (int tabIndex, const String& tabName)
	{
		owner.popupMenuClickOnTab (tabIndex, tabName);
	}

	Colour getTabBackgroundColour (const int tabIndex)
	{
		return owner.tabs->getTabBackgroundColour (tabIndex);
	}

	TabBarButton* createTabButton (const String& tabName, int tabIndex)
	{
		return owner.createTabButton (tabName, tabIndex);
	}

private:
	TabbedComponent& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ButtonBar);
};

TabbedComponent::TabbedComponent (const TabbedButtonBar::Orientation orientation)
	: tabDepth (30),
	  outlineThickness (1),
	  edgeIndent (0)
{
	addAndMakeVisible (tabs = new ButtonBar (*this, orientation));
}

TabbedComponent::~TabbedComponent()
{
	clearTabs();
	tabs = nullptr;
}

void TabbedComponent::setOrientation (const TabbedButtonBar::Orientation orientation)
{
	tabs->setOrientation (orientation);
	resized();
}

TabbedButtonBar::Orientation TabbedComponent::getOrientation() const noexcept
{
	return tabs->getOrientation();
}

void TabbedComponent::setTabBarDepth (const int newDepth)
{
	if (tabDepth != newDepth)
	{
		tabDepth = newDepth;
		resized();
	}
}

TabBarButton* TabbedComponent::createTabButton (const String& tabName, const int /*tabIndex*/)
{
	return new TabBarButton (tabName, *tabs);
}

void TabbedComponent::clearTabs()
{
	if (panelComponent != nullptr)
	{
		panelComponent->setVisible (false);
		removeChildComponent (panelComponent);
		panelComponent = nullptr;
	}

	tabs->clearTabs();

	for (int i = contentComponents.size(); --i >= 0;)
		TabbedComponentHelpers::deleteIfNecessary (contentComponents.getReference (i));

	contentComponents.clear();
}

void TabbedComponent::addTab (const String& tabName,
							  const Colour& tabBackgroundColour,
							  Component* const contentComponent,
							  const bool deleteComponentWhenNotNeeded,
							  const int insertIndex)
{
	contentComponents.insert (insertIndex, WeakReference<Component> (contentComponent));

	if (deleteComponentWhenNotNeeded && contentComponent != nullptr)
		contentComponent->getProperties().set (TabbedComponentHelpers::deleteComponentId, true);

	tabs->addTab (tabName, tabBackgroundColour, insertIndex);
	resized();
}

void TabbedComponent::setTabName (const int tabIndex, const String& newName)
{
	tabs->setTabName (tabIndex, newName);
}

void TabbedComponent::removeTab (const int tabIndex)
{
	if (isPositiveAndBelow (tabIndex, contentComponents.size()))
	{
		TabbedComponentHelpers::deleteIfNecessary (contentComponents.getReference (tabIndex));
		contentComponents.remove (tabIndex);
		tabs->removeTab (tabIndex);
	}
}

int TabbedComponent::getNumTabs() const
{
	return tabs->getNumTabs();
}

StringArray TabbedComponent::getTabNames() const
{
	return tabs->getTabNames();
}

Component* TabbedComponent::getTabContentComponent (const int tabIndex) const noexcept
{
	return contentComponents [tabIndex];
}

Colour TabbedComponent::getTabBackgroundColour (const int tabIndex) const noexcept
{
	return tabs->getTabBackgroundColour (tabIndex);
}

void TabbedComponent::setTabBackgroundColour (const int tabIndex, const Colour& newColour)
{
	tabs->setTabBackgroundColour (tabIndex, newColour);

	if (getCurrentTabIndex() == tabIndex)
		repaint();
}

void TabbedComponent::setCurrentTabIndex (const int newTabIndex, const bool sendChangeMessage)
{
	tabs->setCurrentTabIndex (newTabIndex, sendChangeMessage);
}

int TabbedComponent::getCurrentTabIndex() const
{
	return tabs->getCurrentTabIndex();
}

String TabbedComponent::getCurrentTabName() const
{
	return tabs->getCurrentTabName();
}

void TabbedComponent::setOutline (const int thickness)
{
	outlineThickness = thickness;
	resized();
	repaint();
}

void TabbedComponent::setIndent (const int indentThickness)
{
	edgeIndent = indentThickness;
	resized();
	repaint();
}

void TabbedComponent::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));

	Rectangle<int> content (getLocalBounds());
	BorderSize<int> outline (outlineThickness);
	TabbedComponentHelpers::getTabArea (content, outline, getOrientation(), tabDepth);

	g.reduceClipRegion (content);
	g.fillAll (tabs->getTabBackgroundColour (getCurrentTabIndex()));

	if (outlineThickness > 0)
	{
		RectangleList rl (content);
		rl.subtract (outline.subtractedFrom (content));

		g.reduceClipRegion (rl);
		g.fillAll (findColour (outlineColourId));
	}
}

void TabbedComponent::resized()
{
	Rectangle<int> content (getLocalBounds());
	BorderSize<int> outline (outlineThickness);

	tabs->setBounds (TabbedComponentHelpers::getTabArea (content, outline, getOrientation(), tabDepth));
	content = BorderSize<int> (edgeIndent).subtractedFrom (outline.subtractedFrom (content));

	for (int i = contentComponents.size(); --i >= 0;)
		if (contentComponents.getReference (i) != nullptr)
			contentComponents.getReference (i)->setBounds (content);
}

void TabbedComponent::lookAndFeelChanged()
{
	for (int i = contentComponents.size(); --i >= 0;)
		if (contentComponents.getReference (i) != nullptr)
			contentComponents.getReference (i)->lookAndFeelChanged();
}

void TabbedComponent::changeCallback (const int newCurrentTabIndex, const String& newTabName)
{
	if (panelComponent != nullptr)
	{
		panelComponent->setVisible (false);
		removeChildComponent (panelComponent);
		panelComponent = nullptr;
	}

	if (getCurrentTabIndex() >= 0)
	{
		panelComponent = getTabContentComponent (getCurrentTabIndex());

		if (panelComponent != nullptr)
		{
			// do these ops as two stages instead of addAndMakeVisible() so that the
			// component has always got a parent when it gets the visibilityChanged() callback
			addChildComponent (panelComponent);
			panelComponent->setVisible (true);
			panelComponent->toFront (true);
		}

		repaint();
	}

	resized();

	currentTabChanged (newCurrentTabIndex, newTabName);
}

void TabbedComponent::currentTabChanged (const int, const String&) {}
void TabbedComponent::popupMenuClickOnTab (const int, const String&) {}

/*** End of inlined file: juce_TabbedComponent.cpp ***/


/*** Start of inlined file: juce_Viewport.cpp ***/
Viewport::Viewport (const String& name)
  : Component (name),
	scrollBarThickness (0),
	singleStepX (16),
	singleStepY (16),
	showHScrollbar (true),
	showVScrollbar (true),
	deleteContent (true),
	verticalScrollBar (true),
	horizontalScrollBar (false)
{
	// content holder is used to clip the contents so they don't overlap the scrollbars
	addAndMakeVisible (&contentHolder);
	contentHolder.setInterceptsMouseClicks (false, true);

	addChildComponent (&verticalScrollBar);
	addChildComponent (&horizontalScrollBar);

	verticalScrollBar.addListener (this);
	horizontalScrollBar.addListener (this);

	setInterceptsMouseClicks (false, true);
	setWantsKeyboardFocus (true);
}

Viewport::~Viewport()
{
	deleteContentComp();
}

void Viewport::visibleAreaChanged (const Rectangle<int>&) {}
void Viewport::viewedComponentChanged (Component*) {}

void Viewport::deleteContentComp()
{
	if (contentComp != nullptr)
		contentComp->removeComponentListener (this);

	if (deleteContent)
	{
		// This sets the content comp to a null pointer before deleting the old one, in case
		// anything tries to use the old one while it's in mid-deletion..
		ScopedPointer<Component> oldCompDeleter (contentComp);
	}
	else
	{
		contentComp = nullptr;
	}
}

void Viewport::setViewedComponent (Component* const newViewedComponent, const bool deleteComponentWhenNoLongerNeeded)
{
	if (contentComp.get() != newViewedComponent)
	{
		deleteContentComp();
		contentComp = newViewedComponent;
		deleteContent = deleteComponentWhenNoLongerNeeded;

		if (contentComp != nullptr)
		{
			contentHolder.addAndMakeVisible (contentComp);
			setViewPosition (Point<int>());
			contentComp->addComponentListener (this);
		}

		viewedComponentChanged (contentComp);
		updateVisibleArea();
	}
}

int Viewport::getMaximumVisibleWidth() const    { return contentHolder.getWidth(); }
int Viewport::getMaximumVisibleHeight() const   { return contentHolder.getHeight(); }

Point<int> Viewport::viewportPosToCompPos (const Point<int>& pos) const
{
	jassert (contentComp != nullptr);
	return Point<int> (jmax (jmin (0, contentHolder.getWidth()  - contentComp->getWidth()),  jmin (0, -(pos.x))),
					   jmax (jmin (0, contentHolder.getHeight() - contentComp->getHeight()), jmin (0, -(pos.y))));
}

void Viewport::setViewPosition (const int xPixelsOffset, const int yPixelsOffset)
{
	setViewPosition (Point<int> (xPixelsOffset, yPixelsOffset));
}

void Viewport::setViewPosition (const Point<int>& newPosition)
{
	if (contentComp != nullptr)
		contentComp->setTopLeftPosition (viewportPosToCompPos (newPosition));
}

void Viewport::setViewPositionProportionately (const double x, const double y)
{
	if (contentComp != nullptr)
		setViewPosition (jmax (0, roundToInt (x * (contentComp->getWidth()  - getWidth()))),
						 jmax (0, roundToInt (y * (contentComp->getHeight() - getHeight()))));
}

bool Viewport::autoScroll (const int mouseX, const int mouseY, const int activeBorderThickness, const int maximumSpeed)
{
	if (contentComp != nullptr)
	{
		int dx = 0, dy = 0;

		if (horizontalScrollBar.isVisible() || contentComp->getX() < 0 || contentComp->getRight() > getWidth())
		{
			if (mouseX < activeBorderThickness)
				dx = activeBorderThickness - mouseX;
			else if (mouseX >= contentHolder.getWidth() - activeBorderThickness)
				dx = (contentHolder.getWidth() - activeBorderThickness) - mouseX;

			if (dx < 0)
				dx = jmax (dx, -maximumSpeed, contentHolder.getWidth() - contentComp->getRight());
			else
				dx = jmin (dx, maximumSpeed, -contentComp->getX());
		}

		if (verticalScrollBar.isVisible() || contentComp->getY() < 0 || contentComp->getBottom() > getHeight())
		{
			if (mouseY < activeBorderThickness)
				dy = activeBorderThickness - mouseY;
			else if (mouseY >= contentHolder.getHeight() - activeBorderThickness)
				dy = (contentHolder.getHeight() - activeBorderThickness) - mouseY;

			if (dy < 0)
				dy = jmax (dy, -maximumSpeed, contentHolder.getHeight() - contentComp->getBottom());
			else
				dy = jmin (dy, maximumSpeed, -contentComp->getY());
		}

		if (dx != 0 || dy != 0)
		{
			contentComp->setTopLeftPosition (contentComp->getX() + dx,
											 contentComp->getY() + dy);

			return true;
		}
	}

	return false;
}

void Viewport::componentMovedOrResized (Component&, bool, bool)
{
	updateVisibleArea();
}

void Viewport::resized()
{
	updateVisibleArea();
}

void Viewport::updateVisibleArea()
{
	const int scrollbarWidth = getScrollBarThickness();
	const bool canShowAnyBars = getWidth() > scrollbarWidth && getHeight() > scrollbarWidth;
	const bool canShowHBar = showHScrollbar && canShowAnyBars;
	const bool canShowVBar = showVScrollbar && canShowAnyBars;

	bool hBarVisible = false, vBarVisible = false;
	Rectangle<int> contentArea;

	for (int i = 3; --i >= 0;)
	{
		hBarVisible = canShowHBar && ! horizontalScrollBar.autoHides();
		vBarVisible = canShowVBar && ! verticalScrollBar.autoHides();
		contentArea = getLocalBounds();

		if (contentComp != nullptr && ! contentArea.contains (contentComp->getBounds()))
		{
			hBarVisible = canShowHBar && (hBarVisible || contentComp->getX() < 0 || contentComp->getRight() > contentArea.getWidth());
			vBarVisible = canShowVBar && (vBarVisible || contentComp->getY() < 0 || contentComp->getBottom() > contentArea.getHeight());

			if (vBarVisible)
				contentArea.setWidth (getWidth() - scrollbarWidth);

			if (hBarVisible)
				contentArea.setHeight (getHeight() - scrollbarWidth);

			if (! contentArea.contains (contentComp->getBounds()))
			{
				hBarVisible = canShowHBar && (hBarVisible || contentComp->getRight() > contentArea.getWidth());
				vBarVisible = canShowVBar && (vBarVisible || contentComp->getBottom() > contentArea.getHeight());
			}
		}

		if (vBarVisible)  contentArea.setWidth  (getWidth()  - scrollbarWidth);
		if (hBarVisible)  contentArea.setHeight (getHeight() - scrollbarWidth);

		if (contentComp == nullptr)
		{
			contentHolder.setBounds (contentArea);
			break;
		}

		const Rectangle<int> oldContentBounds (contentComp->getBounds());
		contentHolder.setBounds (contentArea);

		// If the content has changed its size, that might affect our scrollbars, so go round again and re-caclulate..
		if (oldContentBounds == contentComp->getBounds())
			break;
	}

	Rectangle<int> contentBounds;
	if (contentComp != nullptr)
		contentBounds = contentHolder.getLocalArea (contentComp, contentComp->getLocalBounds());

	Point<int> visibleOrigin (-contentBounds.getPosition());

	if (hBarVisible)
	{
		horizontalScrollBar.setBounds (0, contentArea.getHeight(), contentArea.getWidth(), scrollbarWidth);
		horizontalScrollBar.setRangeLimits (0.0, contentBounds.getWidth());
		horizontalScrollBar.setCurrentRange (visibleOrigin.x, contentArea.getWidth());
		horizontalScrollBar.setSingleStepSize (singleStepX);
		horizontalScrollBar.cancelPendingUpdate();
	}
	else if (canShowHBar)
	{
		visibleOrigin.setX (0);
	}

	if (vBarVisible)
	{
		verticalScrollBar.setBounds (contentArea.getWidth(), 0, scrollbarWidth, contentArea.getHeight());
		verticalScrollBar.setRangeLimits (0.0, contentBounds.getHeight());
		verticalScrollBar.setCurrentRange (visibleOrigin.y, contentArea.getHeight());
		verticalScrollBar.setSingleStepSize (singleStepY);
		verticalScrollBar.cancelPendingUpdate();
	}
	else if (canShowVBar)
	{
		visibleOrigin.setY (0);
	}

	// Force the visibility *after* setting the ranges to avoid flicker caused by edge conditions in the numbers.
	horizontalScrollBar.setVisible (hBarVisible);
	verticalScrollBar.setVisible (vBarVisible);

	if (contentComp != nullptr)
	{
		const Point<int> newContentCompPos (viewportPosToCompPos (visibleOrigin));

		if (contentComp->getBounds().getPosition() != newContentCompPos)
		{
			contentComp->setTopLeftPosition (newContentCompPos);  // (this will re-entrantly call updateVisibleArea again)
			return;
		}
	}

	const Rectangle<int> visibleArea (visibleOrigin.x, visibleOrigin.y,
									  jmin (contentBounds.getWidth()  - visibleOrigin.x, contentArea.getWidth()),
									  jmin (contentBounds.getHeight() - visibleOrigin.y, contentArea.getHeight()));

	if (lastVisibleArea != visibleArea)
	{
		lastVisibleArea = visibleArea;
		visibleAreaChanged (visibleArea);
	}

	horizontalScrollBar.handleUpdateNowIfNeeded();
	verticalScrollBar.handleUpdateNowIfNeeded();
}

void Viewport::setSingleStepSizes (const int stepX, const int stepY)
{
	if (singleStepX != stepX || singleStepY != stepY)
	{
		singleStepX = stepX;
		singleStepY = stepY;
		updateVisibleArea();
	}
}

void Viewport::setScrollBarsShown (const bool showVerticalScrollbarIfNeeded,
								   const bool showHorizontalScrollbarIfNeeded)
{
	if (showVScrollbar != showVerticalScrollbarIfNeeded
		 || showHScrollbar != showHorizontalScrollbarIfNeeded)
	{
		showVScrollbar = showVerticalScrollbarIfNeeded;
		showHScrollbar = showHorizontalScrollbarIfNeeded;
		updateVisibleArea();
	}
}

void Viewport::setScrollBarThickness (const int thickness)
{
	if (scrollBarThickness != thickness)
	{
		scrollBarThickness = thickness;
		updateVisibleArea();
	}
}

int Viewport::getScrollBarThickness() const
{
	return scrollBarThickness > 0 ? scrollBarThickness
								  : getLookAndFeel().getDefaultScrollbarWidth();
}

void Viewport::setScrollBarButtonVisibility (const bool buttonsVisible)
{
	verticalScrollBar.setButtonVisibility (buttonsVisible);
	horizontalScrollBar.setButtonVisibility (buttonsVisible);
}

void Viewport::scrollBarMoved (ScrollBar* scrollBarThatHasMoved, double newRangeStart)
{
	const int newRangeStartInt = roundToInt (newRangeStart);

	if (scrollBarThatHasMoved == &horizontalScrollBar)
	{
		setViewPosition (newRangeStartInt, getViewPositionY());
	}
	else if (scrollBarThatHasMoved == &verticalScrollBar)
	{
		setViewPosition (getViewPositionX(), newRangeStartInt);
	}
}

void Viewport::mouseWheelMove (const MouseEvent& e, const float wheelIncrementX, const float wheelIncrementY)
{
	if (! useMouseWheelMoveIfNeeded (e, wheelIncrementX, wheelIncrementY))
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

bool Viewport::useMouseWheelMoveIfNeeded (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (! (e.mods.isAltDown() || e.mods.isCtrlDown()))
	{
		const bool hasVertBar = verticalScrollBar.isVisible();
		const bool hasHorzBar = horizontalScrollBar.isVisible();

		if (hasHorzBar || hasVertBar)
		{
			if (wheelIncrementX != 0)
			{
				wheelIncrementX *= 14.0f * singleStepX;
				wheelIncrementX = (wheelIncrementX < 0) ? jmin (wheelIncrementX, -1.0f)
														: jmax (wheelIncrementX, 1.0f);
			}

			if (wheelIncrementY != 0)
			{
				wheelIncrementY *= 14.0f * singleStepY;
				wheelIncrementY = (wheelIncrementY < 0) ? jmin (wheelIncrementY, -1.0f)
														: jmax (wheelIncrementY, 1.0f);
			}

			Point<int> pos (getViewPosition());

			if (wheelIncrementX != 0 && wheelIncrementY != 0 && hasHorzBar && hasVertBar)
			{
				pos.setX (pos.x - roundToInt (wheelIncrementX));
				pos.setY (pos.y - roundToInt (wheelIncrementY));
			}
			else if (hasHorzBar && (wheelIncrementX != 0 || e.mods.isShiftDown() || ! hasVertBar))
			{
				if (wheelIncrementX == 0 && ! hasVertBar)
					wheelIncrementX = wheelIncrementY;

				pos.setX (pos.x - roundToInt (wheelIncrementX));
			}
			else if (hasVertBar && wheelIncrementY != 0)
			{
				pos.setY (pos.y - roundToInt (wheelIncrementY));
			}

			if (pos != getViewPosition())
			{
				setViewPosition (pos);
				return true;
			}
		}
	}

	return false;
}

bool Viewport::keyPressed (const KeyPress& key)
{
	const bool isUpDownKey = key.isKeyCode (KeyPress::upKey)
								|| key.isKeyCode (KeyPress::downKey)
								|| key.isKeyCode (KeyPress::pageUpKey)
								|| key.isKeyCode (KeyPress::pageDownKey)
								|| key.isKeyCode (KeyPress::homeKey)
								|| key.isKeyCode (KeyPress::endKey);

	if (verticalScrollBar.isVisible() && isUpDownKey)
		return verticalScrollBar.keyPressed (key);

	const bool isLeftRightKey = key.isKeyCode (KeyPress::leftKey)
								 || key.isKeyCode (KeyPress::rightKey);

	if (horizontalScrollBar.isVisible() && (isUpDownKey || isLeftRightKey))
		return horizontalScrollBar.keyPressed (key);

	return false;
}

const Identifier Viewport::Ids::showScrollBarV ("showScrollBarV");
const Identifier Viewport::Ids::showScrollBarH ("showScrollBarH");
const Identifier Viewport::Ids::scrollBarWidth ("scrollBarWidth");

void Viewport::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setScrollBarsShown (state [Ids::showScrollBarV], state [Ids::showScrollBarH]);
	setScrollBarThickness (state [Ids::scrollBarWidth]);
}

/*** End of inlined file: juce_Viewport.cpp ***/


/*** Start of inlined file: juce_LookAndFeel.cpp ***/
namespace LookAndFeelHelpers
{
	static void createRoundedPath (Path& p,
								   const float x, const float y,
								   const float w, const float h,
								   const float cs,
								   const bool curveTopLeft, const bool curveTopRight,
								   const bool curveBottomLeft, const bool curveBottomRight) noexcept
	{
		const float cs2 = 2.0f * cs;

		if (curveTopLeft)
		{
			p.startNewSubPath (x, y + cs);
			p.addArc (x, y, cs2, cs2, float_Pi * 1.5f, float_Pi * 2.0f);
		}
		else
		{
			p.startNewSubPath (x, y);
		}

		if (curveTopRight)
		{
			p.lineTo (x + w - cs, y);
			p.addArc (x + w - cs2, y, cs2, cs2, 0.0f, float_Pi * 0.5f);
		}
		else
		{
			p.lineTo (x + w, y);
		}

		if (curveBottomRight)
		{
			p.lineTo (x + w, y + h - cs);
			p.addArc (x + w - cs2, y + h - cs2, cs2, cs2, float_Pi * 0.5f, float_Pi);
		}
		else
		{
			p.lineTo (x + w, y + h);
		}

		if (curveBottomLeft)
		{
			p.lineTo (x + cs, y + h);
			p.addArc (x, y + h - cs2, cs2, cs2, float_Pi, float_Pi * 1.5f);
		}
		else
		{
			p.lineTo (x, y + h);
		}

		p.closeSubPath();
	}

	static Colour createBaseColour (const Colour& buttonColour,
									const bool hasKeyboardFocus,
									const bool isMouseOverButton,
									const bool isButtonDown) noexcept
	{
		const float sat = hasKeyboardFocus ? 1.3f : 0.9f;
		const Colour baseColour (buttonColour.withMultipliedSaturation (sat));

		if (isButtonDown)
			return baseColour.contrasting (0.2f);
		else if (isMouseOverButton)
			return baseColour.contrasting (0.1f);

		return baseColour;
	}

	static TextLayout layoutTooltipText (const String& text, const Colour& colour) noexcept
	{
		const float tooltipFontSize = 13.0f;
		const int maxToolTipWidth = 400;

		AttributedString s;
		s.setJustification (Justification::centred);
		s.append (text, Font (tooltipFontSize, Font::bold), colour);

		TextLayout tl;
		tl.createLayoutWithBalancedLineLengths (s, (float) maxToolTipWidth);
		return tl;
	}
}

typedef Typeface::Ptr (*GetTypefaceForFont) (const Font&);
extern GetTypefaceForFont juce_getTypefaceForFont;

static Typeface::Ptr getTypefaceForFontFromLookAndFeel (const Font& font)
{
	return LookAndFeel::getDefaultLookAndFeel().getTypefaceForFont (font);
}

LookAndFeel::LookAndFeel()
	: useNativeAlertWindows (false)
{
	/* if this fails it means you're trying to create a LookAndFeel object before
	   the static Colours have been initialised. That ain't gonna work. It probably
	   means that you're using a static LookAndFeel object and that your compiler has
	   decided to intialise it before the Colours class.
	*/
	jassert (Colours::white == Colour (0xffffffff));

	// set up the standard set of colours..
	const uint32 textButtonColour      = 0xffbbbbff;
	const uint32 textHighlightColour   = 0x401111ee;
	const uint32 standardOutlineColour = 0xb2808080;

	static const uint32 standardColours[] =
	{
		TextButton::buttonColourId,                 textButtonColour,
		TextButton::buttonOnColourId,               0xff4444ff,
		TextButton::textColourOnId,                 0xff000000,
		TextButton::textColourOffId,                0xff000000,

		ComboBox::buttonColourId,                   0xffbbbbff,
		ComboBox::outlineColourId,                  standardOutlineColour,

		ToggleButton::textColourId,                 0xff000000,

		TextEditor::backgroundColourId,             0xffffffff,
		TextEditor::textColourId,                   0xff000000,
		TextEditor::highlightColourId,              textHighlightColour,
		TextEditor::highlightedTextColourId,        0xff000000,
		TextEditor::outlineColourId,                0x00000000,
		TextEditor::focusedOutlineColourId,         textButtonColour,
		TextEditor::shadowColourId,                 0x38000000,

		CaretComponent::caretColourId,              0xff000000,

		Label::backgroundColourId,                  0x00000000,
		Label::textColourId,                        0xff000000,
		Label::outlineColourId,                     0x00000000,

		ScrollBar::backgroundColourId,              0x00000000,
		ScrollBar::thumbColourId,                   0xffffffff,

		TreeView::linesColourId,                    0x4c000000,
		TreeView::backgroundColourId,               0x00000000,
		TreeView::dragAndDropIndicatorColourId,     0x80ff0000,

		PopupMenu::backgroundColourId,              0xffffffff,
		PopupMenu::textColourId,                    0xff000000,
		PopupMenu::headerTextColourId,              0xff000000,
		PopupMenu::highlightedTextColourId,         0xffffffff,
		PopupMenu::highlightedBackgroundColourId,   0x991111aa,

		ComboBox::textColourId,                     0xff000000,
		ComboBox::backgroundColourId,               0xffffffff,
		ComboBox::arrowColourId,                    0x99000000,

		ListBox::backgroundColourId,                0xffffffff,
		ListBox::outlineColourId,                   standardOutlineColour,
		ListBox::textColourId,                      0xff000000,

		Slider::backgroundColourId,                 0x00000000,
		Slider::thumbColourId,                      textButtonColour,
		Slider::trackColourId,                      0x7fffffff,
		Slider::rotarySliderFillColourId,           0x7f0000ff,
		Slider::rotarySliderOutlineColourId,        0x66000000,
		Slider::textBoxTextColourId,                0xff000000,
		Slider::textBoxBackgroundColourId,          0xffffffff,
		Slider::textBoxHighlightColourId,           textHighlightColour,
		Slider::textBoxOutlineColourId,             standardOutlineColour,

		ResizableWindow::backgroundColourId,        0xff777777,
		//DocumentWindow::textColourId,               0xff000000, // (this is deliberately not set)

		AlertWindow::backgroundColourId,            0xffededed,
		AlertWindow::textColourId,                  0xff000000,
		AlertWindow::outlineColourId,               0xff666666,

		ProgressBar::backgroundColourId,            0xffeeeeee,
		ProgressBar::foregroundColourId,            0xffaaaaee,

		TooltipWindow::backgroundColourId,          0xffeeeebb,
		TooltipWindow::textColourId,                0xff000000,
		TooltipWindow::outlineColourId,             0x4c000000,

		TabbedComponent::backgroundColourId,        0x00000000,
		TabbedComponent::outlineColourId,           0xff777777,
		TabbedButtonBar::tabOutlineColourId,        0x80000000,
		TabbedButtonBar::frontOutlineColourId,      0x90000000,

		Toolbar::backgroundColourId,                0xfff6f8f9,
		Toolbar::separatorColourId,                 0x4c000000,
		Toolbar::buttonMouseOverBackgroundColourId, 0x4c0000ff,
		Toolbar::buttonMouseDownBackgroundColourId, 0x800000ff,
		Toolbar::labelTextColourId,                 0xff000000,
		Toolbar::editingModeOutlineColourId,        0xffff0000,

		HyperlinkButton::textColourId,              0xcc1111ee,

		GroupComponent::outlineColourId,            0x66000000,
		GroupComponent::textColourId,               0xff000000,

		DirectoryContentsDisplayComponent::highlightColourId,   textHighlightColour,
		DirectoryContentsDisplayComponent::textColourId,        0xff000000,

		0x1000440, /*LassoComponent::lassoFillColourId*/        0x66dddddd,
		0x1000441, /*LassoComponent::lassoOutlineColourId*/     0x99111111,

		0x1005000, /*MidiKeyboardComponent::whiteNoteColourId*/               0xffffffff,
		0x1005001, /*MidiKeyboardComponent::blackNoteColourId*/               0xff000000,
		0x1005002, /*MidiKeyboardComponent::keySeparatorLineColourId*/        0x66000000,
		0x1005003, /*MidiKeyboardComponent::mouseOverKeyOverlayColourId*/     0x80ffff00,
		0x1005004, /*MidiKeyboardComponent::keyDownOverlayColourId*/          0xffb6b600,
		0x1005005, /*MidiKeyboardComponent::textLabelColourId*/               0xff000000,
		0x1005006, /*MidiKeyboardComponent::upDownButtonBackgroundColourId*/  0xffd3d3d3,
		0x1005007, /*MidiKeyboardComponent::upDownButtonArrowColourId*/       0xff000000,

		0x1004500, /*CodeEditorComponent::backgroundColourId*/                0xffffffff,
		0x1004502, /*CodeEditorComponent::highlightColourId*/                 textHighlightColour,
		0x1004503, /*CodeEditorComponent::defaultTextColourId*/               0xff000000,

		0x1007000, /*ColourSelector::backgroundColourId*/                     0xffe5e5e5,
		0x1007001, /*ColourSelector::labelTextColourId*/                      0xff000000,

		0x100ad00, /*KeyMappingEditorComponent::backgroundColourId*/          0x00000000,
		0x100ad01, /*KeyMappingEditorComponent::textColourId*/                0xff000000,

		FileSearchPathListComponent::backgroundColourId,        0xffffffff,

		FileChooserDialogBox::titleTextColourId,                0xff000000,

		DrawableButton::textColourId,                           0xff000000,
	};

	for (int i = 0; i < numElementsInArray (standardColours); i += 2)
		setColour (standardColours [i], Colour ((uint32) standardColours [i + 1]));

	juce_getTypefaceForFont = getTypefaceForFontFromLookAndFeel;
}

LookAndFeel::~LookAndFeel()
{
	masterReference.clear();
}

Colour LookAndFeel::findColour (const int colourId) const noexcept
{
	const int index = colourIds.indexOf (colourId);

	if (index >= 0)
		return colours [index];

	jassertfalse;
	return Colours::black;
}

void LookAndFeel::setColour (const int colourId, const Colour& colour) noexcept
{
	const int index = colourIds.indexOf (colourId);

	if (index >= 0)
	{
		colours.set (index, colour);
	}
	else
	{
		colourIds.add (colourId);
		colours.add (colour);
	}
}

bool LookAndFeel::isColourSpecified (const int colourId) const noexcept
{
	return colourIds.contains (colourId);
}

LookAndFeel& LookAndFeel::getDefaultLookAndFeel() noexcept
{
	return Desktop::getInstance().getDefaultLookAndFeel();
}

void LookAndFeel::setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel) noexcept
{
	Desktop::getInstance().setDefaultLookAndFeel (newDefaultLookAndFeel);
}

const Typeface::Ptr LookAndFeel::getTypefaceForFont (const Font& font)
{
	if (defaultSans.isNotEmpty() && font.getTypefaceName() == Font::getDefaultSansSerifFontName())
	{
		Font f (font);
		f.setTypefaceName (defaultSans);
		return Typeface::createSystemTypefaceFor (f);
	}

	return Font::getDefaultTypefaceForFont (font);
}

void LookAndFeel::setDefaultSansSerifTypefaceName (const String& newName)
{
	defaultSans = newName;
}

MouseCursor LookAndFeel::getMouseCursorFor (Component& component)
{
	return component.getMouseCursor();
}

LowLevelGraphicsContext* LookAndFeel::createGraphicsContext (const Image& imageToRenderOn, const Point<int>& origin, const RectangleList& initialClip)
{
	return new LowLevelGraphicsSoftwareRenderer (imageToRenderOn, origin, initialClip);
}

void LookAndFeel::drawButtonBackground (Graphics& g,
										Button& button,
										const Colour& backgroundColour,
										bool isMouseOverButton,
										bool isButtonDown)
{
	const int width = button.getWidth();
	const int height = button.getHeight();

	const float outlineThickness = button.isEnabled() ? ((isButtonDown || isMouseOverButton) ? 1.2f : 0.7f) : 0.4f;
	const float halfThickness = outlineThickness * 0.5f;

	const float indentL = button.isConnectedOnLeft()   ? 0.1f : halfThickness;
	const float indentR = button.isConnectedOnRight()  ? 0.1f : halfThickness;
	const float indentT = button.isConnectedOnTop()    ? 0.1f : halfThickness;
	const float indentB = button.isConnectedOnBottom() ? 0.1f : halfThickness;

	const Colour baseColour (LookAndFeelHelpers::createBaseColour (backgroundColour,
																   button.hasKeyboardFocus (true),
																   isMouseOverButton, isButtonDown)
							   .withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	drawGlassLozenge (g,
					  indentL,
					  indentT,
					  width - indentL - indentR,
					  height - indentT - indentB,
					  baseColour, outlineThickness, -1.0f,
					  button.isConnectedOnLeft(),
					  button.isConnectedOnRight(),
					  button.isConnectedOnTop(),
					  button.isConnectedOnBottom());
}

const Font LookAndFeel::getFontForTextButton (TextButton& button)
{
	return button.getFont();
}

void LookAndFeel::drawButtonText (Graphics& g, TextButton& button,
								  bool /*isMouseOverButton*/, bool /*isButtonDown*/)
{
	Font font (getFontForTextButton (button));
	g.setFont (font);
	g.setColour (button.findColour (button.getToggleState() ? TextButton::textColourOnId
															: TextButton::textColourOffId)
					   .withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	const int yIndent = jmin (4, button.proportionOfHeight (0.3f));
	const int cornerSize = jmin (button.getHeight(), button.getWidth()) / 2;

	const int fontHeight = roundToInt (font.getHeight() * 0.6f);
	const int leftIndent  = jmin (fontHeight, 2 + cornerSize / (button.isConnectedOnLeft() ? 4 : 2));
	const int rightIndent = jmin (fontHeight, 2 + cornerSize / (button.isConnectedOnRight() ? 4 : 2));

	g.drawFittedText (button.getButtonText(),
					  leftIndent,
					  yIndent,
					  button.getWidth() - leftIndent - rightIndent,
					  button.getHeight() - yIndent * 2,
					  Justification::centred, 2);
}

void LookAndFeel::drawTickBox (Graphics& g,
							   Component& component,
							   float x, float y, float w, float h,
							   const bool ticked,
							   const bool isEnabled,
							   const bool isMouseOverButton,
							   const bool isButtonDown)
{
	const float boxSize = w * 0.7f;

	drawGlassSphere (g, x, y + (h - boxSize) * 0.5f, boxSize,
					 LookAndFeelHelpers::createBaseColour (component.findColour (TextButton::buttonColourId)
																	.withMultipliedAlpha (isEnabled ? 1.0f : 0.5f),
														   true, isMouseOverButton, isButtonDown),
					 isEnabled ? ((isButtonDown || isMouseOverButton) ? 1.1f : 0.5f) : 0.3f);

	if (ticked)
	{
		Path tick;
		tick.startNewSubPath (1.5f, 3.0f);
		tick.lineTo (3.0f, 6.0f);
		tick.lineTo (6.0f, 0.0f);

		g.setColour (isEnabled ? Colours::black : Colours::grey);

		const AffineTransform trans (AffineTransform::scale (w / 9.0f, h / 9.0f)
										 .translated (x, y));

		g.strokePath (tick, PathStrokeType (2.5f), trans);
	}
}

void LookAndFeel::drawToggleButton (Graphics& g,
									ToggleButton& button,
									bool isMouseOverButton,
									bool isButtonDown)
{
	if (button.hasKeyboardFocus (true))
	{
		g.setColour (button.findColour (TextEditor::focusedOutlineColourId));
		g.drawRect (0, 0, button.getWidth(), button.getHeight());
	}

	float fontSize = jmin (15.0f, button.getHeight() * 0.75f);
	const float tickWidth = fontSize * 1.1f;

	drawTickBox (g, button, 4.0f, (button.getHeight() - tickWidth) * 0.5f,
				 tickWidth, tickWidth,
				 button.getToggleState(),
				 button.isEnabled(),
				 isMouseOverButton,
				 isButtonDown);

	g.setColour (button.findColour (ToggleButton::textColourId));
	g.setFont (fontSize);

	if (! button.isEnabled())
		g.setOpacity (0.5f);

	const int textX = (int) tickWidth + 5;

	g.drawFittedText (button.getButtonText(),
					  textX, 0,
					  button.getWidth() - textX - 2, button.getHeight(),
					  Justification::centredLeft, 10);
}

void LookAndFeel::changeToggleButtonWidthToFitText (ToggleButton& button)
{
	Font font (jmin (15.0f, button.getHeight() * 0.6f));

	const int tickWidth = jmin (24, button.getHeight());

	button.setSize (font.getStringWidth (button.getButtonText()) + tickWidth + 8,
					button.getHeight());
}

AlertWindow* LookAndFeel::createAlertWindow (const String& title,
											 const String& message,
											 const String& button1,
											 const String& button2,
											 const String& button3,
											 AlertWindow::AlertIconType iconType,
											 int numButtons,
											 Component* associatedComponent)
{
	AlertWindow* aw = new AlertWindow (title, message, iconType, associatedComponent);

	if (numButtons == 1)
	{
		aw->addButton (button1, 0,
					   KeyPress (KeyPress::escapeKey, 0, 0),
					   KeyPress (KeyPress::returnKey, 0, 0));
	}
	else
	{
		const KeyPress button1ShortCut ((int) CharacterFunctions::toLowerCase (button1[0]), 0, 0);
		KeyPress button2ShortCut ((int) CharacterFunctions::toLowerCase (button2[0]), 0, 0);
		if (button1ShortCut == button2ShortCut)
			button2ShortCut = KeyPress();

		if (numButtons == 2)
		{
			aw->addButton (button1, 1, KeyPress (KeyPress::returnKey, 0, 0), button1ShortCut);
			aw->addButton (button2, 0, KeyPress (KeyPress::escapeKey, 0, 0), button2ShortCut);
		}
		else if (numButtons == 3)
		{
			aw->addButton (button1, 1, button1ShortCut);
			aw->addButton (button2, 2, button2ShortCut);
			aw->addButton (button3, 0, KeyPress (KeyPress::escapeKey, 0, 0));
		}
	}

	return aw;
}

void LookAndFeel::drawAlertBox (Graphics& g,
								AlertWindow& alert,
								const Rectangle<int>& textArea,
								TextLayout& textLayout)
{
	g.fillAll (alert.findColour (AlertWindow::backgroundColourId));

	int iconSpaceUsed = 0;

	const int iconWidth = 80;
	int iconSize = jmin (iconWidth + 50, alert.getHeight() + 20);

	if (alert.containsAnyExtraComponents() || alert.getNumButtons() > 2)
		iconSize = jmin (iconSize, textArea.getHeight() + 50);

	const Rectangle<int> iconRect (iconSize / -10, iconSize / -10,
								   iconSize, iconSize);

	if (alert.getAlertType() != AlertWindow::NoIcon)
	{
		Path icon;
		uint32 colour;
		char character;

		if (alert.getAlertType() == AlertWindow::WarningIcon)
		{
			colour = 0x55ff5555;
			character = '!';

			icon.addTriangle (iconRect.getX() + iconRect.getWidth() * 0.5f, (float) iconRect.getY(),
							  (float) iconRect.getRight(), (float) iconRect.getBottom(),
							  (float) iconRect.getX(), (float) iconRect.getBottom());

			icon = icon.createPathWithRoundedCorners (5.0f);
		}
		else
		{
			colour    = alert.getAlertType() == AlertWindow::InfoIcon ? (uint32) 0x605555ff : (uint32) 0x40b69900;
			character = alert.getAlertType() == AlertWindow::InfoIcon ? 'i' : '?';

			icon.addEllipse ((float) iconRect.getX(), (float) iconRect.getY(),
							 (float) iconRect.getWidth(), (float) iconRect.getHeight());
		}

		GlyphArrangement ga;
		ga.addFittedText (Font (iconRect.getHeight() * 0.9f, Font::bold),
						  String::charToString ((juce_wchar) (uint8) character),
						  (float) iconRect.getX(), (float) iconRect.getY(),
						  (float) iconRect.getWidth(), (float) iconRect.getHeight(),
						  Justification::centred, false);
		ga.createPath (icon);

		icon.setUsingNonZeroWinding (false);
		g.setColour (Colour (colour));
		g.fillPath (icon);

		iconSpaceUsed = iconWidth;
	}

	g.setColour (alert.findColour (AlertWindow::textColourId));

	textLayout.draw (g, Rectangle<int> (textArea.getX() + iconSpaceUsed,
										textArea.getY(),
										textArea.getWidth() - iconSpaceUsed,
										textArea.getHeight()).toFloat());

	g.setColour (alert.findColour (AlertWindow::outlineColourId));
	g.drawRect (0, 0, alert.getWidth(), alert.getHeight());
}

int LookAndFeel::getAlertBoxWindowFlags()
{
	return ComponentPeer::windowAppearsOnTaskbar
			| ComponentPeer::windowHasDropShadow;
}

int LookAndFeel::getAlertWindowButtonHeight()
{
	return 28;
}

const Font LookAndFeel::getAlertWindowMessageFont()
{
	return Font (15.0f);
}

const Font LookAndFeel::getAlertWindowFont()
{
	return Font (12.0f);
}

void LookAndFeel::setUsingNativeAlertWindows (bool shouldUseNativeAlerts)
{
	useNativeAlertWindows = shouldUseNativeAlerts;
}

bool LookAndFeel::isUsingNativeAlertWindows()
{
   #if JUCE_LINUX
	return false; // not available currently..
   #else
	return useNativeAlertWindows;
   #endif
}

void LookAndFeel::drawProgressBar (Graphics& g, ProgressBar& progressBar,
								   int width, int height,
								   double progress, const String& textToShow)
{
	const Colour background (progressBar.findColour (ProgressBar::backgroundColourId));
	const Colour foreground (progressBar.findColour (ProgressBar::foregroundColourId));

	g.fillAll (background);

	if (progress >= 0.0f && progress < 1.0f)
	{
		drawGlassLozenge (g, 1.0f, 1.0f,
						  (float) jlimit (0.0, width - 2.0, progress * (width - 2.0)),
						  (float) (height - 2),
						  foreground,
						  0.5f, 0.0f,
						  true, true, true, true);
	}
	else
	{
		// spinning bar..
		g.setColour (foreground);

		const int stripeWidth = height * 2;
		const int position = (int) (Time::getMillisecondCounter() / 15) % stripeWidth;

		Path p;

		for (float x = (float) (- position); x < width + stripeWidth; x += stripeWidth)
			p.addQuadrilateral (x, 0.0f,
								x + stripeWidth * 0.5f, 0.0f,
								x, (float) height,
								x - stripeWidth * 0.5f, (float) height);

		Image im (Image::ARGB, width, height, true);

		{
			Graphics g2 (im);
			drawGlassLozenge (g2, 1.0f, 1.0f,
							  (float) (width - 2),
							  (float) (height - 2),
							  foreground,
							  0.5f, 0.0f,
							  true, true, true, true);
		}

		g.setTiledImageFill (im, 0, 0, 0.85f);
		g.fillPath (p);
	}

	if (textToShow.isNotEmpty())
	{
		g.setColour (Colour::contrasting (background, foreground));
		g.setFont (height * 0.6f);

		g.drawText (textToShow, 0, 0, width, height, Justification::centred, false);
	}
}

void LookAndFeel::drawSpinningWaitAnimation (Graphics& g, const Colour& colour, int x, int y, int w, int h)
{
	const float radius = jmin (w, h) * 0.4f;
	const float thickness = radius * 0.15f;
	Path p;
	p.addRoundedRectangle (radius * 0.4f, thickness * -0.5f,
						   radius * 0.6f, thickness,
						   thickness * 0.5f);

	const float cx = x + w * 0.5f;
	const float cy = y + h * 0.5f;

	const uint32 animationIndex = (Time::getMillisecondCounter() / (1000 / 10)) % 12;

	for (uint32 i = 0; i < 12; ++i)
	{
		const uint32 n = (i + 12 - animationIndex) % 12;
		g.setColour (colour.withMultipliedAlpha ((n + 1) / 12.0f));

		g.fillPath (p, AffineTransform::rotation (i * (float_Pi / 6.0f))
									   .translated (cx, cy));
	}
}

void LookAndFeel::drawScrollbarButton (Graphics& g,
									   ScrollBar& scrollbar,
									   int width, int height,
									   int buttonDirection,
									   bool /*isScrollbarVertical*/,
									   bool /*isMouseOverButton*/,
									   bool isButtonDown)
{
	Path p;

	if (buttonDirection == 0)
		p.addTriangle (width * 0.5f, height * 0.2f,
					   width * 0.1f, height * 0.7f,
					   width * 0.9f, height * 0.7f);
	else if (buttonDirection == 1)
		p.addTriangle (width * 0.8f, height * 0.5f,
					   width * 0.3f, height * 0.1f,
					   width * 0.3f, height * 0.9f);
	else if (buttonDirection == 2)
		p.addTriangle (width * 0.5f, height * 0.8f,
					   width * 0.1f, height * 0.3f,
					   width * 0.9f, height * 0.3f);
	else if (buttonDirection == 3)
		p.addTriangle (width * 0.2f, height * 0.5f,
					   width * 0.7f, height * 0.1f,
					   width * 0.7f, height * 0.9f);

	if (isButtonDown)
		g.setColour (scrollbar.findColour (ScrollBar::thumbColourId).contrasting (0.2f));
	else
		g.setColour (scrollbar.findColour (ScrollBar::thumbColourId));

	g.fillPath (p);

	g.setColour (Colour (0x80000000));
	g.strokePath (p, PathStrokeType (0.5f));
}

void LookAndFeel::drawScrollbar (Graphics& g,
								 ScrollBar& scrollbar,
								 int x, int y,
								 int width, int height,
								 bool isScrollbarVertical,
								 int thumbStartPosition,
								 int thumbSize,
								 bool /*isMouseOver*/,
								 bool /*isMouseDown*/)
{
	g.fillAll (scrollbar.findColour (ScrollBar::backgroundColourId));

	Path slotPath, thumbPath;

	const float slotIndent = jmin (width, height) > 15 ? 1.0f : 0.0f;
	const float slotIndentx2 = slotIndent * 2.0f;
	const float thumbIndent = slotIndent + 1.0f;
	const float thumbIndentx2 = thumbIndent * 2.0f;

	float gx1 = 0.0f, gy1 = 0.0f, gx2 = 0.0f, gy2 = 0.0f;

	if (isScrollbarVertical)
	{
		slotPath.addRoundedRectangle (x + slotIndent,
									  y + slotIndent,
									  width - slotIndentx2,
									  height - slotIndentx2,
									  (width - slotIndentx2) * 0.5f);

		if (thumbSize > 0)
			thumbPath.addRoundedRectangle (x + thumbIndent,
										   thumbStartPosition + thumbIndent,
										   width - thumbIndentx2,
										   thumbSize - thumbIndentx2,
										   (width - thumbIndentx2) * 0.5f);
		gx1 = (float) x;
		gx2 = x + width * 0.7f;
	}
	else
	{
		slotPath.addRoundedRectangle (x + slotIndent,
									  y + slotIndent,
									  width - slotIndentx2,
									  height - slotIndentx2,
									  (height - slotIndentx2) * 0.5f);

		if (thumbSize > 0)
			thumbPath.addRoundedRectangle (thumbStartPosition + thumbIndent,
										   y + thumbIndent,
										   thumbSize - thumbIndentx2,
										   height - thumbIndentx2,
										   (height - thumbIndentx2) * 0.5f);
		gy1 = (float) y;
		gy2 = y + height * 0.7f;
	}

	const Colour thumbColour (scrollbar.findColour (ScrollBar::thumbColourId));
	Colour trackColour1, trackColour2;

	if (scrollbar.isColourSpecified (ScrollBar::trackColourId)
		 || isColourSpecified (ScrollBar::trackColourId))
	{
		trackColour1 = trackColour2 = scrollbar.findColour (ScrollBar::trackColourId);
	}
	else
	{
		trackColour1 = thumbColour.overlaidWith (Colour (0x44000000));
		trackColour2 = thumbColour.overlaidWith (Colour (0x19000000));
	}

	g.setGradientFill (ColourGradient (trackColour1, gx1, gy1,
									   trackColour2, gx2, gy2, false));
	g.fillPath (slotPath);

	if (isScrollbarVertical)
	{
		gx1 = x + width * 0.6f;
		gx2 = (float) x + width;
	}
	else
	{
		gy1 = y + height * 0.6f;
		gy2 = (float) y + height;
	}

	g.setGradientFill (ColourGradient (Colours::transparentBlack,gx1, gy1,
					   Colour (0x19000000), gx2, gy2, false));
	g.fillPath (slotPath);

	g.setColour (thumbColour);
	g.fillPath (thumbPath);

	g.setGradientFill (ColourGradient (Colour (0x10000000), gx1, gy1,
					   Colours::transparentBlack, gx2, gy2, false));

	g.saveState();

	if (isScrollbarVertical)
		g.reduceClipRegion (x + width / 2, y, width, height);
	else
		g.reduceClipRegion (x, y + height / 2, width, height);

	g.fillPath (thumbPath);
	g.restoreState();

	g.setColour (Colour (0x4c000000));
	g.strokePath (thumbPath, PathStrokeType (0.4f));
}

ImageEffectFilter* LookAndFeel::getScrollbarEffect()
{
	return nullptr;
}

int LookAndFeel::getMinimumScrollbarThumbSize (ScrollBar& scrollbar)
{
	return jmin (scrollbar.getWidth(), scrollbar.getHeight()) * 2;
}

int LookAndFeel::getDefaultScrollbarWidth()
{
	return 18;
}

int LookAndFeel::getScrollbarButtonSize (ScrollBar& scrollbar)
{
	return 2 + (scrollbar.isVertical() ? scrollbar.getWidth()
									   : scrollbar.getHeight());
}

const Path LookAndFeel::getTickShape (const float height)
{
	static const unsigned char tickShapeData[] =
	{
		109,0,224,168,68,0,0,119,67,108,0,224,172,68,0,128,146,67,113,0,192,148,68,0,0,219,67,0,96,110,68,0,224,56,68,113,0,64,51,68,0,32,130,68,0,64,20,68,0,224,
		162,68,108,0,128,3,68,0,128,168,68,113,0,128,221,67,0,192,175,68,0,0,207,67,0,32,179,68,113,0,0,201,67,0,224,173,68,0,0,181,67,0,224,161,68,108,0,128,168,67,
		0,128,154,68,113,0,128,141,67,0,192,138,68,0,128,108,67,0,64,131,68,113,0,0,62,67,0,128,119,68,0,0,5,67,0,128,114,68,113,0,0,102,67,0,192,88,68,0,128,155,
		67,0,192,88,68,113,0,0,190,67,0,192,88,68,0,128,232,67,0,224,131,68,108,0,128,246,67,0,192,139,68,113,0,64,33,68,0,128,87,68,0,0,93,68,0,224,26,68,113,0,
		96,140,68,0,128,188,67,0,224,168,68,0,0,119,67,99,101
	};

	Path p;
	p.loadPathFromData (tickShapeData, sizeof (tickShapeData));
	p.scaleToFit (0, 0, height * 2.0f, height, true);
	return p;
}

const Path LookAndFeel::getCrossShape (const float height)
{
	static const unsigned char crossShapeData[] =
	{
		109,0,0,17,68,0,96,145,68,108,0,192,13,68,0,192,147,68,113,0,0,213,67,0,64,174,68,0,0,168,67,0,64,174,68,113,0,0,104,67,0,64,174,68,0,0,5,67,0,64,
		153,68,113,0,0,18,67,0,64,153,68,0,0,24,67,0,64,153,68,113,0,0,135,67,0,64,153,68,0,128,207,67,0,224,130,68,108,0,0,220,67,0,0,126,68,108,0,0,204,67,
		0,128,117,68,113,0,0,138,67,0,64,82,68,0,0,138,67,0,192,57,68,113,0,0,138,67,0,192,37,68,0,128,210,67,0,64,10,68,113,0,128,220,67,0,64,45,68,0,0,8,
		68,0,128,78,68,108,0,192,14,68,0,0,87,68,108,0,64,20,68,0,0,80,68,113,0,192,57,68,0,0,32,68,0,128,88,68,0,0,32,68,113,0,64,112,68,0,0,32,68,0,
		128,124,68,0,64,68,68,113,0,0,121,68,0,192,67,68,0,128,119,68,0,192,67,68,113,0,192,108,68,0,192,67,68,0,32,89,68,0,96,82,68,113,0,128,69,68,0,0,97,68,
		0,0,56,68,0,64,115,68,108,0,64,49,68,0,128,124,68,108,0,192,55,68,0,96,129,68,113,0,0,92,68,0,224,146,68,0,192,129,68,0,224,146,68,113,0,64,110,68,0,64,
		168,68,0,64,87,68,0,64,168,68,113,0,128,66,68,0,64,168,68,0,64,27,68,0,32,150,68,99,101
	};

	Path p;
	p.loadPathFromData (crossShapeData, sizeof (crossShapeData));
	p.scaleToFit (0, 0, height * 2.0f, height, true);
	return p;
}

void LookAndFeel::drawTreeviewPlusMinusBox (Graphics& g, int x, int y, int w, int h, bool isPlus, bool /*isMouseOver*/)
{
	const int boxSize = ((jmin (16, w, h) << 1) / 3) | 1;

	x += (w - boxSize) >> 1;
	y += (h - boxSize) >> 1;
	w = boxSize;
	h = boxSize;

	g.setColour (Colour (0xe5ffffff));
	g.fillRect (x, y, w, h);

	g.setColour (Colour (0x80000000));
	g.drawRect (x, y, w, h);

	const float size = boxSize / 2 + 1.0f;
	const float centre = (float) (boxSize / 2);

	g.fillRect (x + (w - size) * 0.5f, y + centre, size, 1.0f);

	if (isPlus)
		g.fillRect (x + centre, y + (h - size) * 0.5f, 1.0f, size);
}

void LookAndFeel::drawBubble (Graphics& g,
							  float tipX, float tipY,
							  float boxX, float boxY,
							  float boxW, float boxH)
{
	int side = 0;

	if (tipX < boxX)
		side = 1;
	else if (tipX > boxX + boxW)
		side = 3;
	else if (tipY > boxY + boxH)
		side = 2;

	const float indent = 2.0f;
	Path p;
	p.addBubble (boxX + indent,
				 boxY + indent,
				 boxW - indent * 2.0f,
				 boxH - indent * 2.0f,
				 5.0f,
				 tipX, tipY,
				 side,
				 0.5f,
				 jmin (15.0f, boxW * 0.3f, boxH * 0.3f));

	//xxx need to take comp as param for colour
	g.setColour (findColour (TooltipWindow::backgroundColourId).withAlpha (0.9f));
	g.fillPath (p);

	//xxx as above
	g.setColour (findColour (TooltipWindow::textColourId).withAlpha (0.4f));
	g.strokePath (p, PathStrokeType (1.33f));
}

const Font LookAndFeel::getPopupMenuFont()
{
	return Font (17.0f);
}

void LookAndFeel::getIdealPopupMenuItemSize (const String& text,
											 const bool isSeparator,
											 int standardMenuItemHeight,
											 int& idealWidth,
											 int& idealHeight)
{
	if (isSeparator)
	{
		idealWidth = 50;
		idealHeight = standardMenuItemHeight > 0 ? standardMenuItemHeight / 2 : 10;
	}
	else
	{
		Font font (getPopupMenuFont());

		if (standardMenuItemHeight > 0 && font.getHeight() > standardMenuItemHeight / 1.3f)
			font.setHeight (standardMenuItemHeight / 1.3f);

		idealHeight = standardMenuItemHeight > 0 ? standardMenuItemHeight : roundToInt (font.getHeight() * 1.3f);
		idealWidth = font.getStringWidth (text) + idealHeight * 2;
	}
}

void LookAndFeel::drawPopupMenuBackground (Graphics& g, int width, int height)
{
	const Colour background (findColour (PopupMenu::backgroundColourId));

	g.fillAll (background);
	g.setColour (background.overlaidWith (Colour (0x2badd8e6)));

	for (int i = 0; i < height; i += 3)
		g.fillRect (0, i, width, 1);

#if ! JUCE_MAC
	g.setColour (findColour (PopupMenu::textColourId).withAlpha (0.6f));
	g.drawRect (0, 0, width, height);
#endif
}

void LookAndFeel::drawPopupMenuUpDownArrow (Graphics& g,
											int width, int height,
											bool isScrollUpArrow)
{
	const Colour background (findColour (PopupMenu::backgroundColourId));

	g.setGradientFill (ColourGradient (background, 0.0f, height * 0.5f,
									   background.withAlpha (0.0f),
									   0.0f, isScrollUpArrow ? ((float) height) : 0.0f,
									   false));

	g.fillRect (1, 1, width - 2, height - 2);

	const float hw = width * 0.5f;
	const float arrowW = height * 0.3f;
	const float y1 = height * (isScrollUpArrow ? 0.6f : 0.3f);
	const float y2 = height * (isScrollUpArrow ? 0.3f : 0.6f);

	Path p;
	p.addTriangle (hw - arrowW, y1,
				   hw + arrowW, y1,
				   hw, y2);

	g.setColour (findColour (PopupMenu::textColourId).withAlpha (0.5f));
	g.fillPath (p);
}

void LookAndFeel::drawPopupMenuItem (Graphics& g,
									 int width, int height,
									 const bool isSeparator,
									 const bool isActive,
									 const bool isHighlighted,
									 const bool isTicked,
									 const bool hasSubMenu,
									 const String& text,
									 const String& shortcutKeyText,
									 Image* image,
									 const Colour* const textColourToUse)
{
	const float halfH = height * 0.5f;

	if (isSeparator)
	{
		const float separatorIndent = 5.5f;

		g.setColour (Colour (0x33000000));
		g.drawLine (separatorIndent, halfH, width - separatorIndent, halfH);

		g.setColour (Colour (0x66ffffff));
		g.drawLine (separatorIndent, halfH + 1.0f, width - separatorIndent, halfH + 1.0f);
	}
	else
	{
		Colour textColour (findColour (PopupMenu::textColourId));

		if (textColourToUse != nullptr)
			textColour = *textColourToUse;

		if (isHighlighted)
		{
			g.setColour (findColour (PopupMenu::highlightedBackgroundColourId));
			g.fillRect (1, 1, width - 2, height - 2);

			g.setColour (findColour (PopupMenu::highlightedTextColourId));
		}
		else
		{
			g.setColour (textColour);
		}

		if (! isActive)
			g.setOpacity (0.3f);

		Font font (getPopupMenuFont());

		if (font.getHeight() > height / 1.3f)
			font.setHeight (height / 1.3f);

		g.setFont (font);

		const int leftBorder = (height * 5) / 4;
		const int rightBorder = 4;

		if (image != nullptr)
		{
			g.drawImageWithin (*image,
							   2, 1, leftBorder - 4, height - 2,
							   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize, false);
		}
		else if (isTicked)
		{
			const Path tick (getTickShape (1.0f));
			const float th = font.getAscent();
			const float ty = halfH - th * 0.5f;

			g.fillPath (tick, tick.getTransformToScaleToFit (2.0f, ty, (float) (leftBorder - 4),
															 th, true));
		}

		g.drawFittedText (text,
						  leftBorder, 0,
						  width - (leftBorder + rightBorder), height,
						  Justification::centredLeft, 1);

		if (shortcutKeyText.isNotEmpty())
		{
			Font f2 (font);
			f2.setHeight (f2.getHeight() * 0.75f);
			f2.setHorizontalScale (0.95f);
			g.setFont (f2);

			g.drawText (shortcutKeyText,
						leftBorder,
						0,
						width - (leftBorder + rightBorder + 4),
						height,
						Justification::centredRight,
						true);
		}

		if (hasSubMenu)
		{
			const float arrowH = 0.6f * getPopupMenuFont().getAscent();
			const float x = width - height * 0.6f;

			Path p;
			p.addTriangle (x, halfH - arrowH * 0.5f,
						   x, halfH + arrowH * 0.5f,
						   x + arrowH * 0.6f, halfH);

			g.fillPath (p);
		}
	}
}

int LookAndFeel::getMenuWindowFlags()
{
	return ComponentPeer::windowHasDropShadow;
}

void LookAndFeel::drawMenuBarBackground (Graphics& g, int width, int height,
										 bool, MenuBarComponent& menuBar)
{
	const Colour baseColour (LookAndFeelHelpers::createBaseColour (menuBar.findColour (PopupMenu::backgroundColourId), false, false, false));

	if (menuBar.isEnabled())
	{
		drawShinyButtonShape (g,
							  -4.0f, 0.0f,
							  width + 8.0f, (float) height,
							  0.0f,
							  baseColour,
							  0.4f,
							  true, true, true, true);
	}
	else
	{
		g.fillAll (baseColour);
	}
}

const Font LookAndFeel::getMenuBarFont (MenuBarComponent& menuBar, int /*itemIndex*/, const String& /*itemText*/)
{
	return Font (menuBar.getHeight() * 0.7f);
}

int LookAndFeel::getMenuBarItemWidth (MenuBarComponent& menuBar, int itemIndex, const String& itemText)
{
	return getMenuBarFont (menuBar, itemIndex, itemText)
			.getStringWidth (itemText) + menuBar.getHeight();
}

void LookAndFeel::drawMenuBarItem (Graphics& g,
								   int width, int height,
								   int itemIndex,
								   const String& itemText,
								   bool isMouseOverItem,
								   bool isMenuOpen,
								   bool /*isMouseOverBar*/,
								   MenuBarComponent& menuBar)
{
	if (! menuBar.isEnabled())
	{
		g.setColour (menuBar.findColour (PopupMenu::textColourId)
							.withMultipliedAlpha (0.5f));
	}
	else if (isMenuOpen || isMouseOverItem)
	{
		g.fillAll (menuBar.findColour (PopupMenu::highlightedBackgroundColourId));
		g.setColour (menuBar.findColour (PopupMenu::highlightedTextColourId));
	}
	else
	{
		g.setColour (menuBar.findColour (PopupMenu::textColourId));
	}

	g.setFont (getMenuBarFont (menuBar, itemIndex, itemText));
	g.drawFittedText (itemText, 0, 0, width, height, Justification::centred, 1);
}

void LookAndFeel::fillTextEditorBackground (Graphics& g, int /*width*/, int /*height*/,
											TextEditor& textEditor)
{
	g.fillAll (textEditor.findColour (TextEditor::backgroundColourId));
}

void LookAndFeel::drawTextEditorOutline (Graphics& g, int width, int height, TextEditor& textEditor)
{
	if (textEditor.isEnabled())
	{
		if (textEditor.hasKeyboardFocus (true) && ! textEditor.isReadOnly())
		{
			const int border = 2;

			g.setColour (textEditor.findColour (TextEditor::focusedOutlineColourId));
			g.drawRect (0, 0, width, height, border);

			g.setOpacity (1.0f);
			const Colour shadowColour (textEditor.findColour (TextEditor::shadowColourId).withMultipliedAlpha (0.75f));
			g.drawBevel (0, 0, width, height + 2, border + 2, shadowColour, shadowColour);
		}
		else
		{
			g.setColour (textEditor.findColour (TextEditor::outlineColourId));
			g.drawRect (0, 0, width, height);

			g.setOpacity (1.0f);
			const Colour shadowColour (textEditor.findColour (TextEditor::shadowColourId));
			g.drawBevel (0, 0, width, height + 2, 3, shadowColour, shadowColour);
		}
	}
}

CaretComponent* LookAndFeel::createCaretComponent (Component* keyFocusOwner)
{
	return new CaretComponent (keyFocusOwner);
}

void LookAndFeel::drawComboBox (Graphics& g, int width, int height,
								const bool isButtonDown,
								int buttonX, int buttonY,
								int buttonW, int buttonH,
								ComboBox& box)
{
	g.fillAll (box.findColour (ComboBox::backgroundColourId));

	if (box.isEnabled() && box.hasKeyboardFocus (false))
	{
		g.setColour (box.findColour (TextButton::buttonColourId));
		g.drawRect (0, 0, width, height, 2);
	}
	else
	{
		g.setColour (box.findColour (ComboBox::outlineColourId));
		g.drawRect (0, 0, width, height);
	}

	const float outlineThickness = box.isEnabled() ? (isButtonDown ? 1.2f : 0.5f) : 0.3f;

	const Colour baseColour (LookAndFeelHelpers::createBaseColour (box.findColour (ComboBox::buttonColourId),
																   box.hasKeyboardFocus (true),
																   false, isButtonDown)
								.withMultipliedAlpha (box.isEnabled() ? 1.0f : 0.5f));

	drawGlassLozenge (g,
					  buttonX + outlineThickness, buttonY + outlineThickness,
					  buttonW - outlineThickness * 2.0f, buttonH - outlineThickness * 2.0f,
					  baseColour, outlineThickness, -1.0f,
					  true, true, true, true);

	if (box.isEnabled())
	{
		const float arrowX = 0.3f;
		const float arrowH = 0.2f;

		Path p;
		p.addTriangle (buttonX + buttonW * 0.5f,            buttonY + buttonH * (0.45f - arrowH),
					   buttonX + buttonW * (1.0f - arrowX), buttonY + buttonH * 0.45f,
					   buttonX + buttonW * arrowX,          buttonY + buttonH * 0.45f);

		p.addTriangle (buttonX + buttonW * 0.5f,            buttonY + buttonH * (0.55f + arrowH),
					   buttonX + buttonW * (1.0f - arrowX), buttonY + buttonH * 0.55f,
					   buttonX + buttonW * arrowX,          buttonY + buttonH * 0.55f);

		g.setColour (box.findColour (ComboBox::arrowColourId));
		g.fillPath (p);
	}
}

const Font LookAndFeel::getComboBoxFont (ComboBox& box)
{
	return Font (jmin (15.0f, box.getHeight() * 0.85f));
}

Label* LookAndFeel::createComboBoxTextBox (ComboBox&)
{
	return new Label (String::empty, String::empty);
}

void LookAndFeel::positionComboBoxText (ComboBox& box, Label& label)
{
	label.setBounds (1, 1,
					 box.getWidth() + 3 - box.getHeight(),
					 box.getHeight() - 2);

	label.setFont (getComboBoxFont (box));
}

void LookAndFeel::drawLabel (Graphics& g, Label& label)
{
	g.fillAll (label.findColour (Label::backgroundColourId));

	if (! label.isBeingEdited())
	{
		const float alpha = label.isEnabled() ? 1.0f : 0.5f;

		g.setColour (label.findColour (Label::textColourId).withMultipliedAlpha (alpha));
		g.setFont (label.getFont());
		g.drawFittedText (label.getText(),
						  label.getHorizontalBorderSize(),
						  label.getVerticalBorderSize(),
						  label.getWidth() - 2 * label.getHorizontalBorderSize(),
						  label.getHeight() - 2 * label.getVerticalBorderSize(),
						  label.getJustificationType(),
						  jmax (1, (int) (label.getHeight() / label.getFont().getHeight())),
						  label.getMinimumHorizontalScale());

		g.setColour (label.findColour (Label::outlineColourId).withMultipliedAlpha (alpha));
		g.drawRect (0, 0, label.getWidth(), label.getHeight());
	}
	else if (label.isEnabled())
	{
		g.setColour (label.findColour (Label::outlineColourId));
		g.drawRect (0, 0, label.getWidth(), label.getHeight());
	}
}

void LookAndFeel::drawLinearSliderBackground (Graphics& g,
											  int x, int y,
											  int width, int height,
											  float /*sliderPos*/,
											  float /*minSliderPos*/,
											  float /*maxSliderPos*/,
											  const Slider::SliderStyle /*style*/,
											  Slider& slider)
{
	const float sliderRadius = (float) (getSliderThumbRadius (slider) - 2);

	const Colour trackColour (slider.findColour (Slider::trackColourId));
	const Colour gradCol1 (trackColour.overlaidWith (Colours::black.withAlpha (slider.isEnabled() ? 0.25f : 0.13f)));
	const Colour gradCol2 (trackColour.overlaidWith (Colour (0x14000000)));
	Path indent;

	if (slider.isHorizontal())
	{
		const float iy = y + height * 0.5f - sliderRadius * 0.5f;
		const float ih = sliderRadius;

		g.setGradientFill (ColourGradient (gradCol1, 0.0f, iy,
										   gradCol2, 0.0f, iy + ih, false));

		indent.addRoundedRectangle (x - sliderRadius * 0.5f, iy,
									width + sliderRadius, ih,
									5.0f);
		g.fillPath (indent);
	}
	else
	{
		const float ix = x + width * 0.5f - sliderRadius * 0.5f;
		const float iw = sliderRadius;

		g.setGradientFill (ColourGradient (gradCol1, ix, 0.0f,
										   gradCol2, ix + iw, 0.0f, false));

		indent.addRoundedRectangle (ix, y - sliderRadius * 0.5f,
									iw, height + sliderRadius,
									5.0f);
		g.fillPath (indent);
	}

	g.setColour (Colour (0x4c000000));
	g.strokePath (indent, PathStrokeType (0.5f));
}

void LookAndFeel::drawLinearSliderThumb (Graphics& g,
										 int x, int y,
										 int width, int height,
										 float sliderPos,
										 float minSliderPos,
										 float maxSliderPos,
										 const Slider::SliderStyle style,
										 Slider& slider)
{
	const float sliderRadius = (float) (getSliderThumbRadius (slider) - 2);

	Colour knobColour (LookAndFeelHelpers::createBaseColour (slider.findColour (Slider::thumbColourId),
															 slider.hasKeyboardFocus (false) && slider.isEnabled(),
															 slider.isMouseOverOrDragging() && slider.isEnabled(),
															 slider.isMouseButtonDown() && slider.isEnabled()));

	const float outlineThickness = slider.isEnabled() ? 0.8f : 0.3f;

	if (style == Slider::LinearHorizontal || style == Slider::LinearVertical)
	{
		float kx, ky;

		if (style == Slider::LinearVertical)
		{
			kx = x + width * 0.5f;
			ky = sliderPos;
		}
		else
		{
			kx = sliderPos;
			ky = y + height * 0.5f;
		}

		drawGlassSphere (g,
						 kx - sliderRadius,
						 ky - sliderRadius,
						 sliderRadius * 2.0f,
						 knobColour, outlineThickness);
	}
	else
	{
		if (style == Slider::ThreeValueVertical)
		{
			drawGlassSphere (g, x + width * 0.5f - sliderRadius,
							 sliderPos - sliderRadius,
							 sliderRadius * 2.0f,
							 knobColour, outlineThickness);
		}
		else if (style == Slider::ThreeValueHorizontal)
		{
			drawGlassSphere (g,sliderPos - sliderRadius,
							 y + height * 0.5f - sliderRadius,
							 sliderRadius * 2.0f,
							 knobColour, outlineThickness);
		}

		if (style == Slider::TwoValueVertical || style == Slider::ThreeValueVertical)
		{
			const float sr = jmin (sliderRadius, width * 0.4f);

			drawGlassPointer (g, jmax (0.0f, x + width * 0.5f - sliderRadius * 2.0f),
							  minSliderPos - sliderRadius,
							  sliderRadius * 2.0f, knobColour, outlineThickness, 1);

			drawGlassPointer (g, jmin (x + width - sliderRadius * 2.0f, x + width * 0.5f), maxSliderPos - sr,
							  sliderRadius * 2.0f, knobColour, outlineThickness, 3);
		}
		else if (style == Slider::TwoValueHorizontal || style == Slider::ThreeValueHorizontal)
		{
			const float sr = jmin (sliderRadius, height * 0.4f);

			drawGlassPointer (g, minSliderPos - sr,
							  jmax (0.0f, y + height * 0.5f - sliderRadius * 2.0f),
							  sliderRadius * 2.0f, knobColour, outlineThickness, 2);

			drawGlassPointer (g, maxSliderPos - sliderRadius,
							  jmin (y + height - sliderRadius * 2.0f, y + height * 0.5f),
							  sliderRadius * 2.0f, knobColour, outlineThickness, 4);
		}
	}
}

void LookAndFeel::drawLinearSlider (Graphics& g,
									int x, int y,
									int width, int height,
									float sliderPos,
									float minSliderPos,
									float maxSliderPos,
									const Slider::SliderStyle style,
									Slider& slider)
{
	g.fillAll (slider.findColour (Slider::backgroundColourId));

	if (style == Slider::LinearBar)
	{
		const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

		Colour baseColour (LookAndFeelHelpers::createBaseColour (slider.findColour (Slider::thumbColourId)
																	   .withMultipliedSaturation (slider.isEnabled() ? 1.0f : 0.5f),
																 false, isMouseOver,
																 isMouseOver || slider.isMouseButtonDown()));

		drawShinyButtonShape (g,
							  (float) x, (float) y, sliderPos - (float) x, (float) height, 0.0f,
							  baseColour,
							  slider.isEnabled() ? 0.9f : 0.3f,
							  true, true, true, true);
	}
	else
	{
		drawLinearSliderBackground (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
		drawLinearSliderThumb (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
	}
}

int LookAndFeel::getSliderThumbRadius (Slider& slider)
{
	return jmin (7,
				 slider.getHeight() / 2,
				 slider.getWidth() / 2) + 2;
}

void LookAndFeel::drawRotarySlider (Graphics& g,
									int x, int y,
									int width, int height,
									float sliderPos,
									const float rotaryStartAngle,
									const float rotaryEndAngle,
									Slider& slider)
{
	const float radius = jmin (width / 2, height / 2) - 2.0f;
	const float centreX = x + width * 0.5f;
	const float centreY = y + height * 0.5f;
	const float rx = centreX - radius;
	const float ry = centreY - radius;
	const float rw = radius * 2.0f;
	const float angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
	const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

	if (radius > 12.0f)
	{
		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 1.0f : 0.7f));
		else
			g.setColour (Colour (0x80808080));

		const float thickness = 0.7f;

		{
			Path filledArc;
			filledArc.addPieSegment (rx, ry, rw, rw,
									rotaryStartAngle,
									angle,
									thickness);

			g.fillPath (filledArc);
		}

		if (thickness > 0)
		{
			const float innerRadius = radius * 0.2f;
			Path p;
			p.addTriangle (-innerRadius, 0.0f,
						   0.0f, -radius * thickness * 1.1f,
						   innerRadius, 0.0f);

			p.addEllipse (-innerRadius, -innerRadius, innerRadius * 2.0f, innerRadius * 2.0f);

			g.fillPath (p, AffineTransform::rotation (angle).translated (centreX, centreY));
		}

		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderOutlineColourId));
		else
			g.setColour (Colour (0x80808080));

		Path outlineArc;
		outlineArc.addPieSegment (rx, ry, rw, rw, rotaryStartAngle, rotaryEndAngle, thickness);
		outlineArc.closeSubPath();

		g.strokePath (outlineArc, PathStrokeType (slider.isEnabled() ? (isMouseOver ? 2.0f : 1.2f) : 0.3f));
	}
	else
	{
		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 1.0f : 0.7f));
		else
			g.setColour (Colour (0x80808080));

		Path p;
		p.addEllipse (-0.4f * rw, -0.4f * rw, rw * 0.8f, rw * 0.8f);
		PathStrokeType (rw * 0.1f).createStrokedPath (p, p);

		p.addLineSegment (Line<float> (0.0f, 0.0f, 0.0f, -radius), rw * 0.2f);

		g.fillPath (p, AffineTransform::rotation (angle).translated (centreX, centreY));
	}
}

Button* LookAndFeel::createSliderButton (const bool isIncrement)
{
	return new TextButton (isIncrement ? "+" : "-", String::empty);
}

class SliderLabelComp : public Label
{
public:
	SliderLabelComp() : Label (String::empty, String::empty) {}

	void mouseWheelMove (const MouseEvent&, float, float) {}
};

Label* LookAndFeel::createSliderTextBox (Slider& slider)
{
	Label* const l = new SliderLabelComp();

	l->setJustificationType (Justification::centred);

	l->setColour (Label::textColourId, slider.findColour (Slider::textBoxTextColourId));

	l->setColour (Label::backgroundColourId,
				  (slider.getSliderStyle() == Slider::LinearBar) ? Colours::transparentBlack
																 : slider.findColour (Slider::textBoxBackgroundColourId));
	l->setColour (Label::outlineColourId, slider.findColour (Slider::textBoxOutlineColourId));

	l->setColour (TextEditor::textColourId, slider.findColour (Slider::textBoxTextColourId));

	l->setColour (TextEditor::backgroundColourId,
				  slider.findColour (Slider::textBoxBackgroundColourId)
						.withAlpha (slider.getSliderStyle() == Slider::LinearBar ? 0.7f : 1.0f));

	l->setColour (TextEditor::outlineColourId, slider.findColour (Slider::textBoxOutlineColourId));

	return l;
}

ImageEffectFilter* LookAndFeel::getSliderEffect()
{
	return nullptr;
}

void LookAndFeel::getTooltipSize (const String& tipText, int& width, int& height)
{
	const TextLayout tl (LookAndFeelHelpers::layoutTooltipText (tipText, Colours::black));

	width  = (int) (tl.getWidth() + 14.0f);
	height = (int) (tl.getHeight() + 6.0f);
}

void LookAndFeel::drawTooltip (Graphics& g, const String& text, int width, int height)
{
	g.fillAll (findColour (TooltipWindow::backgroundColourId));

   #if ! JUCE_MAC // The mac windows already have a non-optional 1 pix outline, so don't double it here..
	g.setColour (findColour (TooltipWindow::outlineColourId));
	g.drawRect (0, 0, width, height, 1);
   #endif

	const TextLayout tl (LookAndFeelHelpers::layoutTooltipText (text, findColour (TooltipWindow::textColourId)));
	tl.draw (g, Rectangle<float> ((float) width, (float) height));
}

Button* LookAndFeel::createFilenameComponentBrowseButton (const String& text)
{
	return new TextButton (text, TRANS("click to browse for a different file"));
}

void LookAndFeel::layoutFilenameComponent (FilenameComponent& filenameComp,
										   ComboBox* filenameBox,
										   Button* browseButton)
{
	browseButton->setSize (80, filenameComp.getHeight());

	TextButton* const tb = dynamic_cast <TextButton*> (browseButton);

	if (tb != nullptr)
		tb->changeWidthToFitText();

	browseButton->setTopRightPosition (filenameComp.getWidth(), 0);

	filenameBox->setBounds (0, 0, browseButton->getX(), filenameComp.getHeight());
}

void LookAndFeel::drawImageButton (Graphics& g, Image* image,
								   int imageX, int imageY, int imageW, int imageH,
								   const Colour& overlayColour,
								   float imageOpacity,
								   ImageButton& button)
{
	if (! button.isEnabled())
		imageOpacity *= 0.3f;

	if (! overlayColour.isOpaque())
	{
		g.setOpacity (imageOpacity);

		g.drawImage (*image, imageX, imageY, imageW, imageH,
					 0, 0, image->getWidth(), image->getHeight(), false);
	}

	if (! overlayColour.isTransparent())
	{
		g.setColour (overlayColour);

		g.drawImage (*image, imageX, imageY, imageW, imageH,
					 0, 0, image->getWidth(), image->getHeight(), true);
	}
}

void LookAndFeel::drawCornerResizer (Graphics& g,
									 int w, int h,
									 bool /*isMouseOver*/,
									 bool /*isMouseDragging*/)
{
	const float lineThickness = jmin (w, h) * 0.075f;

	for (float i = 0.0f; i < 1.0f; i += 0.3f)
	{
		g.setColour (Colours::lightgrey);

		g.drawLine (w * i,
					h + 1.0f,
					w + 1.0f,
					h * i,
					lineThickness);

		g.setColour (Colours::darkgrey);

		g.drawLine (w * i + lineThickness,
					h + 1.0f,
					w + 1.0f,
					h * i + lineThickness,
					lineThickness);
	}
}

void LookAndFeel::drawResizableFrame (Graphics& g, int w, int h, const BorderSize<int>& border)
{
	if (! border.isEmpty())
	{
		const Rectangle<int> fullSize (0, 0, w, h);
		const Rectangle<int> centreArea (border.subtractedFrom (fullSize));

		g.saveState();

		g.excludeClipRegion (centreArea);

		g.setColour (Colour (0x50000000));
		g.drawRect (fullSize);

		g.setColour (Colour (0x19000000));
		g.drawRect (centreArea.expanded (1, 1));

		g.restoreState();
	}
}

void LookAndFeel::fillResizableWindowBackground (Graphics& g, int /*w*/, int /*h*/,
												 const BorderSize<int>& /*border*/, ResizableWindow& window)
{
   g.fillAll (window.getBackgroundColour());
}

void LookAndFeel::drawResizableWindowBorder (Graphics&, int /*w*/, int /*h*/,
											 const BorderSize<int>& /*border*/, ResizableWindow&)
{
}

void LookAndFeel::drawDocumentWindowTitleBar (DocumentWindow& window,
											  Graphics& g, int w, int h,
											  int titleSpaceX, int titleSpaceW,
											  const Image* icon,
											  bool drawTitleTextOnLeft)
{
	const bool isActive = window.isActiveWindow();

	g.setGradientFill (ColourGradient (window.getBackgroundColour(),
									   0.0f, 0.0f,
									   window.getBackgroundColour().contrasting (isActive ? 0.15f : 0.05f),
									   0.0f, (float) h, false));
	g.fillAll();

	Font font (h * 0.65f, Font::bold);
	g.setFont (font);

	int textW = font.getStringWidth (window.getName());
	int iconW = 0;
	int iconH = 0;

	if (icon != nullptr)
	{
		iconH = (int) font.getHeight();
		iconW = icon->getWidth() * iconH / icon->getHeight() + 4;
	}

	textW = jmin (titleSpaceW, textW + iconW);
	int textX = drawTitleTextOnLeft ? titleSpaceX
									: jmax (titleSpaceX, (w - textW) / 2);

	if (textX + textW > titleSpaceX + titleSpaceW)
		textX = titleSpaceX + titleSpaceW - textW;

	if (icon != nullptr)
	{
		g.setOpacity (isActive ? 1.0f : 0.6f);
		g.drawImageWithin (*icon, textX, (h - iconH) / 2, iconW, iconH,
						   RectanglePlacement::centred, false);
		textX += iconW;
		textW -= iconW;
	}

	if (window.isColourSpecified (DocumentWindow::textColourId) || isColourSpecified (DocumentWindow::textColourId))
		g.setColour (findColour (DocumentWindow::textColourId));
	else
		g.setColour (window.getBackgroundColour().contrasting (isActive ? 0.7f : 0.4f));

	g.drawText (window.getName(), textX, 0, textW, h, Justification::centredLeft, true);
}

class GlassWindowButton   : public Button
{
public:

	GlassWindowButton (const String& name, const Colour& col,
					   const Path& normalShape_,
					   const Path& toggledShape_) noexcept
		: Button (name),
		  colour (col),
		  normalShape (normalShape_),
		  toggledShape (toggledShape_)
	{
	}

	~GlassWindowButton()
	{
	}

	void paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown)
	{
		float alpha = isMouseOverButton ? (isButtonDown ? 1.0f : 0.8f) : 0.55f;

		if (! isEnabled())
			alpha *= 0.5f;

		float x = 0, y = 0, diam;

		if (getWidth() < getHeight())
		{
			diam = (float) getWidth();
			y = (getHeight() - getWidth()) * 0.5f;
		}
		else
		{
			diam = (float) getHeight();
			y = (getWidth() - getHeight()) * 0.5f;
		}

		x += diam * 0.05f;
		y += diam * 0.05f;
		diam *= 0.9f;

		g.setGradientFill (ColourGradient (Colour::greyLevel (0.9f).withAlpha (alpha), 0, y + diam,
										   Colour::greyLevel (0.6f).withAlpha (alpha), 0, y, false));
		g.fillEllipse (x, y, diam, diam);

		x += 2.0f;
		y += 2.0f;
		diam -= 4.0f;

		LookAndFeel::drawGlassSphere (g, x, y, diam, colour.withAlpha (alpha), 1.0f);

		Path& p = getToggleState() ? toggledShape : normalShape;

		const AffineTransform t (p.getTransformToScaleToFit (x + diam * 0.3f, y + diam * 0.3f,
															 diam * 0.4f, diam * 0.4f, true));

		g.setColour (Colours::black.withAlpha (alpha * 0.6f));
		g.fillPath (p, t);
	}

private:
	Colour colour;
	Path normalShape, toggledShape;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GlassWindowButton);
};

Button* LookAndFeel::createDocumentWindowButton (int buttonType)
{
	Path shape;
	const float crossThickness = 0.25f;

	if (buttonType == DocumentWindow::closeButton)
	{
		shape.addLineSegment (Line<float> (0.0f, 0.0f, 1.0f, 1.0f), crossThickness * 1.4f);
		shape.addLineSegment (Line<float> (1.0f, 0.0f, 0.0f, 1.0f), crossThickness * 1.4f);

		return new GlassWindowButton ("close", Colour (0xffdd1100), shape, shape);
	}
	else if (buttonType == DocumentWindow::minimiseButton)
	{
		shape.addLineSegment (Line<float> (0.0f, 0.5f, 1.0f, 0.5f), crossThickness);

		return new GlassWindowButton ("minimise", Colour (0xffaa8811), shape, shape);
	}
	else if (buttonType == DocumentWindow::maximiseButton)
	{
		shape.addLineSegment (Line<float> (0.5f, 0.0f, 0.5f, 1.0f), crossThickness);
		shape.addLineSegment (Line<float> (0.0f, 0.5f, 1.0f, 0.5f), crossThickness);

		Path fullscreenShape;
		fullscreenShape.startNewSubPath (45.0f, 100.0f);
		fullscreenShape.lineTo (0.0f, 100.0f);
		fullscreenShape.lineTo (0.0f, 0.0f);
		fullscreenShape.lineTo (100.0f, 0.0f);
		fullscreenShape.lineTo (100.0f, 45.0f);
		fullscreenShape.addRectangle (45.0f, 45.0f, 100.0f, 100.0f);
		PathStrokeType (30.0f).createStrokedPath (fullscreenShape, fullscreenShape);

		return new GlassWindowButton ("maximise", Colour (0xff119911), shape, fullscreenShape);
	}

	jassertfalse;
	return nullptr;
}

void LookAndFeel::positionDocumentWindowButtons (DocumentWindow&,
												 int titleBarX,
												 int titleBarY,
												 int titleBarW,
												 int titleBarH,
												 Button* minimiseButton,
												 Button* maximiseButton,
												 Button* closeButton,
												 bool positionTitleBarButtonsOnLeft)
{
	const int buttonW = titleBarH - titleBarH / 8;

	int x = positionTitleBarButtonsOnLeft ? titleBarX + 4
										  : titleBarX + titleBarW - buttonW - buttonW / 4;

	if (closeButton != nullptr)
	{
		closeButton->setBounds (x, titleBarY, buttonW, titleBarH);
		x += positionTitleBarButtonsOnLeft ? buttonW : -(buttonW + buttonW / 4);
	}

	if (positionTitleBarButtonsOnLeft)
		std::swap (minimiseButton, maximiseButton);

	if (maximiseButton != nullptr)
	{
		maximiseButton->setBounds (x, titleBarY, buttonW, titleBarH);
		x += positionTitleBarButtonsOnLeft ? buttonW : -buttonW;
	}

	if (minimiseButton != nullptr)
		minimiseButton->setBounds (x, titleBarY, buttonW, titleBarH);
}

int LookAndFeel::getDefaultMenuBarHeight()
{
	return 24;
}

DropShadower* LookAndFeel::createDropShadowerForComponent (Component*)
{
	return new DropShadower (0.4f, 1, 5, 10);
}

void LookAndFeel::drawStretchableLayoutResizerBar (Graphics& g,
												   int w, int h,
												   bool /*isVerticalBar*/,
												   bool isMouseOver,
												   bool isMouseDragging)
{
	float alpha = 0.5f;

	if (isMouseOver || isMouseDragging)
	{
		g.fillAll (Colour (0x190000ff));
		alpha = 1.0f;
	}

	const float cx = w * 0.5f;
	const float cy = h * 0.5f;
	const float cr = jmin (w, h) * 0.4f;

	g.setGradientFill (ColourGradient (Colours::white.withAlpha (alpha), cx + cr * 0.1f, cy + cr,
									   Colours::black.withAlpha (alpha), cx, cy - cr * 4.0f,
									   true));

	g.fillEllipse (cx - cr, cy - cr, cr * 2.0f, cr * 2.0f);
}

void LookAndFeel::drawGroupComponentOutline (Graphics& g, int width, int height,
											 const String& text,
											 const Justification& position,
											 GroupComponent& group)
{
	const float textH = 15.0f;
	const float indent = 3.0f;
	const float textEdgeGap = 4.0f;
	float cs = 5.0f;

	Font f (textH);

	Path p;
	float x = indent;
	float y = f.getAscent() - 3.0f;
	float w = jmax (0.0f, width - x * 2.0f);
	float h = jmax (0.0f, height - y  - indent);
	cs = jmin (cs, w * 0.5f, h * 0.5f);
	const float cs2 = 2.0f * cs;

	float textW = text.isEmpty() ? 0 : jlimit (0.0f, jmax (0.0f, w - cs2 - textEdgeGap * 2), f.getStringWidth (text) + textEdgeGap * 2.0f);
	float textX = cs + textEdgeGap;

	if (position.testFlags (Justification::horizontallyCentred))
		textX = cs + (w - cs2 - textW) * 0.5f;
	else if (position.testFlags (Justification::right))
		textX = w - cs - textW - textEdgeGap;

	p.startNewSubPath (x + textX + textW, y);
	p.lineTo (x + w - cs, y);

	p.addArc (x + w - cs2, y, cs2, cs2, 0, float_Pi * 0.5f);
	p.lineTo (x + w, y + h - cs);

	p.addArc (x + w - cs2, y + h - cs2, cs2, cs2, float_Pi * 0.5f, float_Pi);
	p.lineTo (x + cs, y + h);

	p.addArc (x, y + h - cs2, cs2, cs2, float_Pi, float_Pi * 1.5f);
	p.lineTo (x, y + cs);

	p.addArc (x, y, cs2, cs2, float_Pi * 1.5f, float_Pi * 2.0f);
	p.lineTo (x + textX, y);

	const float alpha = group.isEnabled() ? 1.0f : 0.5f;

	g.setColour (group.findColour (GroupComponent::outlineColourId)
					.withMultipliedAlpha (alpha));

	g.strokePath (p, PathStrokeType (2.0f));

	g.setColour (group.findColour (GroupComponent::textColourId)
					.withMultipliedAlpha (alpha));
	g.setFont (f);
	g.drawText (text,
				roundToInt (x + textX), 0,
				roundToInt (textW),
				roundToInt (textH),
				Justification::centred, true);
}

int LookAndFeel::getTabButtonOverlap (int tabDepth)
{
	return 1 + tabDepth / 3;
}

int LookAndFeel::getTabButtonSpaceAroundImage()
{
	return 4;
}

void LookAndFeel::createTabButtonShape (Path& p,
										int width, int height,
										int /*tabIndex*/,
										const String& /*text*/,
										Button& /*button*/,
										TabbedButtonBar::Orientation orientation,
										const bool /*isMouseOver*/,
										const bool /*isMouseDown*/,
										const bool /*isFrontTab*/)
{
	const float w = (float) width;
	const float h = (float) height;

	float length = w;
	float depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	const float indent = (float) getTabButtonOverlap ((int) depth);
	const float overhang = 4.0f;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		p.startNewSubPath (w, 0.0f);
		p.lineTo (0.0f, indent);
		p.lineTo (0.0f, h - indent);
		p.lineTo (w, h);
		p.lineTo (w + overhang, h + overhang);
		p.lineTo (w + overhang, -overhang);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		p.startNewSubPath (0.0f, 0.0f);
		p.lineTo (w, indent);
		p.lineTo (w, h - indent);
		p.lineTo (0.0f, h);
		p.lineTo (-overhang, h + overhang);
		p.lineTo (-overhang, -overhang);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		p.startNewSubPath (0.0f, 0.0f);
		p.lineTo (indent, h);
		p.lineTo (w - indent, h);
		p.lineTo (w, 0.0f);
		p.lineTo (w + overhang, -overhang);
		p.lineTo (-overhang, -overhang);
	}
	else
	{
		p.startNewSubPath (0.0f, h);
		p.lineTo (indent, 0.0f);
		p.lineTo (w - indent, 0.0f);
		p.lineTo (w, h);
		p.lineTo (w + overhang, h + overhang);
		p.lineTo (-overhang, h + overhang);
	}

	p.closeSubPath();

	p = p.createPathWithRoundedCorners (3.0f);
}

void LookAndFeel::fillTabButtonShape (Graphics& g,
									  const Path& path,
									  const Colour& preferredColour,
									  int /*tabIndex*/,
									  const String& /*text*/,
									  Button& button,
									  TabbedButtonBar::Orientation /*orientation*/,
									  const bool /*isMouseOver*/,
									  const bool /*isMouseDown*/,
									  const bool isFrontTab)
{
	g.setColour (isFrontTab ? preferredColour
							: preferredColour.withMultipliedAlpha (0.9f));

	g.fillPath (path);

	g.setColour (button.findColour (isFrontTab ? TabbedButtonBar::frontOutlineColourId
											   : TabbedButtonBar::tabOutlineColourId, false)
					.withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	g.strokePath (path, PathStrokeType (isFrontTab ? 1.0f : 0.5f));
}

void LookAndFeel::drawTabButtonText (Graphics& g,
									 int x, int y, int w, int h,
									 const Colour& preferredBackgroundColour,
									 int /*tabIndex*/,
									 const String& text,
									 Button& button,
									 TabbedButtonBar::Orientation orientation,
									 const bool isMouseOver,
									 const bool isMouseDown,
									 const bool isFrontTab)
{
	int length = w;
	int depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	Font font (depth * 0.6f);
	font.setUnderline (button.hasKeyboardFocus (false));

	GlyphArrangement textLayout;
	textLayout.addFittedText (font, text.trim(),
							  0.0f, 0.0f, (float) length, (float) depth,
							  Justification::centred,
							  jmax (1, depth / 12));

	AffineTransform transform;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		transform = transform.rotated (float_Pi * -0.5f)
							 .translated ((float) x, (float) (y + h));
	}
	else if (orientation  == TabbedButtonBar::TabsAtRight)
	{
		transform = transform.rotated (float_Pi * 0.5f)
							 .translated ((float) (x + w), (float) y);
	}
	else
	{
		transform = transform.translated ((float) x, (float) y);
	}

	if (isFrontTab && (button.isColourSpecified (TabbedButtonBar::frontTextColourId) || isColourSpecified (TabbedButtonBar::frontTextColourId)))
		g.setColour (findColour (TabbedButtonBar::frontTextColourId));
	else if (button.isColourSpecified (TabbedButtonBar::tabTextColourId) || isColourSpecified (TabbedButtonBar::tabTextColourId))
		g.setColour (findColour (TabbedButtonBar::tabTextColourId));
	else
		g.setColour (preferredBackgroundColour.contrasting());

	if (! (isMouseOver || isMouseDown))
		g.setOpacity (0.8f);

	if (! button.isEnabled())
		g.setOpacity (0.3f);

	textLayout.draw (g, transform);
}

int LookAndFeel::getTabButtonBestWidth (int /*tabIndex*/,
										const String& text,
										int tabDepth,
										Button&)
{
	Font f (tabDepth * 0.6f);
	return f.getStringWidth (text.trim()) + getTabButtonOverlap (tabDepth) * 2;
}

void LookAndFeel::drawTabButton (Graphics& g,
								 int w, int h,
								 const Colour& preferredColour,
								 int tabIndex,
								 const String& text,
								 Button& button,
								 TabbedButtonBar::Orientation orientation,
								 const bool isMouseOver,
								 const bool isMouseDown,
								 const bool isFrontTab)
{
	int length = w;
	int depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
			|| orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	Path tabShape;

	createTabButtonShape (tabShape, w, h,
						  tabIndex, text, button, orientation,
						  isMouseOver, isMouseDown, isFrontTab);

	fillTabButtonShape (g, tabShape, preferredColour,
						tabIndex, text, button, orientation,
						isMouseOver, isMouseDown, isFrontTab);

	const int indent = getTabButtonOverlap (depth);
	int x = 0, y = 0;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		y += indent;
		h -= indent * 2;
	}
	else
	{
		x += indent;
		w -= indent * 2;
	}

	drawTabButtonText (g, x, y, w, h, preferredColour,
					   tabIndex, text, button, orientation,
					   isMouseOver, isMouseDown, isFrontTab);
}

void LookAndFeel::drawTabAreaBehindFrontButton (Graphics& g,
												int w, int h,
												TabbedButtonBar& tabBar,
												TabbedButtonBar::Orientation orientation)
{
	const float shadowSize = 0.2f;

	float x1 = 0.0f, y1 = 0.0f, x2 = 0.0f, y2 = 0.0f;
	Rectangle<int> shadowRect;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		x1 = (float) w;
		x2 = w * (1.0f - shadowSize);
		shadowRect.setBounds ((int) x2, 0, w - (int) x2, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		x2 = w * shadowSize;
		shadowRect.setBounds (0, 0, (int) x2, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		y2 = h * shadowSize;
		shadowRect.setBounds (0, 0, w, (int) y2);
	}
	else
	{
		y1 = (float) h;
		y2 = h * (1.0f - shadowSize);
		shadowRect.setBounds (0, (int) y2, w, h - (int) y2);
	}

	g.setGradientFill (ColourGradient (Colours::black.withAlpha (tabBar.isEnabled() ? 0.3f : 0.15f), x1, y1,
									   Colours::transparentBlack, x2, y2, false));

	shadowRect.expand (2, 2);
	g.fillRect (shadowRect);

	g.setColour (Colour (0x80000000));

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		g.fillRect (w - 1, 0, 1, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		g.fillRect (0, 0, 1, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		g.fillRect (0, 0, w, 1);
	}
	else
	{
		g.fillRect (0, h - 1, w, 1);
	}
}

Button* LookAndFeel::createTabBarExtrasButton()
{
	const float thickness = 7.0f;
	const float indent = 22.0f;

	Path p;
	p.addEllipse (-10.0f, -10.0f, 120.0f, 120.0f);

	DrawablePath ellipse;
	ellipse.setPath (p);
	ellipse.setFill (Colour (0x99ffffff));

	p.clear();
	p.addEllipse (0.0f, 0.0f, 100.0f, 100.0f);
	p.addRectangle (indent, 50.0f - thickness, 100.0f - indent * 2.0f, thickness * 2.0f);
	p.addRectangle (50.0f - thickness, indent, thickness * 2.0f, 50.0f - indent - thickness);
	p.addRectangle (50.0f - thickness, 50.0f + thickness, thickness * 2.0f, 50.0f - indent - thickness);
	p.setUsingNonZeroWinding (false);

	DrawablePath dp;
	dp.setPath (p);
	dp.setFill (Colour (0x59000000));

	DrawableComposite normalImage;
	normalImage.addAndMakeVisible (ellipse.createCopy());
	normalImage.addAndMakeVisible (dp.createCopy());

	dp.setFill (Colour (0xcc000000));

	DrawableComposite overImage;
	overImage.addAndMakeVisible (ellipse.createCopy());
	overImage.addAndMakeVisible (dp.createCopy());

	DrawableButton* db = new DrawableButton ("tabs", DrawableButton::ImageFitted);
	db->setImages (&normalImage, &overImage, nullptr);
	return db;
}

void LookAndFeel::drawTableHeaderBackground (Graphics& g, TableHeaderComponent& header)
{
	g.fillAll (Colours::white);

	const int w = header.getWidth();
	const int h = header.getHeight();

	g.setGradientFill (ColourGradient (Colour (0xffe8ebf9), 0.0f, h * 0.5f,
									   Colour (0xfff6f8f9), 0.0f, h - 1.0f,
									   false));
	g.fillRect (0, h / 2, w, h);

	g.setColour (Colour (0x33000000));
	g.fillRect (0, h - 1, w, 1);

	for (int i = header.getNumColumns (true); --i >= 0;)
		g.fillRect (header.getColumnPosition (i).getRight() - 1, 0, 1, h - 1);
}

void LookAndFeel::drawTableHeaderColumn (Graphics& g, const String& columnName, int /*columnId*/,
										 int width, int height,
										 bool isMouseOver, bool isMouseDown,
										 int columnFlags)
{
	if (isMouseDown)
		g.fillAll (Colour (0x8899aadd));
	else if (isMouseOver)
		g.fillAll (Colour (0x5599aadd));

	int rightOfText = width - 4;

	if ((columnFlags & (TableHeaderComponent::sortedForwards | TableHeaderComponent::sortedBackwards)) != 0)
	{
		const float top = height * ((columnFlags & TableHeaderComponent::sortedForwards) != 0 ? 0.35f : (1.0f - 0.35f));
		const float bottom = height - top;

		const float w = height * 0.5f;
		const float x = rightOfText - (w * 1.25f);
		rightOfText = (int) x;

		Path sortArrow;
		sortArrow.addTriangle (x, bottom, x + w * 0.5f, top, x + w, bottom);

		g.setColour (Colour (0x99000000));
		g.fillPath (sortArrow);
	}

	g.setColour (Colours::black);
	g.setFont (height * 0.5f, Font::bold);
	const int textX = 4;
	g.drawFittedText (columnName, textX, 0, rightOfText - textX, height, Justification::centredLeft, 1);
}

void LookAndFeel::paintToolbarBackground (Graphics& g, int w, int h, Toolbar& toolbar)
{
	const Colour background (toolbar.findColour (Toolbar::backgroundColourId));

	g.setGradientFill (ColourGradient (background, 0.0f, 0.0f,
									   background.darker (0.1f),
									   toolbar.isVertical() ? w - 1.0f : 0.0f,
									   toolbar.isVertical() ? 0.0f : h - 1.0f,
									   false));
	g.fillAll();
}

Button* LookAndFeel::createToolbarMissingItemsButton (Toolbar& /*toolbar*/)
{
	return createTabBarExtrasButton();
}

void LookAndFeel::paintToolbarButtonBackground (Graphics& g, int /*width*/, int /*height*/,
												bool isMouseOver, bool isMouseDown,
												ToolbarItemComponent& component)
{
	if (isMouseDown)
		g.fillAll (component.findColour (Toolbar::buttonMouseDownBackgroundColourId, true));
	else if (isMouseOver)
		g.fillAll (component.findColour (Toolbar::buttonMouseOverBackgroundColourId, true));
}

void LookAndFeel::paintToolbarButtonLabel (Graphics& g, int x, int y, int width, int height,
										   const String& text, ToolbarItemComponent& component)
{
	g.setColour (component.findColour (Toolbar::labelTextColourId, true)
					.withAlpha (component.isEnabled() ? 1.0f : 0.25f));

	const float fontHeight = jmin (14.0f, height * 0.85f);
	g.setFont (fontHeight);

	g.drawFittedText (text,
					  x, y, width, height,
					  Justification::centred,
					  jmax (1, height / (int) fontHeight));
}

void LookAndFeel::drawPropertyPanelSectionHeader (Graphics& g, const String& name,
												  bool isOpen, int width, int height)
{
	const int buttonSize = (height * 3) / 4;
	const int buttonIndent = (height - buttonSize) / 2;

	drawTreeviewPlusMinusBox (g, buttonIndent, buttonIndent, buttonSize, buttonSize, ! isOpen, false);

	const int textX = buttonIndent * 2 + buttonSize + 2;

	g.setColour (Colours::black);
	g.setFont (height * 0.7f, Font::bold);
	g.drawText (name, textX, 0, width - textX - 4, height, Justification::centredLeft, true);
}

void LookAndFeel::drawPropertyComponentBackground (Graphics& g, int width, int height,
												   PropertyComponent&)
{
	g.setColour (Colour (0x66ffffff));
	g.fillRect (0, 0, width, height - 1);
}

void LookAndFeel::drawPropertyComponentLabel (Graphics& g, int, int height,
											  PropertyComponent& component)
{
	g.setColour (Colours::black);

	if (! component.isEnabled())
		g.setOpacity (0.6f);

	g.setFont (jmin (height, 24) * 0.65f);

	const Rectangle<int> r (getPropertyComponentContentPosition (component));

	g.drawFittedText (component.getName(),
					  3, r.getY(), r.getX() - 5, r.getHeight(),
					  Justification::centredLeft, 2);
}

const Rectangle<int> LookAndFeel::getPropertyComponentContentPosition (PropertyComponent& component)
{
	return Rectangle<int> (component.getWidth() / 3, 1,
						   component.getWidth() - component.getWidth() / 3 - 1, component.getHeight() - 3);
}

void LookAndFeel::drawCallOutBoxBackground (CallOutBox& box, Graphics& g, const Path& path)
{
	Image content (Image::ARGB, box.getWidth(), box.getHeight(), true);

	{
		Graphics g2 (content);

		g2.setColour (Colour::greyLevel (0.23f).withAlpha (0.9f));
		g2.fillPath (path);

		g2.setColour (Colours::white.withAlpha (0.8f));
		g2.strokePath (path, PathStrokeType (2.0f));
	}

	DropShadowEffect shadow;
	shadow.setShadowProperties (5.0f, 0.4f, 0, 2);
	shadow.applyEffect (content, g, 1.0f);
}

void LookAndFeel::createFileChooserHeaderText (const String& title,
											   const String& instructions,
											   GlyphArrangement& text,
											   int width)
{
	text.clear();

	text.addJustifiedText (Font (17.0f, Font::bold), title,
						   8.0f, 22.0f, width - 16.0f,
						   Justification::centred);

	text.addJustifiedText (Font (14.0f), instructions,
						   8.0f, 24.0f + 16.0f, width - 16.0f,
						   Justification::centred);
}

void LookAndFeel::drawFileBrowserRow (Graphics& g, int width, int height,
									  const String& filename, Image* icon,
									  const String& fileSizeDescription,
									  const String& fileTimeDescription,
									  const bool isDirectory,
									  const bool isItemSelected,
									  const int /*itemIndex*/,
									  DirectoryContentsDisplayComponent&)
{
	if (isItemSelected)
		g.fillAll (findColour (DirectoryContentsDisplayComponent::highlightColourId));

	const int x = 32;
	g.setColour (Colours::black);

	if (icon != nullptr && icon->isValid())
	{
		g.drawImageWithin (*icon, 2, 2, x - 4, height - 4,
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize,
						   false);
	}
	else
	{
		const Drawable* d = isDirectory ? getDefaultFolderImage()
										: getDefaultDocumentFileImage();

		if (d != nullptr)
			d->drawWithin (g, Rectangle<float> (2.0f, 2.0f, x - 4.0f, height - 4.0f),
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize, 1.0f);
	}

	g.setColour (findColour (DirectoryContentsDisplayComponent::textColourId));
	g.setFont (height * 0.7f);

	if (width > 450 && ! isDirectory)
	{
		const int sizeX = roundToInt (width * 0.7f);
		const int dateX = roundToInt (width * 0.8f);

		g.drawFittedText (filename,
						  x, 0, sizeX - x, height,
						  Justification::centredLeft, 1);

		g.setFont (height * 0.5f);
		g.setColour (Colours::darkgrey);

		if (! isDirectory)
		{
			g.drawFittedText (fileSizeDescription,
							  sizeX, 0, dateX - sizeX - 8, height,
							  Justification::centredRight, 1);

			g.drawFittedText (fileTimeDescription,
							  dateX, 0, width - 8 - dateX, height,
							  Justification::centredRight, 1);
		}
	}
	else
	{
		g.drawFittedText (filename,
						  x, 0, width - x, height,
						  Justification::centredLeft, 1);

	}
}

Button* LookAndFeel::createFileBrowserGoUpButton()
{
	DrawableButton* goUpButton = new DrawableButton ("up", DrawableButton::ImageOnButtonBackground);

	Path arrowPath;
	arrowPath.addArrow (Line<float> (50.0f, 100.0f, 50.0f, 0.0f), 40.0f, 100.0f, 50.0f);

	DrawablePath arrowImage;
	arrowImage.setFill (Colours::black.withAlpha (0.4f));
	arrowImage.setPath (arrowPath);

	goUpButton->setImages (&arrowImage);

	return goUpButton;
}

void LookAndFeel::layoutFileBrowserComponent (FileBrowserComponent& browserComp,
											  DirectoryContentsDisplayComponent* fileListComponent,
											  FilePreviewComponent* previewComp,
											  ComboBox* currentPathBox,
											  TextEditor* filenameBox,
											  Button* goUpButton)
{
	const int x = 8;
	int w = browserComp.getWidth() - x - x;

	if (previewComp != nullptr)
	{
		const int previewWidth = w / 3;
		previewComp->setBounds (x + w - previewWidth, 0, previewWidth, browserComp.getHeight());

		w -= previewWidth + 4;
	}

	int y = 4;

	const int controlsHeight = 22;
	const int bottomSectionHeight = controlsHeight + 8;
	const int upButtonWidth = 50;

	currentPathBox->setBounds (x, y, w - upButtonWidth - 6, controlsHeight);
	goUpButton->setBounds (x + w - upButtonWidth, y, upButtonWidth, controlsHeight);

	y += controlsHeight + 4;

	Component* const listAsComp = dynamic_cast <Component*> (fileListComponent);
	listAsComp->setBounds (x, y, w, browserComp.getHeight() - y - bottomSectionHeight);

	y = listAsComp->getBottom() + 4;
	filenameBox->setBounds (x + 50, y, w - 50, controlsHeight);
}

// Pulls a drawable out of compressed valuetree data..
Drawable* LookAndFeel::loadDrawableFromData (const void* data, size_t numBytes)
{
	MemoryInputStream m (data, numBytes, false);
	GZIPDecompressorInputStream gz (m);
	ValueTree drawable (ValueTree::readFromStream (gz));
	return Drawable::createFromValueTree (drawable.getChild (0), nullptr);
}

const Drawable* LookAndFeel::getDefaultFolderImage()
{
	if (folderImage == nullptr)
	{
		static const unsigned char drawableData[] =
		{ 120,218,197,86,77,111,27,55,16,229,182,161,237,6,61,39,233,77,63,192,38,56,195,225,215,209,105,210,2,141,13,20,201,193,109,111,178,181,178,183,145,181,130,180,110,145,127,159,199,93,73,137,87,53,218,91,109,192,160,151,179,156,55,111,222,188,229,155,247,
		231,87,231,175,47,222,170,234,155,229,244,190,86,213,115,253,102,61,253,123,122,189,168,85,51,83,213,119,250,238,221,47,231,151,175,223,169,170,250,121,221,62,172,84,245,172,60,63,209,243,118,49,171,215,170,107,87,23,245,188,83,213,145,182,167,19,91,
		254,127,223,220,222,117,37,68,82,40,143,174,219,174,107,239,135,168,147,18,37,108,85,245,237,46,207,70,33,249,175,211,238,78,85,186,28,253,76,175,73,109,186,117,251,177,190,106,102,229,241,247,58,24,103,203,15,101,245,103,219,44,187,15,221,39,0,172,142,
		245,125,211,1,196,205,116,181,125,114,164,175,31,186,78,45,219,229,31,245,186,189,106,150,179,102,121,139,100,154,240,231,167,102,177,64,72,247,105,213,23,122,187,158,206,154,122,217,169,85,57,18,1,47,53,101,107,18,135,204,167,147,192,201,216,20,114,
		244,195,62,171,234,7,125,198,100,136,216,145,149,211,9,57,103,40,249,72,219,8,167,170,87,250,140,162,199,123,226,3,34,82,202,134,131,13,172,74,170,233,162,0,177,234,166,93,180,15,235,141,170,206,180,157,204,231,150,156,159,207,39,195,50,214,88,18,150,
		245,205,124,250,104,169,212,135,158,19,144,53,20,112,172,55,237,2,132,13,199,149,130,230,115,145,112,147,147,82,61,157,32,238,178,253,11,145,213,138,10,52,138,38,103,111,99,164,211,137,139,198,35,177,35,167,212,143,15,215,205,13,160,109,163,172,225,152,
		16,232,17,149,140,103,144,158,146,90,113,217,12,6,197,167,236,3,54,5,181,101,73,54,138,90,245,165,227,120,18,252,150,77,15,242,188,228,204,81,169,139,102,249,5,68,192,145,14,244,112,1,145,29,94,137,96,235,49,136,151,58,246,32,88,192,161,88,176,76,226,
		36,247,24,176,7,232,62,16,83,42,155,201,160,30,222,65,72,98,82,76,33,198,254,197,96,124,10,150,243,8,130,48,228,36,94,124,6,4,43,38,0,142,205,99,30,4,221,13,33,230,220,71,177,65,49,142,243,150,7,1,51,20,2,5,96,96,84,225,56,217,188,3,33,46,24,228,112,
		69,69,12,68,228,108,242,99,16,165,118,208,28,51,200,98,87,42,74,62,209,24,4,206,48,22,153,125,132,220,196,56,15,234,99,216,130,0,141,38,74,162,130,48,35,163,141,94,196,245,32,94,104,7,154,132,209,40,108,162,165,232,153,165,17,4,138,201,176,135,58,49,
		165,130,122,108,114,54,28,240,64,17,89,188,79,177,116,149,10,4,246,91,30,94,104,112,96,226,144,131,144,142,98,78,177,7,128,81,242,224,140,36,249,80,208,145,196,12,202,15,16,60,161,200,69,187,169,213,86,198,123,87,224,255,199,21,94,105,134,72,40,177,245,
		14,182,32,232,54,196,231,100,111,11,189,168,201,39,177,84,102,38,139,177,168,74,210,87,174,64,20,138,160,67,111,10,4,98,196,97,60,158,118,133,25,111,173,224,171,37,97,185,119,133,221,242,63,184,194,140,71,174,240,252,145,43,72,32,147,146,147,4,104,104,
		117,134,10,18,12,107,212,40,72,148,57,6,71,69,135,222,248,16,160,168,3,169,144,55,201,69,41,147,137,134,99,50,97,8,178,85,43,217,140,201,151,192,152,10,242,190,24,11,59,183,29,25,42,115,236,98,14,229,252,32,80,66,0,162,17,136,72,6,67,5,45,242,224,10,
		193,102,71,50,6,17,129,212,18,115,105,150,80,169,45,123,222,141,76,178,70,32,55,24,90,217,132,71,73,200,57,238,204,3,136,49,144,185,55,183,190,20,137,52,246,47,113,232,158,69,35,49,145,208,129,193,56,178,77,135,230,145,113,22,140,69,74,20,146,2,120,218,
		155,135,48,32,10,89,30,156,165,204,254,222,193,160,12,19,49,6,210,59,11,70,62,4,31,15,64,196,2,157,98,33,58,1,104,32,152,50,31,128,64,148,183,197,108,209,89,107,240,41,75,36,123,16,208,108,180,44,236,250,182,227,27,20,137,118,76,60,165,137,221,92,94,
		78,215,31,235,245,230,183,242,229,30,214,251,251,195,145,94,148,15,253,170,221,52,93,211,46,7,109,171,81,208,177,94,247,119,132,47,81,186,92,22,246,7,255,254,15,7,107,141,171,197,191,156,123,162,135,187,198,227,131,113,219,80,159,1,4,239,223,231,0,0 };

		folderImage = loadDrawableFromData (drawableData, sizeof (drawableData));
	}

	return folderImage;
}

const Drawable* LookAndFeel::getDefaultDocumentFileImage()
{
	if (documentImage == nullptr)
	{
		static const unsigned char drawableData[] =
		{ 120,218,213,88,77,115,219,54,16,37,147,208,246,228,214,75,155,246,164,123,29,12,176,216,197,199,49,105,218,94,156,153,78,114,72,219,155,108,75,137,26,89,212,200,116,59,233,175,239,3,105,201,164,68,50,158,166,233,76,196,11,69,60,173,128,197,123,139,183,
		124,241,234,217,155,103,207,207,126,204,242,7,171,233,213,44,203,31,23,47,54,211,191,166,231,203,89,182,184,204,242,147,226,195,165,219,252,125,150,229,249,207,155,242,102,157,229,143,210,227,199,197,101,121,113,115,53,91,85,89,85,174,207,102,243,42,
		203,143,10,125,58,209,233,251,171,197,219,119,85,250,173,97,151,30,157,151,85,85,94,53,168,147,132,50,226,179,252,225,246,143,174,179,44,63,254,101,90,189,203,242,34,5,127,84,172,77,118,93,109,202,247,179,55,139,203,244,248,97,161,179,63,202,197,170,
		122,93,125,192,196,242,227,226,106,81,205,54,217,197,116,125,251,228,168,56,191,169,170,108,85,174,126,159,109,202,55,139,213,229,98,245,182,249,97,254,240,167,197,114,137,5,86,31,214,245,111,175,203,37,254,230,162,92,150,55,155,180,148,249,237,39,203,
		94,215,127,58,10,213,245,39,203,234,249,102,249,87,47,203,63,129,204,49,227,252,73,225,149,145,104,131,245,254,116,34,202,82,164,16,153,179,236,108,177,234,7,49,41,237,130,144,167,17,144,15,42,104,239,93,12,35,32,99,68,9,187,24,125,7,244,77,23,36,164,
		40,56,226,61,12,107,229,130,215,100,105,24,227,89,17,246,211,105,55,140,49,218,43,207,100,245,72,28,195,70,17,230,201,118,8,243,164,139,233,95,88,23,52,152,162,54,104,48,217,237,105,15,111,91,107,253,131,160,118,34,239,69,128,54,232,135,101,121,61,203,
		110,169,181,147,2,253,159,82,48,180,229,247,167,74,193,41,141,188,35,93,241,116,18,148,113,214,120,207,113,47,19,109,16,51,182,153,193,5,59,2,10,90,69,114,218,135,48,2,50,198,43,171,189,152,81,144,88,108,85,136,78,246,64,54,42,163,35,69,30,3,121,82,38,
		98,81,98,70,64,70,139,34,111,163,167,49,144,13,202,138,179,58,220,23,52,180,186,54,104,48,79,109,208,96,198,219,19,31,220,187,118,10,6,65,237,100,222,139,5,109,80,191,30,236,151,162,135,147,142,30,68,105,182,58,6,22,84,43,229,124,148,116,97,145,55,231,
		139,11,76,228,16,37,14,48,205,145,77,134,34,176,55,152,182,200,57,99,93,204,144,145,253,65,97,229,132,72,104,63,62,71,21,140,54,186,41,226,59,84,19,63,130,15,222,235,224,185,59,104,27,226,68,101,153,241,227,177,248,29,20,136,26,8,252,178,183,241,219,
		131,137,160,209,107,109,92,79,124,16,211,184,104,93,77,130,110,124,2,65,172,67,201,60,157,88,163,2,91,99,92,216,198,55,78,69,75,190,150,119,84,98,200,71,150,109,124,36,204,227,52,8,33,229,223,68,167,173,167,131,248,137,212,226,141,19,233,160,154,248,
		144,142,195,140,137,185,59,104,15,247,119,40,126,23,69,81,200,242,110,254,123,20,49,94,112,110,245,199,111,241,167,87,36,252,101,138,132,149,22,22,38,65,134,29,182,139,24,230,192,31,144,184,133,130,72,44,131,210,142,111,147,216,30,76,123,30,113,206,242,
		150,196,157,65,129,130,76,180,194,61,34,225,160,5,228,233,160,118,34,137,26,202,115,212,29,108,72,134,243,223,90,114,226,199,226,119,80,6,245,152,197,122,217,146,184,53,24,140,210,30,21,59,80,79,124,182,202,71,207,218,112,159,72,80,53,140,109,68,2,191,
		227,217,210,78,36,94,137,88,231,82,157,8,176,61,0,122,191,19,137,3,255,13,39,183,228,20,193,151,144,119,166,79,36,40,253,156,138,72,11,181,19,137,14,46,176,217,27,180,135,251,219,31,255,235,61,148,165,96,72,122,118,23,229,81,52,135,24,250,163,183,216,
		211,43,17,217,151,136,253,116,137,28,53,188,127,92,188,221,76,47,23,169,59,90,167,144,141,239,197,86,104,141,189,60,157,80,84,142,140,4,31,154,241,122,105,132,41,107,13,201,39,86,120,24,82,114,206,198,6,96,27,227,172,36,232,168,201,36,219,24,113,62,163,
		154,101,233,143,166,203,102,26,141,206,174,179,252,89,161,39,243,249,197,121,186,38,233,246,146,211,53,1,123,56,194,231,122,143,103,179,217,60,204,167,19,147,110,41,93,173,219,123,72,89,248,35,173,16,220,50,179,111,60,181,24,88,103,156,235,7,78,248,14,
		4,119,78,162,93,60,112,35,109,16,124,126,12,17,71,67,24,1,165,142,1,181,215,248,56,6,66,235,193,137,167,61,22,30,5,3,27,101,71,64,169,25,112,216,2,63,22,169,110,43,18,200,140,129,208,160,88,44,220,208,125,65,67,171,107,131,6,243,212,6,13,102,188,61,241,
		225,189,107,165,96,16,212,78,230,189,88,208,6,245,235,214,237,235,150,62,167,110,155,106,170,53,133,192,117,193,20,84,78,74,174,98,39,92,156,8,112,21,46,80,106,12,209,207,225,228,16,113,59,225,126,87,60,133,25,209,34,36,2,99,242,52,197,48,30,75,244,247,
		212,238,246,182,173,221,185,78,215,127,167,221,162,163,221,250,152,217,146,196,222,145,100,223,235,105,108,28,250,149,212,74,224,86,2,213,118,110,119,204,224,144,208,38,214,131,200,14,214,223,120,189,230,53,1,193,70,133,154,131,56,223,16,229,48,188,14,
		201,205,213,121,71,233,68,89,15,124,103,37,53,26,11,118,176,127,169,88,166,158,219,178,117,173,83,108,75,95,55,68,186,193,53,246,146,206,127,6,63,53,78,58,228,204,155,224,113,74,91,232,221,195,240,105,215,34,29,138,64,128,183,8,130,233,71,173,56,54,101,
		99,75,186,111,65,58,28,229,145,82,19,152,12,99,180,81,130,131,75,234,229,220,247,53,231,154,79,205,185,185,155,199,249,172,38,85,253,204,76,68,95,92,204,207,255,221,75,178,227,14,187,224,224,97,202,172,173,219,12,167,130,133,9,54,135,245,92,176,29,134,
		165,110,139,141,18,16,223,29,188,183,65,207,144,106,144,151,143,128,224,176,168,110,140,32,62,56,110,219,195,54,235,20,68,209,216,34,232,21,6,41,234,157,39,211,201,107,160,230,66,225,56,153,9,101,21,37,237,150,204,14,115,208,22,221,54,216,230,33,116,
		14,65,14,44,19,8,236,73,71,246,182,110,125,224,75,132,195,214,247,163,36,51,252,84,76,124,37,212,100,88,62,183,179,76,67,217,218,242,244,229,116,243,126,182,185,254,21,105,126,208,220,239,94,229,30,21,203,244,202,117,93,94,47,170,69,185,106,246,60,219,
		3,29,23,155,250,109,237,29,170,72,175,109,119,129,127,235,9,92,20,85,185,254,72,220,147,162,121,235,219,13,44,144,225,63,241,244,165,51,0,0 };

		documentImage = loadDrawableFromData (drawableData, sizeof (drawableData));
	}

	return documentImage;
}

void LookAndFeel::drawLevelMeter (Graphics& g, int width, int height, float level)
{
	g.setColour (Colours::white.withAlpha (0.7f));
	g.fillRoundedRectangle (0.0f, 0.0f, (float) width, (float) height, 3.0f);
	g.setColour (Colours::black.withAlpha (0.2f));
	g.drawRoundedRectangle (1.0f, 1.0f, width - 2.0f, height - 2.0f, 3.0f, 1.0f);

	const int totalBlocks = 7;
	const int numBlocks = roundToInt (totalBlocks * level);
	const float w = (width - 6.0f) / (float) totalBlocks;

	for (int i = 0; i < totalBlocks; ++i)
	{
		if (i >= numBlocks)
			g.setColour (Colours::lightblue.withAlpha (0.6f));
		else
			g.setColour (i < totalBlocks - 1 ? Colours::blue.withAlpha (0.5f)
											 : Colours::red);

		g.fillRoundedRectangle (3.0f + i * w + w * 0.1f, 3.0f, w * 0.8f, height - 6.0f, w * 0.4f);
	}
}

void LookAndFeel::drawKeymapChangeButton (Graphics& g, int width, int height, Button& button, const String& keyDescription)
{
	const Colour textColour (button.findColour (0x100ad01 /*KeyMappingEditorComponent::textColourId*/, true));

	if (keyDescription.isNotEmpty())
	{
		if (button.isEnabled())
		{
			const float alpha = button.isDown() ? 0.3f : (button.isOver() ? 0.15f : 0.08f);
			g.fillAll (textColour.withAlpha (alpha));

			g.setOpacity (0.3f);
			g.drawBevel (0, 0, width, height, 2);
		}

		g.setColour (textColour);
		g.setFont (height * 0.6f);
		g.drawFittedText (keyDescription,
						  3, 0, width - 6, height,
						  Justification::centred, 1);
	}
	else
	{
		const float thickness = 7.0f;
		const float indent = 22.0f;

		Path p;
		p.addEllipse (0.0f, 0.0f, 100.0f, 100.0f);
		p.addRectangle (indent, 50.0f - thickness, 100.0f - indent * 2.0f, thickness * 2.0f);
		p.addRectangle (50.0f - thickness, indent, thickness * 2.0f, 50.0f - indent - thickness);
		p.addRectangle (50.0f - thickness, 50.0f + thickness, thickness * 2.0f, 50.0f - indent - thickness);
		p.setUsingNonZeroWinding (false);

		g.setColour (textColour.withAlpha (button.isDown() ? 0.7f : (button.isOver() ? 0.5f : 0.3f)));
		g.fillPath (p, p.getTransformToScaleToFit (2.0f, 2.0f, width - 4.0f, height - 4.0f, true));
	}

	if (button.hasKeyboardFocus (false))
	{
		g.setColour (textColour.withAlpha (0.4f));
		g.drawRect (0, 0, width, height);
	}
}

void LookAndFeel::drawShinyButtonShape (Graphics& g,
										float x, float y, float w, float h,
										float maxCornerSize,
										const Colour& baseColour,
										const float strokeWidth,
										const bool flatOnLeft,
										const bool flatOnRight,
										const bool flatOnTop,
										const bool flatOnBottom) noexcept
{
	if (w <= strokeWidth * 1.1f || h <= strokeWidth * 1.1f)
		return;

	const float cs = jmin (maxCornerSize, w * 0.5f, h * 0.5f);

	Path outline;
	LookAndFeelHelpers::createRoundedPath (outline, x, y, w, h, cs,
											! (flatOnLeft || flatOnTop),
											! (flatOnRight || flatOnTop),
											! (flatOnLeft || flatOnBottom),
											! (flatOnRight || flatOnBottom));

	ColourGradient cg (baseColour, 0.0f, y,
					   baseColour.overlaidWith (Colour (0x070000ff)), 0.0f, y + h,
					   false);

	cg.addColour (0.5, baseColour.overlaidWith (Colour (0x33ffffff)));
	cg.addColour (0.51, baseColour.overlaidWith (Colour (0x110000ff)));

	g.setGradientFill (cg);
	g.fillPath (outline);

	g.setColour (Colour (0x80000000));
	g.strokePath (outline, PathStrokeType (strokeWidth));
}

void LookAndFeel::drawGlassSphere (Graphics& g,
								   const float x, const float y,
								   const float diameter,
								   const Colour& colour,
								   const float outlineThickness) noexcept
{
	if (diameter <= outlineThickness)
		return;

	Path p;
	p.addEllipse (x, y, diameter, diameter);

	{
		ColourGradient cg (Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y,
						   Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y + diameter, false);

		cg.addColour (0.4, Colours::white.overlaidWith (colour));

		g.setGradientFill (cg);
		g.fillPath (p);
	}

	g.setGradientFill (ColourGradient (Colours::white, 0, y + diameter * 0.06f,
									   Colours::transparentWhite, 0, y + diameter * 0.3f, false));
	g.fillEllipse (x + diameter * 0.2f, y + diameter * 0.05f, diameter * 0.6f, diameter * 0.4f);

	ColourGradient cg (Colours::transparentBlack,
					   x + diameter * 0.5f, y + diameter * 0.5f,
					   Colours::black.withAlpha (0.5f * outlineThickness * colour.getFloatAlpha()),
					   x, y + diameter * 0.5f, true);

	cg.addColour (0.7, Colours::transparentBlack);
	cg.addColour (0.8, Colours::black.withAlpha (0.1f * outlineThickness));

	g.setGradientFill (cg);
	g.fillPath (p);

	g.setColour (Colours::black.withAlpha (0.5f * colour.getFloatAlpha()));
	g.drawEllipse (x, y, diameter, diameter, outlineThickness);
}

void LookAndFeel::drawGlassPointer (Graphics& g,
									const float x, const float y,
									const float diameter,
									const Colour& colour, const float outlineThickness,
									const int direction) noexcept
{
	if (diameter <= outlineThickness)
		return;

	Path p;
	p.startNewSubPath (x + diameter * 0.5f, y);
	p.lineTo (x + diameter, y + diameter * 0.6f);
	p.lineTo (x + diameter, y + diameter);
	p.lineTo (x, y + diameter);
	p.lineTo (x, y + diameter * 0.6f);
	p.closeSubPath();

	p.applyTransform (AffineTransform::rotation (direction * (float_Pi * 0.5f), x + diameter * 0.5f, y + diameter * 0.5f));

	{
		ColourGradient cg (Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y,
						   Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y + diameter, false);

		cg.addColour (0.4, Colours::white.overlaidWith (colour));

		g.setGradientFill (cg);
		g.fillPath (p);
	}

	ColourGradient cg (Colours::transparentBlack,
					   x + diameter * 0.5f, y + diameter * 0.5f,
					   Colours::black.withAlpha (0.5f * outlineThickness * colour.getFloatAlpha()),
					   x - diameter * 0.2f, y + diameter * 0.5f, true);

	cg.addColour (0.5, Colours::transparentBlack);
	cg.addColour (0.7, Colours::black.withAlpha (0.07f * outlineThickness));

	g.setGradientFill (cg);
	g.fillPath (p);

	g.setColour (Colours::black.withAlpha (0.5f * colour.getFloatAlpha()));
	g.strokePath (p, PathStrokeType (outlineThickness));
}

void LookAndFeel::drawGlassLozenge (Graphics& g,
									const float x, const float y,
									const float width, const float height,
									const Colour& colour,
									const float outlineThickness,
									const float cornerSize,
									const bool flatOnLeft,
									const bool flatOnRight,
									const bool flatOnTop,
									const bool flatOnBottom) noexcept
{
	if (width <= outlineThickness || height <= outlineThickness)
		return;

	const int intX = (int) x;
	const int intY = (int) y;
	const int intW = (int) width;
	const int intH = (int) height;

	const float cs = cornerSize < 0 ? jmin (width * 0.5f, height * 0.5f) : cornerSize;
	const float edgeBlurRadius = height * 0.75f + (height - cs * 2.0f);
	const int intEdge = (int) edgeBlurRadius;

	Path outline;
	LookAndFeelHelpers::createRoundedPath (outline, x, y, width, height, cs,
											! (flatOnLeft || flatOnTop),
											! (flatOnRight || flatOnTop),
											! (flatOnLeft || flatOnBottom),
											! (flatOnRight || flatOnBottom));

	{
		ColourGradient cg (colour.darker (0.2f), 0, y,
						   colour.darker (0.2f), 0, y + height, false);

		cg.addColour (0.03, colour.withMultipliedAlpha (0.3f));
		cg.addColour (0.4, colour);
		cg.addColour (0.97, colour.withMultipliedAlpha (0.3f));

		g.setGradientFill (cg);
		g.fillPath (outline);
	}

	ColourGradient cg (Colours::transparentBlack, x + edgeBlurRadius, y + height * 0.5f,
					   colour.darker (0.2f), x, y + height * 0.5f, true);

	cg.addColour (jlimit (0.0, 1.0, 1.0 - (cs * 0.5f) / edgeBlurRadius), Colours::transparentBlack);
	cg.addColour (jlimit (0.0, 1.0, 1.0 - (cs * 0.25f) / edgeBlurRadius), colour.darker (0.2f).withMultipliedAlpha (0.3f));

	if (! (flatOnLeft || flatOnTop || flatOnBottom))
	{
		g.saveState();
		g.setGradientFill (cg);
		g.reduceClipRegion (intX, intY, intEdge, intH);
		g.fillPath (outline);
		g.restoreState();
	}

	if (! (flatOnRight || flatOnTop || flatOnBottom))
	{
		cg.point1.setX (x + width - edgeBlurRadius);
		cg.point2.setX (x + width);

		g.saveState();
		g.setGradientFill (cg);
		g.reduceClipRegion (intX + intW - intEdge, intY, 2 + intEdge, intH);
		g.fillPath (outline);
		g.restoreState();
	}

	{
		const float leftIndent = flatOnTop || flatOnLeft ? 0.0f : cs * 0.4f;
		const float rightIndent = flatOnTop || flatOnRight ? 0.0f : cs * 0.4f;

		Path highlight;
		LookAndFeelHelpers::createRoundedPath (highlight,
											   x + leftIndent,
											   y + cs * 0.1f,
											   width - (leftIndent + rightIndent),
											   height * 0.4f, cs * 0.4f,
											   ! (flatOnLeft || flatOnTop),
											   ! (flatOnRight || flatOnTop),
											   ! (flatOnLeft || flatOnBottom),
											   ! (flatOnRight || flatOnBottom));

		g.setGradientFill (ColourGradient (colour.brighter (10.0f), 0, y + height * 0.06f,
										   Colours::transparentWhite, 0, y + height * 0.4f, false));
		g.fillPath (highlight);
	}

	g.setColour (colour.darker().withMultipliedAlpha (1.5f));
	g.strokePath (outline, PathStrokeType (outlineThickness));
}

/*** End of inlined file: juce_LookAndFeel.cpp ***/


/*** Start of inlined file: juce_MenuBarComponent.cpp ***/
MenuBarComponent::MenuBarComponent (MenuBarModel* model_)
	: model (nullptr),
	  itemUnderMouse (-1),
	  currentPopupIndex (-1),
	  topLevelIndexClicked (0)
{
	setRepaintsOnMouseActivity (true);
	setWantsKeyboardFocus (false);
	setMouseClickGrabsKeyboardFocus (false);

	setModel (model_);
}

MenuBarComponent::~MenuBarComponent()
{
	setModel (nullptr);
	Desktop::getInstance().removeGlobalMouseListener (this);
}

MenuBarModel* MenuBarComponent::getModel() const noexcept
{
	return model;
}

void MenuBarComponent::setModel (MenuBarModel* const newModel)
{
	if (model != newModel)
	{
		if (model != nullptr)
			model->removeListener (this);

		model = newModel;

		if (model != nullptr)
			model->addListener (this);

		repaint();
		menuBarItemsChanged (nullptr);
	}
}

void MenuBarComponent::paint (Graphics& g)
{
	const bool isMouseOverBar = currentPopupIndex >= 0 || itemUnderMouse >= 0 || isMouseOver();

	getLookAndFeel().drawMenuBarBackground (g,
											getWidth(),
											getHeight(),
											isMouseOverBar,
											*this);

	if (model != nullptr)
	{
		for (int i = 0; i < menuNames.size(); ++i)
		{
			Graphics::ScopedSaveState ss (g);

			g.setOrigin (xPositions [i], 0);
			g.reduceClipRegion (0, 0, xPositions[i + 1] - xPositions[i], getHeight());

			getLookAndFeel().drawMenuBarItem (g,
											  xPositions[i + 1] - xPositions[i],
											  getHeight(),
											  i,
											  menuNames[i],
											  i == itemUnderMouse,
											  i == currentPopupIndex,
											  isMouseOverBar,
											  *this);
		}
	}
}

void MenuBarComponent::resized()
{
	xPositions.clear();
	int x = 0;
	xPositions.add (x);

	for (int i = 0; i < menuNames.size(); ++i)
	{
		x += getLookAndFeel().getMenuBarItemWidth (*this, i, menuNames[i]);
		xPositions.add (x);
	}
}

int MenuBarComponent::getItemAt (const Point<int>& p)
{
	for (int i = 0; i < xPositions.size(); ++i)
		if (p.x >= xPositions[i] && p.x < xPositions[i + 1])
			return reallyContains (p, true) ? i : -1;

	return -1;
}

void MenuBarComponent::repaintMenuItem (int index)
{
	if (isPositiveAndBelow (index, xPositions.size()))
	{
		const int x1 = xPositions [index];
		const int x2 = xPositions [index + 1];

		repaint (x1 - 2, 0, x2 - x1 + 4, getHeight());
	}
}

void MenuBarComponent::setItemUnderMouse (const int index)
{
	if (itemUnderMouse != index)
	{
		repaintMenuItem (itemUnderMouse);
		itemUnderMouse = index;
		repaintMenuItem (itemUnderMouse);
	}
}

void MenuBarComponent::setOpenItem (int index)
{
	if (currentPopupIndex != index)
	{
		repaintMenuItem (currentPopupIndex);
		currentPopupIndex = index;
		repaintMenuItem (currentPopupIndex);

		Desktop& desktop = Desktop::getInstance();

		if (index >= 0)
			desktop.addGlobalMouseListener (this);
		else
			desktop.removeGlobalMouseListener (this);
	}
}

void MenuBarComponent::updateItemUnderMouse (const Point<int>& p)
{
	setItemUnderMouse (getItemAt (p));
}

void MenuBarComponent::showMenu (int index)
{
	if (index != currentPopupIndex)
	{
		PopupMenu::dismissAllActiveMenus();
		menuBarItemsChanged (nullptr);

		setOpenItem (index);
		setItemUnderMouse (index);

		if (index >= 0)
		{
			PopupMenu m (model->getMenuForIndex (itemUnderMouse,
												 menuNames [itemUnderMouse]));

			if (m.lookAndFeel == nullptr)
				m.setLookAndFeel (&getLookAndFeel());

			const Rectangle<int> itemPos (xPositions [index], 0, xPositions [index + 1] - xPositions [index], getHeight());

			m.showMenuAsync (PopupMenu::Options().withTargetComponent (this)
												 .withTargetScreenArea (localAreaToGlobal (itemPos))
												 .withMinimumWidth (itemPos.getWidth()),
							 ModalCallbackFunction::forComponent (menuBarMenuDismissedCallback, this, index));
		}
	}
}

void MenuBarComponent::menuBarMenuDismissedCallback (int result, MenuBarComponent* bar, int topLevelIndex)
{
	if (bar != nullptr)
		bar->menuDismissed (topLevelIndex, result);
}

void MenuBarComponent::menuDismissed (int topLevelIndex, int itemId)
{
	topLevelIndexClicked = topLevelIndex;
	postCommandMessage (itemId);
}

void MenuBarComponent::handleCommandMessage (int commandId)
{
	const Point<int> mousePos (getMouseXYRelative());
	updateItemUnderMouse (mousePos);

	if (currentPopupIndex == topLevelIndexClicked)
		setOpenItem (-1);

	if (commandId != 0 && model != nullptr)
		model->menuItemSelected (commandId, topLevelIndexClicked);
}

void MenuBarComponent::mouseEnter (const MouseEvent& e)
{
	if (e.eventComponent == this)
		updateItemUnderMouse (e.getPosition());
}

void MenuBarComponent::mouseExit (const MouseEvent& e)
{
	if (e.eventComponent == this)
		updateItemUnderMouse (e.getPosition());
}

void MenuBarComponent::mouseDown (const MouseEvent& e)
{
	if (currentPopupIndex < 0)
	{
		const MouseEvent e2 (e.getEventRelativeTo (this));
		updateItemUnderMouse (e2.getPosition());

		currentPopupIndex = -2;
		showMenu (itemUnderMouse);
	}
}

void MenuBarComponent::mouseDrag (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));
	const int item = getItemAt (e2.getPosition());

	if (item >= 0)
		showMenu (item);
}

void MenuBarComponent::mouseUp (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));

	updateItemUnderMouse (e2.getPosition());

	if (itemUnderMouse < 0 && getLocalBounds().contains (e2.x, e2.y))
	{
		setOpenItem (-1);
		PopupMenu::dismissAllActiveMenus();
	}
}

void MenuBarComponent::mouseMove (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));

	if (lastMousePos != e2.getPosition())
	{
		if (currentPopupIndex >= 0)
		{
			const int item = getItemAt (e2.getPosition());

			if (item >= 0)
				showMenu (item);
		}
		else
		{
			updateItemUnderMouse (e2.getPosition());
		}

		lastMousePos = e2.getPosition();
	}
}

bool MenuBarComponent::keyPressed (const KeyPress& key)
{
	bool used = false;
	const int numMenus = menuNames.size();
	const int currentIndex = jlimit (0, menuNames.size() - 1, currentPopupIndex);

	if (key.isKeyCode (KeyPress::leftKey))
	{
		showMenu ((currentIndex + numMenus - 1) % numMenus);
		used = true;
	}
	else if (key.isKeyCode (KeyPress::rightKey))
	{
		showMenu ((currentIndex + 1) % numMenus);
		used = true;
	}

	return used;
}

void MenuBarComponent::menuBarItemsChanged (MenuBarModel* /*menuBarModel*/)
{
	StringArray newNames;

	if (model != nullptr)
		newNames = model->getMenuBarNames();

	if (newNames != menuNames)
	{
		menuNames = newNames;
		repaint();
		resized();
	}
}

void MenuBarComponent::menuCommandInvoked (MenuBarModel* /*menuBarModel*/,
										   const ApplicationCommandTarget::InvocationInfo& info)
{
	if (model == nullptr || (info.commandFlags & ApplicationCommandInfo::dontTriggerVisualFeedback) != 0)
		return;

	for (int i = 0; i < menuNames.size(); ++i)
	{
		const PopupMenu menu (model->getMenuForIndex (i, menuNames [i]));

		if (menu.containsCommandItem (info.commandID))
		{
			setItemUnderMouse (i);
			startTimer (200);
			break;
		}
	}
}

void MenuBarComponent::timerCallback()
{
	stopTimer();
	updateItemUnderMouse (getMouseXYRelative());
}

/*** End of inlined file: juce_MenuBarComponent.cpp ***/


/*** Start of inlined file: juce_MenuBarModel.cpp ***/
MenuBarModel::MenuBarModel() noexcept
	: manager (nullptr)
{
}

MenuBarModel::~MenuBarModel()
{
	setApplicationCommandManagerToWatch (nullptr);
}

void MenuBarModel::menuItemsChanged()
{
	triggerAsyncUpdate();
}

void MenuBarModel::setApplicationCommandManagerToWatch (ApplicationCommandManager* const newManager) noexcept
{
	if (manager != newManager)
	{
		if (manager != nullptr)
			manager->removeListener (this);

		manager = newManager;

		if (manager != nullptr)
			manager->addListener (this);
	}
}

void MenuBarModel::addListener (Listener* const newListener) noexcept
{
	listeners.add (newListener);
}

void MenuBarModel::removeListener (Listener* const listenerToRemove) noexcept
{
	// Trying to remove a listener that isn't on the list!
	// If this assertion happens because this object is a dangling pointer, make sure you've not
	// deleted this menu model while it's still being used by something (e.g. by a MenuBarComponent)
	jassert (listeners.contains (listenerToRemove));

	listeners.remove (listenerToRemove);
}

void MenuBarModel::handleAsyncUpdate()
{
	listeners.call (&MenuBarModel::Listener::menuBarItemsChanged, this);
}

void MenuBarModel::applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info)
{
	listeners.call (&MenuBarModel::Listener::menuCommandInvoked, this, info);
}

void MenuBarModel::applicationCommandListChanged()
{
	menuItemsChanged();
}

/*** End of inlined file: juce_MenuBarModel.cpp ***/


/*** Start of inlined file: juce_PopupMenu.cpp ***/
class PopupMenu::Item
{
public:
	Item()
	  : itemId (0), active (true), isSeparator (true), isTicked (false),
		usesColour (false), commandManager (nullptr)
	{
	}

	Item (const int itemId_,
		  const String& text_,
		  const bool active_,
		  const bool isTicked_,
		  const Image& im,
		  const Colour& textColour_,
		  const bool usesColour_,
		  CustomComponent* const customComp_,
		  const PopupMenu* const subMenu_,
		  ApplicationCommandManager* const commandManager_)
	  : itemId (itemId_), text (text_), textColour (textColour_),
		active (active_), isSeparator (false), isTicked (isTicked_),
		usesColour (usesColour_), image (im), customComp (customComp_),
		commandManager (commandManager_)
	{
		if (subMenu_ != nullptr)
			subMenu = new PopupMenu (*subMenu_);

		if (commandManager_ != nullptr && itemId_ != 0)
		{
			String shortcutKey;

			Array <KeyPress> keyPresses (commandManager_->getKeyMappings()
											->getKeyPressesAssignedToCommand (itemId_));

			for (int i = 0; i < keyPresses.size(); ++i)
			{
				const String key (keyPresses.getReference(i).getTextDescriptionWithIcons());

				if (shortcutKey.isNotEmpty())
					shortcutKey << ", ";

				if (key.length() == 1 && key[0] < 128)
					shortcutKey << "shortcut: '" << key << '\'';
				else
					shortcutKey << key;
			}

			shortcutKey = shortcutKey.trim();

			if (shortcutKey.isNotEmpty())
				text << "<end>" << shortcutKey;
		}
	}

	Item (const Item& other)
		: itemId (other.itemId),
		  text (other.text),
		  textColour (other.textColour),
		  active (other.active),
		  isSeparator (other.isSeparator),
		  isTicked (other.isTicked),
		  usesColour (other.usesColour),
		  image (other.image),
		  customComp (other.customComp),
		  commandManager (other.commandManager)
	{
		if (other.subMenu != nullptr)
			subMenu = new PopupMenu (*(other.subMenu));
	}

	bool canBeTriggered() const noexcept    { return active && ! (isSeparator || (subMenu != nullptr)); }
	bool hasActiveSubMenu() const noexcept  { return active && subMenu != nullptr && subMenu->items.size() > 0; }

	const int itemId;
	String text;
	const Colour textColour;
	const bool active, isSeparator, isTicked, usesColour;
	Image image;
	ReferenceCountedObjectPtr <CustomComponent> customComp;
	ScopedPointer <PopupMenu> subMenu;
	ApplicationCommandManager* const commandManager;

private:
	Item& operator= (const Item&);

	JUCE_LEAK_DETECTOR (Item);
};

class PopupMenu::ItemComponent  : public Component
{
public:
	ItemComponent (const PopupMenu::Item& itemInfo_, int standardItemHeight, Component* const parent)
	  : itemInfo (itemInfo_),
		isHighlighted (false)
	{
		addAndMakeVisible (itemInfo.customComp);
		parent->addAndMakeVisible (this);

		int itemW = 80;
		int itemH = 16;
		getIdealSize (itemW, itemH, standardItemHeight);
		setSize (itemW, jlimit (2, 600, itemH));

		addMouseListener (parent, false);
	}

	~ItemComponent()
	{
		removeChildComponent (itemInfo.customComp);
	}

	void getIdealSize (int& idealWidth, int& idealHeight, const int standardItemHeight)
	{
		if (itemInfo.customComp != nullptr)
			itemInfo.customComp->getIdealSize (idealWidth, idealHeight);
		else
			getLookAndFeel().getIdealPopupMenuItemSize (itemInfo.text,
														itemInfo.isSeparator,
														standardItemHeight,
														idealWidth, idealHeight);
	}

	void paint (Graphics& g)
	{
		if (itemInfo.customComp == nullptr)
		{
			String mainText (itemInfo.text);
			String endText;
			const int endIndex = mainText.indexOf ("<end>");

			if (endIndex >= 0)
			{
				endText = mainText.substring (endIndex + 5).trim();
				mainText = mainText.substring (0, endIndex);
			}

			getLookAndFeel()
				.drawPopupMenuItem (g, getWidth(), getHeight(),
									itemInfo.isSeparator,
									itemInfo.active,
									isHighlighted,
									itemInfo.isTicked,
									itemInfo.subMenu != nullptr,
									mainText, endText,
									itemInfo.image.isValid() ? &itemInfo.image : nullptr,
									itemInfo.usesColour ? &(itemInfo.textColour) : nullptr);
		}
	}

	void resized()
	{
		Component* const child = getChildComponent (0);
		if (child != nullptr)
			child->setBounds (getLocalBounds().reduced (2, 0));
	}

	void setHighlighted (bool shouldBeHighlighted)
	{
		shouldBeHighlighted = shouldBeHighlighted && itemInfo.active;

		if (isHighlighted != shouldBeHighlighted)
		{
			isHighlighted = shouldBeHighlighted;

			if (itemInfo.customComp != nullptr)
				itemInfo.customComp->setHighlighted (shouldBeHighlighted);

			repaint();
		}
	}

	PopupMenu::Item itemInfo;

private:
	bool isHighlighted;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ItemComponent);
};

namespace PopupMenuSettings
{
	const int scrollZone = 24;
	const int borderSize = 2;
	const int timerInterval = 50;
	const int dismissCommandId = 0x6287345f;

	static bool menuWasHiddenBecauseOfAppChange = false;
}

class PopupMenu::Window  : public Component,
						   private Timer
{
public:
	Window (const PopupMenu& menu, Window* const owner_,
			const Options& options_,
			const bool alignToRectangle,
			const bool dismissOnMouseUp_,
			ApplicationCommandManager** const managerOfChosenCommand_)
	   : Component ("menu"),
		 owner (owner_),
		 options (options_),
		 activeSubMenu (nullptr),
		 managerOfChosenCommand (managerOfChosenCommand_),
		 componentAttachedTo (options.targetComponent),
		 isOver (false),
		 hasBeenOver (false),
		 isDown (false),
		 needsToScroll (false),
		 dismissOnMouseUp (dismissOnMouseUp_),
		 hideOnExit (false),
		 disableMouseMoves (false),
		 hasAnyJuceCompHadFocus (false),
		 numColumns (0),
		 contentHeight (0),
		 childYOffset (0),
		 menuCreationTime (Time::getMillisecondCounter()),
		 lastMouseMoveTime (0),
		 timeEnteredCurrentChildComp (0),
		 scrollAcceleration (1.0)
	{
		lastFocusedTime = lastScrollTime = menuCreationTime;
		setWantsKeyboardFocus (false);
		setMouseClickGrabsKeyboardFocus (false);
		setAlwaysOnTop (true);

		setLookAndFeel (menu.lookAndFeel);
		setOpaque (getLookAndFeel().findColour (PopupMenu::backgroundColourId).isOpaque() || ! Desktop::canUseSemiTransparentWindows());

		for (int i = 0; i < menu.items.size(); ++i)
		{
			PopupMenu::Item* const item = menu.items.getUnchecked(i);

			if (i < menu.items.size() - 1 || ! item->isSeparator)
				items.add (new PopupMenu::ItemComponent (*item, options.standardHeight, this));
		}

		calculateWindowPos (options.targetArea, alignToRectangle);
		setTopLeftPosition (windowPos.getPosition());
		updateYPositions();

		if (options.visibleItemID != 0)
		{
			const int y = options.targetArea.getY() - windowPos.getY();
			ensureItemIsVisible (options.visibleItemID,
								 isPositiveAndBelow (y, windowPos.getHeight()) ? y : -1);
		}

		resizeToBestWindowPos();
		addToDesktop (ComponentPeer::windowIsTemporary
					   | ComponentPeer::windowIgnoresKeyPresses
					   | getLookAndFeel().getMenuWindowFlags());

		getActiveWindows().add (this);
		Desktop::getInstance().addGlobalMouseListener (this);
	}

	~Window()
	{
		getActiveWindows().removeValue (this);
		Desktop::getInstance().removeGlobalMouseListener (this);
		activeSubMenu = nullptr;
		items.clear();
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (Colours::white);

		getLookAndFeel().drawPopupMenuBackground (g, getWidth(), getHeight());
	}

	void paintOverChildren (Graphics& g)
	{
		if (canScroll())
		{
			LookAndFeel& lf = getLookAndFeel();

			if (isTopScrollZoneActive())
				lf.drawPopupMenuUpDownArrow (g, getWidth(), PopupMenuSettings::scrollZone, true);

			if (isBottomScrollZoneActive())
			{
				g.setOrigin (0, getHeight() - PopupMenuSettings::scrollZone);
				lf.drawPopupMenuUpDownArrow (g, getWidth(), PopupMenuSettings::scrollZone, false);
			}
		}
	}

	// hide this and all sub-comps
	void hide (const PopupMenu::Item* const item, const bool makeInvisible)
	{
		if (isVisible())
		{
			WeakReference<Component> deletionChecker (this);

			activeSubMenu = nullptr;
			currentChild = nullptr;

			if (item != nullptr
				 && item->commandManager != nullptr
				 && item->itemId != 0)
			{
				*managerOfChosenCommand = item->commandManager;
			}

			exitModalState (item != nullptr ? item->itemId : 0);

			if (makeInvisible && (deletionChecker != nullptr))
				setVisible (false);
		}
	}

	void dismissMenu (const PopupMenu::Item* const item)
	{
		if (owner != nullptr)
		{
			owner->dismissMenu (item);
		}
		else
		{
			if (item != nullptr)
			{
				// need a copy of this on the stack as the one passed in will get deleted during this call
				const PopupMenu::Item mi (*item);
				hide (&mi, false);
			}
			else
			{
				hide (nullptr, false);
			}
		}
	}

	void mouseMove (const MouseEvent&)    { timerCallback(); }
	void mouseDown (const MouseEvent&)    { timerCallback(); }
	void mouseDrag (const MouseEvent&)    { timerCallback(); }
	void mouseUp   (const MouseEvent&)    { timerCallback(); }

	void mouseWheelMove (const MouseEvent&, float /*amountX*/, float amountY)
	{
		alterChildYPos (roundToInt (-10.0f * amountY * PopupMenuSettings::scrollZone));
		lastMousePos = Point<int> (-1, -1);
	}

	bool keyPressed (const KeyPress& key)
	{
		if (key.isKeyCode (KeyPress::downKey))
		{
			selectNextItem (1);
		}
		else if (key.isKeyCode (KeyPress::upKey))
		{
			selectNextItem (-1);
		}
		else if (key.isKeyCode (KeyPress::leftKey))
		{
			if (owner != nullptr)
			{
				Component::SafePointer<Window> parentWindow (owner);
				PopupMenu::ItemComponent* currentChildOfParent = parentWindow->currentChild;

				hide (0, true);

				if (parentWindow != nullptr)
					parentWindow->setCurrentlyHighlightedChild (currentChildOfParent);

				disableTimerUntilMouseMoves();
			}
			else if (componentAttachedTo != nullptr)
			{
				componentAttachedTo->keyPressed (key);
			}
		}
		else if (key.isKeyCode (KeyPress::rightKey))
		{
			disableTimerUntilMouseMoves();

			if (showSubMenuFor (currentChild))
			{
				if (isSubMenuVisible())
					activeSubMenu->selectNextItem (1);
			}
			else if (componentAttachedTo != nullptr)
			{
				componentAttachedTo->keyPressed (key);
			}
		}
		else if (key.isKeyCode (KeyPress::returnKey))
		{
			triggerCurrentlyHighlightedItem();
		}
		else if (key.isKeyCode (KeyPress::escapeKey))
		{
			dismissMenu (nullptr);
		}
		else
		{
			return false;
		}

		return true;
	}

	void inputAttemptWhenModal()
	{
		WeakReference<Component> deletionChecker (this);

		timerCallback();

		if (deletionChecker != nullptr && ! isOverAnyMenu())
		{
			if (componentAttachedTo != nullptr)
			{
				// we want to dismiss the menu, but if we do it synchronously, then
				// the mouse-click will be allowed to pass through. That's good, except
				// when the user clicks on the button that orginally popped the menu up,
				// as they'll expect the menu to go away, and in fact it'll just
				// come back. So only dismiss synchronously if they're not on the original
				// comp that we're attached to.
				const Point<int> mousePos (componentAttachedTo->getMouseXYRelative());

				if (componentAttachedTo->reallyContains (mousePos, true))
				{
					postCommandMessage (PopupMenuSettings::dismissCommandId); // dismiss asynchrounously
					return;
				}
			}

			dismissMenu (nullptr);
		}
	}

	void handleCommandMessage (int commandId)
	{
		Component::handleCommandMessage (commandId);

		if (commandId == PopupMenuSettings::dismissCommandId)
			dismissMenu (nullptr);
	}

	void timerCallback()
	{
		if (! isVisible())
			return;

		if (componentAttachedTo != options.targetComponent)
		{
			dismissMenu (nullptr);
			return;
		}

		Window* currentlyModalWindow = dynamic_cast <Window*> (Component::getCurrentlyModalComponent());

		if (currentlyModalWindow != nullptr && ! treeContains (currentlyModalWindow))
			return;

		startTimer (PopupMenuSettings::timerInterval);  // do this in case it was called from a mouse
														// move rather than a real timer callback

		const Point<int> globalMousePos (Desktop::getMousePosition());
		const Point<int> localMousePos (getLocalPoint (nullptr, globalMousePos));

		const uint32 timeNow = Time::getMillisecondCounter();

		if (timeNow > timeEnteredCurrentChildComp + 100
			 && reallyContains (localMousePos, true)
			 && currentChild != nullptr
			 && ! (disableMouseMoves || isSubMenuVisible()))
		{
			showSubMenuFor (currentChild);
		}

		highlightItemUnderMouse (globalMousePos, localMousePos, timeNow);

		const bool overScrollArea = scrollIfNecessary (localMousePos, timeNow);
		const bool wasDown = isDown;

		bool isOverAny = isOverAnyMenu();

		if (activeSubMenu != nullptr && hideOnExit && hasBeenOver && ! isOverAny)
		{
			activeSubMenu->updateMouseOverStatus (globalMousePos);
			isOverAny = isOverAnyMenu();
		}

		if (hideOnExit && hasBeenOver && ! isOverAny)
			hide (0, true);
		else
			checkButtonState (localMousePos, timeNow, wasDown, overScrollArea, isOverAny);
	}

	static Array<Window*>& getActiveWindows()
	{
		static Array<Window*> activeMenuWindows;
		return activeMenuWindows;
	}

private:
	Window* owner;
	const Options options;
	OwnedArray <PopupMenu::ItemComponent> items;
	Component::SafePointer<PopupMenu::ItemComponent> currentChild;
	ScopedPointer <Window> activeSubMenu;
	ApplicationCommandManager** managerOfChosenCommand;
	WeakReference<Component> componentAttachedTo;
	Rectangle<int> windowPos;
	Point<int> lastMousePos;
	bool isOver, hasBeenOver, isDown, needsToScroll;
	bool dismissOnMouseUp, hideOnExit, disableMouseMoves, hasAnyJuceCompHadFocus;
	int numColumns, contentHeight, childYOffset;
	Array<int> columnWidths;
	uint32 menuCreationTime, lastFocusedTime, lastScrollTime, lastMouseMoveTime, timeEnteredCurrentChildComp;
	double scrollAcceleration;

	bool overlaps (const Rectangle<int>& r) const
	{
		return r.intersects (getBounds())
				|| (owner != nullptr && owner->overlaps (r));
	}

	bool isOverAnyMenu() const
	{
		return owner != nullptr ? owner->isOverAnyMenu()
								: isOverChildren();
	}

	bool isOverChildren() const
	{
		return isVisible()
				&& (isOver || (activeSubMenu != nullptr && activeSubMenu->isOverChildren()));
	}

	void updateMouseOverStatus (const Point<int>& globalMousePos)
	{
		isOver = reallyContains (getLocalPoint (nullptr, globalMousePos), true);

		if (activeSubMenu != nullptr)
			activeSubMenu->updateMouseOverStatus (globalMousePos);
	}

	bool treeContains (const Window* const window) const noexcept
	{
		const Window* mw = this;

		while (mw->owner != nullptr)
			mw = mw->owner;

		while (mw != nullptr)
		{
			if (mw == window)
				return true;

			mw = mw->activeSubMenu;
		}

		return false;
	}

	bool doesAnyJuceCompHaveFocus()
	{
		bool anyFocused = Process::isForegroundProcess();

		if (anyFocused && Component::getCurrentlyFocusedComponent() == nullptr)
		{
			// because no component at all may have focus, our test here will
			// only be triggered when something has focus and then loses it.
			anyFocused = ! hasAnyJuceCompHadFocus;

			for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
			{
				if (ComponentPeer::getPeer (i)->isFocused())
				{
					anyFocused = true;
					hasAnyJuceCompHadFocus = true;
					break;
				}
			}
		}

		return anyFocused;
	}

	void calculateWindowPos (const Rectangle<int>& target, const bool alignToRectangle)
	{
		const Rectangle<int> mon (Desktop::getInstance().getDisplays()
									 .getDisplayContaining (target.getCentre())
														   #if JUCE_MAC
															.userArea);
														   #else
															.totalArea); // on windows, don't stop the menu overlapping the taskbar
														   #endif

		const int maxMenuHeight = mon.getHeight() - 24;

		int x, y, widthToUse, heightToUse;
		layoutMenuItems (mon.getWidth() - 24, maxMenuHeight, widthToUse, heightToUse);

		if (alignToRectangle)
		{
			x = target.getX();

			const int spaceUnder = mon.getHeight() - (target.getBottom() - mon.getY());
			const int spaceOver = target.getY() - mon.getY();

			if (heightToUse < spaceUnder - 30 || spaceUnder >= spaceOver)
				y = target.getBottom();
			else
				y = target.getY() - heightToUse;
		}
		else
		{
			bool tendTowardsRight = target.getCentreX() < mon.getCentreX();

			if (owner != nullptr)
			{
				if (owner->owner != nullptr)
				{
					const bool ownerGoingRight = (owner->getX() + owner->getWidth() / 2
													> owner->owner->getX() + owner->owner->getWidth() / 2);

					if (ownerGoingRight && target.getRight() + widthToUse < mon.getRight() - 4)
						tendTowardsRight = true;
					else if ((! ownerGoingRight) && target.getX() > widthToUse + 4)
						tendTowardsRight = false;
				}
				else if (target.getRight() + widthToUse < mon.getRight() - 32)
				{
					tendTowardsRight = true;
				}
			}

			const int biggestSpace = jmax (mon.getRight() - target.getRight(),
										   target.getX() - mon.getX()) - 32;

			if (biggestSpace < widthToUse)
			{
				layoutMenuItems (biggestSpace + target.getWidth() / 3, maxMenuHeight, widthToUse, heightToUse);

				if (numColumns > 1)
					layoutMenuItems (biggestSpace - 4, maxMenuHeight, widthToUse, heightToUse);

				tendTowardsRight = (mon.getRight() - target.getRight()) >= (target.getX() - mon.getX());
			}

			if (tendTowardsRight)
				x = jmin (mon.getRight() - widthToUse - 4, target.getRight());
			else
				x = jmax (mon.getX() + 4, target.getX() - widthToUse);

			y = target.getY();
			if (target.getCentreY() > mon.getCentreY())
				y = jmax (mon.getY(), target.getBottom() - heightToUse);
		}

		x = jmax (mon.getX() + 1, jmin (mon.getRight() - (widthToUse + 6), x));
		y = jmax (mon.getY() + 1, jmin (mon.getBottom() - (heightToUse + 6), y));

		windowPos.setBounds (x, y, widthToUse, heightToUse);

		// sets this flag if it's big enough to obscure any of its parent menus
		hideOnExit = owner != nullptr
					  && owner->windowPos.intersects (windowPos.expanded (-4, -4));
	}

	void layoutMenuItems (const int maxMenuW, const int maxMenuH, int& width, int& height)
	{
		numColumns = 0;
		contentHeight = 0;
		int totalW;

		const int maximumNumColumns = options.maxColumns > 0 ? options.maxColumns : 7;

		do
		{
			++numColumns;
			totalW = workOutBestSize (maxMenuW);

			if (totalW > maxMenuW)
			{
				numColumns = jmax (1, numColumns - 1);
				totalW = workOutBestSize (maxMenuW); // to update col widths
				break;
			}
			else if (totalW > maxMenuW / 2 || contentHeight < maxMenuH)
			{
				break;
			}

		} while (numColumns < maximumNumColumns);

		const int actualH = jmin (contentHeight, maxMenuH);

		needsToScroll = contentHeight > actualH;

		width = updateYPositions();
		height = actualH + PopupMenuSettings::borderSize * 2;
	}

	int workOutBestSize (const int maxMenuW)
	{
		int totalW = 0;
		contentHeight = 0;
		int childNum = 0;

		for (int col = 0; col < numColumns; ++col)
		{
			int i, colW = options.standardHeight, colH = 0;

			const int numChildren = jmin (items.size() - childNum,
										  (items.size() + numColumns - 1) / numColumns);

			for (i = numChildren; --i >= 0;)
			{
				colW = jmax (colW, items.getUnchecked (childNum + i)->getWidth());
				colH += items.getUnchecked (childNum + i)->getHeight();
			}

			colW = jmin (maxMenuW / jmax (1, numColumns - 2), colW + PopupMenuSettings::borderSize * 2);

			columnWidths.set (col, colW);
			totalW += colW;
			contentHeight = jmax (contentHeight, colH);

			childNum += numChildren;
		}

		if (totalW < options.minWidth)
		{
			totalW = options.minWidth;

			for (int col = 0; col < numColumns; ++col)
				columnWidths.set (0, totalW / numColumns);
		}

		return totalW;
	}

	void ensureItemIsVisible (const int itemId, int wantedY)
	{
		jassert (itemId != 0)

		for (int i = items.size(); --i >= 0;)
		{
			PopupMenu::ItemComponent* const m = items.getUnchecked(i);

			if (m != nullptr
				&& m->itemInfo.itemId == itemId
				&& windowPos.getHeight() > PopupMenuSettings::scrollZone * 4)
			{
				const int currentY = m->getY();

				if (wantedY > 0 || currentY < 0 || m->getBottom() > windowPos.getHeight())
				{
					if (wantedY < 0)
						wantedY = jlimit (PopupMenuSettings::scrollZone,
										  jmax (PopupMenuSettings::scrollZone,
												windowPos.getHeight() - (PopupMenuSettings::scrollZone + m->getHeight())),
										  currentY);

					const Rectangle<int> mon (Desktop::getInstance().getDisplays()
												.getDisplayContaining (windowPos.getPosition()).userArea);

					int deltaY = wantedY - currentY;

					windowPos.setSize (jmin (windowPos.getWidth(), mon.getWidth()),
									   jmin (windowPos.getHeight(), mon.getHeight()));

					const int newY = jlimit (mon.getY(),
											 mon.getBottom() - windowPos.getHeight(),
											 windowPos.getY() + deltaY);

					deltaY -= newY - windowPos.getY();

					childYOffset -= deltaY;
					windowPos.setPosition (windowPos.getX(), newY);

					updateYPositions();
				}

				break;
			}
		}
	}

	void resizeToBestWindowPos()
	{
		Rectangle<int> r (windowPos);

		if (childYOffset < 0)
		{
			r = r.withTop (r.getY() - childYOffset);
		}
		else if (childYOffset > 0)
		{
			const int spaceAtBottom = r.getHeight() - (contentHeight - childYOffset);

			if (spaceAtBottom > 0)
				r.setSize (r.getWidth(), r.getHeight() - spaceAtBottom);
		}

		setBounds (r);
		updateYPositions();
	}

	void alterChildYPos (const int delta)
	{
		if (canScroll())
		{
			childYOffset += delta;

			if (delta < 0)
			{
				childYOffset = jmax (childYOffset, 0);
			}
			else if (delta > 0)
			{
				childYOffset = jmin (childYOffset,
									 contentHeight - windowPos.getHeight() + PopupMenuSettings::borderSize);
			}

			updateYPositions();
		}
		else
		{
			childYOffset = 0;
		}

		resizeToBestWindowPos();
		repaint();
	}

	int updateYPositions()
	{
		int x = 0;
		int childNum = 0;

		for (int col = 0; col < numColumns; ++col)
		{
			const int numChildren = jmin (items.size() - childNum,
										  (items.size() + numColumns - 1) / numColumns);

			const int colW = columnWidths [col];

			int y = PopupMenuSettings::borderSize - (childYOffset + (getY() - windowPos.getY()));

			for (int i = 0; i < numChildren; ++i)
			{
				Component* const c = items.getUnchecked (childNum + i);
				c->setBounds (x, y, colW, c->getHeight());
				y += c->getHeight();
			}

			x += colW;
			childNum += numChildren;
		}

		return x;
	}

	void setCurrentlyHighlightedChild (PopupMenu::ItemComponent* const child)
	{
		if (currentChild != nullptr)
			currentChild->setHighlighted (false);

		currentChild = child;

		if (currentChild != nullptr)
		{
			currentChild->setHighlighted (true);
			timeEnteredCurrentChildComp = Time::getApproximateMillisecondCounter();
		}
	}

	bool isSubMenuVisible() const noexcept          { return activeSubMenu != nullptr && activeSubMenu->isVisible(); }

	bool showSubMenuFor (PopupMenu::ItemComponent* const childComp)
	{
		activeSubMenu = nullptr;

		if (childComp != nullptr
			 && childComp->itemInfo.hasActiveSubMenu())
		{
			activeSubMenu = new Window (*(childComp->itemInfo.subMenu), this,
										options.withTargetScreenArea (childComp->getScreenBounds())
											   .withMinimumWidth (0)
											   .withTargetComponent (nullptr),
										false, dismissOnMouseUp, managerOfChosenCommand);

			activeSubMenu->setVisible (true); // (must be called before enterModalState on Windows to avoid DropShadower confusion)
			activeSubMenu->enterModalState (false);
			activeSubMenu->toFront (false);
			return true;
		}

		return false;
	}

	void highlightItemUnderMouse (const Point<int>& globalMousePos, const Point<int>& localMousePos, const uint32 timeNow)
	{
		if (globalMousePos != lastMousePos || timeNow > lastMouseMoveTime + 350)
		{
			isOver = reallyContains (localMousePos, true);

			if (isOver)
				hasBeenOver = true;

			if (lastMousePos.getDistanceFrom (globalMousePos) > 2)
			{
				lastMouseMoveTime = timeNow;

				if (disableMouseMoves && isOver)
					disableMouseMoves = false;
			}

			if (disableMouseMoves || (activeSubMenu != nullptr && activeSubMenu->isOverChildren()))
				return;

			bool isMovingTowardsMenu = false;

			if (isOver && (activeSubMenu != nullptr) && globalMousePos != lastMousePos)
			{
				// try to intelligently guess whether the user is moving the mouse towards a currently-open
				// submenu. To do this, look at whether the mouse stays inside a triangular region that
				// extends from the last mouse pos to the submenu's rectangle..

				float subX = (float) activeSubMenu->getScreenX();

				if (activeSubMenu->getX() > getX())
				{
					lastMousePos -= Point<int> (2, 0);  // to enlarge the triangle a bit, in case the mouse only moves a couple of pixels
				}
				else
				{
					lastMousePos += Point<int> (2, 0);
					subX += activeSubMenu->getWidth();
				}

				Path areaTowardsSubMenu;
				areaTowardsSubMenu.addTriangle ((float) lastMousePos.x, (float) lastMousePos.y,
												subX, (float) activeSubMenu->getScreenY(),
												subX, (float) (activeSubMenu->getScreenY() + activeSubMenu->getHeight()));

				isMovingTowardsMenu = areaTowardsSubMenu.contains (globalMousePos.toFloat());
			}

			lastMousePos = globalMousePos;

			if (! isMovingTowardsMenu)
			{
				Component* c = getComponentAt (localMousePos);
				if (c == this)
					c = nullptr;

				PopupMenu::ItemComponent* itemUnderMouse = dynamic_cast <PopupMenu::ItemComponent*> (c);

				if (itemUnderMouse == nullptr && c != nullptr)
					itemUnderMouse = c->findParentComponentOfClass<PopupMenu::ItemComponent>();

				if (itemUnderMouse != currentChild
					  && (isOver || (activeSubMenu == nullptr) || ! activeSubMenu->isVisible()))
				{
					if (isOver && (c != nullptr) && (activeSubMenu != nullptr))
						activeSubMenu->hide (0, true);

					if (! isOver)
						itemUnderMouse = nullptr;

					setCurrentlyHighlightedChild (itemUnderMouse);
				}
			}
		}
	}

	void checkButtonState (const Point<int>& localMousePos, const uint32 timeNow,
						   const bool wasDown, const bool overScrollArea, const bool isOverAny)
	{
		isDown = hasBeenOver
					&& (ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown()
						 || ModifierKeys::getCurrentModifiersRealtime().isAnyMouseButtonDown());

		if (! doesAnyJuceCompHaveFocus())
		{
			if (timeNow > lastFocusedTime + 10)
			{
				PopupMenuSettings::menuWasHiddenBecauseOfAppChange = true;
				dismissMenu (nullptr);
				// Note: this object may have been deleted by the previous call..
			}
		}
		else if (wasDown && timeNow > menuCreationTime + 250
				   && ! (isDown || overScrollArea))
		{
			isOver = reallyContains (localMousePos, true);

			if (isOver)
				triggerCurrentlyHighlightedItem();
			else if ((hasBeenOver || ! dismissOnMouseUp) && ! isOverAny)
				dismissMenu (nullptr);

			// Note: this object may have been deleted by the previous call..
		}
		else
		{
			lastFocusedTime = timeNow;
		}
	}

	void triggerCurrentlyHighlightedItem()
	{
		if (currentChild != nullptr
			 && currentChild->itemInfo.canBeTriggered()
			 && (currentChild->itemInfo.customComp == nullptr
				  || currentChild->itemInfo.customComp->isTriggeredAutomatically()))
		{
			dismissMenu (&currentChild->itemInfo);
		}
	}

	void selectNextItem (const int delta)
	{
		disableTimerUntilMouseMoves();
		PopupMenu::ItemComponent* mic = nullptr;
		bool wasLastOne = (currentChild == nullptr);
		const int numItems = items.size();

		for (int i = 0; i < numItems + 1; ++i)
		{
			int index = (delta > 0) ? i : (numItems - 1 - i);
			index = (index + numItems) % numItems;

			mic = items.getUnchecked (index);

			if (mic != nullptr && (mic->itemInfo.canBeTriggered() || mic->itemInfo.hasActiveSubMenu())
				 && wasLastOne)
				break;

			if (mic == currentChild)
				wasLastOne = true;
		}

		setCurrentlyHighlightedChild (mic);
	}

	void disableTimerUntilMouseMoves()
	{
		disableMouseMoves = true;

		if (owner != nullptr)
			owner->disableTimerUntilMouseMoves();
	}

	bool canScroll() const noexcept                 { return childYOffset != 0 || needsToScroll; }
	bool isTopScrollZoneActive() const noexcept     { return canScroll() && childYOffset > 0; }
	bool isBottomScrollZoneActive() const noexcept  { return canScroll() && childYOffset < contentHeight - windowPos.getHeight(); }

	bool scrollIfNecessary (const Point<int>& localMousePos, const uint32 timeNow)
	{
		if (canScroll()
			 && (isOver || (isDown && isPositiveAndBelow (localMousePos.x, getWidth()))))
		{
			if (isTopScrollZoneActive() && localMousePos.y < PopupMenuSettings::scrollZone)
				return scroll (timeNow, -1);

			if (isBottomScrollZoneActive() && localMousePos.y > getHeight() - PopupMenuSettings::scrollZone)
				return scroll (timeNow, 1);
		}

		scrollAcceleration = 1.0;
		return false;
	}

	bool scroll (const uint32 timeNow, const int direction)
	{
		if (timeNow > lastScrollTime + 20)
		{
			scrollAcceleration = jmin (4.0, scrollAcceleration * 1.04);
			int amount = 0;

			for (int i = 0; i < items.size() && amount == 0; ++i)
				amount = ((int) scrollAcceleration) * items.getUnchecked(i)->getHeight();

			alterChildYPos (amount * direction);
			lastScrollTime = timeNow;
		}

		lastMousePos = Point<int> (-1, -1); // to trigger a mouse-move
		return true;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Window);
};

PopupMenu::PopupMenu()
	: lookAndFeel (nullptr)
{
}

PopupMenu::PopupMenu (const PopupMenu& other)
	: lookAndFeel (other.lookAndFeel)
{
	items.addCopiesOf (other.items);
}

PopupMenu& PopupMenu::operator= (const PopupMenu& other)
{
	if (this != &other)
	{
		lookAndFeel = other.lookAndFeel;

		clear();
		items.addCopiesOf (other.items);
	}

	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
PopupMenu::PopupMenu (PopupMenu&& other) noexcept
	: lookAndFeel (other.lookAndFeel)
{
	items.swapWithArray (other.items);
}

PopupMenu& PopupMenu::operator= (PopupMenu&& other) noexcept
{
	jassert (this != &other); // hopefully the compiler should make this situation impossible!

	items.swapWithArray (other.items);
	lookAndFeel = other.lookAndFeel;
	return *this;
}
#endif

PopupMenu::~PopupMenu()
{
}

void PopupMenu::clear()
{
	items.clear();
}

void PopupMenu::addItem (const int itemResultId, const String& itemText,
						 const bool isActive, const bool isTicked, const Image& iconToUse)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, itemText, isActive, isTicked, iconToUse,
						 Colours::black, false, nullptr, nullptr, nullptr));
}

void PopupMenu::addCommandItem (ApplicationCommandManager* commandManager,
								const int commandID,
								const String& displayName)
{
	jassert (commandManager != nullptr && commandID != 0);

	const ApplicationCommandInfo* const registeredInfo = commandManager->getCommandForID (commandID);

	if (registeredInfo != nullptr)
	{
		ApplicationCommandInfo info (*registeredInfo);
		ApplicationCommandTarget* const target = commandManager->getTargetForCommand (commandID, info);

		items.add (new Item (commandID,
							 displayName.isNotEmpty() ? displayName
													  : info.shortName,
							 target != nullptr && (info.flags & ApplicationCommandInfo::isDisabled) == 0,
							 (info.flags & ApplicationCommandInfo::isTicked) != 0,
							 Image::null,
							 Colours::black,
							 false,
							 nullptr, nullptr,
							 commandManager));
	}
}

void PopupMenu::addColouredItem (const int itemResultId,
								 const String& itemText,
								 const Colour& itemTextColour,
								 const bool isActive,
								 const bool isTicked,
								 const Image& iconToUse)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, itemText, isActive, isTicked, iconToUse,
						 itemTextColour, true, nullptr, nullptr, nullptr));
}

void PopupMenu::addCustomItem (const int itemResultId, CustomComponent* const customComponent)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, String::empty, true, false, Image::null,
						 Colours::black, false, customComponent, nullptr, nullptr));
}

class NormalComponentWrapper : public PopupMenu::CustomComponent
{
public:
	NormalComponentWrapper (Component* const comp, const int w, const int h,
							const bool triggerMenuItemAutomaticallyWhenClicked)
		: PopupMenu::CustomComponent (triggerMenuItemAutomaticallyWhenClicked),
		  width (w), height (h)
	{
		addAndMakeVisible (comp);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		idealWidth = width;
		idealHeight = height;
	}

	void resized()
	{
		if (getChildComponent(0) != nullptr)
			getChildComponent(0)->setBounds (getLocalBounds());
	}

private:
	const int width, height;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NormalComponentWrapper);
};

void PopupMenu::addCustomItem (const int itemResultId,
							   Component* customComponent,
							   int idealWidth, int idealHeight,
							   const bool triggerMenuItemAutomaticallyWhenClicked)
{
	addCustomItem (itemResultId,
				   new NormalComponentWrapper (customComponent, idealWidth, idealHeight,
											   triggerMenuItemAutomaticallyWhenClicked));
}

void PopupMenu::addSubMenu (const String& subMenuName,
							const PopupMenu& subMenu,
							const bool isActive,
							const Image& iconToUse,
							const bool isTicked)
{
	items.add (new Item (0, subMenuName, isActive && (subMenu.getNumItems() > 0), isTicked,
						 iconToUse, Colours::black, false, nullptr, &subMenu, nullptr));
}

void PopupMenu::addSeparator()
{
	if (items.size() > 0 && ! items.getLast()->isSeparator)
		items.add (new Item());
}

class HeaderItemComponent  : public PopupMenu::CustomComponent
{
public:
	HeaderItemComponent (const String& name)
		: PopupMenu::CustomComponent (false)
	{
		setName (name);
	}

	void paint (Graphics& g)
	{
		Font f (getLookAndFeel().getPopupMenuFont());
		f.setBold (true);
		g.setFont (f);
		g.setColour (findColour (PopupMenu::headerTextColourId));

		g.drawFittedText (getName(),
						  12, 0, getWidth() - 16, proportionOfHeight (0.8f),
						  Justification::bottomLeft, 1);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		getLookAndFeel().getIdealPopupMenuItemSize (getName(), false, -1, idealWidth, idealHeight);
		idealHeight += idealHeight / 2;
		idealWidth += idealWidth / 4;
	}

private:
	JUCE_LEAK_DETECTOR (HeaderItemComponent);
};

void PopupMenu::addSectionHeader (const String& title)
{
	addCustomItem (0X4734a34f, new HeaderItemComponent (title));
}

PopupMenu::Options::Options()
	: targetComponent (nullptr),
	  visibleItemID (0),
	  minWidth (0),
	  maxColumns (0),
	  standardHeight (0)
{
	targetArea.setPosition (Desktop::getMousePosition());
}

PopupMenu::Options PopupMenu::Options::withTargetComponent (Component* comp) const noexcept
{
	Options o (*this);
	o.targetComponent = comp;

	if (comp != nullptr)
		o.targetArea = comp->getScreenBounds();

	return o;
}

PopupMenu::Options PopupMenu::Options::withTargetScreenArea (const Rectangle<int>& area) const noexcept
{
	Options o (*this);
	o.targetArea = area;
	return o;
}

PopupMenu::Options PopupMenu::Options::withMinimumWidth (int w) const noexcept
{
	Options o (*this);
	o.minWidth = w;
	return o;
}

PopupMenu::Options PopupMenu::Options::withMaximumNumColumns (int cols) const noexcept
{
	Options o (*this);
	o.maxColumns = cols;
	return o;
}

PopupMenu::Options PopupMenu::Options::withStandardItemHeight (int height) const noexcept
{
	Options o (*this);
	o.standardHeight = height;
	return o;
}

PopupMenu::Options PopupMenu::Options::withItemThatMustBeVisible (int idOfItemToBeVisible) const noexcept
{
	Options o (*this);
	o.visibleItemID = idOfItemToBeVisible;
	return o;
}

Component* PopupMenu::createWindow (const Options& options,
									ApplicationCommandManager** managerOfChosenCommand) const
{
	if (items.size() > 0)
		return new Window (*this, nullptr, options,
						   ! options.targetArea.isEmpty(),
						   ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown(),
						   managerOfChosenCommand);

	return nullptr;
}

// This invokes any command manager commands and deletes the menu window when it is dismissed
class PopupMenuCompletionCallback  : public ModalComponentManager::Callback
{
public:
	PopupMenuCompletionCallback()
		: managerOfChosenCommand (nullptr),
		  prevFocused (Component::getCurrentlyFocusedComponent()),
		  prevTopLevel (prevFocused != nullptr ? prevFocused->getTopLevelComponent() : 0)
	{
		PopupMenuSettings::menuWasHiddenBecauseOfAppChange = false;
	}

	void modalStateFinished (int result)
	{
		if (managerOfChosenCommand != nullptr && result != 0)
		{
			ApplicationCommandTarget::InvocationInfo info (result);
			info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromMenu;

			managerOfChosenCommand->invoke (info, true);
		}

		// (this would be the place to fade out the component, if that's what's required)
		component = nullptr;

		if (! PopupMenuSettings::menuWasHiddenBecauseOfAppChange)
		{
			if (prevTopLevel != nullptr)
				prevTopLevel->toFront (true);

			if (prevFocused != nullptr)
				prevFocused->grabKeyboardFocus();
		}
	}

	ApplicationCommandManager* managerOfChosenCommand;
	ScopedPointer<Component> component;
	WeakReference<Component> prevFocused, prevTopLevel;

private:
	JUCE_DECLARE_NON_COPYABLE (PopupMenuCompletionCallback);
};

int PopupMenu::showWithOptionalCallback (const Options& options, ModalComponentManager::Callback* const userCallback,
										 const bool canBeModal)
{
	ScopedPointer<ModalComponentManager::Callback> userCallbackDeleter (userCallback);
	ScopedPointer<PopupMenuCompletionCallback> callback (new PopupMenuCompletionCallback());

	Component* window = createWindow (options, &(callback->managerOfChosenCommand));
	if (window == nullptr)
		return 0;

	callback->component = window;

	window->setVisible (true); // (must be called before enterModalState on Windows to avoid DropShadower confusion)
	window->enterModalState (false, userCallbackDeleter.release());
	ModalComponentManager::getInstance()->attachCallback (window, callback.release());

	window->toFront (false);  // need to do this after making it modal, or it could
							  // be stuck behind other comps that are already modal..

   #if JUCE_MODAL_LOOPS_PERMITTED
	return (userCallback == nullptr && canBeModal) ? window->runModalLoop() : 0;
   #else
	jassert (userCallback != nullptr && canBeModal);
	return 0;
   #endif
}

#if JUCE_MODAL_LOOPS_PERMITTED
int PopupMenu::showMenu (const Options& options)
{
	return showWithOptionalCallback (options, 0, true);
}
#endif

void PopupMenu::showMenuAsync (const Options& options, ModalComponentManager::Callback* userCallback)
{
   #if ! JUCE_MODAL_LOOPS_PERMITTED
	jassert (userCallback != nullptr);
   #endif

	showWithOptionalCallback (options, userCallback, false);
}

#if JUCE_MODAL_LOOPS_PERMITTED
int PopupMenu::show (const int itemIdThatMustBeVisible,
					 const int minimumWidth, const int maximumNumColumns,
					 const int standardItemHeight,
					 ModalComponentManager::Callback* callback)
{
	return showWithOptionalCallback (Options().withItemThatMustBeVisible (itemIdThatMustBeVisible)
											  .withMinimumWidth (minimumWidth)
											  .withMaximumNumColumns (maximumNumColumns)
											  .withStandardItemHeight (standardItemHeight),
									 callback, true);
}

int PopupMenu::showAt (const Rectangle<int>& screenAreaToAttachTo,
					   const int itemIdThatMustBeVisible,
					   const int minimumWidth, const int maximumNumColumns,
					   const int standardItemHeight,
					   ModalComponentManager::Callback* callback)
{
	return showWithOptionalCallback (Options().withTargetScreenArea (screenAreaToAttachTo)
											  .withItemThatMustBeVisible (itemIdThatMustBeVisible)
											  .withMinimumWidth (minimumWidth)
											  .withMaximumNumColumns (maximumNumColumns)
											  .withStandardItemHeight (standardItemHeight),
									 callback, true);
}

int PopupMenu::showAt (Component* componentToAttachTo,
					   const int itemIdThatMustBeVisible,
					   const int minimumWidth, const int maximumNumColumns,
					   const int standardItemHeight,
					   ModalComponentManager::Callback* callback)
{
	Options options (Options().withItemThatMustBeVisible (itemIdThatMustBeVisible)
							  .withMinimumWidth (minimumWidth)
							  .withMaximumNumColumns (maximumNumColumns)
							  .withStandardItemHeight (standardItemHeight));

	if (componentToAttachTo != nullptr)
		options = options.withTargetComponent (componentToAttachTo);

	return showWithOptionalCallback (options, callback, true);
}
#endif

bool JUCE_CALLTYPE PopupMenu::dismissAllActiveMenus()
{
	Array<Window*>& windows = Window::getActiveWindows();

	const int numWindows = windows.size();
	for (int i = numWindows; --i >= 0;)
	{
		Window* const pmw = windows[i];

		if (pmw != nullptr)
			pmw->dismissMenu (nullptr);
	}

	return numWindows > 0;
}

int PopupMenu::getNumItems() const noexcept
{
	int num = 0;

	for (int i = items.size(); --i >= 0;)
		if (! items.getUnchecked(i)->isSeparator)
			++num;

	return num;
}

bool PopupMenu::containsCommandItem (const int commandID) const
{
	for (int i = items.size(); --i >= 0;)
	{
		const Item* const mi = items.getUnchecked (i);

		if ((mi->itemId == commandID && mi->commandManager != nullptr)
			 || (mi->subMenu != nullptr && mi->subMenu->containsCommandItem (commandID)))
		{
			return true;
		}
	}

	return false;
}

bool PopupMenu::containsAnyActiveItems() const noexcept
{
	for (int i = items.size(); --i >= 0;)
	{
		const Item* const mi = items.getUnchecked (i);

		if (mi->subMenu != nullptr)
		{
			if (mi->subMenu->containsAnyActiveItems())
				return true;
		}
		else if (mi->active)
		{
			return true;
		}
	}

	return false;
}

void PopupMenu::setLookAndFeel (LookAndFeel* const newLookAndFeel)
{
	lookAndFeel = newLookAndFeel;
}

PopupMenu::CustomComponent::CustomComponent (const bool isTriggeredAutomatically_)
	: isHighlighted (false),
	  triggeredAutomatically (isTriggeredAutomatically_)
{
}

PopupMenu::CustomComponent::~CustomComponent()
{
}

void PopupMenu::CustomComponent::setHighlighted (bool shouldBeHighlighted)
{
	isHighlighted = shouldBeHighlighted;
	repaint();
}

void PopupMenu::CustomComponent::triggerMenuItem()
{
	PopupMenu::ItemComponent* const mic = dynamic_cast <PopupMenu::ItemComponent*> (getParentComponent());

	if (mic != nullptr)
	{
		PopupMenu::Window* const pmw = dynamic_cast <PopupMenu::Window*> (mic->getParentComponent());

		if (pmw != nullptr)
		{
			pmw->dismissMenu (&mic->itemInfo);
		}
		else
		{
			// something must have gone wrong with the component hierarchy if this happens..
			jassertfalse;
		}
	}
	else
	{
		// why isn't this component inside a menu? Not much point triggering the item if
		// there's no menu.
		jassertfalse;
	}
}

PopupMenu::MenuItemIterator::MenuItemIterator (const PopupMenu& menu_)
	: subMenu (nullptr),
	  itemId (0),
	  isSeparator (false),
	  isTicked (false),
	  isEnabled (false),
	  isCustomComponent (false),
	  isSectionHeader (false),
	  customColour (nullptr),
	  menu (menu_),
	  index (0)
{
}

PopupMenu::MenuItemIterator::~MenuItemIterator()
{
}

bool PopupMenu::MenuItemIterator::next()
{
	if (index >= menu.items.size())
		return false;

	const Item* const item = menu.items.getUnchecked (index);
	++index;

	if (item->isSeparator && index >= menu.items.size()) // (avoid showing a separator at the end)
		return false;

	itemName        = item->customComp != nullptr ? item->customComp->getName() : item->text;
	subMenu         = item->subMenu;
	itemId          = item->itemId;
	isSeparator     = item->isSeparator;
	isTicked        = item->isTicked;
	isEnabled       = item->active;
	isSectionHeader = dynamic_cast <HeaderItemComponent*> (static_cast <CustomComponent*> (item->customComp)) != nullptr;
	isCustomComponent = (! isSectionHeader) && item->customComp != nullptr;
	customColour    = item->usesColour ? &(item->textColour) : nullptr;
	customImage     = item->image;
	commandManager  = item->commandManager;

	return true;
}

/*** End of inlined file: juce_PopupMenu.cpp ***/


/*** Start of inlined file: juce_MarkerList.cpp ***/
MarkerList::MarkerList()
{
}

MarkerList::MarkerList (const MarkerList& other)
{
	operator= (other);
}

MarkerList& MarkerList::operator= (const MarkerList& other)
{
	if (other != *this)
	{
		markers.clear();
		markers.addCopiesOf (other.markers);
		markersHaveChanged();
	}

	return *this;
}

MarkerList::~MarkerList()
{
	listeners.call (&MarkerList::Listener::markerListBeingDeleted, this);
}

bool MarkerList::operator== (const MarkerList& other) const noexcept
{
	if (other.markers.size() != markers.size())
		return false;

	for (int i = markers.size(); --i >= 0;)
	{
		const Marker* const m1 = markers.getUnchecked(i);
		jassert (m1 != nullptr);

		const Marker* const m2 = other.getMarker (m1->name);

		if (m2 == nullptr || *m1 != *m2)
			return false;
	}

	return true;
}

bool MarkerList::operator!= (const MarkerList& other) const noexcept
{
	return ! operator== (other);
}

int MarkerList::getNumMarkers() const noexcept
{
	return markers.size();
}

const MarkerList::Marker* MarkerList::getMarker (const int index) const noexcept
{
	return markers [index];
}

const MarkerList::Marker* MarkerList::getMarker (const String& name) const noexcept
{
	return getMarkerByName (name);
}

MarkerList::Marker* MarkerList::getMarkerByName (const String& name) const noexcept
{
	for (int i = 0; i < markers.size(); ++i)
	{
		Marker* const m = markers.getUnchecked(i);

		if (m->name == name)
			return m;
	}

	return nullptr;
}

void MarkerList::setMarker (const String& name, const RelativeCoordinate& position)
{
	Marker* const m = getMarkerByName (name);

	if (m != nullptr)
	{
		if (m->position != position)
		{
			m->position = position;
			markersHaveChanged();
		}

		return;
	}

	markers.add (new Marker (name, position));
	markersHaveChanged();
}

void MarkerList::removeMarker (const int index)
{
	if (isPositiveAndBelow (index, markers.size()))
	{
		markers.remove (index);
		markersHaveChanged();
	}
}

void MarkerList::removeMarker (const String& name)
{
	for (int i = 0; i < markers.size(); ++i)
	{
		const Marker* const m = markers.getUnchecked(i);

		if (m->name == name)
		{
			markers.remove (i);
			markersHaveChanged();
		}
	}
}

void MarkerList::markersHaveChanged()
{
	listeners.call (&MarkerList::Listener::markersChanged, this);
}

void MarkerList::Listener::markerListBeingDeleted (MarkerList*)
{
}

void MarkerList::addListener (Listener* listener)
{
	listeners.add (listener);
}

void MarkerList::removeListener (Listener* listener)
{
	listeners.remove (listener);
}

MarkerList::Marker::Marker (const Marker& other)
	: name (other.name), position (other.position)
{
}

MarkerList::Marker::Marker (const String& name_, const RelativeCoordinate& position_)
	: name (name_), position (position_)
{
}

bool MarkerList::Marker::operator== (const Marker& other) const noexcept
{
	return name == other.name && position == other.position;
}

bool MarkerList::Marker::operator!= (const Marker& other) const noexcept
{
	return ! operator== (other);
}

const Identifier MarkerList::ValueTreeWrapper::markerTag ("Marker");
const Identifier MarkerList::ValueTreeWrapper::nameProperty ("name");
const Identifier MarkerList::ValueTreeWrapper::posProperty ("position");

MarkerList::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: state (state_)
{
}

int MarkerList::ValueTreeWrapper::getNumMarkers() const
{
	return state.getNumChildren();
}

ValueTree MarkerList::ValueTreeWrapper::getMarkerState (int index) const
{
	return state.getChild (index);
}

ValueTree MarkerList::ValueTreeWrapper::getMarkerState (const String& name) const
{
	return state.getChildWithProperty (nameProperty, name);
}

bool MarkerList::ValueTreeWrapper::containsMarker (const ValueTree& marker) const
{
	return marker.isAChildOf (state);
}

MarkerList::Marker MarkerList::ValueTreeWrapper::getMarker (const ValueTree& marker) const
{
	jassert (containsMarker (marker));

	return MarkerList::Marker (marker [nameProperty], RelativeCoordinate (marker [posProperty].toString()));
}

void MarkerList::ValueTreeWrapper::setMarker (const MarkerList::Marker& m, UndoManager* undoManager)
{
	ValueTree marker (state.getChildWithProperty (nameProperty, m.name));

	if (marker.isValid())
	{
		marker.setProperty (posProperty, m.position.toString(), undoManager);
	}
	else
	{
		marker = ValueTree (markerTag);
		marker.setProperty (nameProperty, m.name, nullptr);
		marker.setProperty (posProperty, m.position.toString(), nullptr);
		state.addChild (marker, -1, undoManager);
	}
}

void MarkerList::ValueTreeWrapper::removeMarker (const ValueTree& marker, UndoManager* undoManager)
{
	state.removeChild (marker, undoManager);
}

double MarkerList::getMarkerPosition (const Marker& marker, Component* parentComponent) const
{
	if (parentComponent != nullptr)
	{
		RelativeCoordinatePositionerBase::ComponentScope scope (*parentComponent);
		return marker.position.resolve (&scope);
	}
	else
	{
		return marker.position.resolve (nullptr);
	}
}

void MarkerList::ValueTreeWrapper::applyTo (MarkerList& markerList)
{
	const int numMarkers = getNumMarkers();

	StringArray updatedMarkers;

	int i;
	for (i = 0; i < numMarkers; ++i)
	{
		const ValueTree marker (state.getChild (i));
		const String name (marker [nameProperty].toString());
		markerList.setMarker (name, RelativeCoordinate (marker [posProperty].toString()));
		updatedMarkers.add (name);
	}

	for (i = markerList.getNumMarkers(); --i >= 0;)
		if (! updatedMarkers.contains (markerList.getMarker (i)->name))
			markerList.removeMarker (i);
}

void MarkerList::ValueTreeWrapper::readFrom (const MarkerList& markerList, UndoManager* undoManager)
{
	state.removeAllChildren (undoManager);

	for (int i = 0; i < markerList.getNumMarkers(); ++i)
		setMarker (*markerList.getMarker(i), undoManager);
}

/*** End of inlined file: juce_MarkerList.cpp ***/


/*** Start of inlined file: juce_RelativeCoordinate.cpp ***/
const String RelativeCoordinate::Strings::parent ("parent");
const String RelativeCoordinate::Strings::left ("left");
const String RelativeCoordinate::Strings::right ("right");
const String RelativeCoordinate::Strings::top ("top");
const String RelativeCoordinate::Strings::bottom ("bottom");
const String RelativeCoordinate::Strings::x ("x");
const String RelativeCoordinate::Strings::y ("y");
const String RelativeCoordinate::Strings::width ("width");
const String RelativeCoordinate::Strings::height ("height");

RelativeCoordinate::StandardStrings::Type RelativeCoordinate::StandardStrings::getTypeOf (const String& s) noexcept
{
	if (s == Strings::left)    return left;
	if (s == Strings::right)   return right;
	if (s == Strings::top)     return top;
	if (s == Strings::bottom)  return bottom;
	if (s == Strings::x)       return x;
	if (s == Strings::y)       return y;
	if (s == Strings::width)   return width;
	if (s == Strings::height)  return height;
	if (s == Strings::parent)  return parent;
	return unknown;
}

RelativeCoordinate::RelativeCoordinate()
{
}

RelativeCoordinate::RelativeCoordinate (const Expression& term_)
	: term (term_)
{
}

RelativeCoordinate::RelativeCoordinate (const RelativeCoordinate& other)
	: term (other.term)
{
}

RelativeCoordinate& RelativeCoordinate::operator= (const RelativeCoordinate& other)
{
	term = other.term;
	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
RelativeCoordinate::RelativeCoordinate (RelativeCoordinate&& other) noexcept
	: term (static_cast <Expression&&> (other.term))
{
}

RelativeCoordinate& RelativeCoordinate::operator= (RelativeCoordinate&& other) noexcept
{
	term = static_cast <Expression&&> (other.term);
	return *this;
}
#endif

RelativeCoordinate::RelativeCoordinate (const double absoluteDistanceFromOrigin)
	: term (absoluteDistanceFromOrigin)
{
}

RelativeCoordinate::RelativeCoordinate (const String& s)
{
	try
	{
		term = Expression (s);
	}
	catch (Expression::ParseError&)
	{}
}

RelativeCoordinate::~RelativeCoordinate()
{
}

bool RelativeCoordinate::operator== (const RelativeCoordinate& other) const noexcept
{
	return term.toString() == other.term.toString();
}

bool RelativeCoordinate::operator!= (const RelativeCoordinate& other) const noexcept
{
	return ! operator== (other);
}

double RelativeCoordinate::resolve (const Expression::Scope* scope) const
{
	try
	{
		if (scope != nullptr)
			return term.evaluate (*scope);
		else
			return term.evaluate();
	}
	catch (Expression::ParseError&)
	{}

	return 0.0;
}

bool RelativeCoordinate::isRecursive (const Expression::Scope* scope) const
{
	try
	{
		if (scope != nullptr)
			term.evaluate (*scope);
		else
			term.evaluate();
	}
	catch (Expression::ParseError&)
	{
		return true;
	}

	return false;
}

void RelativeCoordinate::moveToAbsolute (double newPos, const Expression::Scope* scope)
{
	try
	{
		if (scope != nullptr)
		{
			term = term.adjustedToGiveNewResult (newPos, *scope);
		}
		else
		{
			Expression::Scope defaultScope;
			term = term.adjustedToGiveNewResult (newPos, defaultScope);
		}
	}
	catch (Expression::ParseError&)
	{}
}

bool RelativeCoordinate::isDynamic() const
{
	return term.usesAnySymbols();
}

String RelativeCoordinate::toString() const
{
	return term.toString();
}

/*** End of inlined file: juce_RelativeCoordinate.cpp ***/


/*** Start of inlined file: juce_RelativeCoordinatePositioner.cpp ***/
class MarkerListScope  : public Expression::Scope
{
public:
	MarkerListScope (Component& component_) : component (component_) {}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::width:  return Expression ((double) component.getWidth());
			case RelativeCoordinate::StandardStrings::height: return Expression ((double) component.getHeight());
			default: break;
		}

		MarkerList* list;
		const MarkerList::Marker* const marker = findMarker (component, symbol, list);

		if (marker != nullptr)
			return Expression (marker->position.getExpression().evaluate (*this));

		return Expression::Scope::getSymbolValue (symbol);
	}

	void visitRelativeScope (const String& scopeName, Visitor& visitor) const
	{
		if (scopeName == RelativeCoordinate::Strings::parent)
		{
			Component* const parent = component.getParentComponent();

			if (parent != nullptr)
			{
				visitor.visit (MarkerListScope (*parent));
				return;
			}
		}

		Expression::Scope::visitRelativeScope (scopeName, visitor);
	}

	String getScopeUID() const
	{
		return String::toHexString ((pointer_sized_int) (void*) &component) + "m";
	}

	static const MarkerList::Marker* findMarker (Component& component, const String& name, MarkerList*& list)
	{
		const MarkerList::Marker* marker = nullptr;
		list = component.getMarkers (true);

		if (list != nullptr)
			marker = list->getMarker (name);

		if (marker == nullptr)
		{
			list = component.getMarkers (false);

			if (list != nullptr)
				marker = list->getMarker (name);
		}

		return marker;
	}

private:
	Component& component;

	JUCE_DECLARE_NON_COPYABLE (MarkerListScope);
};

RelativeCoordinatePositionerBase::ComponentScope::ComponentScope (Component& component_)
	: component (component_)
{
}

Expression RelativeCoordinatePositionerBase::ComponentScope::getSymbolValue (const String& symbol) const
{
	switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
	{
		case RelativeCoordinate::StandardStrings::x:
		case RelativeCoordinate::StandardStrings::left:   return Expression ((double) component.getX());
		case RelativeCoordinate::StandardStrings::y:
		case RelativeCoordinate::StandardStrings::top:    return Expression ((double) component.getY());
		case RelativeCoordinate::StandardStrings::width:  return Expression ((double) component.getWidth());
		case RelativeCoordinate::StandardStrings::height: return Expression ((double) component.getHeight());
		case RelativeCoordinate::StandardStrings::right:  return Expression ((double) component.getRight());
		case RelativeCoordinate::StandardStrings::bottom: return Expression ((double) component.getBottom());
		default: break;
	}

	Component* const parent = component.getParentComponent();

	if (parent != nullptr)
	{
		MarkerList* list;
		const MarkerList::Marker* const marker = MarkerListScope::findMarker (*parent, symbol, list);

		if (marker != nullptr)
		{
			MarkerListScope scope (*parent);
			return Expression (marker->position.getExpression().evaluate (scope));
		}
	}

	return Expression::Scope::getSymbolValue (symbol);
}

void RelativeCoordinatePositionerBase::ComponentScope::visitRelativeScope (const String& scopeName, Visitor& visitor) const
{
	Component* const targetComp = (scopeName == RelativeCoordinate::Strings::parent)
										? component.getParentComponent()
										: findSiblingComponent (scopeName);

	if (targetComp != nullptr)
		visitor.visit (ComponentScope (*targetComp));
	else
		Expression::Scope::visitRelativeScope (scopeName, visitor);
}

String RelativeCoordinatePositionerBase::ComponentScope::getScopeUID() const
{
	return String::toHexString ((pointer_sized_int) (void*) &component);
}

Component* RelativeCoordinatePositionerBase::ComponentScope::findSiblingComponent (const String& componentID) const
{
	Component* const parent = component.getParentComponent();

	return parent != nullptr ? parent->findChildWithID (componentID)
							 : nullptr;
}

class RelativeCoordinatePositionerBase::DependencyFinderScope  : public ComponentScope
{
public:
	DependencyFinderScope (Component& component_, RelativeCoordinatePositionerBase& positioner_, bool& ok_)
		: ComponentScope (component_), positioner (positioner_), ok (ok_)
	{
	}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::x:
			case RelativeCoordinate::StandardStrings::left:
			case RelativeCoordinate::StandardStrings::y:
			case RelativeCoordinate::StandardStrings::top:
			case RelativeCoordinate::StandardStrings::width:
			case RelativeCoordinate::StandardStrings::height:
			case RelativeCoordinate::StandardStrings::right:
			case RelativeCoordinate::StandardStrings::bottom:
				positioner.registerComponentListener (component);
				break;

			default:
			{
				Component* const parent = component.getParentComponent();
				if (parent != nullptr)
				{
					MarkerList* list;
					const MarkerList::Marker* marker = MarkerListScope::findMarker (*parent, symbol, list);

					if (marker != nullptr)
					{
						positioner.registerMarkerListListener (list);
					}
					else
					{
						// The marker we want doesn't exist, so watch all lists in case they change and the marker appears later..
						positioner.registerMarkerListListener (parent->getMarkers (true));
						positioner.registerMarkerListListener (parent->getMarkers (false));
						ok = false;
					}
				}
			}
			break;
		}

		return ComponentScope::getSymbolValue (symbol);
	}

	void visitRelativeScope (const String& scopeName, Visitor& visitor) const
	{
		Component* const targetComp = (scopeName == RelativeCoordinate::Strings::parent)
											? component.getParentComponent()
											: findSiblingComponent (scopeName);

		if (targetComp != nullptr)
		{
			visitor.visit (DependencyFinderScope (*targetComp, positioner, ok));
		}
		else
		{
			// The named component doesn't exist, so we'll watch the parent for changes in case it appears later..
			Component* const parent = component.getParentComponent();
			if (parent != nullptr)
				positioner.registerComponentListener (*parent);

			positioner.registerComponentListener (component);
			ok = false;
		}
	}

private:
	RelativeCoordinatePositionerBase& positioner;
	bool& ok;

	JUCE_DECLARE_NON_COPYABLE (DependencyFinderScope);
};

RelativeCoordinatePositionerBase::RelativeCoordinatePositionerBase (Component& component_)
	: Component::Positioner (component_), registeredOk (false)
{
}

RelativeCoordinatePositionerBase::~RelativeCoordinatePositionerBase()
{
	unregisterListeners();
}

void RelativeCoordinatePositionerBase::componentMovedOrResized (Component&, bool /*wasMoved*/, bool /*wasResized*/)
{
	apply();
}

void RelativeCoordinatePositionerBase::componentParentHierarchyChanged (Component&)
{
	apply();
}

void RelativeCoordinatePositionerBase::componentChildrenChanged (Component& changed)
{
	if (getComponent().getParentComponent() == &changed && ! registeredOk)
		apply();
}

void RelativeCoordinatePositionerBase::componentBeingDeleted (Component& comp)
{
	jassert (sourceComponents.contains (&comp));
	sourceComponents.removeValue (&comp);
	registeredOk = false;
}

void RelativeCoordinatePositionerBase::markersChanged (MarkerList*)
{
	apply();
}

void RelativeCoordinatePositionerBase::markerListBeingDeleted (MarkerList* markerList)
{
	jassert (sourceMarkerLists.contains (markerList));
	sourceMarkerLists.removeValue (markerList);
}

void RelativeCoordinatePositionerBase::apply()
{
	if (! registeredOk)
	{
		unregisterListeners();
		registeredOk = registerCoordinates();
	}

	applyToComponentBounds();
}

bool RelativeCoordinatePositionerBase::addCoordinate (const RelativeCoordinate& coord)
{
	bool ok = true;
	DependencyFinderScope finderScope (getComponent(), *this, ok);
	coord.getExpression().evaluate (finderScope);
	return ok;
}

bool RelativeCoordinatePositionerBase::addPoint (const RelativePoint& point)
{
	const bool ok = addCoordinate (point.x);
	return addCoordinate (point.y) && ok;
}

void RelativeCoordinatePositionerBase::registerComponentListener (Component& comp)
{
	if (! sourceComponents.contains (&comp))
	{
		comp.addComponentListener (this);
		sourceComponents.add (&comp);
	}
}

void RelativeCoordinatePositionerBase::registerMarkerListListener (MarkerList* const list)
{
	if (list != nullptr && ! sourceMarkerLists.contains (list))
	{
		list->addListener (this);
		sourceMarkerLists.add (list);
	}
}

void RelativeCoordinatePositionerBase::unregisterListeners()
{
	int i;
	for (i = sourceComponents.size(); --i >= 0;)
		sourceComponents.getUnchecked(i)->removeComponentListener (this);

	for (i = sourceMarkerLists.size(); --i >= 0;)
		sourceMarkerLists.getUnchecked(i)->removeListener (this);

	sourceComponents.clear();
	sourceMarkerLists.clear();
}

/*** End of inlined file: juce_RelativeCoordinatePositioner.cpp ***/


/*** Start of inlined file: juce_RelativeParallelogram.cpp ***/
RelativeParallelogram::RelativeParallelogram()
{
}

RelativeParallelogram::RelativeParallelogram (const Rectangle<float>& r)
	: topLeft (r.getTopLeft()), topRight (r.getTopRight()), bottomLeft (r.getBottomLeft())
{
}

RelativeParallelogram::RelativeParallelogram (const RelativePoint& topLeft_, const RelativePoint& topRight_, const RelativePoint& bottomLeft_)
	: topLeft (topLeft_), topRight (topRight_), bottomLeft (bottomLeft_)
{
}

RelativeParallelogram::RelativeParallelogram (const String& topLeft_, const String& topRight_, const String& bottomLeft_)
	: topLeft (topLeft_), topRight (topRight_), bottomLeft (bottomLeft_)
{
}

RelativeParallelogram::~RelativeParallelogram()
{
}

void RelativeParallelogram::resolveThreePoints (Point<float>* points, Expression::Scope* const scope) const
{
	points[0] = topLeft.resolve (scope);
	points[1] = topRight.resolve (scope);
	points[2] = bottomLeft.resolve (scope);
}

void RelativeParallelogram::resolveFourCorners (Point<float>* points, Expression::Scope* const scope) const
{
	resolveThreePoints (points, scope);
	points[3] = points[1] + (points[2] - points[0]);
}

const Rectangle<float> RelativeParallelogram::getBounds (Expression::Scope* const scope) const
{
	Point<float> points[4];
	resolveFourCorners (points, scope);
	return Rectangle<float>::findAreaContainingPoints (points, 4);
}

void RelativeParallelogram::getPath (Path& path, Expression::Scope* const scope) const
{
	Point<float> points[4];
	resolveFourCorners (points, scope);

	path.startNewSubPath (points[0]);
	path.lineTo (points[1]);
	path.lineTo (points[3]);
	path.lineTo (points[2]);
	path.closeSubPath();
}

const AffineTransform RelativeParallelogram::resetToPerpendicular (Expression::Scope* const scope)
{
	Point<float> corners[3];
	resolveThreePoints (corners, scope);

	const Line<float> top (corners[0], corners[1]);
	const Line<float> left (corners[0], corners[2]);
	const Point<float> newTopRight (corners[0] + Point<float> (top.getLength(), 0.0f));
	const Point<float> newBottomLeft (corners[0] + Point<float> (0.0f, left.getLength()));

	topRight.moveToAbsolute (newTopRight, scope);
	bottomLeft.moveToAbsolute (newBottomLeft, scope);

	return AffineTransform::fromTargetPoints (corners[0].x, corners[0].y, corners[0].x, corners[0].y,
											  corners[1].x, corners[1].y, newTopRight.x, newTopRight.y,
											  corners[2].x, corners[2].y, newBottomLeft.x, newBottomLeft.y);
}

bool RelativeParallelogram::isDynamic() const
{
	return topLeft.isDynamic() || topRight.isDynamic() || bottomLeft.isDynamic();
}

bool RelativeParallelogram::operator== (const RelativeParallelogram& other) const noexcept
{
	return topLeft == other.topLeft && topRight == other.topRight && bottomLeft == other.bottomLeft;
}

bool RelativeParallelogram::operator!= (const RelativeParallelogram& other) const noexcept
{
	return ! operator== (other);
}

const Point<float> RelativeParallelogram::getInternalCoordForPoint (const Point<float>* const corners, Point<float> target) noexcept
{
	const Point<float> tr (corners[1] - corners[0]);
	const Point<float> bl (corners[2] - corners[0]);
	target -= corners[0];

	return Point<float> (Line<float> (Point<float>(), tr).getIntersection (Line<float> (target, target - bl)).getDistanceFromOrigin(),
						 Line<float> (Point<float>(), bl).getIntersection (Line<float> (target, target - tr)).getDistanceFromOrigin());
}

const Point<float> RelativeParallelogram::getPointForInternalCoord (const Point<float>* const corners, const Point<float>& point) noexcept
{
	return corners[0]
			+ Line<float> (Point<float>(), corners[1] - corners[0]).getPointAlongLine (point.x)
			+ Line<float> (Point<float>(), corners[2] - corners[0]).getPointAlongLine (point.y);
}

const Rectangle<float> RelativeParallelogram::getBoundingBox (const Point<float>* const p) noexcept
{
	const Point<float> points[] = { p[0], p[1], p[2], p[1] + (p[2] - p[0]) };
	return Rectangle<float>::findAreaContainingPoints (points, 4);
}

/*** End of inlined file: juce_RelativeParallelogram.cpp ***/


/*** Start of inlined file: juce_RelativePoint.cpp ***/
namespace RelativePointHelpers
{
	inline void skipComma (String::CharPointerType& s)
	{
		s = s.findEndOfWhitespace();

		if (*s == ',')
			++s;
	}
}

RelativePoint::RelativePoint()
{
}

RelativePoint::RelativePoint (const Point<float>& absolutePoint)
	: x (absolutePoint.x), y (absolutePoint.y)
{
}

RelativePoint::RelativePoint (const float x_, const float y_)
	: x (x_), y (y_)
{
}

RelativePoint::RelativePoint (const RelativeCoordinate& x_, const RelativeCoordinate& y_)
	: x (x_), y (y_)
{
}

RelativePoint::RelativePoint (const String& s)
{
	String::CharPointerType text (s.getCharPointer());
	x = RelativeCoordinate (Expression::parse (text));
	RelativePointHelpers::skipComma (text);
	y = RelativeCoordinate (Expression::parse (text));
}

bool RelativePoint::operator== (const RelativePoint& other) const noexcept
{
	return x == other.x && y == other.y;
}

bool RelativePoint::operator!= (const RelativePoint& other) const noexcept
{
	return ! operator== (other);
}

const Point<float> RelativePoint::resolve (const Expression::Scope* scope) const
{
	return Point<float> ((float) x.resolve (scope),
						 (float) y.resolve (scope));
}

void RelativePoint::moveToAbsolute (const Point<float>& newPos, const Expression::Scope* scope)
{
	x.moveToAbsolute (newPos.x, scope);
	y.moveToAbsolute (newPos.y, scope);
}

String RelativePoint::toString() const
{
	return x.toString() + ", " + y.toString();
}

bool RelativePoint::isDynamic() const
{
	return x.isDynamic() || y.isDynamic();
}

/*** End of inlined file: juce_RelativePoint.cpp ***/


/*** Start of inlined file: juce_RelativePointPath.cpp ***/
RelativePointPath::RelativePointPath()
	: usesNonZeroWinding (true),
	  containsDynamicPoints (false)
{
}

RelativePointPath::RelativePointPath (const RelativePointPath& other)
	: usesNonZeroWinding (true),
	  containsDynamicPoints (false)
{
	for (int i = 0; i < other.elements.size(); ++i)
		elements.add (other.elements.getUnchecked(i)->clone());
}

RelativePointPath::RelativePointPath (const Path& path)
	: usesNonZeroWinding (path.isUsingNonZeroWinding()),
	  containsDynamicPoints (false)
{
	for (Path::Iterator i (path); i.next();)
	{
		switch (i.elementType)
		{
			case Path::Iterator::startNewSubPath:   elements.add (new StartSubPath (RelativePoint (i.x1, i.y1))); break;
			case Path::Iterator::lineTo:            elements.add (new LineTo (RelativePoint (i.x1, i.y1))); break;
			case Path::Iterator::quadraticTo:       elements.add (new QuadraticTo (RelativePoint (i.x1, i.y1), RelativePoint (i.x2, i.y2))); break;
			case Path::Iterator::cubicTo:           elements.add (new CubicTo (RelativePoint (i.x1, i.y1), RelativePoint (i.x2, i.y2), RelativePoint (i.x3, i.y3))); break;
			case Path::Iterator::closePath:         elements.add (new CloseSubPath()); break;
			default:                                jassertfalse; break;
		}
	}
}

RelativePointPath::~RelativePointPath()
{
}

bool RelativePointPath::operator== (const RelativePointPath& other) const noexcept
{
	if (elements.size() != other.elements.size()
		 || usesNonZeroWinding != other.usesNonZeroWinding
		 || containsDynamicPoints != other.containsDynamicPoints)
		return false;

	for (int i = 0; i < elements.size(); ++i)
	{
		ElementBase* const e1 = elements.getUnchecked(i);
		ElementBase* const e2 = other.elements.getUnchecked(i);

		if (e1->type != e2->type)
			return false;

		int numPoints1, numPoints2;
		const RelativePoint* const points1 = e1->getControlPoints (numPoints1);
		const RelativePoint* const points2 = e2->getControlPoints (numPoints2);

		jassert (numPoints1 == numPoints2);

		for (int j = numPoints1; --j >= 0;)
			if (points1[j] != points2[j])
				return false;
	}

	return true;
}

bool RelativePointPath::operator!= (const RelativePointPath& other) const noexcept
{
	return ! operator== (other);
}

void RelativePointPath::swapWith (RelativePointPath& other) noexcept
{
	elements.swapWithArray (other.elements);
	std::swap (usesNonZeroWinding, other.usesNonZeroWinding);
	std::swap (containsDynamicPoints, other.containsDynamicPoints);
}

void RelativePointPath::createPath (Path& path, Expression::Scope* scope) const
{
	for (int i = 0; i < elements.size(); ++i)
		elements.getUnchecked(i)->addToPath (path, scope);
}

bool RelativePointPath::containsAnyDynamicPoints() const
{
	return containsDynamicPoints;
}

void RelativePointPath::addElement (ElementBase* newElement)
{
	if (newElement != nullptr)
	{
		elements.add (newElement);
		containsDynamicPoints = containsDynamicPoints || newElement->isDynamic();
	}
}

RelativePointPath::ElementBase::ElementBase (const ElementType type_) : type (type_)
{
}

bool RelativePointPath::ElementBase::isDynamic()
{
	int numPoints;
	const RelativePoint* const points = getControlPoints (numPoints);

	for (int i = numPoints; --i >= 0;)
		if (points[i].isDynamic())
			return true;

	return false;
}

RelativePointPath::StartSubPath::StartSubPath (const RelativePoint& pos)
	: ElementBase (startSubPathElement), startPos (pos)
{
}

ValueTree RelativePointPath::StartSubPath::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::startSubPathElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, startPos.toString(), nullptr);
	return v;
}

void RelativePointPath::StartSubPath::addToPath (Path& path, Expression::Scope* scope) const
{
	path.startNewSubPath (startPos.resolve (scope));
}

RelativePoint* RelativePointPath::StartSubPath::getControlPoints (int& numPoints)
{
	numPoints = 1;
	return &startPos;
}

RelativePointPath::ElementBase* RelativePointPath::StartSubPath::clone() const
{
	return new StartSubPath (startPos);
}

RelativePointPath::CloseSubPath::CloseSubPath()
	: ElementBase (closeSubPathElement)
{
}

ValueTree RelativePointPath::CloseSubPath::createTree() const
{
	return ValueTree (DrawablePath::ValueTreeWrapper::Element::closeSubPathElement);
}

void RelativePointPath::CloseSubPath::addToPath (Path& path, Expression::Scope*) const
{
	path.closeSubPath();
}

RelativePoint* RelativePointPath::CloseSubPath::getControlPoints (int& numPoints)
{
	numPoints = 0;
	return nullptr;
}

RelativePointPath::ElementBase* RelativePointPath::CloseSubPath::clone() const
{
	return new CloseSubPath();
}

RelativePointPath::LineTo::LineTo (const RelativePoint& endPoint_)
	: ElementBase (lineToElement), endPoint (endPoint_)
{
}

ValueTree RelativePointPath::LineTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::lineToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, endPoint.toString(), nullptr);
	return v;
}

void RelativePointPath::LineTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.lineTo (endPoint.resolve (scope));
}

RelativePoint* RelativePointPath::LineTo::getControlPoints (int& numPoints)
{
	numPoints = 1;
	return &endPoint;
}

RelativePointPath::ElementBase* RelativePointPath::LineTo::clone() const
{
	return new LineTo (endPoint);
}

RelativePointPath::QuadraticTo::QuadraticTo (const RelativePoint& controlPoint, const RelativePoint& endPoint)
	: ElementBase (quadraticToElement)
{
	controlPoints[0] = controlPoint;
	controlPoints[1] = endPoint;
}

ValueTree RelativePointPath::QuadraticTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::quadraticToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, controlPoints[0].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point2, controlPoints[1].toString(), nullptr);
	return v;
}

void RelativePointPath::QuadraticTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.quadraticTo (controlPoints[0].resolve (scope),
					  controlPoints[1].resolve (scope));
}

RelativePoint* RelativePointPath::QuadraticTo::getControlPoints (int& numPoints)
{
	numPoints = 2;
	return controlPoints;
}

RelativePointPath::ElementBase* RelativePointPath::QuadraticTo::clone() const
{
	return new QuadraticTo (controlPoints[0], controlPoints[1]);
}

RelativePointPath::CubicTo::CubicTo (const RelativePoint& controlPoint1, const RelativePoint& controlPoint2, const RelativePoint& endPoint)
	: ElementBase (cubicToElement)
{
	controlPoints[0] = controlPoint1;
	controlPoints[1] = controlPoint2;
	controlPoints[2] = endPoint;
}

ValueTree RelativePointPath::CubicTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::cubicToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, controlPoints[0].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point2, controlPoints[1].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point3, controlPoints[2].toString(), nullptr);
	return v;
}

void RelativePointPath::CubicTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.cubicTo (controlPoints[0].resolve (scope),
				  controlPoints[1].resolve (scope),
				  controlPoints[2].resolve (scope));
}

RelativePoint* RelativePointPath::CubicTo::getControlPoints (int& numPoints)
{
	numPoints = 3;
	return controlPoints;
}

RelativePointPath::ElementBase* RelativePointPath::CubicTo::clone() const
{
	return new CubicTo (controlPoints[0], controlPoints[1], controlPoints[2]);
}

/*** End of inlined file: juce_RelativePointPath.cpp ***/


/*** Start of inlined file: juce_RelativeRectangle.cpp ***/
namespace RelativeRectangleHelpers
{
	inline void skipComma (String::CharPointerType& s)
	{
		s = s.findEndOfWhitespace();

		if (*s == ',')
			++s;
	}

	static bool dependsOnSymbolsOtherThanThis (const Expression& e)
	{
		if (e.getType() == Expression::operatorType && e.getSymbolOrFunction() == ".")
			return true;

		if (e.getType() == Expression::symbolType)
		{
			switch (RelativeCoordinate::StandardStrings::getTypeOf (e.getSymbolOrFunction()))
			{
				case RelativeCoordinate::StandardStrings::x:
				case RelativeCoordinate::StandardStrings::y:
				case RelativeCoordinate::StandardStrings::left:
				case RelativeCoordinate::StandardStrings::right:
				case RelativeCoordinate::StandardStrings::top:
				case RelativeCoordinate::StandardStrings::bottom:   return false;
				default: break;
			}

			return true;
		}
		else
		{
			for (int i = e.getNumInputs(); --i >= 0;)
				if (dependsOnSymbolsOtherThanThis (e.getInput(i)))
					return true;
		}

		return false;
	}
}

RelativeRectangle::RelativeRectangle()
{
}

RelativeRectangle::RelativeRectangle (const RelativeCoordinate& left_, const RelativeCoordinate& right_,
									  const RelativeCoordinate& top_, const RelativeCoordinate& bottom_)
	: left (left_), right (right_), top (top_), bottom (bottom_)
{
}

RelativeRectangle::RelativeRectangle (const Rectangle<float>& rect)
	: left (rect.getX()),
	  right (Expression::symbol (RelativeCoordinate::Strings::left) + Expression ((double) rect.getWidth())),
	  top (rect.getY()),
	  bottom (Expression::symbol (RelativeCoordinate::Strings::top) + Expression ((double) rect.getHeight()))
{
}

RelativeRectangle::RelativeRectangle (const String& s)
{
	String::CharPointerType text (s.getCharPointer());
	left = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	top = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	right = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	bottom = RelativeCoordinate (Expression::parse (text));
}

bool RelativeRectangle::operator== (const RelativeRectangle& other) const noexcept
{
	return left == other.left && top == other.top && right == other.right && bottom == other.bottom;
}

bool RelativeRectangle::operator!= (const RelativeRectangle& other) const noexcept
{
	return ! operator== (other);
}

// An expression context that can evaluate expressions using "this"
class RelativeRectangleLocalScope  : public Expression::Scope
{
public:
	RelativeRectangleLocalScope (const RelativeRectangle& rect_)  : rect (rect_) {}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::x:
			case RelativeCoordinate::StandardStrings::left:     return rect.left.getExpression();
			case RelativeCoordinate::StandardStrings::y:
			case RelativeCoordinate::StandardStrings::top:      return rect.top.getExpression();
			case RelativeCoordinate::StandardStrings::right:    return rect.right.getExpression();
			case RelativeCoordinate::StandardStrings::bottom:   return rect.bottom.getExpression();
			default: break;
		}

		return Expression::Scope::getSymbolValue (symbol);
	}

private:
	const RelativeRectangle& rect;

	JUCE_DECLARE_NON_COPYABLE (RelativeRectangleLocalScope);
};

const Rectangle<float> RelativeRectangle::resolve (const Expression::Scope* scope) const
{
	if (scope == nullptr)
	{
		RelativeRectangleLocalScope defaultScope (*this);
		return resolve (&defaultScope);
	}
	else
	{
		const double l = left.resolve (scope);
		const double r = right.resolve (scope);
		const double t = top.resolve (scope);
		const double b = bottom.resolve (scope);

		return Rectangle<float> ((float) l, (float) t, (float) jmax (0.0, r - l), (float) jmax (0.0, b - t));
	}
}

void RelativeRectangle::moveToAbsolute (const Rectangle<float>& newPos, const Expression::Scope* scope)
{
	left.moveToAbsolute (newPos.getX(), scope);
	right.moveToAbsolute (newPos.getRight(), scope);
	top.moveToAbsolute (newPos.getY(), scope);
	bottom.moveToAbsolute (newPos.getBottom(), scope);
}

bool RelativeRectangle::isDynamic() const
{
	using namespace RelativeRectangleHelpers;

	return dependsOnSymbolsOtherThanThis (left.getExpression())
			|| dependsOnSymbolsOtherThanThis (right.getExpression())
			|| dependsOnSymbolsOtherThanThis (top.getExpression())
			|| dependsOnSymbolsOtherThanThis (bottom.getExpression());
}

String RelativeRectangle::toString() const
{
	return left.toString() + ", " + top.toString() + ", " + right.toString() + ", " + bottom.toString();
}

void RelativeRectangle::renameSymbol (const Expression::Symbol& oldSymbol, const String& newName, const Expression::Scope& scope)
{
	left = left.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	right = right.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	top = top.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	bottom = bottom.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
}

class RelativeRectangleComponentPositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativeRectangleComponentPositioner (Component& component_, const RelativeRectangle& rectangle_)
		: RelativeCoordinatePositionerBase (component_),
		  rectangle (rectangle_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = addCoordinate (rectangle.left);
		ok = addCoordinate (rectangle.right) && ok;
		ok = addCoordinate (rectangle.top) && ok;
		ok = addCoordinate (rectangle.bottom) && ok;
		return ok;
	}

	bool isUsingRectangle (const RelativeRectangle& other) const noexcept
	{
		return rectangle == other;
	}

	void applyToComponentBounds()
	{
		for (int i = 4; --i >= 0;)
		{
			ComponentScope scope (getComponent());
			const Rectangle<int> newBounds (rectangle.resolve (&scope).getSmallestIntegerContainer());

			if (newBounds == getComponent().getBounds())
				return;

			getComponent().setBounds (newBounds);
		}

		jassertfalse; // Seems to be a recursive reference!
	}

	void applyNewBounds (const Rectangle<int>& newBounds)
	{
		if (newBounds != getComponent().getBounds())
		{
			ComponentScope scope (getComponent());
			rectangle.moveToAbsolute (newBounds.toFloat(), &scope);

			applyToComponentBounds();
		}
	}

private:
	RelativeRectangle rectangle;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativeRectangleComponentPositioner);
};

void RelativeRectangle::applyToComponent (Component& component) const
{
	if (isDynamic())
	{
		RelativeRectangleComponentPositioner* current = dynamic_cast <RelativeRectangleComponentPositioner*> (component.getPositioner());

		if (current == nullptr || ! current->isUsingRectangle (*this))
		{
			RelativeRectangleComponentPositioner* p = new RelativeRectangleComponentPositioner (component, *this);

			component.setPositioner (p);
			p->apply();
		}
	}
	else
	{
		component.setPositioner (nullptr);
		component.setBounds (resolve (nullptr).getSmallestIntegerContainer());
	}
}

/*** End of inlined file: juce_RelativeRectangle.cpp ***/


/*** Start of inlined file: juce_BooleanPropertyComponent.cpp ***/
BooleanPropertyComponent::BooleanPropertyComponent (const String& name,
													const String& buttonTextWhenTrue,
													const String& buttonTextWhenFalse)
	: PropertyComponent (name),
	  onText (buttonTextWhenTrue),
	  offText (buttonTextWhenFalse)
{
	addAndMakeVisible (&button);
	button.setClickingTogglesState (false);
	button.addListener (this);
}

BooleanPropertyComponent::BooleanPropertyComponent (const Value& valueToControl,
													const String& name,
													const String& buttonText)
	: PropertyComponent (name),
	  onText (buttonText),
	  offText (buttonText)
{
	addAndMakeVisible (&button);
	button.setClickingTogglesState (false);
	button.setButtonText (buttonText);
	button.getToggleStateValue().referTo (valueToControl);
	button.setClickingTogglesState (true);
}

BooleanPropertyComponent::~BooleanPropertyComponent()
{
}

void BooleanPropertyComponent::setState (const bool newState)
{
	button.setToggleState (newState, true);
}

bool BooleanPropertyComponent::getState() const
{
	return button.getToggleState();
}

void BooleanPropertyComponent::paint (Graphics& g)
{
	PropertyComponent::paint (g);

	g.setColour (Colours::white);
	g.fillRect (button.getBounds());

	g.setColour (findColour (ComboBox::outlineColourId));
	g.drawRect (button.getBounds());
}

void BooleanPropertyComponent::refresh()
{
	button.setToggleState (getState(), false);
	button.setButtonText (button.getToggleState() ? onText : offText);
}

void BooleanPropertyComponent::buttonClicked (Button*)
{
	setState (! getState());
}

/*** End of inlined file: juce_BooleanPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ButtonPropertyComponent.cpp ***/
ButtonPropertyComponent::ButtonPropertyComponent (const String& name,
												  const bool triggerOnMouseDown)
	: PropertyComponent (name)
{
	addAndMakeVisible (&button);
	button.setTriggeredOnMouseDown (triggerOnMouseDown);
	button.addListener (this);
}

ButtonPropertyComponent::~ButtonPropertyComponent()
{
}

void ButtonPropertyComponent::refresh()
{
	button.setButtonText (getButtonText());
}

void ButtonPropertyComponent::buttonClicked (Button*)
{
	buttonClicked();
}

/*** End of inlined file: juce_ButtonPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ChoicePropertyComponent.cpp ***/
class ChoicePropertyComponent::RemapperValueSource    : public Value::ValueSource,
														public ValueListener
{
public:
	RemapperValueSource (const Value& sourceValue_, const Array<var>& mappings_)
	   : sourceValue (sourceValue_),
		 mappings (mappings_)
	{
		sourceValue.addListener (this);
	}

	~RemapperValueSource() {}

	var getValue() const
	{
		return mappings.indexOf (sourceValue.getValue()) + 1;
	}

	void setValue (const var& newValue)
	{
		const var remappedVal (mappings [(int) newValue - 1]);

		if (remappedVal != sourceValue)
			sourceValue = remappedVal;
	}

	void valueChanged (Value&)
	{
		sendChangeMessage (true);
	}

protected:

	Value sourceValue;
	Array<var> mappings;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RemapperValueSource);
};

ChoicePropertyComponent::ChoicePropertyComponent (const String& name)
	: PropertyComponent (name),
	  isCustomClass (true)
{
}

ChoicePropertyComponent::ChoicePropertyComponent (const Value& valueToControl,
												  const String& name,
												  const StringArray& choices_,
												  const Array <var>& correspondingValues)
	: PropertyComponent (name),
	  choices (choices_),
	  isCustomClass (false)
{
	// The array of corresponding values must contain one value for each of the items in
	// the choices array!
	jassert (correspondingValues.size() == choices.size());

	createComboBox();

	comboBox.getSelectedIdAsValue().referTo (Value (new RemapperValueSource (valueToControl, correspondingValues)));
}

ChoicePropertyComponent::~ChoicePropertyComponent()
{
}

void ChoicePropertyComponent::createComboBox()
{
	addAndMakeVisible (&comboBox);

	for (int i = 0; i < choices.size(); ++i)
	{
		if (choices[i].isNotEmpty())
			comboBox.addItem (choices[i], i + 1);
		else
			comboBox.addSeparator();
	}

	comboBox.setEditableText (false);
}

void ChoicePropertyComponent::setIndex (const int /*newIndex*/)
{
	jassertfalse; // you need to override this method in your subclass!
}

int ChoicePropertyComponent::getIndex() const
{
	jassertfalse; // you need to override this method in your subclass!
	return -1;
}

const StringArray& ChoicePropertyComponent::getChoices() const
{
	return choices;
}

void ChoicePropertyComponent::refresh()
{
	if (isCustomClass)
	{
		if (! comboBox.isVisible())
		{
			createComboBox();
			comboBox.addListener (this);
		}

		comboBox.setSelectedId (getIndex() + 1, true);
	}
}

void ChoicePropertyComponent::comboBoxChanged (ComboBox*)
{
	if (isCustomClass)
	{
		const int newIndex = comboBox.getSelectedId() - 1;

		if (newIndex != getIndex())
			setIndex (newIndex);
	}
}

/*** End of inlined file: juce_ChoicePropertyComponent.cpp ***/


/*** Start of inlined file: juce_PropertyComponent.cpp ***/
PropertyComponent::PropertyComponent (const String& name,
									  const int preferredHeight_)
	: Component (name),
	  preferredHeight (preferredHeight_)
{
	jassert (name.isNotEmpty());
}

PropertyComponent::~PropertyComponent()
{
}

void PropertyComponent::paint (Graphics& g)
{
	getLookAndFeel().drawPropertyComponentBackground (g, getWidth(), getHeight(), *this);
	getLookAndFeel().drawPropertyComponentLabel (g, getWidth(), getHeight(), *this);
}

void PropertyComponent::resized()
{
	if (getNumChildComponents() > 0)
		getChildComponent (0)->setBounds (getLookAndFeel().getPropertyComponentContentPosition (*this));
}

void PropertyComponent::enablementChanged()
{
	repaint();
}

/*** End of inlined file: juce_PropertyComponent.cpp ***/


/*** Start of inlined file: juce_PropertyPanel.cpp ***/
class PropertySectionComponent  : public Component
{
public:
	PropertySectionComponent (const String& sectionTitle,
							  const Array <PropertyComponent*>& newProperties,
							  const bool sectionIsOpen_)
		: Component (sectionTitle),
		  titleHeight (sectionTitle.isNotEmpty() ? 22 : 0),
		  sectionIsOpen (sectionIsOpen_)
	{
		propertyComps.addArray (newProperties);

		for (int i = propertyComps.size(); --i >= 0;)
		{
			addAndMakeVisible (propertyComps.getUnchecked(i));
			propertyComps.getUnchecked(i)->refresh();
		}
	}

	~PropertySectionComponent()
	{
		propertyComps.clear();
	}

	void paint (Graphics& g)
	{
		if (titleHeight > 0)
			getLookAndFeel().drawPropertyPanelSectionHeader (g, getName(), isOpen(), getWidth(), titleHeight);
	}

	void resized()
	{
		int y = titleHeight;

		for (int i = 0; i < propertyComps.size(); ++i)
		{
			PropertyComponent* const pec = propertyComps.getUnchecked (i);
			pec->setBounds (1, y, getWidth() - 2, pec->getPreferredHeight());
			y = pec->getBottom();
		}
	}

	int getPreferredHeight() const
	{
		int y = titleHeight;

		if (isOpen())
		{
			for (int i = propertyComps.size(); --i >= 0;)
				y += propertyComps.getUnchecked(i)->getPreferredHeight();
		}

		return y;
	}

	void setOpen (const bool open)
	{
		if (sectionIsOpen != open)
		{
			sectionIsOpen = open;

			for (int i = propertyComps.size(); --i >= 0;)
				propertyComps.getUnchecked(i)->setVisible (open);

			PropertyPanel* const pp = findParentComponentOfClass<PropertyPanel>();

			if (pp != nullptr)
				pp->resized();
		}
	}

	bool isOpen() const
	{
		return sectionIsOpen;
	}

	void refreshAll() const
	{
		for (int i = propertyComps.size(); --i >= 0;)
			propertyComps.getUnchecked (i)->refresh();
	}

	void mouseUp (const MouseEvent& e)
	{
		if (e.getMouseDownX() < titleHeight
			 && e.x < titleHeight
			 && e.y < titleHeight
			 && e.getNumberOfClicks() != 2)
		{
			setOpen (! isOpen());
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (e.y < titleHeight)
			setOpen (! isOpen());
	}

private:
	OwnedArray <PropertyComponent> propertyComps;
	int titleHeight;
	bool sectionIsOpen;

	JUCE_DECLARE_NON_COPYABLE (PropertySectionComponent);
};

class PropertyPanel::PropertyHolderComponent  : public Component
{
public:
	PropertyHolderComponent() {}

	void paint (Graphics&) {}

	void updateLayout (int width)
	{
		int y = 0;

		for (int i = 0; i < sections.size(); ++i)
		{
			PropertySectionComponent* const section = sections.getUnchecked(i);

			section->setBounds (0, y, width, section->getPreferredHeight());
			y = section->getBottom();
		}

		setSize (width, y);
		repaint();
	}

	void refreshAll() const
	{
		for (int i = 0; i < sections.size(); ++i)
			sections.getUnchecked(i)->refreshAll();
	}

	void clear()
	{
		sections.clear();
	}

	void addSection (PropertySectionComponent* newSection)
	{
		sections.add (newSection);
		addAndMakeVisible (newSection, 0);
	}

	int getNumSections() const noexcept                             { return sections.size(); }
	PropertySectionComponent* getSection (const int index) const    { return sections [index]; }

private:
	OwnedArray<PropertySectionComponent> sections;

	JUCE_DECLARE_NON_COPYABLE (PropertyHolderComponent);
};

PropertyPanel::PropertyPanel()
{
	messageWhenEmpty = TRANS("(nothing selected)");

	addAndMakeVisible (&viewport);
	viewport.setViewedComponent (propertyHolderComponent = new PropertyHolderComponent());
	viewport.setFocusContainer (true);
}

PropertyPanel::~PropertyPanel()
{
	clear();
}

void PropertyPanel::paint (Graphics& g)
{
	if (propertyHolderComponent->getNumSections() == 0)
	{
		g.setColour (Colours::black.withAlpha (0.5f));
		g.setFont (14.0f);
		g.drawText (messageWhenEmpty, 0, 0, getWidth(), 30,
					Justification::centred, true);
	}
}

void PropertyPanel::resized()
{
	viewport.setBounds (getLocalBounds());
	updatePropHolderLayout();
}

void PropertyPanel::clear()
{
	if (propertyHolderComponent->getNumSections() > 0)
	{
		propertyHolderComponent->clear();
		repaint();
	}
}

void PropertyPanel::addProperties (const Array <PropertyComponent*>& newProperties)
{
	if (propertyHolderComponent->getNumSections() == 0)
		repaint();

	propertyHolderComponent->addSection (new PropertySectionComponent (String::empty, newProperties, true));
	updatePropHolderLayout();
}

void PropertyPanel::addSection (const String& sectionTitle,
								const Array <PropertyComponent*>& newProperties,
								const bool shouldBeOpen)
{
	jassert (sectionTitle.isNotEmpty());

	if (propertyHolderComponent->getNumSections() == 0)
		repaint();

	propertyHolderComponent->addSection (new PropertySectionComponent (sectionTitle, newProperties, shouldBeOpen));
	updatePropHolderLayout();
}

void PropertyPanel::updatePropHolderLayout() const
{
	const int maxWidth = viewport.getMaximumVisibleWidth();
	propertyHolderComponent->updateLayout (maxWidth);

	const int newMaxWidth = viewport.getMaximumVisibleWidth();
	if (maxWidth != newMaxWidth)
	{
		// need to do this twice because of scrollbars changing the size, etc.
		propertyHolderComponent->updateLayout (newMaxWidth);
	}
}

void PropertyPanel::refreshAll() const
{
	propertyHolderComponent->refreshAll();
}

StringArray PropertyPanel::getSectionNames() const
{
	StringArray s;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
			s.add (section->getName());
	}

	return s;
}

bool PropertyPanel::isSectionOpen (const int sectionIndex) const
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
				return section->isOpen();

			++index;
		}
	}

	return false;
}

void PropertyPanel::setSectionOpen (const int sectionIndex, const bool shouldBeOpen)
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
			{
				section->setOpen (shouldBeOpen);
				break;
			}

			++index;
		}
	}
}

void PropertyPanel::setSectionEnabled (const int sectionIndex, const bool shouldBeEnabled)
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
			{
				section->setEnabled (shouldBeEnabled);
				break;
			}

			++index;
		}
	}
}

XmlElement* PropertyPanel::getOpennessState() const
{
	XmlElement* const xml = new XmlElement ("PROPERTYPANELSTATE");

	xml->setAttribute ("scrollPos", viewport.getViewPositionY());

	const StringArray sections (getSectionNames());

	for (int i = 0; i < sections.size(); ++i)
	{
		if (sections[i].isNotEmpty())
		{
			XmlElement* const e = xml->createNewChildElement ("SECTION");
			e->setAttribute ("name", sections[i]);
			e->setAttribute ("open", isSectionOpen (i) ? 1 : 0);
		}
	}

	return xml;
}

void PropertyPanel::restoreOpennessState (const XmlElement& xml)
{
	if (xml.hasTagName ("PROPERTYPANELSTATE"))
	{
		const StringArray sections (getSectionNames());

		forEachXmlChildElementWithTagName (xml, e, "SECTION")
		{
			setSectionOpen (sections.indexOf (e->getStringAttribute ("name")),
							e->getBoolAttribute ("open"));
		}

		viewport.setViewPosition (viewport.getViewPositionX(),
								  xml.getIntAttribute ("scrollPos", viewport.getViewPositionY()));
	}
}

void PropertyPanel::setMessageWhenEmpty (const String& newMessage)
{
	if (messageWhenEmpty != newMessage)
	{
		messageWhenEmpty = newMessage;
		repaint();
	}
}

const String& PropertyPanel::getMessageWhenEmpty() const
{
	return messageWhenEmpty;
}

/*** End of inlined file: juce_PropertyPanel.cpp ***/


/*** Start of inlined file: juce_SliderPropertyComponent.cpp ***/
SliderPropertyComponent::SliderPropertyComponent (const String& name,
												  const double rangeMin,
												  const double rangeMax,
												  const double interval,
												  const double skewFactor)
	: PropertyComponent (name)
{
	addAndMakeVisible (&slider);

	slider.setRange (rangeMin, rangeMax, interval);
	slider.setSkewFactor (skewFactor);
	slider.setSliderStyle (Slider::LinearBar);

	slider.addListener (this);
}

SliderPropertyComponent::SliderPropertyComponent (const Value& valueToControl,
												  const String& name,
												  const double rangeMin,
												  const double rangeMax,
												  const double interval,
												  const double skewFactor)
	: PropertyComponent (name)
{
	addAndMakeVisible (&slider);

	slider.setRange (rangeMin, rangeMax, interval);
	slider.setSkewFactor (skewFactor);
	slider.setSliderStyle (Slider::LinearBar);

	slider.getValueObject().referTo (valueToControl);
}

SliderPropertyComponent::~SliderPropertyComponent()
{
}

void SliderPropertyComponent::setValue (const double /*newValue*/)
{
}

double SliderPropertyComponent::getValue() const
{
	return slider.getValue();
}

void SliderPropertyComponent::refresh()
{
	slider.setValue (getValue(), false);
}

void SliderPropertyComponent::sliderValueChanged (Slider*)
{
	if (getValue() != slider.getValue())
		setValue (slider.getValue());
}

/*** End of inlined file: juce_SliderPropertyComponent.cpp ***/


/*** Start of inlined file: juce_TextPropertyComponent.cpp ***/
class TextPropLabel  : public Label
{
public:
	TextPropLabel (TextPropertyComponent& owner_,
				   const int maxChars_, const bool isMultiline_)
		: Label (String::empty, String::empty),
		  owner (owner_),
		  maxChars (maxChars_),
		  isMultiline (isMultiline_)
	{
		setEditable (true, true, false);

		setColour (backgroundColourId, Colours::white);
		setColour (outlineColourId, findColour (ComboBox::outlineColourId));
	}

	TextEditor* createEditorComponent()
	{
		TextEditor* const textEditor = Label::createEditorComponent();
		textEditor->setInputRestrictions (maxChars);

		if (isMultiline)
		{
			textEditor->setMultiLine (true, true);
			textEditor->setReturnKeyStartsNewLine (true);
		}

		return textEditor;
	}

	void textWasEdited()
	{
		owner.textWasEdited();
	}

private:
	TextPropertyComponent& owner;
	int maxChars;
	bool isMultiline;
};

TextPropertyComponent::TextPropertyComponent (const String& name,
											  const int maxNumChars,
											  const bool isMultiLine)
	: PropertyComponent (name)
{
	createEditor (maxNumChars, isMultiLine);
}

TextPropertyComponent::TextPropertyComponent (const Value& valueToControl,
											  const String& name,
											  const int maxNumChars,
											  const bool isMultiLine)
	: PropertyComponent (name)
{
	createEditor (maxNumChars, isMultiLine);

	textEditor->getTextValue().referTo (valueToControl);
}

TextPropertyComponent::~TextPropertyComponent()
{
}

void TextPropertyComponent::setText (const String& newText)
{
	textEditor->setText (newText, true);
}

String TextPropertyComponent::getText() const
{
	return textEditor->getText();
}

void TextPropertyComponent::createEditor (const int maxNumChars, const bool isMultiLine)
{
	addAndMakeVisible (textEditor = new TextPropLabel (*this, maxNumChars, isMultiLine));

	if (isMultiLine)
	{
		textEditor->setJustificationType (Justification::topLeft);
		preferredHeight = 120;
	}
}

void TextPropertyComponent::refresh()
{
	textEditor->setText (getText(), false);
}

void TextPropertyComponent::textWasEdited()
{
	const String newText (textEditor->getText());

	if (getText() != newText)
		setText (newText);
}

/*** End of inlined file: juce_TextPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ComboBox.cpp ***/
ComboBox::ItemInfo::ItemInfo (const String& name_, int itemId_, bool isEnabled_, bool isHeading_)
	: name (name_), itemId (itemId_), isEnabled (isEnabled_), isHeading (isHeading_)
{
}

bool ComboBox::ItemInfo::isSeparator() const noexcept
{
	return name.isEmpty();
}

bool ComboBox::ItemInfo::isRealItem() const noexcept
{
	return ! (isHeading || name.isEmpty());
}

ComboBox::ComboBox (const String& name)
	: Component (name),
	  lastCurrentId (0),
	  isButtonDown (false),
	  separatorPending (false),
	  menuActive (false),
	  noChoicesMessage (TRANS("(no choices)"))
{
	setRepaintsOnMouseActivity (true);
	ComboBox::lookAndFeelChanged();
	currentId.addListener (this);
}

ComboBox::~ComboBox()
{
	currentId.removeListener (this);

	if (menuActive)
		PopupMenu::dismissAllActiveMenus();

	label = nullptr;
}

void ComboBox::setEditableText (const bool isEditable)
{
	if (label->isEditableOnSingleClick() != isEditable || label->isEditableOnDoubleClick() != isEditable)
	{
		label->setEditable (isEditable, isEditable, false);
		setWantsKeyboardFocus (! isEditable);
		resized();
	}
}

bool ComboBox::isTextEditable() const noexcept
{
	return label->isEditable();
}

void ComboBox::setJustificationType (const Justification& justification)
{
	label->setJustificationType (justification);
}

Justification ComboBox::getJustificationType() const noexcept
{
	return label->getJustificationType();
}

void ComboBox::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	label->setTooltip (newTooltip);
}

void ComboBox::addItem (const String& newItemText, const int newItemId)
{
	// you can't add empty strings to the list..
	jassert (newItemText.isNotEmpty());

	// IDs must be non-zero, as zero is used to indicate a lack of selecion.
	jassert (newItemId != 0);

	// you shouldn't use duplicate item IDs!
	jassert (getItemForId (newItemId) == nullptr);

	if (newItemText.isNotEmpty() && newItemId != 0)
	{
		if (separatorPending)
		{
			separatorPending = false;
			items.add (new ItemInfo (String::empty, 0, false, false));
		}

		items.add (new ItemInfo (newItemText, newItemId, true, false));
	}
}

void ComboBox::addItemList (const StringArray& items, const int firstItemIdOffset)
{
	for (int i = 0; i < items.size(); ++i)
		addItem (items[i], i + firstItemIdOffset);
}

void ComboBox::addSeparator()
{
	separatorPending = (items.size() > 0);
}

void ComboBox::addSectionHeading (const String& headingName)
{
	// you can't add empty strings to the list..
	jassert (headingName.isNotEmpty());

	if (headingName.isNotEmpty())
	{
		if (separatorPending)
		{
			separatorPending = false;
			items.add (new ItemInfo (String::empty, 0, false, false));
		}

		items.add (new ItemInfo (headingName, 0, true, true));
	}
}

void ComboBox::setItemEnabled (const int itemId, const bool shouldBeEnabled)
{
	ItemInfo* const item = getItemForId (itemId);

	if (item != nullptr)
		item->isEnabled = shouldBeEnabled;
}

bool ComboBox::isItemEnabled (int itemId) const noexcept
{
	const ItemInfo* const item = getItemForId (itemId);
	return item != nullptr && item->isEnabled;
}

void ComboBox::changeItemText (const int itemId, const String& newText)
{
	ItemInfo* const item = getItemForId (itemId);

	jassert (item != nullptr);

	if (item != nullptr)
		item->name = newText;
}

void ComboBox::clear (const bool dontSendChangeMessage)
{
	items.clear();
	separatorPending = false;

	if (! label->isEditable())
		setSelectedItemIndex (-1, dontSendChangeMessage);
}

ComboBox::ItemInfo* ComboBox::getItemForId (const int itemId) const noexcept
{
	if (itemId != 0)
	{
		for (int i = items.size(); --i >= 0;)
			if (items.getUnchecked(i)->itemId == itemId)
				return items.getUnchecked(i);
	}

	return nullptr;
}

ComboBox::ItemInfo* ComboBox::getItemForIndex (const int index) const noexcept
{
	for (int n = 0, i = 0; i < items.size(); ++i)
	{
		ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem())
			if (n++ == index)
				return item;
	}

	return nullptr;
}

int ComboBox::getNumItems() const noexcept
{
	int n = 0;

	for (int i = items.size(); --i >= 0;)
		if (items.getUnchecked(i)->isRealItem())
			++n;

	return n;
}

String ComboBox::getItemText (const int index) const
{
	const ItemInfo* const item = getItemForIndex (index);

	return item != nullptr ? item->name : String::empty;
}

int ComboBox::getItemId (const int index) const noexcept
{
	const ItemInfo* const item = getItemForIndex (index);

	return item != nullptr ? item->itemId : 0;
}

int ComboBox::indexOfItemId (const int itemId) const noexcept
{
	for (int n = 0, i = 0; i < items.size(); ++i)
	{
		const ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem())
		{
			if (item->itemId == itemId)
				return n;

			++n;
		}
	}

	return -1;
}

int ComboBox::getSelectedItemIndex() const
{
	int index = indexOfItemId (currentId.getValue());

	if (getText() != getItemText (index))
		index = -1;

	return index;
}

void ComboBox::setSelectedItemIndex (const int index, const bool dontSendChangeMessage)
{
	setSelectedId (getItemId (index), dontSendChangeMessage);
}

int ComboBox::getSelectedId() const noexcept
{
	const ItemInfo* const item = getItemForId (currentId.getValue());

	return (item != nullptr && getText() == item->name) ? item->itemId : 0;
}

void ComboBox::setSelectedId (const int newItemId, const bool dontSendChangeMessage)
{
	const ItemInfo* const item = getItemForId (newItemId);
	const String newItemText (item != nullptr ? item->name : String::empty);

	if (lastCurrentId != newItemId || label->getText() != newItemText)
	{
		if (! dontSendChangeMessage)
			triggerAsyncUpdate();

		label->setText (newItemText, false);
		lastCurrentId = newItemId;
		currentId = newItemId;

		repaint();  // for the benefit of the 'none selected' text
	}
}

bool ComboBox::selectIfEnabled (const int index)
{
	const ItemInfo* const item = getItemForIndex (index);

	if (item != nullptr && item->isEnabled)
	{
		setSelectedItemIndex (index);
		return true;
	}

	return false;
}

void ComboBox::valueChanged (Value&)
{
	if (lastCurrentId != (int) currentId.getValue())
		setSelectedId (currentId.getValue(), false);
}

String ComboBox::getText() const
{
	return label->getText();
}

void ComboBox::setText (const String& newText, const bool dontSendChangeMessage)
{
	for (int i = items.size(); --i >= 0;)
	{
		const ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem()
			 && item->name == newText)
		{
			setSelectedId (item->itemId, dontSendChangeMessage);
			return;
		}
	}

	lastCurrentId = 0;
	currentId = 0;

	if (label->getText() != newText)
	{
		label->setText (newText, false);

		if (! dontSendChangeMessage)
			triggerAsyncUpdate();
	}

	repaint();
}

void ComboBox::showEditor()
{
	jassert (isTextEditable()); // you probably shouldn't do this to a non-editable combo box?

	label->showEditor();
}

void ComboBox::setTextWhenNothingSelected (const String& newMessage)
{
	if (textWhenNothingSelected != newMessage)
	{
		textWhenNothingSelected = newMessage;
		repaint();
	}
}

String ComboBox::getTextWhenNothingSelected() const
{
	return textWhenNothingSelected;
}

void ComboBox::setTextWhenNoChoicesAvailable (const String& newMessage)
{
	noChoicesMessage = newMessage;
}

String ComboBox::getTextWhenNoChoicesAvailable() const
{
	return noChoicesMessage;
}

void ComboBox::paint (Graphics& g)
{
	getLookAndFeel().drawComboBox (g, getWidth(), getHeight(), isButtonDown,
								   label->getRight(), 0, getWidth() - label->getRight(), getHeight(),
								   *this);

	if (textWhenNothingSelected.isNotEmpty()
		 && label->getText().isEmpty()
		 && ! label->isBeingEdited())
	{
		g.setColour (findColour (textColourId).withMultipliedAlpha (0.5f));
		g.setFont (label->getFont());
		g.drawFittedText (textWhenNothingSelected,
						  label->getX() + 2, label->getY() + 1,
						  label->getWidth() - 4, label->getHeight() - 2,
						  label->getJustificationType(),
						  jmax (1, (int) (label->getHeight() / label->getFont().getHeight())));
	}
}

void ComboBox::resized()
{
	if (getHeight() > 0 && getWidth() > 0)
		getLookAndFeel().positionComboBoxText (*this, *label);
}

void ComboBox::enablementChanged()
{
	repaint();
}

void ComboBox::lookAndFeelChanged()
{
	repaint();

	{
		ScopedPointer <Label> newLabel (getLookAndFeel().createComboBoxTextBox (*this));
		jassert (newLabel != nullptr);

		if (label != nullptr)
		{
			newLabel->setEditable (label->isEditable());
			newLabel->setJustificationType (label->getJustificationType());
			newLabel->setTooltip (label->getTooltip());
			newLabel->setText (label->getText(), false);
		}

		label = newLabel;
	}

	addAndMakeVisible (label);
	setWantsKeyboardFocus (! label->isEditable());

	label->addListener (this);
	label->addMouseListener (this, false);

	label->setColour (Label::backgroundColourId, Colours::transparentBlack);
	label->setColour (Label::textColourId, findColour (ComboBox::textColourId));

	label->setColour (TextEditor::textColourId, findColour (ComboBox::textColourId));
	label->setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
	label->setColour (TextEditor::highlightColourId, findColour (TextEditor::highlightColourId));
	label->setColour (TextEditor::outlineColourId, Colours::transparentBlack);

	resized();
}

void ComboBox::colourChanged()
{
	lookAndFeelChanged();
}

bool ComboBox::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::upKey) || key.isKeyCode (KeyPress::leftKey))
	{
		int index = getSelectedItemIndex() - 1;

		while (index >= 0 && ! selectIfEnabled (index))
			--index;

		return true;
	}
	else if (key.isKeyCode (KeyPress::downKey) || key.isKeyCode (KeyPress::rightKey))
	{
		int index = getSelectedItemIndex() + 1;

		while (index < getNumItems() && ! selectIfEnabled (index))
			++index;

		return true;
	}
	else if (key.isKeyCode (KeyPress::returnKey))
	{
		showPopup();
		return true;
	}

	return false;
}

bool ComboBox::keyStateChanged (const bool isKeyDown)
{
	// only forward key events that aren't used by this component
	return isKeyDown
			&& (KeyPress::isKeyCurrentlyDown (KeyPress::upKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::leftKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::downKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::rightKey));
}

void ComboBox::focusGained (FocusChangeType)    { repaint(); }
void ComboBox::focusLost (FocusChangeType)      { repaint(); }

void ComboBox::labelTextChanged (Label*)
{
	triggerAsyncUpdate();
}

void ComboBox::popupMenuFinishedCallback (int result, ComboBox* box)
{
	if (box != nullptr)
	{
		box->menuActive = false;

		if (result != 0)
			box->setSelectedId (result);
	}
}

void ComboBox::showPopup()
{
	if (! menuActive)
	{
		const int selectedId = getSelectedId();

		PopupMenu menu;
		menu.setLookAndFeel (&getLookAndFeel());

		for (int i = 0; i < items.size(); ++i)
		{
			const ItemInfo* const item = items.getUnchecked(i);

			if (item->isSeparator())
				menu.addSeparator();
			else if (item->isHeading)
				menu.addSectionHeader (item->name);
			else
				menu.addItem (item->itemId, item->name,
							  item->isEnabled, item->itemId == selectedId);
		}

		if (items.size() == 0)
			menu.addItem (1, noChoicesMessage, false);

		menuActive = true;

		menu.showMenuAsync (PopupMenu::Options().withTargetComponent (this)
												.withItemThatMustBeVisible (selectedId)
												.withMinimumWidth (getWidth())
												.withMaximumNumColumns (1)
												.withStandardItemHeight (jlimit (12, 24, getHeight())),
							ModalCallbackFunction::forComponent (popupMenuFinishedCallback, this));
	}
}

void ComboBox::mouseDown (const MouseEvent& e)
{
	beginDragAutoRepeat (300);

	isButtonDown = isEnabled() && ! e.mods.isPopupMenu();

	if (isButtonDown && (e.eventComponent == this || ! label->isEditable()))
		showPopup();
}

void ComboBox::mouseDrag (const MouseEvent& e)
{
	beginDragAutoRepeat (50);

	if (isButtonDown && ! e.mouseWasClicked())
		showPopup();
}

void ComboBox::mouseUp (const MouseEvent& e2)
{
	if (isButtonDown)
	{
		isButtonDown = false;
		repaint();

		const MouseEvent e (e2.getEventRelativeTo (this));

		if (reallyContains (e.getPosition(), true)
			 && (e2.eventComponent == this || ! label->isEditable()))
		{
			showPopup();
		}
	}
}

void ComboBox::addListener (ComboBoxListener* const listener)
{
	listeners.add (listener);
}

void ComboBox::removeListener (ComboBoxListener* const listener)
{
	listeners.remove (listener);
}

void ComboBox::handleAsyncUpdate()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &ComboBoxListener::comboBoxChanged, this);  // (can't use ComboBox::Listener due to idiotic VC2005 bug)
}

const Identifier ComboBox::Ids::tagType ("COMBOBOX");
const Identifier ComboBox::Ids::items ("items");
const Identifier ComboBox::Ids::editable ("editable");
const Identifier ComboBox::Ids::textJustification ("textJustification");
const Identifier ComboBox::Ids::unselectedText ("unselectedText");
const Identifier ComboBox::Ids::noItemsText ("noItemsText");

void ComboBox::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	{
		StringArray items;
		items.addLines (state [Ids::items].toString());
		items.removeEmptyStrings (true);

		StringArray existingItems;

		for (int i = 0; i < getNumItems(); ++i)
			existingItems.add (getItemText (i));

		if (existingItems != items)
		{
			clear();

			for (int i = 0; i < items.size(); ++i)
				addItem (items[i], i + 1);
		}
	}

	setEditableText (state [Ids::editable]);
	setJustificationType ((int) state [Ids::textJustification]);
	setTextWhenNothingSelected (state [Ids::unselectedText].toString());
	setTextWhenNoChoicesAvailable (state [Ids::noItemsText].toString());
}

/*** End of inlined file: juce_ComboBox.cpp ***/


/*** Start of inlined file: juce_ImageComponent.cpp ***/
ImageComponent::ImageComponent (const String& name)
	: Component (name),
	  placement (RectanglePlacement::centred)
{
}

ImageComponent::~ImageComponent()
{
}

void ImageComponent::setImage (const Image& newImage)
{
	if (image != newImage)
	{
		image = newImage;
		repaint();
	}
}

void ImageComponent::setImage (const Image& newImage, const RectanglePlacement& placementToUse)
{
	if (image != newImage || placement != placementToUse)
	{
		image = newImage;
		placement = placementToUse;
		repaint();
	}
}

void ImageComponent::setImagePlacement (const RectanglePlacement& newPlacement)
{
	if (placement != newPlacement)
	{
		placement = newPlacement;
		repaint();
	}
}

const Image& ImageComponent::getImage() const
{
	return image;
}

const RectanglePlacement ImageComponent::getImagePlacement() const
{
	return placement;
}

void ImageComponent::paint (Graphics& g)
{
	g.setOpacity (1.0f);
	g.drawImageWithin (image, 0, 0, getWidth(), getHeight(), placement, false);
}

const Identifier ImageComponent::Ids::tagType ("IMAGECOMPONENT");
const Identifier ImageComponent::Ids::image ("image");
const Identifier ImageComponent::Ids::placement ("placement");

void ImageComponent::refreshFromValueTree (const ValueTree& state, ComponentBuilder& builder)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	Image newImage;
	const var imageIdentifier (state [Ids::image]);

	ComponentBuilder::ImageProvider* const imageProvider = builder.getImageProvider();
	jassert (imageProvider != nullptr || imageIdentifier.isVoid());

	if (imageProvider != nullptr)
		newImage = imageProvider->getImageForIdentifier (imageIdentifier);

	setImage (newImage, getPlacement (state));
}

RectanglePlacement ImageComponent::getPlacement (const ValueTree& state)
{
	return RectanglePlacement (static_cast <int> (state [Ids::placement]));
}

/*** End of inlined file: juce_ImageComponent.cpp ***/


/*** Start of inlined file: juce_Label.cpp ***/
Label::Label (const String& name,
			  const String& labelText)
	: Component (name),
	  textValue (labelText),
	  lastTextValue (labelText),
	  font (15.0f),
	  justification (Justification::centredLeft),
	  horizontalBorderSize (5),
	  verticalBorderSize (1),
	  minimumHorizontalScale (0.7f),
	  editSingleClick (false),
	  editDoubleClick (false),
	  lossOfFocusDiscardsChanges (false)
{
	setColour (TextEditor::textColourId, Colours::black);
	setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
	setColour (TextEditor::outlineColourId, Colours::transparentBlack);

	textValue.addListener (this);
}

Label::~Label()
{
	textValue.removeListener (this);

	if (ownerComponent != nullptr)
		ownerComponent->removeComponentListener (this);

	editor = nullptr;
}

void Label::setText (const String& newText,
					 const bool broadcastChangeMessage)
{
	hideEditor (true);

	if (lastTextValue != newText)
	{
		lastTextValue = newText;
		textValue = newText;
		repaint();

		textWasChanged();

		if (ownerComponent != nullptr)
			componentMovedOrResized (*ownerComponent, true, true);

		if (broadcastChangeMessage)
			callChangeListeners();
	}
}

String Label::getText (const bool returnActiveEditorContents) const
{
	return (returnActiveEditorContents && isBeingEdited())
				? editor->getText()
				: textValue.toString();
}

void Label::valueChanged (Value&)
{
	if (lastTextValue != textValue.toString())
		setText (textValue.toString(), true);
}

void Label::setFont (const Font& newFont)
{
	if (font != newFont)
	{
		font = newFont;
		repaint();
	}
}

const Font& Label::getFont() const noexcept
{
	return font;
}

void Label::setEditable (const bool editOnSingleClick,
						 const bool editOnDoubleClick,
						 const bool lossOfFocusDiscardsChanges_)
{
	editSingleClick = editOnSingleClick;
	editDoubleClick = editOnDoubleClick;
	lossOfFocusDiscardsChanges = lossOfFocusDiscardsChanges_;

	setWantsKeyboardFocus (editOnSingleClick || editOnDoubleClick);
	setFocusContainer (editOnSingleClick || editOnDoubleClick);
}

void Label::setJustificationType (const Justification& newJustification)
{
	if (justification != newJustification)
	{
		justification = newJustification;
		repaint();
	}
}

void Label::setBorderSize (int h, int v)
{
	if (horizontalBorderSize != h || verticalBorderSize != v)
	{
		horizontalBorderSize = h;
		verticalBorderSize = v;
		repaint();
	}
}

Component* Label::getAttachedComponent() const
{
	return static_cast<Component*> (ownerComponent);
}

void Label::attachToComponent (Component* owner, const bool onLeft)
{
	if (ownerComponent != nullptr)
		ownerComponent->removeComponentListener (this);

	ownerComponent = owner;

	leftOfOwnerComp = onLeft;

	if (ownerComponent != nullptr)
	{
		setVisible (owner->isVisible());
		ownerComponent->addComponentListener (this);
		componentParentHierarchyChanged (*ownerComponent);
		componentMovedOrResized (*ownerComponent, true, true);
	}
}

void Label::componentMovedOrResized (Component& component, bool /*wasMoved*/, bool /*wasResized*/)
{
	if (leftOfOwnerComp)
	{
		setSize (jmin (getFont().getStringWidth (textValue.toString()) + 8, component.getX()),
				 component.getHeight());

		setTopRightPosition (component.getX(), component.getY());
	}
	else
	{
		setSize (component.getWidth(),
				 8 + roundToInt (getFont().getHeight()));

		setTopLeftPosition (component.getX(), component.getY() - getHeight());
	}
}

void Label::componentParentHierarchyChanged (Component& component)
{
	if (component.getParentComponent() != nullptr)
		component.getParentComponent()->addChildComponent (this);
}

void Label::componentVisibilityChanged (Component& component)
{
	setVisible (component.isVisible());
}

void Label::textWasEdited() {}
void Label::textWasChanged() {}
void Label::editorShown (TextEditor*) {}
void Label::editorAboutToBeHidden (TextEditor*) {}

void Label::showEditor()
{
	if (editor == nullptr)
	{
		addAndMakeVisible (editor = createEditorComponent());
		editor->setText (getText(), false);
		editor->addListener (this);
		editor->grabKeyboardFocus();
		editor->setHighlightedRegion (Range<int> (0, textValue.toString().length()));

		resized();
		repaint();

		editorShown (editor);

		enterModalState (false);
		editor->grabKeyboardFocus();
	}
}

bool Label::updateFromTextEditorContents (TextEditor& ed)
{
	const String newText (ed.getText());

	if (textValue.toString() != newText)
	{
		lastTextValue = newText;
		textValue = newText;
		repaint();

		textWasChanged();

		if (ownerComponent != nullptr)
			componentMovedOrResized (*ownerComponent, true, true);

		return true;
	}

	return false;
}

void Label::hideEditor (const bool discardCurrentEditorContents)
{
	if (editor != nullptr)
	{
		WeakReference<Component> deletionChecker (this);

		ScopedPointer<TextEditor> outgoingEditor (editor);

		editorAboutToBeHidden (outgoingEditor);

		const bool changed = (! discardCurrentEditorContents)
							   && updateFromTextEditorContents (*outgoingEditor);
		outgoingEditor = nullptr;
		repaint();

		if (changed)
			textWasEdited();

		if (deletionChecker != nullptr)
			exitModalState (0);

		if (changed && deletionChecker != nullptr)
			callChangeListeners();
	}
}

void Label::inputAttemptWhenModal()
{
	if (editor != nullptr)
	{
		if (lossOfFocusDiscardsChanges)
			textEditorEscapeKeyPressed (*editor);
		else
			textEditorReturnKeyPressed (*editor);
	}
}

bool Label::isBeingEdited() const noexcept
{
	return editor != nullptr;
}

TextEditor* Label::createEditorComponent()
{
	TextEditor* const ed = new TextEditor (getName());
	ed->setFont (font);

	// copy these colours from our own settings..
	const int cols[] = { TextEditor::backgroundColourId,
						 TextEditor::textColourId,
						 TextEditor::highlightColourId,
						 TextEditor::highlightedTextColourId,
						 TextEditor::outlineColourId,
						 TextEditor::focusedOutlineColourId,
						 TextEditor::shadowColourId,
						 CaretComponent::caretColourId };

	for (int i = 0; i < numElementsInArray (cols); ++i)
		ed->setColour (cols[i], findColour (cols[i]));

	return ed;
}

void Label::paint (Graphics& g)
{
	getLookAndFeel().drawLabel (g, *this);
}

void Label::mouseUp (const MouseEvent& e)
{
	if (editSingleClick
		 && e.mouseWasClicked()
		 && contains (e.getPosition())
		 && ! e.mods.isPopupMenu())
	{
		showEditor();
	}
}

void Label::mouseDoubleClick (const MouseEvent& e)
{
	if (editDoubleClick && ! e.mods.isPopupMenu())
		showEditor();
}

void Label::resized()
{
	if (editor != nullptr)
		editor->setBoundsInset (BorderSize<int> (0));
}

void Label::focusGained (FocusChangeType cause)
{
	if (editSingleClick && cause == focusChangedByTabKey)
		showEditor();
}

void Label::enablementChanged()
{
	repaint();
}

void Label::colourChanged()
{
	repaint();
}

void Label::setMinimumHorizontalScale (const float newScale)
{
	if (minimumHorizontalScale != newScale)
	{
		minimumHorizontalScale = newScale;
		repaint();
	}
}

// We'll use a custom focus traverser here to make sure focus goes from the
// text editor to another component rather than back to the label itself.
class LabelKeyboardFocusTraverser   : public KeyboardFocusTraverser
{
public:
	LabelKeyboardFocusTraverser() {}

	Component* getNextComponent (Component* current)
	{
		return KeyboardFocusTraverser::getNextComponent (dynamic_cast <TextEditor*> (current) != nullptr
															? current->getParentComponent() : current);
	}

	Component* getPreviousComponent (Component* current)
	{
		return KeyboardFocusTraverser::getPreviousComponent (dynamic_cast <TextEditor*> (current) != nullptr
																? current->getParentComponent() : current);
	}
};

KeyboardFocusTraverser* Label::createFocusTraverser()
{
	return new LabelKeyboardFocusTraverser();
}

void Label::addListener (LabelListener* const listener)
{
	listeners.add (listener);
}

void Label::removeListener (LabelListener* const listener)
{
	listeners.remove (listener);
}

void Label::callChangeListeners()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &LabelListener::labelTextChanged, this);  // (can't use Label::Listener due to idiotic VC2005 bug)
}

void Label::textEditorTextChanged (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);

		if (! (hasKeyboardFocus (true) || isCurrentlyBlockedByAnotherModalComponent()))
		{
			if (lossOfFocusDiscardsChanges)
				textEditorEscapeKeyPressed (ed);
			else
				textEditorReturnKeyPressed (ed);
		}
	}
}

void Label::textEditorReturnKeyPressed (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);

		const bool changed = updateFromTextEditorContents (ed);
		hideEditor (true);

		if (changed)
		{
			WeakReference<Component> deletionChecker (this);
			textWasEdited();

			if (deletionChecker != nullptr)
				callChangeListeners();
		}
	}
}

void Label::textEditorEscapeKeyPressed (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);
		(void) ed;

		editor->setText (textValue.toString(), false);
		hideEditor (true);
	}
}

void Label::textEditorFocusLost (TextEditor& ed)
{
	textEditorTextChanged (ed);
}

const Identifier Label::Ids::tagType ("LABEL");
const Identifier Label::Ids::text ("text");
const Identifier Label::Ids::font ("font");
const Identifier Label::Ids::editMode ("editMode");
const Identifier Label::Ids::justification ("justification");
const Identifier Label::Ids::focusLossDiscardsChanges ("focusLossDiscardsChanges");

void Label::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setText (state [Ids::text].toString(), false);
	setFont (Font::fromString (state [Ids::font]));
	const int editMode = static_cast <int> (state [Ids::editMode]);
	setEditable (editMode == 2, editMode == 3, static_cast <bool> (state [Ids::focusLossDiscardsChanges]));
	setJustificationType (static_cast <int> (state [Ids::justification]));
}

/*** End of inlined file: juce_Label.cpp ***/


/*** Start of inlined file: juce_ListBox.cpp ***/
class ListBoxRowComponent  : public Component,
							 public TooltipClient
{
public:
	ListBoxRowComponent (ListBox& owner_)
		: owner (owner_), row (-1),
		  selected (false), isDragging (false), selectRowOnMouseUp (false)
	{
	}

	void paint (Graphics& g)
	{
		if (owner.getModel() != nullptr)
			owner.getModel()->paintListBoxItem (row, g, getWidth(), getHeight(), selected);
	}

	void update (const int row_, const bool selected_)
	{
		if (row != row_ || selected != selected_)
		{
			repaint();
			row = row_;
			selected = selected_;
		}

		if (owner.getModel() != nullptr)
		{
			customComponent = owner.getModel()->refreshComponentForRow (row_, selected_, customComponent.release());

			if (customComponent != nullptr)
			{
				addAndMakeVisible (customComponent);
				customComponent->setBounds (getLocalBounds());
			}
		}
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		selectRowOnMouseUp = false;

		if (isEnabled())
		{
			if (! selected)
			{
				owner.selectRowsBasedOnModifierKeys (row, e.mods, false);

				if (owner.getModel() != nullptr)
					owner.getModel()->listBoxItemClicked (row, e);
			}
			else
			{
				selectRowOnMouseUp = true;
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		if (isEnabled() && selectRowOnMouseUp && ! isDragging)
		{
			owner.selectRowsBasedOnModifierKeys (row, e.mods, true);

			if (owner.getModel() != nullptr)
				owner.getModel()->listBoxItemClicked (row, e);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (owner.getModel() != nullptr && isEnabled())
			owner.getModel()->listBoxItemDoubleClicked (row, e);
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled() && owner.getModel() != nullptr && ! (e.mouseWasClicked() || isDragging))
		{
			const SparseSet<int> selectedRows (owner.getSelectedRows());

			if (selectedRows.size() > 0)
			{
				const var dragDescription (owner.getModel()->getDragSourceDescription (selectedRows));

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					isDragging = true;
					owner.startDragAndDrop (e, dragDescription, true);
				}
			}
		}
	}

	void resized()
	{
		if (customComponent != nullptr)
			customComponent->setBounds (getLocalBounds());
	}

	String getTooltip()
	{
		if (owner.getModel() != nullptr)
			return owner.getModel()->getTooltipForRow (row);

		return String::empty;
	}

	ScopedPointer<Component> customComponent;

private:
	ListBox& owner;
	int row;
	bool selected, isDragging, selectRowOnMouseUp;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ListBoxRowComponent);
};

class ListBox::ListViewport  : public Viewport
{
public:
	ListViewport (ListBox& owner_)
		: owner (owner_)
	{
		setWantsKeyboardFocus (false);

		Component* const content = new Component();
		setViewedComponent (content);
		content->addMouseListener (this, false);
		content->setWantsKeyboardFocus (false);
	}

	ListBoxRowComponent* getComponentForRow (const int row) const noexcept
	{
		return rows [row % jmax (1, rows.size())];
	}

	ListBoxRowComponent* getComponentForRowIfOnscreen (const int row) const noexcept
	{
		return (row >= firstIndex && row < firstIndex + rows.size())
				 ? getComponentForRow (row) : nullptr;
	}

	int getRowNumberOfComponent (Component* const rowComponent) const noexcept
	{
		const int index = getIndexOfChildComponent (rowComponent);
		const int num = rows.size();

		for (int i = num; --i >= 0;)
			if (((firstIndex + i) % jmax (1, num)) == index)
				return firstIndex + i;

		return -1;
	}

	void visibleAreaChanged (const Rectangle<int>&)
	{
		updateVisibleArea (true);

		if (owner.getModel() != nullptr)
			owner.getModel()->listWasScrolled();
	}

	void updateVisibleArea (const bool makeSureItUpdatesContent)
	{
		hasUpdated = false;

		const int newX = getViewedComponent()->getX();
		int newY = getViewedComponent()->getY();
		const int newW = jmax (owner.minimumRowWidth, getMaximumVisibleWidth());
		const int newH = owner.totalItems * owner.getRowHeight();

		if (newY + newH < getMaximumVisibleHeight() && newH > getMaximumVisibleHeight())
			newY = getMaximumVisibleHeight() - newH;

		getViewedComponent()->setBounds (newX, newY, newW, newH);

		if (makeSureItUpdatesContent && ! hasUpdated)
			updateContents();
	}

	void updateContents()
	{
		hasUpdated = true;
		const int rowHeight = owner.getRowHeight();

		if (rowHeight > 0)
		{
			const int y = getViewPositionY();
			const int w = getViewedComponent()->getWidth();

			const int numNeeded = 2 + getMaximumVisibleHeight() / rowHeight;
			rows.removeRange (numNeeded, rows.size());

			while (numNeeded > rows.size())
			{
				ListBoxRowComponent* newRow = new ListBoxRowComponent (owner);
				rows.add (newRow);
				getViewedComponent()->addAndMakeVisible (newRow);
			}

			firstIndex = y / rowHeight;
			firstWholeIndex = (y + rowHeight - 1) / rowHeight;
			lastWholeIndex = (y + getMaximumVisibleHeight() - 1) / rowHeight;

			for (int i = 0; i < numNeeded; ++i)
			{
				const int row = i + firstIndex;
				ListBoxRowComponent* const rowComp = getComponentForRow (row);

				if (rowComp != nullptr)
				{
					rowComp->setBounds (0, row * rowHeight, w, rowHeight);
					rowComp->update (row, owner.isRowSelected (row));
				}
			}
		}

		if (owner.headerComponent != nullptr)
			owner.headerComponent->setBounds (owner.outlineThickness + getViewedComponent()->getX(),
											  owner.outlineThickness,
											  jmax (owner.getWidth() - owner.outlineThickness * 2,
													getViewedComponent()->getWidth()),
											  owner.headerComponent->getHeight());
	}

	void selectRow (const int row, const int rowHeight, const bool dontScroll,
					const int lastRowSelected, const int totalItems, const bool isMouseClick)
	{
		hasUpdated = false;

		if (row < firstWholeIndex && ! dontScroll)
		{
			setViewPosition (getViewPositionX(), row * rowHeight);
		}
		else if (row >= lastWholeIndex && ! dontScroll)
		{
			const int rowsOnScreen = lastWholeIndex - firstWholeIndex;

			if (row >= lastRowSelected + rowsOnScreen
				 && rowsOnScreen < totalItems - 1
				 && ! isMouseClick)
			{
				setViewPosition (getViewPositionX(),
								 jlimit (0, jmax (0, totalItems - rowsOnScreen), row) * rowHeight);
			}
			else
			{
				setViewPosition (getViewPositionX(),
								 jmax (0, (row  + 1) * rowHeight - getMaximumVisibleHeight()));
			}
		}

		if (! hasUpdated)
			updateContents();
	}

	void scrollToEnsureRowIsOnscreen (const int row, const int rowHeight)
	{
		if (row < firstWholeIndex)
		{
			setViewPosition (getViewPositionX(), row * rowHeight);
		}
		else if (row >= lastWholeIndex)
		{
			setViewPosition (getViewPositionX(),
							 jmax (0, (row  + 1) * rowHeight - getMaximumVisibleHeight()));
		}
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (owner.findColour (ListBox::backgroundColourId));
	}

	bool keyPressed (const KeyPress& key)
	{
		if (key.isKeyCode (KeyPress::upKey)
			|| key.isKeyCode (KeyPress::downKey)
			|| key.isKeyCode (KeyPress::pageUpKey)
			|| key.isKeyCode (KeyPress::pageDownKey)
			|| key.isKeyCode (KeyPress::homeKey)
			|| key.isKeyCode (KeyPress::endKey))
		{
			// we want to avoid these keypresses going to the viewport, and instead allow
			// them to pass up to our listbox..
			return false;
		}

		return Viewport::keyPressed (key);
	}

private:
	ListBox& owner;
	OwnedArray<ListBoxRowComponent> rows;
	int firstIndex, firstWholeIndex, lastWholeIndex;
	bool hasUpdated;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ListViewport);
};

enum { defaultListRowHeight = 22 };

ListBox::ListBox (const String& name, ListBoxModel* const model_)
	: Component (name),
	  model (model_),
	  totalItems (0),
	  rowHeight (defaultListRowHeight),
	  minimumRowWidth (0),
	  outlineThickness (0),
	  lastRowSelected (-1),
	  mouseMoveSelects (false),
	  multipleSelection (false),
	  hasDoneInitialUpdate (false)
{
	addAndMakeVisible (viewport = new ListViewport (*this));

	ListBox::setWantsKeyboardFocus (true);
	ListBox::colourChanged();
}

ListBox::~ListBox()
{
	headerComponent = nullptr;
	viewport = nullptr;
}

void ListBox::setModel (ListBoxModel* const newModel)
{
	if (model != newModel)
	{
		model = newModel;
		repaint();
		updateContent();
	}
}

void ListBox::setMultipleSelectionEnabled (bool b)
{
	multipleSelection = b;
}

void ListBox::setMouseMoveSelectsRows (bool b)
{
	mouseMoveSelects = b;

	if (b)
		addMouseListener (this, true);
}

void ListBox::paint (Graphics& g)
{
	if (! hasDoneInitialUpdate)
		updateContent();

	g.fillAll (findColour (backgroundColourId));
}

void ListBox::paintOverChildren (Graphics& g)
{
	if (outlineThickness > 0)
	{
		g.setColour (findColour (outlineColourId));
		g.drawRect (0, 0, getWidth(), getHeight(), outlineThickness);
	}
}

void ListBox::resized()
{
	viewport->setBoundsInset (BorderSize<int> (outlineThickness + ((headerComponent != nullptr) ? headerComponent->getHeight() : 0),
											   outlineThickness, outlineThickness, outlineThickness));

	viewport->setSingleStepSizes (20, getRowHeight());

	viewport->updateVisibleArea (false);
}

void ListBox::visibilityChanged()
{
	viewport->updateVisibleArea (true);
}

Viewport* ListBox::getViewport() const noexcept
{
	return viewport;
}

void ListBox::updateContent()
{
	hasDoneInitialUpdate = true;
	totalItems = (model != nullptr) ? model->getNumRows() : 0;

	bool selectionChanged = false;

	if (selected.size() > 0 && selected [selected.size() - 1] >= totalItems)
	{
		selected.removeRange (Range <int> (totalItems, std::numeric_limits<int>::max()));
		lastRowSelected = getSelectedRow (0);
		selectionChanged = true;
	}

	viewport->updateVisibleArea (isVisible());
	viewport->resized();

	if (selectionChanged && model != nullptr)
		model->selectedRowsChanged (lastRowSelected);
}

void ListBox::selectRow (const int row,
						 bool dontScroll,
						 bool deselectOthersFirst)
{
	selectRowInternal (row, dontScroll, deselectOthersFirst, false);
}

void ListBox::selectRowInternal (const int row,
								 bool dontScroll,
								 bool deselectOthersFirst,
								 bool isMouseClick)
{
	if (! multipleSelection)
		deselectOthersFirst = true;

	if ((! isRowSelected (row))
		 || (deselectOthersFirst && getNumSelectedRows() > 1))
	{
		if (isPositiveAndBelow (row, totalItems))
		{
			if (deselectOthersFirst)
				selected.clear();

			selected.addRange (Range<int> (row, row + 1));

			if (getHeight() == 0 || getWidth() == 0)
				dontScroll = true;

			viewport->selectRow (row, getRowHeight(), dontScroll,
								 lastRowSelected, totalItems, isMouseClick);

			lastRowSelected = row;
			model->selectedRowsChanged (row);
		}
		else
		{
			if (deselectOthersFirst)
				deselectAllRows();
		}
	}
}

void ListBox::deselectRow (const int row)
{
	if (selected.contains (row))
	{
		selected.removeRange (Range <int> (row, row + 1));

		if (row == lastRowSelected)
			lastRowSelected = getSelectedRow (0);

		viewport->updateContents();
		model->selectedRowsChanged (lastRowSelected);
	}
}

void ListBox::setSelectedRows (const SparseSet<int>& setOfRowsToBeSelected,
							   const bool sendNotificationEventToModel)
{
	selected = setOfRowsToBeSelected;
	selected.removeRange (Range <int> (totalItems, std::numeric_limits<int>::max()));

	if (! isRowSelected (lastRowSelected))
		lastRowSelected = getSelectedRow (0);

	viewport->updateContents();

	if ((model != nullptr) && sendNotificationEventToModel)
		model->selectedRowsChanged (lastRowSelected);
}

SparseSet<int> ListBox::getSelectedRows() const
{
	return selected;
}

void ListBox::selectRangeOfRows (int firstRow, int lastRow)
{
	if (multipleSelection && (firstRow != lastRow))
	{
		const int numRows = totalItems - 1;
		firstRow = jlimit (0, jmax (0, numRows), firstRow);
		lastRow = jlimit (0, jmax (0, numRows), lastRow);

		selected.addRange (Range <int> (jmin (firstRow, lastRow),
										jmax (firstRow, lastRow) + 1));

		selected.removeRange (Range <int> (lastRow, lastRow + 1));
	}

	selectRowInternal (lastRow, false, false, true);
}

void ListBox::flipRowSelection (const int row)
{
	if (isRowSelected (row))
		deselectRow (row);
	else
		selectRowInternal (row, false, false, true);
}

void ListBox::deselectAllRows()
{
	if (! selected.isEmpty())
	{
		selected.clear();
		lastRowSelected = -1;

		viewport->updateContents();

		if (model != nullptr)
			model->selectedRowsChanged (lastRowSelected);
	}
}

void ListBox::selectRowsBasedOnModifierKeys (const int row,
											 const ModifierKeys& mods,
											 const bool isMouseUpEvent)
{
	if (multipleSelection && mods.isCommandDown())
	{
		flipRowSelection (row);
	}
	else if (multipleSelection && mods.isShiftDown() && lastRowSelected >= 0)
	{
		selectRangeOfRows (lastRowSelected, row);
	}
	else if ((! mods.isPopupMenu()) || ! isRowSelected (row))
	{
		selectRowInternal (row, false, ! (multipleSelection && (! isMouseUpEvent) && isRowSelected (row)), true);
	}
}

int ListBox::getNumSelectedRows() const
{
	return selected.size();
}

int ListBox::getSelectedRow (const int index) const
{
	return (isPositiveAndBelow (index, selected.size()))
				? selected [index] : -1;
}

bool ListBox::isRowSelected (const int row) const
{
	return selected.contains (row);
}

int ListBox::getLastRowSelected() const
{
	return (isRowSelected (lastRowSelected)) ? lastRowSelected : -1;
}

int ListBox::getRowContainingPosition (const int x, const int y) const noexcept
{
	if (isPositiveAndBelow (x, getWidth()))
	{
		const int row = (viewport->getViewPositionY() + y - viewport->getY()) / rowHeight;

		if (isPositiveAndBelow (row, totalItems))
			return row;
	}

	return -1;
}

int ListBox::getInsertionIndexForPosition (const int x, const int y) const noexcept
{
	if (isPositiveAndBelow (x, getWidth()))
	{
		const int row = (viewport->getViewPositionY() + y + rowHeight / 2 - viewport->getY()) / rowHeight;
		return jlimit (0, totalItems, row);
	}

	return -1;
}

Component* ListBox::getComponentForRowNumber (const int row) const noexcept
{
	ListBoxRowComponent* const listRowComp = viewport->getComponentForRowIfOnscreen (row);
	return listRowComp != nullptr ? static_cast <Component*> (listRowComp->customComponent) : nullptr;
}

int ListBox::getRowNumberOfComponent (Component* const rowComponent) const noexcept
{
	return viewport->getRowNumberOfComponent (rowComponent);
}

Rectangle<int> ListBox::getRowPosition (const int rowNumber,
										const bool relativeToComponentTopLeft) const noexcept
{
	int y = viewport->getY() + rowHeight * rowNumber;

	if (relativeToComponentTopLeft)
		y -= viewport->getViewPositionY();

	return Rectangle<int> (viewport->getX(), y,
						   viewport->getViewedComponent()->getWidth(), rowHeight);
}

void ListBox::setVerticalPosition (const double proportion)
{
	const int offscreen = viewport->getViewedComponent()->getHeight() - viewport->getHeight();

	viewport->setViewPosition (viewport->getViewPositionX(),
							   jmax (0, roundToInt (proportion * offscreen)));
}

double ListBox::getVerticalPosition() const
{
	const int offscreen = viewport->getViewedComponent()->getHeight() - viewport->getHeight();

	return (offscreen > 0) ? viewport->getViewPositionY() / (double) offscreen
						   : 0;
}

int ListBox::getVisibleRowWidth() const noexcept
{
	return viewport->getViewWidth();
}

void ListBox::scrollToEnsureRowIsOnscreen (const int row)
{
	viewport->scrollToEnsureRowIsOnscreen (row, getRowHeight());
}

bool ListBox::keyPressed (const KeyPress& key)
{
	const int numVisibleRows = viewport->getHeight() / getRowHeight();

	const bool multiple = multipleSelection
							&& (lastRowSelected >= 0)
							&& (key.getModifiers().isShiftDown()
								 || key.getModifiers().isCtrlDown()
								 || key.getModifiers().isCommandDown());

	if (key.isKeyCode (KeyPress::upKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected - 1);
		else
			selectRow (jmax (0, lastRowSelected - 1));
	}
	else if (key.isKeyCode (KeyPress::returnKey)
			  && isRowSelected (lastRowSelected))
	{
		if (model != nullptr)
			model->returnKeyPressed (lastRowSelected);
	}
	else if (key.isKeyCode (KeyPress::pageUpKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected - numVisibleRows);
		else
			selectRow (jmax (0, jmax (0, lastRowSelected) - numVisibleRows));
	}
	else if (key.isKeyCode (KeyPress::pageDownKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected + numVisibleRows);
		else
			selectRow (jmin (totalItems - 1, jmax (0, lastRowSelected) + numVisibleRows));
	}
	else if (key.isKeyCode (KeyPress::homeKey))
	{
		if (multiple && key.getModifiers().isShiftDown())
			selectRangeOfRows (lastRowSelected, 0);
		else
			selectRow (0);
	}
	else if (key.isKeyCode (KeyPress::endKey))
	{
		if (multiple && key.getModifiers().isShiftDown())
			selectRangeOfRows (lastRowSelected, totalItems - 1);
		else
			selectRow (totalItems - 1);
	}
	else if (key.isKeyCode (KeyPress::downKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected + 1);
		else
			selectRow (jmin (totalItems - 1, jmax (0, lastRowSelected) + 1));
	}
	else if ((key.isKeyCode (KeyPress::deleteKey) || key.isKeyCode (KeyPress::backspaceKey))
			   && isRowSelected (lastRowSelected))
	{
		if (model != nullptr)
			model->deleteKeyPressed (lastRowSelected);
	}
	else if (multiple && key == KeyPress ('a', ModifierKeys::commandModifier, 0))
	{
		selectRangeOfRows (0, std::numeric_limits<int>::max());
	}
	else
	{
		return false;
	}

	return true;
}

bool ListBox::keyStateChanged (const bool isKeyDown)
{
	return isKeyDown
			&& (KeyPress::isKeyCurrentlyDown (KeyPress::upKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::pageUpKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::downKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::pageDownKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::homeKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::endKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::returnKey));
}

void ListBox::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	bool eventWasUsed = false;

	if (viewport->getHorizontalScrollBar()->isVisible() && wheelIncrementX != 0)
	{
		eventWasUsed = true;
		viewport->getHorizontalScrollBar()->mouseWheelMove (e, wheelIncrementX, 0);
	}

	if (viewport->getVerticalScrollBar()->isVisible() && wheelIncrementY != 0)
	{
		eventWasUsed = true;
		viewport->getVerticalScrollBar()->mouseWheelMove (e, 0, wheelIncrementY);
	}

	if (! eventWasUsed)
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

void ListBox::mouseMove (const MouseEvent& e)
{
	if (mouseMoveSelects)
	{
		const MouseEvent e2 (e.getEventRelativeTo (this));
		selectRow (getRowContainingPosition (e2.x, e2.y), true);
	}
}

void ListBox::mouseExit (const MouseEvent& e)
{
	mouseMove (e);
}

void ListBox::mouseUp (const MouseEvent& e)
{
	if (e.mouseWasClicked() && model != nullptr)
		model->backgroundClicked();
}

void ListBox::setRowHeight (const int newHeight)
{
	rowHeight = jmax (1, newHeight);
	viewport->setSingleStepSizes (20, rowHeight);
	updateContent();
}

int ListBox::getNumRowsOnScreen() const noexcept
{
	return viewport->getMaximumVisibleHeight() / rowHeight;
}

void ListBox::setMinimumContentWidth (const int newMinimumWidth)
{
	minimumRowWidth = newMinimumWidth;
	updateContent();
}

int ListBox::getVisibleContentWidth() const noexcept
{
	return viewport->getMaximumVisibleWidth();
}

ScrollBar* ListBox::getVerticalScrollBar() const noexcept
{
	return viewport->getVerticalScrollBar();
}

ScrollBar* ListBox::getHorizontalScrollBar() const noexcept
{
	return viewport->getHorizontalScrollBar();
}

void ListBox::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	viewport->setOpaque (isOpaque());
	repaint();
}

void ListBox::setOutlineThickness (const int outlineThickness_)
{
	outlineThickness = outlineThickness_;
	resized();
}

void ListBox::setHeaderComponent (Component* const newHeaderComponent)
{
	if (headerComponent != newHeaderComponent)
	{
		headerComponent = newHeaderComponent;

		addAndMakeVisible (newHeaderComponent);
		ListBox::resized();
	}
}

void ListBox::repaintRow (const int rowNumber) noexcept
{
	repaint (getRowPosition (rowNumber, true));
}

Image ListBox::createSnapshotOfSelectedRows (int& imageX, int& imageY)
{
	Rectangle<int> imageArea;
	const int firstRow = getRowContainingPosition (0, 0);

	int i;
	for (i = getNumRowsOnScreen() + 2; --i >= 0;)
	{
		Component* rowComp = viewport->getComponentForRowIfOnscreen (firstRow + i);

		if (rowComp != nullptr && isRowSelected (firstRow + i))
		{
			const Point<int> pos (getLocalPoint (rowComp, Point<int>()));
			const Rectangle<int> rowRect (pos.getX(), pos.getY(), rowComp->getWidth(), rowComp->getHeight());
			imageArea = imageArea.getUnion (rowRect);
		}
	}

	imageArea = imageArea.getIntersection (getLocalBounds());
	imageX = imageArea.getX();
	imageY = imageArea.getY();
	Image snapshot (Image::ARGB, imageArea.getWidth(), imageArea.getHeight(), true);

	for (i = getNumRowsOnScreen() + 2; --i >= 0;)
	{
		Component* rowComp = viewport->getComponentForRowIfOnscreen (firstRow + i);

		if (rowComp != nullptr && isRowSelected (firstRow + i))
		{
			const Point<int> pos (getLocalPoint (rowComp, Point<int>()));

			Graphics g (snapshot);
			g.setOrigin (pos.getX() - imageX, pos.getY() - imageY);

			if (g.reduceClipRegion (rowComp->getLocalBounds()))
			{
				g.beginTransparencyLayer (0.6f);
				rowComp->paintEntireComponent (g, false);
				g.endTransparencyLayer();
			}
		}
	}

	return snapshot;
}

void ListBox::startDragAndDrop (const MouseEvent& e, const var& dragDescription, bool allowDraggingToOtherWindows)
{
	DragAndDropContainer* const dragContainer
		= DragAndDropContainer::findParentDragContainerFor (this);

	if (dragContainer != nullptr)
	{
		int x, y;
		Image dragImage (createSnapshotOfSelectedRows (x, y));

		MouseEvent e2 (e.getEventRelativeTo (this));
		const Point<int> p (x - e2.x, y - e2.y);
		dragContainer->startDragging (dragDescription, this, dragImage, allowDraggingToOtherWindows, &p);
	}
	else
	{
		// to be able to do a drag-and-drop operation, the listbox needs to
		// be inside a component which is also a DragAndDropContainer.
		jassertfalse;
	}
}

const Identifier ListBox::Ids::rowHeight ("rowHeight");
const Identifier ListBox::Ids::borderThickness ("borderThickness");

void ListBox::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setRowHeight (state.getProperty (Ids::rowHeight, defaultListRowHeight));
	setOutlineThickness (state.getProperty (Ids::borderThickness, 0));
}

Component* ListBoxModel::refreshComponentForRow (int, bool, Component* existingComponentToUpdate)
{
	(void) existingComponentToUpdate;
	jassert (existingComponentToUpdate == nullptr); // indicates a failure in the code the recycles the components
	return nullptr;
}

void ListBoxModel::listBoxItemClicked (int, const MouseEvent&) {}
void ListBoxModel::listBoxItemDoubleClicked (int, const MouseEvent&) {}
void ListBoxModel::backgroundClicked() {}
void ListBoxModel::selectedRowsChanged (int) {}
void ListBoxModel::deleteKeyPressed (int) {}
void ListBoxModel::returnKeyPressed (int) {}
void ListBoxModel::listWasScrolled() {}
var ListBoxModel::getDragSourceDescription (const SparseSet<int>&)      { return var::null; }
String ListBoxModel::getTooltipForRow (int)                             { return String::empty; }

/*** End of inlined file: juce_ListBox.cpp ***/


/*** Start of inlined file: juce_ProgressBar.cpp ***/
ProgressBar::ProgressBar (double& progress_)
   : progress (progress_),
	 displayPercentage (true),
	 lastCallbackTime (0)
{
	currentValue = jlimit (0.0, 1.0, progress);
}

ProgressBar::~ProgressBar()
{
}

void ProgressBar::setPercentageDisplay (const bool shouldDisplayPercentage)
{
	displayPercentage = shouldDisplayPercentage;
	repaint();
}

void ProgressBar::setTextToDisplay (const String& text)
{
	displayPercentage = false;
	displayedMessage = text;
}

void ProgressBar::lookAndFeelChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
}

void ProgressBar::colourChanged()
{
	lookAndFeelChanged();
}

void ProgressBar::paint (Graphics& g)
{
	String text;

	if (displayPercentage)
	{
		if (currentValue >= 0 && currentValue <= 1.0)
			text << roundToInt (currentValue * 100.0) << '%';
	}
	else
	{
		text = displayedMessage;
	}

	getLookAndFeel().drawProgressBar (g, *this,
									  getWidth(), getHeight(),
									  currentValue, text);
}

void ProgressBar::visibilityChanged()
{
	if (isVisible())
		startTimer (30);
	else
		stopTimer();
}

void ProgressBar::timerCallback()
{
	double newProgress = progress;

	const uint32 now = Time::getMillisecondCounter();
	const int timeSinceLastCallback = (int) (now - lastCallbackTime);
	lastCallbackTime = now;

	if (currentValue != newProgress
		 || newProgress < 0 || newProgress >= 1.0
		 || currentMessage != displayedMessage)
	{
		if (currentValue < newProgress
			 && newProgress >= 0 && newProgress < 1.0
			 && currentValue >= 0 && currentValue < 1.0)
		{
			newProgress = jmin (currentValue + 0.0008 * timeSinceLastCallback,
								newProgress);
		}

		currentValue = newProgress;
		currentMessage = displayedMessage;
		repaint();
	}
}

/*** End of inlined file: juce_ProgressBar.cpp ***/


/*** Start of inlined file: juce_Slider.cpp ***/
class Slider::PopupDisplayComponent  : public BubbleComponent,
									   public Timer
{
public:
	PopupDisplayComponent (Slider& owner_)
		: owner (owner_),
		  font (15.0f, Font::bold)
	{
		setAlwaysOnTop (true);
	}

	void paintContent (Graphics& g, int w, int h)
	{
		g.setFont (font);
		g.setColour (findColour (TooltipWindow::textColourId, true));
		g.drawFittedText (text, 0, 0, w, h, Justification::centred, 1);
	}

	void getContentSize (int& w, int& h)
	{
		w = font.getStringWidth (text) + 18;
		h = (int) (font.getHeight() * 1.6f);
	}

	void updatePosition (const String& newText)
	{
		text = newText;
		BubbleComponent::setPosition (&owner);
		repaint();
	}

	void timerCallback()
	{
		owner.popupDisplay = nullptr;
	}

private:
	Slider& owner;
	Font font;
	String text;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PopupDisplayComponent);
};

Slider::Slider (const String& name)
  : Component (name),
	lastCurrentValue (0),
	lastValueMin (0),
	lastValueMax (0),
	minimum (0),
	maximum (10),
	interval (0),
	skewFactor (1.0),
	velocityModeSensitivity (1.0),
	velocityModeOffset (0.0),
	velocityModeThreshold (1),
	rotaryStart (float_Pi * 1.2f),
	rotaryEnd (float_Pi * 2.8f),
	numDecimalPlaces (7),
	sliderRegionStart (0),
	sliderRegionSize (1),
	sliderBeingDragged (-1),
	pixelsForFullDragExtent (250),
	style (LinearHorizontal),
	textBoxPos (TextBoxLeft),
	textBoxWidth (80),
	textBoxHeight (20),
	incDecButtonMode (incDecButtonsNotDraggable),
	editableText (true),
	doubleClickToValue (false),
	isVelocityBased (false),
	userKeyOverridesVelocity (true),
	rotaryStop (true),
	incDecButtonsSideBySide (false),
	sendChangeOnlyOnRelease (false),
	popupDisplayEnabled (false),
	menuEnabled (false),
	menuShown (false),
	scrollWheelEnabled (true),
	snapsToMousePos (true),
	parentForPopupDisplay (nullptr)
{
	setWantsKeyboardFocus (false);
	setRepaintsOnMouseActivity (true);

	Slider::lookAndFeelChanged();
	updateText();

	currentValue.addListener (this);
	valueMin.addListener (this);
	valueMax.addListener (this);
}

Slider::~Slider()
{
	currentValue.removeListener (this);
	valueMin.removeListener (this);
	valueMax.removeListener (this);
	popupDisplay = nullptr;
}

void Slider::handleAsyncUpdate()
{
	cancelPendingUpdate();

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderValueChanged, this);  // (can't use Slider::Listener due to idiotic VC2005 bug)
}

void Slider::sendDragStart()
{
	startedDragging();

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderDragStarted, this);
}

void Slider::sendDragEnd()
{
	stoppedDragging();

	sliderBeingDragged = -1;

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderDragEnded, this);
}

void Slider::addListener (SliderListener* const listener)
{
	listeners.add (listener);
}

void Slider::removeListener (SliderListener* const listener)
{
	listeners.remove (listener);
}

void Slider::setSliderStyle (const SliderStyle newStyle)
{
	if (style != newStyle)
	{
		style = newStyle;
		repaint();
		lookAndFeelChanged();
	}
}

void Slider::setRotaryParameters (const float startAngleRadians,
								  const float endAngleRadians,
								  const bool stopAtEnd)
{
	// make sure the values are sensible..
	jassert (rotaryStart >= 0 && rotaryEnd >= 0);
	jassert (rotaryStart < float_Pi * 4.0f && rotaryEnd < float_Pi * 4.0f);
	jassert (rotaryStart < rotaryEnd);

	rotaryStart = startAngleRadians;
	rotaryEnd = endAngleRadians;
	rotaryStop = stopAtEnd;
}

void Slider::setVelocityBasedMode (const bool velBased)
{
	isVelocityBased = velBased;
}

void Slider::setVelocityModeParameters (const double sensitivity,
										const int threshold,
										const double offset,
										const bool userCanPressKeyToSwapMode)
{
	jassert (threshold >= 0);
	jassert (sensitivity > 0);
	jassert (offset >= 0);

	velocityModeSensitivity = sensitivity;
	velocityModeOffset = offset;
	velocityModeThreshold = threshold;
	userKeyOverridesVelocity = userCanPressKeyToSwapMode;
}

void Slider::setSkewFactor (const double factor)
{
	skewFactor = factor;
}

void Slider::setSkewFactorFromMidPoint (const double sliderValueToShowAtMidPoint)
{
	if (maximum > minimum)
		skewFactor = log (0.5) / log ((sliderValueToShowAtMidPoint - minimum)
										/ (maximum - minimum));
}

void Slider::setMouseDragSensitivity (const int distanceForFullScaleDrag)
{
	jassert (distanceForFullScaleDrag > 0);

	pixelsForFullDragExtent = distanceForFullScaleDrag;
}

void Slider::setIncDecButtonsMode (const IncDecButtonMode mode)
{
	if (incDecButtonMode != mode)
	{
		incDecButtonMode = mode;
		lookAndFeelChanged();
	}
}

void Slider::setTextBoxStyle (const TextEntryBoxPosition newPosition,
							  const bool isReadOnly,
							  const int textEntryBoxWidth,
							  const int textEntryBoxHeight)
{
	if (textBoxPos != newPosition
		 || editableText != (! isReadOnly)
		 || textBoxWidth != textEntryBoxWidth
		 || textBoxHeight != textEntryBoxHeight)
	{
		textBoxPos = newPosition;
		editableText = ! isReadOnly;
		textBoxWidth = textEntryBoxWidth;
		textBoxHeight = textEntryBoxHeight;

		repaint();
		lookAndFeelChanged();
	}
}

void Slider::setTextBoxIsEditable (const bool shouldBeEditable)
{
	editableText = shouldBeEditable;

	if (valueBox != nullptr)
		valueBox->setEditable (shouldBeEditable && isEnabled());
}

void Slider::showTextBox()
{
	jassert (editableText); // this should probably be avoided in read-only sliders.

	if (valueBox != nullptr)
		valueBox->showEditor();
}

void Slider::hideTextBox (const bool discardCurrentEditorContents)
{
	if (valueBox != nullptr)
	{
		valueBox->hideEditor (discardCurrentEditorContents);

		if (discardCurrentEditorContents)
			updateText();
	}
}

void Slider::setChangeNotificationOnlyOnRelease (const bool onlyNotifyOnRelease)
{
	sendChangeOnlyOnRelease = onlyNotifyOnRelease;
}

void Slider::setSliderSnapsToMousePosition (const bool shouldSnapToMouse)
{
	snapsToMousePos = shouldSnapToMouse;
}

void Slider::setPopupDisplayEnabled (const bool enabled, Component* const parentComponentToUse)
{
	popupDisplayEnabled = enabled;
	parentForPopupDisplay = parentComponentToUse;
}

Component* Slider::getCurrentPopupDisplay() const noexcept
{
	return popupDisplay.get();
}

void Slider::colourChanged()
{
	lookAndFeelChanged();
}

void Slider::lookAndFeelChanged()
{
	LookAndFeel& lf = getLookAndFeel();

	if (textBoxPos != NoTextBox)
	{
		const String previousTextBoxContent (valueBox != nullptr ? valueBox->getText()
																 : getTextFromValue (currentValue.getValue()));

		valueBox = nullptr;
		addAndMakeVisible (valueBox = getLookAndFeel().createSliderTextBox (*this));

		valueBox->setWantsKeyboardFocus (false);
		valueBox->setText (previousTextBoxContent, false);

		if (valueBox->isEditable() != editableText) // (avoid overriding the single/double click flags unless we have to)
			valueBox->setEditable (editableText && isEnabled());

		valueBox->addListener (this);

		if (style == LinearBar)
			valueBox->addMouseListener (this, false);
		else
			valueBox->setTooltip (getTooltip());
	}
	else
	{
		valueBox = nullptr;
	}

	if (style == IncDecButtons)
	{
		addAndMakeVisible (incButton = lf.createSliderButton (true));
		incButton->addListener (this);

		addAndMakeVisible (decButton = lf.createSliderButton (false));
		decButton->addListener (this);

		if (incDecButtonMode != incDecButtonsNotDraggable)
		{
			incButton->addMouseListener (this, false);
			decButton->addMouseListener (this, false);
		}
		else
		{
			incButton->setRepeatSpeed (300, 100, 20);
			incButton->addMouseListener (decButton, false);

			decButton->setRepeatSpeed (300, 100, 20);
			decButton->addMouseListener (incButton, false);
		}

		incButton->setTooltip (getTooltip());
		decButton->setTooltip (getTooltip());
	}
	else
	{
		incButton = nullptr;
		decButton = nullptr;
	}

	setComponentEffect (lf.getSliderEffect());

	resized();
	repaint();
}

void Slider::setRange (const double newMin,
					   const double newMax,
					   const double newInt)
{
	if (minimum != newMin
		|| maximum != newMax
		|| interval != newInt)
	{
		minimum = newMin;
		maximum = newMax;
		interval = newInt;

		// figure out the number of DPs needed to display all values at this
		// interval setting.
		numDecimalPlaces = 7;

		if (newInt != 0)
		{
			int v = abs ((int) (newInt * 10000000));

			while ((v % 10) == 0)
			{
				--numDecimalPlaces;
				v /= 10;
			}
		}

		// keep the current values inside the new range..
		if (style != TwoValueHorizontal && style != TwoValueVertical)
		{
			setValue (getValue(), false, false);
		}
		else
		{
			setMinValue (getMinValue(), false, false);
			setMaxValue (getMaxValue(), false, false);
		}

		updateText();
	}
}

void Slider::triggerChangeMessage (const bool synchronous)
{
	if (synchronous)
		handleAsyncUpdate();
	else
		triggerAsyncUpdate();

	valueChanged();
}

void Slider::valueChanged (Value& value)
{
	if (value.refersToSameSourceAs (currentValue))
	{
		if (style != TwoValueHorizontal && style != TwoValueVertical)
			setValue (currentValue.getValue(), false, false);
	}
	else if (value.refersToSameSourceAs (valueMin))
		setMinValue (valueMin.getValue(), false, false, true);
	else if (value.refersToSameSourceAs (valueMax))
		setMaxValue (valueMax.getValue(), false, false, true);
}

double Slider::getValue() const
{
	// for a two-value style slider, you should use the getMinValue() and getMaxValue()
	// methods to get the two values.
	jassert (style != TwoValueHorizontal && style != TwoValueVertical);

	return currentValue.getValue();
}

void Slider::setValue (double newValue,
					   const bool sendUpdateMessage,
					   const bool sendMessageSynchronously)
{
	// for a two-value style slider, you should use the setMinValue() and setMaxValue()
	// methods to set the two values.
	jassert (style != TwoValueHorizontal && style != TwoValueVertical);

	newValue = constrainedValue (newValue);

	if (style == ThreeValueHorizontal || style == ThreeValueVertical)
	{
		jassert ((double) valueMin.getValue() <= (double) valueMax.getValue());

		newValue = jlimit ((double) valueMin.getValue(),
						   (double) valueMax.getValue(),
						   newValue);
	}

	if (newValue != lastCurrentValue)
	{
		if (valueBox != nullptr)
			valueBox->hideEditor (true);

		lastCurrentValue = newValue;

		// (need to do this comparison because the Value will use equalsWithSameType to compare
		// the new and old values, so will generate unwanted change events if the type changes)
		if (currentValue != newValue)
			currentValue = newValue;

		updateText();
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (newValue));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

double Slider::getMinValue() const
{
	// The minimum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	return valueMin.getValue();
}

double Slider::getMaxValue() const
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	return valueMax.getValue();
}

void Slider::setMinValue (double newValue, const bool sendUpdateMessage, const bool sendMessageSynchronously, const bool allowNudgingOfOtherValues)
{
	// The minimum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	newValue = constrainedValue (newValue);

	if (style == TwoValueHorizontal || style == TwoValueVertical)
	{
		if (allowNudgingOfOtherValues && newValue > (double) valueMax.getValue())
			setMaxValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmin ((double) valueMax.getValue(), newValue);
	}
	else
	{
		if (allowNudgingOfOtherValues && newValue > lastCurrentValue)
			setValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmin (lastCurrentValue, newValue);
	}

	if (lastValueMin != newValue)
	{
		lastValueMin = newValue;
		valueMin = newValue;
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (newValue));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setMaxValue (double newValue, const bool sendUpdateMessage, const bool sendMessageSynchronously, const bool allowNudgingOfOtherValues)
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	newValue = constrainedValue (newValue);

	if (style == TwoValueHorizontal || style == TwoValueVertical)
	{
		if (allowNudgingOfOtherValues && newValue < (double) valueMin.getValue())
			setMinValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmax ((double) valueMin.getValue(), newValue);
	}
	else
	{
		if (allowNudgingOfOtherValues && newValue < lastCurrentValue)
			setValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmax (lastCurrentValue, newValue);
	}

	if (lastValueMax != newValue)
	{
		lastValueMax = newValue;
		valueMax = newValue;
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (valueMax.getValue()));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setMinAndMaxValues (double newMinValue, double newMaxValue, bool sendUpdateMessage, bool sendMessageSynchronously)
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	if (newMaxValue < newMinValue)
		std::swap (newMaxValue, newMinValue);

	newMinValue = constrainedValue (newMinValue);
	newMaxValue = constrainedValue (newMaxValue);

	if (lastValueMax != newMaxValue || lastValueMin != newMinValue)
	{
		lastValueMax = newMaxValue;
		lastValueMin = newMinValue;
		valueMin = newMinValue;
		valueMax = newMaxValue;
		repaint();

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setDoubleClickReturnValue (const bool isDoubleClickEnabled,
										const double valueToSetOnDoubleClick)
{
	doubleClickToValue = isDoubleClickEnabled;
	doubleClickReturnValue = valueToSetOnDoubleClick;
}

double Slider::getDoubleClickReturnValue (bool& isEnabled_) const
{
	isEnabled_ = doubleClickToValue;
	return doubleClickReturnValue;
}

void Slider::updateText()
{
	if (valueBox != nullptr)
		valueBox->setText (getTextFromValue (currentValue.getValue()), false);
}

void Slider::setTextValueSuffix (const String& suffix)
{
	if (textSuffix != suffix)
	{
		textSuffix = suffix;
		updateText();
	}
}

String Slider::getTextValueSuffix() const
{
	return textSuffix;
}

String Slider::getTextFromValue (double v)
{
	if (getNumDecimalPlacesToDisplay() > 0)
		return String (v, getNumDecimalPlacesToDisplay()) + getTextValueSuffix();
	else
		return String (roundToInt (v)) + getTextValueSuffix();
}

double Slider::getValueFromText (const String& text)
{
	String t (text.trimStart());

	if (t.endsWith (textSuffix))
		t = t.substring (0, t.length() - textSuffix.length());

	while (t.startsWithChar ('+'))
		t = t.substring (1).trimStart();

	return t.initialSectionContainingOnly ("0123456789.,-")
			.getDoubleValue();
}

double Slider::proportionOfLengthToValue (double proportion)
{
	if (skewFactor != 1.0 && proportion > 0.0)
		proportion = exp (log (proportion) / skewFactor);

	return minimum + (maximum - minimum) * proportion;
}

double Slider::valueToProportionOfLength (double value)
{
	const double n = (value - minimum) / (maximum - minimum);

	return skewFactor == 1.0 ? n : pow (n, skewFactor);
}

double Slider::snapValue (double attemptedValue, const bool)
{
	return attemptedValue;
}

void Slider::startedDragging()
{
}

void Slider::stoppedDragging()
{
}

void Slider::valueChanged()
{
}

void Slider::enablementChanged()
{
	repaint();
}

void Slider::setPopupMenuEnabled (const bool menuEnabled_)
{
	menuEnabled = menuEnabled_;
}

void Slider::setScrollWheelEnabled (const bool enabled)
{
	scrollWheelEnabled = enabled;
}

void Slider::labelTextChanged (Label* label)
{
	const double newValue = snapValue (getValueFromText (label->getText()), false);

	if (newValue != (double) currentValue.getValue())
	{
		sendDragStart();
		setValue (newValue, true, true);
		sendDragEnd();
	}

	updateText(); // force a clean-up of the text, needed in case setValue() hasn't done this.
}

void Slider::buttonClicked (Button* button)
{
	if (style == IncDecButtons)
	{
		sendDragStart();

		if (button == incButton)
			setValue (snapValue (getValue() + interval, false), true, true);
		else if (button == decButton)
			setValue (snapValue (getValue() - interval, false), true, true);

		sendDragEnd();
	}
}

double Slider::constrainedValue (double value) const
{
	if (interval > 0)
		value = minimum + interval * std::floor ((value - minimum) / interval + 0.5);

	if (value <= minimum || maximum <= minimum)
		value = minimum;
	else if (value >= maximum)
		value = maximum;

	return value;
}

float Slider::getLinearSliderPos (const double value)
{
	double sliderPosProportional;

	if (maximum > minimum)
	{
		if (value < minimum)
		{
			sliderPosProportional = 0.0;
		}
		else if (value > maximum)
		{
			sliderPosProportional = 1.0;
		}
		else
		{
			sliderPosProportional = valueToProportionOfLength (value);
			jassert (sliderPosProportional >= 0 && sliderPosProportional <= 1.0);
		}
	}
	else
	{
		sliderPosProportional = 0.5;
	}

	if (isVertical() || style == IncDecButtons)
		sliderPosProportional = 1.0 - sliderPosProportional;

	return (float) (sliderRegionStart + sliderPosProportional * sliderRegionSize);
}

bool Slider::isHorizontal() const
{
	return style == LinearHorizontal
		|| style == LinearBar
		|| style == TwoValueHorizontal
		|| style == ThreeValueHorizontal;
}

bool Slider::isVertical() const
{
	return style == LinearVertical
		|| style == TwoValueVertical
		|| style == ThreeValueVertical;
}

bool Slider::incDecDragDirectionIsHorizontal() const
{
	return incDecButtonMode == incDecButtonsDraggable_Horizontal
			|| (incDecButtonMode == incDecButtonsDraggable_AutoDirection && incDecButtonsSideBySide);
}

float Slider::getPositionOfValue (const double value)
{
	if (isHorizontal() || isVertical())
	{
		return getLinearSliderPos (value);
	}
	else
	{
		jassertfalse; // not a valid call on a slider that doesn't work linearly!
		return 0.0f;
	}
}

void Slider::paint (Graphics& g)
{
	if (style != IncDecButtons)
	{
		if (style == Rotary || style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
		{
			const float sliderPos = (float) valueToProportionOfLength (lastCurrentValue);
			jassert (sliderPos >= 0 && sliderPos <= 1.0f);

			getLookAndFeel().drawRotarySlider (g,
											   sliderRect.getX(),
											   sliderRect.getY(),
											   sliderRect.getWidth(),
											   sliderRect.getHeight(),
											   sliderPos,
											   rotaryStart, rotaryEnd,
											   *this);
		}
		else
		{
			getLookAndFeel().drawLinearSlider (g,
											   sliderRect.getX(),
											   sliderRect.getY(),
											   sliderRect.getWidth(),
											   sliderRect.getHeight(),
											   getLinearSliderPos (lastCurrentValue),
											   getLinearSliderPos (lastValueMin),
											   getLinearSliderPos (lastValueMax),
											   style,
											   *this);
		}

		if (style == LinearBar && valueBox == nullptr)
		{
			g.setColour (findColour (Slider::textBoxOutlineColourId));
			g.drawRect (0, 0, getWidth(), getHeight(), 1);
		}
	}
}

void Slider::resized()
{
	int minXSpace = 0;
	int minYSpace = 0;

	if (textBoxPos == TextBoxLeft || textBoxPos == TextBoxRight)
		minXSpace = 30;
	else
		minYSpace = 15;

	const int tbw = jmax (0, jmin (textBoxWidth, getWidth() - minXSpace));
	const int tbh = jmax (0, jmin (textBoxHeight, getHeight() - minYSpace));

	if (style == LinearBar)
	{
		if (valueBox != nullptr)
			valueBox->setBounds (getLocalBounds());
	}
	else
	{
		if (textBoxPos == NoTextBox)
		{
			sliderRect = getLocalBounds();
		}
		else if (textBoxPos == TextBoxLeft)
		{
			valueBox->setBounds (0, (getHeight() - tbh) / 2, tbw, tbh);
			sliderRect.setBounds (tbw, 0, getWidth() - tbw, getHeight());
		}
		else if (textBoxPos == TextBoxRight)
		{
			valueBox->setBounds (getWidth() - tbw, (getHeight() - tbh) / 2, tbw, tbh);
			sliderRect.setBounds (0, 0, getWidth() - tbw, getHeight());
		}
		else if (textBoxPos == TextBoxAbove)
		{
			valueBox->setBounds ((getWidth() - tbw) / 2, 0, tbw, tbh);
			sliderRect.setBounds (0, tbh, getWidth(), getHeight() - tbh);
		}
		else if (textBoxPos == TextBoxBelow)
		{
			valueBox->setBounds ((getWidth() - tbw) / 2, getHeight() - tbh, tbw, tbh);
			sliderRect.setBounds (0, 0, getWidth(), getHeight() - tbh);
		}
	}

	const int indent = getLookAndFeel().getSliderThumbRadius (*this);

	if (style == LinearBar)
	{
		const int barIndent = 1;
		sliderRegionStart = barIndent;
		sliderRegionSize = getWidth() - barIndent * 2;

		sliderRect.setBounds (sliderRegionStart, barIndent,
							  sliderRegionSize, getHeight() - barIndent * 2);
	}
	else if (isHorizontal())
	{
		sliderRegionStart = sliderRect.getX() + indent;
		sliderRegionSize = jmax (1, sliderRect.getWidth() - indent * 2);

		sliderRect.setBounds (sliderRegionStart, sliderRect.getY(),
							  sliderRegionSize, sliderRect.getHeight());
	}
	else if (isVertical())
	{
		sliderRegionStart = sliderRect.getY() + indent;
		sliderRegionSize = jmax (1, sliderRect.getHeight() - indent * 2);

		sliderRect.setBounds (sliderRect.getX(), sliderRegionStart,
							  sliderRect.getWidth(), sliderRegionSize);
	}
	else
	{
		sliderRegionStart = 0;
		sliderRegionSize = 100;
	}

	if (style == IncDecButtons)
	{
		Rectangle<int> buttonRect (sliderRect);

		if (textBoxPos == TextBoxLeft || textBoxPos == TextBoxRight)
			buttonRect.expand (-2, 0);
		else
			buttonRect.expand (0, -2);

		incDecButtonsSideBySide = buttonRect.getWidth() > buttonRect.getHeight();

		if (incDecButtonsSideBySide)
		{
			decButton->setBounds (buttonRect.removeFromLeft (buttonRect.getWidth() / 2));
			decButton->setConnectedEdges (Button::ConnectedOnRight);
			incButton->setConnectedEdges (Button::ConnectedOnLeft);
		}
		else
		{
			decButton->setBounds (buttonRect.removeFromBottom (buttonRect.getHeight() / 2));
			decButton->setConnectedEdges (Button::ConnectedOnTop);
			incButton->setConnectedEdges (Button::ConnectedOnBottom);
		}

		incButton->setBounds (buttonRect);
	}
}

void Slider::focusOfChildComponentChanged (FocusChangeType)
{
	repaint();
}

namespace SliderHelpers
{
	static double smallestAngleBetween (double a1, double a2) noexcept
	{
		return jmin (std::abs (a1 - a2),
					 std::abs (a1 + double_Pi * 2.0 - a2),
					 std::abs (a2 + double_Pi * 2.0 - a1));
	}

	static void sliderMenuCallback (int result, Slider* slider)
	{
		if (slider != nullptr)
		{
			switch (result)
			{
				case 1: slider->setVelocityBasedMode (! slider->getVelocityBasedMode()); break;
				case 2: slider->setSliderStyle (Slider::Rotary); break;
				case 3: slider->setSliderStyle (Slider::RotaryHorizontalDrag); break;
				case 4: slider->setSliderStyle (Slider::RotaryVerticalDrag); break;
				default: break;
			}
		}
	}
}

void Slider::showPopupMenu()
{
	menuShown = true;

	PopupMenu m;
	m.setLookAndFeel (&getLookAndFeel());
	m.addItem (1, TRANS ("velocity-sensitive mode"), true, isVelocityBased);
	m.addSeparator();

	if (style == Rotary || style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
	{
		PopupMenu rotaryMenu;
		rotaryMenu.addItem (2, TRANS ("use circular dragging"), true, style == Rotary);
		rotaryMenu.addItem (3, TRANS ("use left-right dragging"), true, style == RotaryHorizontalDrag);
		rotaryMenu.addItem (4, TRANS ("use up-down dragging"), true, style == RotaryVerticalDrag);

		m.addSubMenu (TRANS ("rotary mode"), rotaryMenu);
	}

	m.showMenuAsync (PopupMenu::Options(),
					 ModalCallbackFunction::forComponent (SliderHelpers::sliderMenuCallback, this));
}

int Slider::getThumbIndexAt (const MouseEvent& e)
{
	const bool isTwoValue   = (style == TwoValueHorizontal   || style == TwoValueVertical);
	const bool isThreeValue = (style == ThreeValueHorizontal || style == ThreeValueVertical);

	if (isTwoValue || isThreeValue)
	{
		const float mousePos = (float) (isVertical() ? e.y : e.x);

		const float normalPosDistance = std::abs (getLinearSliderPos (currentValue.getValue()) - mousePos);
		const float minPosDistance    = std::abs (getLinearSliderPos (valueMin.getValue()) - 0.1f - mousePos);
		const float maxPosDistance    = std::abs (getLinearSliderPos (valueMax.getValue()) + 0.1f - mousePos);

		if (isTwoValue)
			return maxPosDistance <= minPosDistance ? 2 : 1;

		if (normalPosDistance >= minPosDistance && maxPosDistance >= minPosDistance)
			return 1;
		else if (normalPosDistance >= maxPosDistance)
			return 2;
	}

	return 0;
}

void Slider::mouseDown (const MouseEvent& e)
{
	mouseWasHidden = false;
	incDecDragged = false;
	mouseDragStartPos = mousePosWhenLastDragged = e.getPosition();

	if (isEnabled())
	{
		if (e.mods.isPopupMenu() && menuEnabled)
		{
			showPopupMenu();
		}
		else if (maximum > minimum)
		{
			menuShown = false;

			if (valueBox != nullptr)
				valueBox->hideEditor (true);

			sliderBeingDragged = getThumbIndexAt (e);

			minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();

			lastAngle = rotaryStart + (rotaryEnd - rotaryStart)
										* valueToProportionOfLength (currentValue.getValue());

			valueWhenLastDragged = (sliderBeingDragged == 2 ? valueMax
															: (sliderBeingDragged == 1 ? valueMin
																					   : currentValue)).getValue();
			valueOnMouseDown = valueWhenLastDragged;

			if (popupDisplayEnabled)
			{
				PopupDisplayComponent* const popup = new PopupDisplayComponent (*this);
				popupDisplay = popup;

				if (parentForPopupDisplay != nullptr)
					parentForPopupDisplay->addChildComponent (popup);
				else
					popup->addToDesktop (0);

				popup->setVisible (true);
			}

			sendDragStart();
			mouseDrag (e);
		}
	}
}

void Slider::mouseUp (const MouseEvent&)
{
	if (isEnabled()
		 && (! menuShown)
		 && (maximum > minimum)
		 && (style != IncDecButtons || incDecDragged))
	{
		restoreMouseIfHidden();

		if (sendChangeOnlyOnRelease && valueOnMouseDown != (double) currentValue.getValue())
			triggerChangeMessage (false);

		sendDragEnd();
		popupDisplay = nullptr;

		if (style == IncDecButtons)
		{
			incButton->setState (Button::buttonNormal);
			decButton->setState (Button::buttonNormal);
		}
	}
	else if (popupDisplay != nullptr)
	{
		popupDisplay->startTimer (2000);
	}
}

void Slider::restoreMouseIfHidden()
{
	if (mouseWasHidden)
	{
		mouseWasHidden = false;

		for (int i = Desktop::getInstance().getNumMouseSources(); --i >= 0;)
			Desktop::getInstance().getMouseSource(i)->enableUnboundedMouseMovement (false);

		const double pos = sliderBeingDragged == 2 ? getMaxValue()
												   : (sliderBeingDragged == 1 ? getMinValue()
																			  : (double) currentValue.getValue());
		Point<int> mousePos;

		if (style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
		{
			mousePos = Desktop::getLastMouseDownPosition();

			if (style == RotaryHorizontalDrag)
			{
				const double posDiff = valueToProportionOfLength (pos) - valueToProportionOfLength (valueOnMouseDown);
				mousePos += Point<int> (roundToInt (pixelsForFullDragExtent * posDiff), 0);
			}
			else
			{
				const double posDiff = valueToProportionOfLength (valueOnMouseDown) - valueToProportionOfLength (pos);
				mousePos += Point<int> (0, roundToInt (pixelsForFullDragExtent * posDiff));
			}
		}
		else
		{
			const int pixelPos = (int) getLinearSliderPos (pos);

			mousePos = localPointToGlobal (Point<int> (isHorizontal() ? pixelPos : (getWidth() / 2),
													   isVertical()   ? pixelPos : (getHeight() / 2)));
		}

		Desktop::setMousePosition (mousePos);
	}
}

void Slider::modifierKeysChanged (const ModifierKeys& modifiers)
{
	if (isEnabled()
		 && style != IncDecButtons
		 && style != Rotary
		 && isVelocityBased == modifiers.isAnyModifierKeyDown())
	{
		restoreMouseIfHidden();
	}
}

void Slider::handleRotaryDrag (const MouseEvent& e)
{
	const int dx = e.x - sliderRect.getCentreX();
	const int dy = e.y - sliderRect.getCentreY();

	if (dx * dx + dy * dy > 25)
	{
		double angle = std::atan2 ((double) dx, (double) -dy);
		while (angle < 0.0)
			angle += double_Pi * 2.0;

		if (rotaryStop && ! e.mouseWasClicked())
		{
			if (std::abs (angle - lastAngle) > double_Pi)
			{
				if (angle >= lastAngle)
					angle -= double_Pi * 2.0;
				else
					angle += double_Pi * 2.0;
			}

			if (angle >= lastAngle)
				angle = jmin (angle, (double) jmax (rotaryStart, rotaryEnd));
			else
				angle = jmax (angle, (double) jmin (rotaryStart, rotaryEnd));
		}
		else
		{
			while (angle < rotaryStart)
				angle += double_Pi * 2.0;

			if (angle > rotaryEnd)
			{
				if (SliderHelpers::smallestAngleBetween (angle, rotaryStart)
					 <= SliderHelpers::smallestAngleBetween (angle, rotaryEnd))
					angle = rotaryStart;
				else
					angle = rotaryEnd;
			}
		}

		const double proportion = (angle - rotaryStart) / (rotaryEnd - rotaryStart);
		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, proportion));
		lastAngle = angle;
	}
}

void Slider::handleAbsoluteDrag (const MouseEvent& e)
{
	const int mousePos = (isHorizontal() || style == RotaryHorizontalDrag) ? e.x : e.y;

	double scaledMousePos = (mousePos - sliderRegionStart) / (double) sliderRegionSize;

	if (style == RotaryHorizontalDrag
		|| style == RotaryVerticalDrag
		|| style == IncDecButtons
		|| ((style == LinearHorizontal || style == LinearVertical || style == LinearBar)
			&& ! snapsToMousePos))
	{
		const int mouseDiff = (style == RotaryHorizontalDrag
								 || style == LinearHorizontal
								 || style == LinearBar
								 || (style == IncDecButtons && incDecDragDirectionIsHorizontal()))
								? e.x - mouseDragStartPos.x
								: mouseDragStartPos.y - e.y;

		double newPos = valueToProportionOfLength (valueOnMouseDown)
						   + mouseDiff * (1.0 / pixelsForFullDragExtent);

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, newPos));

		if (style == IncDecButtons)
		{
			incButton->setState (mouseDiff < 0 ? Button::buttonNormal : Button::buttonDown);
			decButton->setState (mouseDiff > 0 ? Button::buttonNormal : Button::buttonDown);
		}
	}
	else
	{
		if (isVertical())
			scaledMousePos = 1.0 - scaledMousePos;

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, scaledMousePos));
	}
}

void Slider::handleVelocityDrag (const MouseEvent& e)
{
	const int mouseDiff = (isHorizontal() || style == RotaryHorizontalDrag
							 || (style == IncDecButtons && incDecDragDirectionIsHorizontal()))
							? e.x - mousePosWhenLastDragged.x
							: e.y - mousePosWhenLastDragged.y;

	const double maxSpeed = jmax (200, sliderRegionSize);
	double speed = jlimit (0.0, maxSpeed, (double) abs (mouseDiff));

	if (speed != 0)
	{
		speed = 0.2 * velocityModeSensitivity
				  * (1.0 + std::sin (double_Pi * (1.5 + jmin (0.5, velocityModeOffset
																+ jmax (0.0, (double) (speed - velocityModeThreshold))
																	/ maxSpeed))));

		if (mouseDiff < 0)
			speed = -speed;

		if (isVertical() || style == RotaryVerticalDrag
			 || (style == IncDecButtons && ! incDecDragDirectionIsHorizontal()))
			speed = -speed;

		const double currentPos = valueToProportionOfLength (valueWhenLastDragged);

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, currentPos + speed));

		e.source.enableUnboundedMouseMovement (true, false);
		mouseWasHidden = true;
	}
}

void Slider::mouseDrag (const MouseEvent& e)
{
	if (isEnabled()
		 && (! menuShown)
		 && (maximum > minimum)
		 && ! (style == LinearBar && e.mouseWasClicked() && valueBox != nullptr && valueBox->isEditable()))
	{
		if (style == Rotary)
		{
			handleRotaryDrag (e);
		}
		else
		{
			if (style == IncDecButtons && ! incDecDragged)
			{
				if (e.getDistanceFromDragStart() < 10 || e.mouseWasClicked())
					return;

				incDecDragged = true;
				mouseDragStartPos = e.getPosition();
			}

			if (isVelocityBased == (userKeyOverridesVelocity && e.mods.testFlags (ModifierKeys::ctrlModifier
																					| ModifierKeys::commandModifier
																					| ModifierKeys::altModifier))
				 || (maximum - minimum) / sliderRegionSize < interval)
				handleAbsoluteDrag (e);
			else
				handleVelocityDrag (e);
		}

		valueWhenLastDragged = jlimit (minimum, maximum, valueWhenLastDragged);

		if (sliderBeingDragged == 0)
		{
			setValue (snapValue (valueWhenLastDragged, true),
					  ! sendChangeOnlyOnRelease, true);
		}
		else if (sliderBeingDragged == 1)
		{
			setMinValue (snapValue (valueWhenLastDragged, true),
						 ! sendChangeOnlyOnRelease, false, true);

			if (e.mods.isShiftDown())
				setMaxValue (getMinValue() + minMaxDiff, false, false, true);
			else
				minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();
		}
		else if (sliderBeingDragged == 2)
		{
			setMaxValue (snapValue (valueWhenLastDragged, true),
						 ! sendChangeOnlyOnRelease, false, true);

			if (e.mods.isShiftDown())
				setMinValue (getMaxValue() - minMaxDiff, false, false, true);
			else
				minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();
		}

		mousePosWhenLastDragged = e.getPosition();
	}
}

void Slider::mouseDoubleClick (const MouseEvent&)
{
	if (doubleClickToValue
		 && isEnabled()
		 && style != IncDecButtons
		 && minimum <= doubleClickReturnValue
		 && maximum >= doubleClickReturnValue)
	{
		sendDragStart();
		setValue (doubleClickReturnValue, true, true);
		sendDragEnd();
	}
}

void Slider::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (scrollWheelEnabled && isEnabled()
		 && style != TwoValueHorizontal
		 && style != TwoValueVertical)
	{
		if (maximum > minimum && ! e.mods.isAnyMouseButtonDown())
		{
			if (valueBox != nullptr)
				valueBox->hideEditor (false);

			const double value = (double) currentValue.getValue();
			const double proportionDelta = (wheelIncrementX != 0 ? -wheelIncrementX : wheelIncrementY) * 0.15f;
			const double currentPos = valueToProportionOfLength (value);
			const double newValue = proportionOfLengthToValue (jlimit (0.0, 1.0, currentPos + proportionDelta));

			double delta = (newValue != value)
							? jmax (std::abs (newValue - value), interval) : 0;

			if (value > newValue)
				delta = -delta;

			sendDragStart();
			setValue (snapValue (value + delta, false), true, true);
			sendDragEnd();
		}
	}
	else
	{
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
	}
}

void SliderListener::sliderDragStarted (Slider*)  // (can't write Slider::Listener due to idiotic VC2005 bug)
{
}

void SliderListener::sliderDragEnded (Slider*)
{
}

const Identifier Slider::Ids::tagType ("SLIDER");
const Identifier Slider::Ids::min ("min");
const Identifier Slider::Ids::max ("max");
const Identifier Slider::Ids::interval ("interval");
const Identifier Slider::Ids::type ("type");
const Identifier Slider::Ids::editable ("editable");
const Identifier Slider::Ids::textBoxPos ("textBoxPos");
const Identifier Slider::Ids::textBoxWidth ("textBoxWidth");
const Identifier Slider::Ids::textBoxHeight ("textBoxHeight");
const Identifier Slider::Ids::skew ("skew");

void Slider::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setRange (static_cast <double> (state [Ids::min]),
			  static_cast <double> (state [Ids::max]),
			  static_cast <double> (state [Ids::interval]));

	setSliderStyle ((SliderStyle) static_cast <int> (state [Ids::type]));

	setTextBoxStyle ((TextEntryBoxPosition) static_cast <int> (state [Ids::textBoxPos]),
					 ! static_cast <bool> (state [Ids::editable]),
					 static_cast <int> (state [Ids::textBoxWidth]),
					 static_cast <int> (state [Ids::textBoxHeight]));

	setSkewFactor (static_cast <double> (state [Ids::skew]));
}

/*** End of inlined file: juce_Slider.cpp ***/


/*** Start of inlined file: juce_TableHeaderComponent.cpp ***/
class DragOverlayComp   : public Component
{
public:
	DragOverlayComp (const Image& image_)
		: image (image_)
	{
		image.duplicateIfShared();
		image.multiplyAllAlphas (0.8f);
		setAlwaysOnTop (true);
	}

	void paint (Graphics& g)
	{
		g.drawImageAt (image, 0, 0);
	}

private:
	Image image;

	JUCE_DECLARE_NON_COPYABLE (DragOverlayComp);
};

TableHeaderComponent::TableHeaderComponent()
	: columnsChanged (false),
	  columnsResized (false),
	  sortChanged (false),
	  menuActive (true),
	  stretchToFit (false),
	  columnIdBeingResized (0),
	  columnIdBeingDragged (0),
	  columnIdUnderMouse (0),
	  lastDeliberateWidth (0)
{
}

TableHeaderComponent::~TableHeaderComponent()
{
	dragOverlayComp = nullptr;
}

void TableHeaderComponent::setPopupMenuActive (const bool hasMenu)
{
	menuActive = hasMenu;
}

bool TableHeaderComponent::isPopupMenuActive() const                    { return menuActive; }

int TableHeaderComponent::getNumColumns (const bool onlyCountVisibleColumns) const
{
	if (onlyCountVisibleColumns)
	{
		int num = 0;

		for (int i = columns.size(); --i >= 0;)
			if (columns.getUnchecked(i)->isVisible())
				++num;

		return num;
	}
	else
	{
		return columns.size();
	}
}

String TableHeaderComponent::getColumnName (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr ? ci->name : String::empty;
}

void TableHeaderComponent::setColumnName (const int columnId, const String& newName)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && ci->name != newName)
	{
		ci->name = newName;
		sendColumnsChanged();
	}
}

void TableHeaderComponent::addColumn (const String& columnName,
									  const int columnId,
									  const int width,
									  const int minimumWidth,
									  const int maximumWidth,
									  const int propertyFlags,
									  const int insertIndex)
{
	// can't have a duplicate or null ID!
	jassert (columnId != 0 && getIndexOfColumnId (columnId, false) < 0);
	jassert (width > 0);

	ColumnInfo* const ci = new ColumnInfo();
	ci->name = columnName;
	ci->id = columnId;
	ci->width = width;
	ci->lastDeliberateWidth = width;
	ci->minimumWidth = minimumWidth;
	ci->maximumWidth = maximumWidth;
	if (ci->maximumWidth < 0)
		ci->maximumWidth = std::numeric_limits<int>::max();
	jassert (ci->maximumWidth >= ci->minimumWidth);
	ci->propertyFlags = propertyFlags;

	columns.insert (insertIndex, ci);
	sendColumnsChanged();
}

void TableHeaderComponent::removeColumn (const int columnIdToRemove)
{
	const int index = getIndexOfColumnId (columnIdToRemove, false);

	if (index >= 0)
	{
		columns.remove (index);
		sortChanged = true;
		sendColumnsChanged();
	}
}

void TableHeaderComponent::removeAllColumns()
{
	if (columns.size() > 0)
	{
		columns.clear();
		sendColumnsChanged();
	}
}

void TableHeaderComponent::moveColumn (const int columnId, int newIndex)
{
	const int currentIndex = getIndexOfColumnId (columnId, false);
	newIndex = visibleIndexToTotalIndex (newIndex);

	if (columns [currentIndex] != 0 && currentIndex != newIndex)
	{
		columns.move (currentIndex, newIndex);
		sendColumnsChanged();
	}
}

int TableHeaderComponent::getColumnWidth (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr ? ci->width : 0;
}

void TableHeaderComponent::setColumnWidth (const int columnId, const int newWidth)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && ci->width != newWidth)
	{
		const int numColumns = getNumColumns (true);

		ci->lastDeliberateWidth = ci->width
			= jlimit (ci->minimumWidth, ci->maximumWidth, newWidth);

		if (stretchToFit)
		{
			const int index = getIndexOfColumnId (columnId, true) + 1;

			if (isPositiveAndBelow (index, numColumns))
			{
				const int x = getColumnPosition (index).getX();

				if (lastDeliberateWidth == 0)
					lastDeliberateWidth = getTotalWidth();

				resizeColumnsToFit (visibleIndexToTotalIndex (index), lastDeliberateWidth - x);
			}
		}

		repaint();
		columnsResized = true;
		triggerAsyncUpdate();
	}
}

int TableHeaderComponent::getIndexOfColumnId (const int columnId, const bool onlyCountVisibleColumns) const
{
	int n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		if ((! onlyCountVisibleColumns) || columns.getUnchecked(i)->isVisible())
		{
			if (columns.getUnchecked(i)->id == columnId)
				return n;

			++n;
		}
	}

	return -1;
}

int TableHeaderComponent::getColumnIdOfIndex (int index, const bool onlyCountVisibleColumns) const
{
	if (onlyCountVisibleColumns)
		index = visibleIndexToTotalIndex (index);

	const ColumnInfo* const ci = columns [index];
	return (ci != nullptr) ? ci->id : 0;
}

Rectangle<int> TableHeaderComponent::getColumnPosition (const int index) const
{
	int x = 0, width = 0, n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		x += width;

		if (columns.getUnchecked(i)->isVisible())
		{
			width = columns.getUnchecked(i)->width;

			if (n++ == index)
				break;
		}
		else
		{
			width = 0;
		}
	}

	return Rectangle<int> (x, 0, width, getHeight());
}

int TableHeaderComponent::getColumnIdAtX (const int xToFind) const
{
	if (xToFind >= 0)
	{
		int x = 0;

		for (int i = 0; i < columns.size(); ++i)
		{
			const ColumnInfo* const ci = columns.getUnchecked(i);

			if (ci->isVisible())
			{
				x += ci->width;

				if (xToFind < x)
					return ci->id;
			}
		}
	}

	return 0;
}

int TableHeaderComponent::getTotalWidth() const
{
	int w = 0;

	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked(i)->isVisible())
			w += columns.getUnchecked(i)->width;

	return w;
}

void TableHeaderComponent::setStretchToFitActive (const bool shouldStretchToFit)
{
	stretchToFit = shouldStretchToFit;
	lastDeliberateWidth = getTotalWidth();
	resized();
}

bool TableHeaderComponent::isStretchToFitActive() const
{
	return stretchToFit;
}

void TableHeaderComponent::resizeAllColumnsToFit (int targetTotalWidth)
{
	if (stretchToFit && getWidth() > 0
		 && columnIdBeingResized == 0 && columnIdBeingDragged == 0)
	{
		lastDeliberateWidth = targetTotalWidth;
		resizeColumnsToFit (0, targetTotalWidth);
	}
}

void TableHeaderComponent::resizeColumnsToFit (int firstColumnIndex, int targetTotalWidth)
{
	targetTotalWidth = jmax (targetTotalWidth, 0);

	StretchableObjectResizer sor;
	int i;
	for (i = firstColumnIndex; i < columns.size(); ++i)
	{
		ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
			sor.addItem (ci->lastDeliberateWidth, ci->minimumWidth, ci->maximumWidth);
	}

	sor.resizeToFit (targetTotalWidth);

	int visIndex = 0;
	for (i = firstColumnIndex; i < columns.size(); ++i)
	{
		ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
		{
			const int newWidth = jlimit (ci->minimumWidth, ci->maximumWidth,
										 (int) std::floor (sor.getItemSize (visIndex++)));

			if (newWidth != ci->width)
			{
				ci->width = newWidth;
				repaint();
				columnsResized = true;
				triggerAsyncUpdate();
			}
		}
	}
}

void TableHeaderComponent::setColumnVisible (const int columnId, const bool shouldBeVisible)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && shouldBeVisible != ci->isVisible())
	{
		if (shouldBeVisible)
			ci->propertyFlags |= visible;
		else
			ci->propertyFlags &= ~visible;

		sendColumnsChanged();
		resized();
	}
}

bool TableHeaderComponent::isColumnVisible (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr && ci->isVisible();
}

void TableHeaderComponent::setSortColumnId (const int columnId, const bool sortForwards)
{
	if (getSortColumnId() != columnId || isSortedForwards() != sortForwards)
	{
		for (int i = columns.size(); --i >= 0;)
			columns.getUnchecked(i)->propertyFlags &= ~(sortedForwards | sortedBackwards);

		ColumnInfo* const ci = getInfoForId (columnId);

		if (ci != nullptr)
			ci->propertyFlags |= (sortForwards ? sortedForwards : sortedBackwards);

		reSortTable();
	}
}

int TableHeaderComponent::getSortColumnId() const
{
	for (int i = columns.size(); --i >= 0;)
		if ((columns.getUnchecked(i)->propertyFlags & (sortedForwards | sortedBackwards)) != 0)
			return columns.getUnchecked(i)->id;

	return 0;
}

bool TableHeaderComponent::isSortedForwards() const
{
	for (int i = columns.size(); --i >= 0;)
		if ((columns.getUnchecked(i)->propertyFlags & (sortedForwards | sortedBackwards)) != 0)
			return (columns.getUnchecked(i)->propertyFlags & sortedForwards) != 0;

	return true;
}

void TableHeaderComponent::reSortTable()
{
	sortChanged = true;
	repaint();
	triggerAsyncUpdate();
}

String TableHeaderComponent::toString() const
{
	String s;

	XmlElement doc ("TABLELAYOUT");

	doc.setAttribute ("sortedCol", getSortColumnId());
	doc.setAttribute ("sortForwards", isSortedForwards());

	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked (i);

		XmlElement* const e = doc.createNewChildElement ("COLUMN");
		e->setAttribute ("id", ci->id);
		e->setAttribute ("visible", ci->isVisible());
		e->setAttribute ("width", ci->width);
	}

	return doc.createDocument (String::empty, true, false);
}

void TableHeaderComponent::restoreFromString (const String& storedVersion)
{
	ScopedPointer <XmlElement> storedXml (XmlDocument::parse (storedVersion));
	int index = 0;

	if (storedXml != nullptr && storedXml->hasTagName ("TABLELAYOUT"))
	{
		forEachXmlChildElement (*storedXml, col)
		{
			const int tabId = col->getIntAttribute ("id");

			ColumnInfo* const ci = getInfoForId (tabId);

			if (ci != nullptr)
			{
				columns.move (columns.indexOf (ci), index);
				ci->width = col->getIntAttribute ("width");
				setColumnVisible (tabId, col->getBoolAttribute ("visible"));
			}

			++index;
		}

		columnsResized = true;
		sendColumnsChanged();

		setSortColumnId (storedXml->getIntAttribute ("sortedCol"),
						 storedXml->getBoolAttribute ("sortForwards", true));
	}
}

void TableHeaderComponent::addListener (Listener* const newListener)
{
	listeners.addIfNotAlreadyThere (newListener);
}

void TableHeaderComponent::removeListener (Listener* const listenerToRemove)
{
	listeners.removeValue (listenerToRemove);
}

void TableHeaderComponent::columnClicked (int columnId, const ModifierKeys& mods)
{
	const ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && (ci->propertyFlags & sortable) != 0 && ! mods.isPopupMenu())
		setSortColumnId (columnId, (ci->propertyFlags & sortedForwards) == 0);
}

void TableHeaderComponent::addMenuItems (PopupMenu& menu, const int /*columnIdClicked*/)
{
	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked(i);

		if ((ci->propertyFlags & appearsOnColumnMenu) != 0)
			menu.addItem (ci->id, ci->name,
						  (ci->propertyFlags & (sortedForwards | sortedBackwards)) == 0,
						  isColumnVisible (ci->id));
	}
}

void TableHeaderComponent::reactToMenuItem (const int menuReturnId, const int /*columnIdClicked*/)
{
	if (getIndexOfColumnId (menuReturnId, false) >= 0)
		setColumnVisible (menuReturnId, ! isColumnVisible (menuReturnId));
}

void TableHeaderComponent::paint (Graphics& g)
{
	LookAndFeel& lf = getLookAndFeel();

	lf.drawTableHeaderBackground (g, *this);

	const Rectangle<int> clip (g.getClipBounds());

	int x = 0;
	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
		{
			if (x + ci->width > clip.getX()
				 && (ci->id != columnIdBeingDragged
					  || dragOverlayComp == nullptr
					  || ! dragOverlayComp->isVisible()))
			{
				Graphics::ScopedSaveState ss (g);

				g.setOrigin (x, 0);
				g.reduceClipRegion (0, 0, ci->width, getHeight());

				lf.drawTableHeaderColumn (g, ci->name, ci->id, ci->width, getHeight(),
										  ci->id == columnIdUnderMouse,
										  ci->id == columnIdUnderMouse && isMouseButtonDown(),
										  ci->propertyFlags);
			}

			x += ci->width;

			if (x >= clip.getRight())
				break;
		}
	}
}

void TableHeaderComponent::resized()
{
}

void TableHeaderComponent::mouseMove (const MouseEvent& e)
{
	updateColumnUnderMouse (e);
}

void TableHeaderComponent::mouseEnter (const MouseEvent& e)
{
	updateColumnUnderMouse (e);
}

void TableHeaderComponent::mouseExit (const MouseEvent&)
{
	setColumnUnderMouse (0);
}

void TableHeaderComponent::mouseDown (const MouseEvent& e)
{
	repaint();
	columnIdBeingResized = 0;
	columnIdBeingDragged = 0;

	if (columnIdUnderMouse != 0)
	{
		draggingColumnOffset = e.x - getColumnPosition (getIndexOfColumnId (columnIdUnderMouse, true)).getX();

		if (e.mods.isPopupMenu())
			columnClicked (columnIdUnderMouse, e.mods);
	}

	if (menuActive && e.mods.isPopupMenu())
		showColumnChooserMenu (columnIdUnderMouse);
}

void TableHeaderComponent::mouseDrag (const MouseEvent& e)
{
	if (columnIdBeingResized == 0
		 && columnIdBeingDragged == 0
		 && ! (e.mouseWasClicked() || e.mods.isPopupMenu()))
	{
		dragOverlayComp = nullptr;

		columnIdBeingResized = getResizeDraggerAt (e.getMouseDownX());

		if (columnIdBeingResized != 0)
		{
			const ColumnInfo* const ci = getInfoForId (columnIdBeingResized);
			initialColumnWidth = ci->width;
		}
		else
		{
			beginDrag (e);
		}
	}

	if (columnIdBeingResized != 0)
	{
		const ColumnInfo* const ci = getInfoForId (columnIdBeingResized);

		if (ci != nullptr)
		{
			int w = jlimit (ci->minimumWidth, ci->maximumWidth,
							initialColumnWidth + e.getDistanceFromDragStartX());

			if (stretchToFit)
			{
				// prevent us dragging a column too far right if we're in stretch-to-fit mode
				int minWidthOnRight = 0;
				for (int i = getIndexOfColumnId (columnIdBeingResized, false) + 1; i < columns.size(); ++i)
					if (columns.getUnchecked (i)->isVisible())
						minWidthOnRight += columns.getUnchecked (i)->minimumWidth;

				const Rectangle<int> currentPos (getColumnPosition (getIndexOfColumnId (columnIdBeingResized, true)));
				w = jmax (ci->minimumWidth, jmin (w, getWidth() - minWidthOnRight - currentPos.getX()));
			}

			setColumnWidth (columnIdBeingResized, w);
		}
	}
	else if (columnIdBeingDragged != 0)
	{
		if (e.y >= -50 && e.y < getHeight() + 50)
		{
			if (dragOverlayComp != nullptr)
			{
				dragOverlayComp->setVisible (true);
				dragOverlayComp->setBounds (jlimit (0,
													jmax (0, getTotalWidth() - dragOverlayComp->getWidth()),
													e.x - draggingColumnOffset),
											0,
											dragOverlayComp->getWidth(),
											getHeight());

				for (int i = columns.size(); --i >= 0;)
				{
					const int currentIndex = getIndexOfColumnId (columnIdBeingDragged, true);
					int newIndex = currentIndex;

					if (newIndex > 0)
					{
						// if the previous column isn't draggable, we can't move our column
						// past it, because that'd change the undraggable column's position..
						const ColumnInfo* const previous = columns.getUnchecked (newIndex - 1);

						if ((previous->propertyFlags & draggable) != 0)
						{
							const int leftOfPrevious = getColumnPosition (newIndex - 1).getX();
							const int rightOfCurrent = getColumnPosition (newIndex).getRight();

							if (abs (dragOverlayComp->getX() - leftOfPrevious)
								< abs (dragOverlayComp->getRight() - rightOfCurrent))
							{
								--newIndex;
							}
						}
					}

					if (newIndex < columns.size() - 1)
					{
						// if the next column isn't draggable, we can't move our column
						// past it, because that'd change the undraggable column's position..
						const ColumnInfo* const nextCol = columns.getUnchecked (newIndex + 1);

						if ((nextCol->propertyFlags & draggable) != 0)
						{
							const int leftOfCurrent = getColumnPosition (newIndex).getX();
							const int rightOfNext = getColumnPosition (newIndex + 1).getRight();

							if (abs (dragOverlayComp->getX() - leftOfCurrent)
								> abs (dragOverlayComp->getRight() - rightOfNext))
							{
								++newIndex;
							}
						}
					}

					if (newIndex != currentIndex)
						moveColumn (columnIdBeingDragged, newIndex);
					else
						break;
				}
			}
		}
		else
		{
			endDrag (draggingColumnOriginalIndex);
		}
	}
}

void TableHeaderComponent::beginDrag (const MouseEvent& e)
{
	if (columnIdBeingDragged == 0)
	{
		columnIdBeingDragged = getColumnIdAtX (e.getMouseDownX());

		const ColumnInfo* const ci = getInfoForId (columnIdBeingDragged);

		if (ci == nullptr || (ci->propertyFlags & draggable) == 0)
		{
			columnIdBeingDragged = 0;
		}
		else
		{
			draggingColumnOriginalIndex = getIndexOfColumnId (columnIdBeingDragged, true);

			const Rectangle<int> columnRect (getColumnPosition (draggingColumnOriginalIndex));

			const int temp = columnIdBeingDragged;
			columnIdBeingDragged = 0;

			addAndMakeVisible (dragOverlayComp = new DragOverlayComp (createComponentSnapshot (columnRect, false)));
			columnIdBeingDragged = temp;

			dragOverlayComp->setBounds (columnRect);

			for (int i = listeners.size(); --i >= 0;)
			{
				listeners.getUnchecked(i)->tableColumnDraggingChanged (this, columnIdBeingDragged);
				i = jmin (i, listeners.size() - 1);
			}
		}
	}
}

void TableHeaderComponent::endDrag (const int finalIndex)
{
	if (columnIdBeingDragged != 0)
	{
		moveColumn (columnIdBeingDragged, finalIndex);

		columnIdBeingDragged = 0;
		repaint();

		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnDraggingChanged (this, 0);
			i = jmin (i, listeners.size() - 1);
		}
	}
}

void TableHeaderComponent::mouseUp (const MouseEvent& e)
{
	mouseDrag (e);

	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked (i)->isVisible())
			columns.getUnchecked (i)->lastDeliberateWidth = columns.getUnchecked (i)->width;

	columnIdBeingResized = 0;
	repaint();

	endDrag (getIndexOfColumnId (columnIdBeingDragged, true));

	updateColumnUnderMouse (e);

	if (columnIdUnderMouse != 0 && e.mouseWasClicked() && ! e.mods.isPopupMenu())
		columnClicked (columnIdUnderMouse, e.mods);

	dragOverlayComp = nullptr;
}

MouseCursor TableHeaderComponent::getMouseCursor()
{
	if (columnIdBeingResized != 0 || (getResizeDraggerAt (getMouseXYRelative().getX()) != 0 && ! isMouseButtonDown()))
		return MouseCursor (MouseCursor::LeftRightResizeCursor);

	return Component::getMouseCursor();
}

bool TableHeaderComponent::ColumnInfo::isVisible() const
{
	return (propertyFlags & TableHeaderComponent::visible) != 0;
}

TableHeaderComponent::ColumnInfo* TableHeaderComponent::getInfoForId (const int id) const
{
	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked(i)->id == id)
			return columns.getUnchecked(i);

	return nullptr;
}

int TableHeaderComponent::visibleIndexToTotalIndex (const int visibleIndex) const
{
	int n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		if (columns.getUnchecked(i)->isVisible())
		{
			if (n == visibleIndex)
				return i;

			++n;
		}
	}

	return -1;
}

void TableHeaderComponent::sendColumnsChanged()
{
	if (stretchToFit && lastDeliberateWidth > 0)
		resizeAllColumnsToFit (lastDeliberateWidth);

	repaint();
	columnsChanged = true;
	triggerAsyncUpdate();
}

void TableHeaderComponent::handleAsyncUpdate()
{
	const bool changed = columnsChanged || sortChanged;
	const bool sized = columnsResized || changed;
	const bool sorted = sortChanged;
	columnsChanged = false;
	columnsResized = false;
	sortChanged = false;

	if (sorted)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableSortOrderChanged (this);
			i = jmin (i, listeners.size() - 1);
		}
	}

	if (changed)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnsChanged (this);
			i = jmin (i, listeners.size() - 1);
		}
	}

	if (sized)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnsResized (this);
			i = jmin (i, listeners.size() - 1);
		}
	}
}

int TableHeaderComponent::getResizeDraggerAt (const int mouseX) const
{
	if (isPositiveAndBelow (mouseX, getWidth()))
	{
		const int draggableDistance = 3;
		int x = 0;

		for (int i = 0; i < columns.size(); ++i)
		{
			const ColumnInfo* const ci = columns.getUnchecked(i);

			if (ci->isVisible())
			{
				if (abs (mouseX - (x + ci->width)) <= draggableDistance
					 && (ci->propertyFlags & resizable) != 0)
					return ci->id;

				x += ci->width;
			}
		}
	}

	return 0;
}

void TableHeaderComponent::setColumnUnderMouse (const int newCol)
{
	if (newCol != columnIdUnderMouse)
	{
		columnIdUnderMouse = newCol;
		repaint();
	}
}

void TableHeaderComponent::updateColumnUnderMouse (const MouseEvent& e)
{
	setColumnUnderMouse (reallyContains (e.getPosition(), true) && getResizeDraggerAt (e.x) == 0
							? getColumnIdAtX (e.x) : 0);
}

static void tableHeaderMenuCallback (int result, TableHeaderComponent* tableHeader, int columnIdClicked)
{
	if (tableHeader != nullptr && result != 0)
		tableHeader->reactToMenuItem (result, columnIdClicked);
}

void TableHeaderComponent::showColumnChooserMenu (const int columnIdClicked)
{
	PopupMenu m;
	addMenuItems (m, columnIdClicked);

	if (m.getNumItems() > 0)
	{
		m.setLookAndFeel (&getLookAndFeel());

		m.showMenuAsync (PopupMenu::Options(),
						 ModalCallbackFunction::forComponent (tableHeaderMenuCallback, this, columnIdClicked));
	}
}

void TableHeaderComponent::Listener::tableColumnDraggingChanged (TableHeaderComponent*, int)
{
}

/*** End of inlined file: juce_TableHeaderComponent.cpp ***/


/*** Start of inlined file: juce_TableListBox.cpp ***/
class TableListRowComp   : public Component,
						   public TooltipClient
{
public:
	TableListRowComp (TableListBox& owner_)
		: owner (owner_), row (-1), isSelected (false)
	{
	}

	void paint (Graphics& g)
	{
		TableListBoxModel* const model = owner.getModel();

		if (model != nullptr)
		{
			model->paintRowBackground (g, row, getWidth(), getHeight(), isSelected);

			const TableHeaderComponent& header = owner.getHeader();
			const int numColumns = header.getNumColumns (true);

			for (int i = 0; i < numColumns; ++i)
			{
				if (columnComponents[i] == nullptr)
				{
					const int columnId = header.getColumnIdOfIndex (i, true);
					const Rectangle<int> columnRect (header.getColumnPosition(i).withHeight (getHeight()));

					Graphics::ScopedSaveState ss (g);

					g.reduceClipRegion (columnRect);
					g.setOrigin (columnRect.getX(), 0);
					model->paintCell (g, row, columnId, columnRect.getWidth(), columnRect.getHeight(), isSelected);
				}
			}
		}
	}

	void update (const int newRow, const bool isNowSelected)
	{
		jassert (newRow >= 0);

		if (newRow != row || isNowSelected != isSelected)
		{
			row = newRow;
			isSelected = isNowSelected;
			repaint();
		}

		TableListBoxModel* const model = owner.getModel();

		if (model != nullptr && row < owner.getNumRows())
		{
			const Identifier columnProperty ("_tableColumnId");
			const int numColumns = owner.getHeader().getNumColumns (true);

			for (int i = 0; i < numColumns; ++i)
			{
				const int columnId = owner.getHeader().getColumnIdOfIndex (i, true);
				Component* comp = columnComponents[i];

				if (comp != nullptr && columnId != (int) comp->getProperties() [columnProperty])
				{
					columnComponents.set (i, nullptr);
					comp = nullptr;
				}

				comp = model->refreshComponentForCell (row, columnId, isSelected, comp);
				columnComponents.set (i, comp, false);

				if (comp != nullptr)
				{
					comp->getProperties().set (columnProperty, columnId);

					addAndMakeVisible (comp);
					resizeCustomComp (i);
				}
			}

			columnComponents.removeRange (numColumns, columnComponents.size());
		}
		else
		{
			columnComponents.clear();
		}
	}

	void resized()
	{
		for (int i = columnComponents.size(); --i >= 0;)
			resizeCustomComp (i);
	}

	void resizeCustomComp (const int index)
	{
		Component* const c = columnComponents.getUnchecked (index);

		if (c != nullptr)
			c->setBounds (owner.getHeader().getColumnPosition (index)
							.withY (0).withHeight (getHeight()));
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		selectRowOnMouseUp = false;

		if (isEnabled())
		{
			if (! isSelected)
			{
				owner.selectRowsBasedOnModifierKeys (row, e.mods, false);

				const int columnId = owner.getHeader().getColumnIdAtX (e.x);

				if (columnId != 0 && owner.getModel() != nullptr)
					owner.getModel()->cellClicked (row, columnId, e);
			}
			else
			{
				selectRowOnMouseUp = true;
			}
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled() && owner.getModel() != nullptr && ! (e.mouseWasClicked() || isDragging))
		{
			const SparseSet<int> selectedRows (owner.getSelectedRows());

			if (selectedRows.size() > 0)
			{
				const var dragDescription (owner.getModel()->getDragSourceDescription (selectedRows));

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					isDragging = true;
					owner.startDragAndDrop (e, dragDescription, true);
				}
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		if (selectRowOnMouseUp && e.mouseWasClicked() && isEnabled())
		{
			owner.selectRowsBasedOnModifierKeys (row, e.mods, true);

			const int columnId = owner.getHeader().getColumnIdAtX (e.x);

			if (columnId != 0 && owner.getModel() != nullptr)
				owner.getModel()->cellClicked (row, columnId, e);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		const int columnId = owner.getHeader().getColumnIdAtX (e.x);

		if (columnId != 0 && owner.getModel() != nullptr)
			owner.getModel()->cellDoubleClicked (row, columnId, e);
	}

	String getTooltip()
	{
		const int columnId = owner.getHeader().getColumnIdAtX (getMouseXYRelative().getX());

		if (columnId != 0 && owner.getModel() != nullptr)
			return owner.getModel()->getCellTooltip (row, columnId);

		return String::empty;
	}

	Component* findChildComponentForColumn (const int columnId) const
	{
		return columnComponents [owner.getHeader().getIndexOfColumnId (columnId, true)];
	}

private:
	TableListBox& owner;
	OwnedArray<Component> columnComponents;
	int row;
	bool isSelected, isDragging, selectRowOnMouseUp;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableListRowComp);
};

class TableListBoxHeader  : public TableHeaderComponent
{
public:
	TableListBoxHeader (TableListBox& owner_)
		: owner (owner_)
	{
	}

	void addMenuItems (PopupMenu& menu, int columnIdClicked)
	{
		if (owner.isAutoSizeMenuOptionShown())
		{
			menu.addItem (autoSizeColumnId, TRANS("Auto-size this column"), columnIdClicked != 0);
			menu.addItem (autoSizeAllId, TRANS("Auto-size all columns"), owner.getHeader().getNumColumns (true) > 0);
			menu.addSeparator();
		}

		TableHeaderComponent::addMenuItems (menu, columnIdClicked);
	}

	void reactToMenuItem (int menuReturnId, int columnIdClicked)
	{
		switch (menuReturnId)
		{
			case autoSizeColumnId:      owner.autoSizeColumn (columnIdClicked); break;
			case autoSizeAllId:         owner.autoSizeAllColumns(); break;
			default:                    TableHeaderComponent::reactToMenuItem (menuReturnId, columnIdClicked); break;
		}
	}

private:
	TableListBox& owner;

	enum { autoSizeColumnId = 0xf836743, autoSizeAllId = 0xf836744 };

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableListBoxHeader);
};

TableListBox::TableListBox (const String& name, TableListBoxModel* const model_)
	: ListBox (name, nullptr),
	  header (nullptr),
	  model (model_),
	  autoSizeOptionsShown (true)
{
	ListBox::model = this;

	setHeader (new TableListBoxHeader (*this));
}

TableListBox::~TableListBox()
{
}

void TableListBox::setModel (TableListBoxModel* const newModel)
{
	if (model != newModel)
	{
		model = newModel;
		updateContent();
	}
}

void TableListBox::setHeader (TableHeaderComponent* newHeader)
{
	jassert (newHeader != nullptr); // you need to supply a real header for a table!

	Rectangle<int> newBounds (0, 0, 100, 28);
	if (header != nullptr)
		newBounds = header->getBounds();

	header = newHeader;
	header->setBounds (newBounds);

	setHeaderComponent (header);

	header->addListener (this);
}

int TableListBox::getHeaderHeight() const
{
	return header->getHeight();
}

void TableListBox::setHeaderHeight (const int newHeight)
{
	header->setSize (header->getWidth(), newHeight);
	resized();
}

void TableListBox::autoSizeColumn (const int columnId)
{
	const int width = model != nullptr ? model->getColumnAutoSizeWidth (columnId) : 0;

	if (width > 0)
		header->setColumnWidth (columnId, width);
}

void TableListBox::autoSizeAllColumns()
{
	for (int i = 0; i < header->getNumColumns (true); ++i)
		autoSizeColumn (header->getColumnIdOfIndex (i, true));
}

void TableListBox::setAutoSizeMenuOptionShown (const bool shouldBeShown)
{
	autoSizeOptionsShown = shouldBeShown;
}

bool TableListBox::isAutoSizeMenuOptionShown() const
{
	return autoSizeOptionsShown;
}

Rectangle<int> TableListBox::getCellPosition (const int columnId, const int rowNumber,
											  const bool relativeToComponentTopLeft) const
{
	Rectangle<int> headerCell (header->getColumnPosition (header->getIndexOfColumnId (columnId, true)));

	if (relativeToComponentTopLeft)
		headerCell.translate (header->getX(), 0);

	return getRowPosition (rowNumber, relativeToComponentTopLeft)
			.withX (headerCell.getX())
			.withWidth (headerCell.getWidth());
}

Component* TableListBox::getCellComponent (int columnId, int rowNumber) const
{
	TableListRowComp* const rowComp = dynamic_cast <TableListRowComp*> (getComponentForRowNumber (rowNumber));
	return rowComp != nullptr ? rowComp->findChildComponentForColumn (columnId) : 0;
}

void TableListBox::scrollToEnsureColumnIsOnscreen (const int columnId)
{
	ScrollBar* const scrollbar = getHorizontalScrollBar();

	if (scrollbar != nullptr)
	{
		const Rectangle<int> pos (header->getColumnPosition (header->getIndexOfColumnId (columnId, true)));

		double x = scrollbar->getCurrentRangeStart();
		const double w = scrollbar->getCurrentRangeSize();

		if (pos.getX() < x)
			x = pos.getX();
		else if (pos.getRight() > x + w)
			x += jmax (0.0, pos.getRight() - (x + w));

		scrollbar->setCurrentRangeStart (x);
	}
}

int TableListBox::getNumRows()
{
	return model != nullptr ? model->getNumRows() : 0;
}

void TableListBox::paintListBoxItem (int, Graphics&, int, int, bool)
{
}

Component* TableListBox::refreshComponentForRow (int rowNumber, bool isRowSelected_, Component* existingComponentToUpdate)
{
	if (existingComponentToUpdate == nullptr)
		existingComponentToUpdate = new TableListRowComp (*this);

	static_cast <TableListRowComp*> (existingComponentToUpdate)->update (rowNumber, isRowSelected_);

	return existingComponentToUpdate;
}

void TableListBox::selectedRowsChanged (int row)
{
	if (model != nullptr)
		model->selectedRowsChanged (row);
}

void TableListBox::deleteKeyPressed (int row)
{
	if (model != nullptr)
		model->deleteKeyPressed (row);
}

void TableListBox::returnKeyPressed (int row)
{
	if (model != nullptr)
		model->returnKeyPressed (row);
}

void TableListBox::backgroundClicked()
{
	if (model != nullptr)
		model->backgroundClicked();
}

void TableListBox::listWasScrolled()
{
	if (model != nullptr)
		model->listWasScrolled();
}

void TableListBox::tableColumnsChanged (TableHeaderComponent*)
{
	setMinimumContentWidth (header->getTotalWidth());
	repaint();
	updateColumnComponents();
}

void TableListBox::tableColumnsResized (TableHeaderComponent*)
{
	setMinimumContentWidth (header->getTotalWidth());
	repaint();
	updateColumnComponents();
}

void TableListBox::tableSortOrderChanged (TableHeaderComponent*)
{
	if (model != nullptr)
		model->sortOrderChanged (header->getSortColumnId(),
								 header->isSortedForwards());
}

void TableListBox::tableColumnDraggingChanged (TableHeaderComponent*, int columnIdNowBeingDragged_)
{
	columnIdNowBeingDragged = columnIdNowBeingDragged_;
	repaint();
}

void TableListBox::resized()
{
	ListBox::resized();

	header->resizeAllColumnsToFit (getVisibleContentWidth());
	setMinimumContentWidth (header->getTotalWidth());
}

void TableListBox::updateColumnComponents() const
{
	const int firstRow = getRowContainingPosition (0, 0);

	for (int i = firstRow + getNumRowsOnScreen() + 2; --i >= firstRow;)
	{
		TableListRowComp* const rowComp = dynamic_cast <TableListRowComp*> (getComponentForRowNumber (i));

		if (rowComp != nullptr)
			rowComp->resized();
	}
}

void TableListBoxModel::cellClicked (int, int, const MouseEvent&)       {}
void TableListBoxModel::cellDoubleClicked (int, int, const MouseEvent&) {}
void TableListBoxModel::backgroundClicked()                             {}
void TableListBoxModel::sortOrderChanged (int, const bool)              {}
int TableListBoxModel::getColumnAutoSizeWidth (int)                     { return 0; }
void TableListBoxModel::selectedRowsChanged (int)                       {}
void TableListBoxModel::deleteKeyPressed (int)                          {}
void TableListBoxModel::returnKeyPressed (int)                          {}
void TableListBoxModel::listWasScrolled()                               {}

String TableListBoxModel::getCellTooltip (int /*rowNumber*/, int /*columnId*/)    { return String::empty; }
var TableListBoxModel::getDragSourceDescription (const SparseSet<int>&)           { return var::null; }

Component* TableListBoxModel::refreshComponentForCell (int, int, bool, Component* existingComponentToUpdate)
{
	(void) existingComponentToUpdate;
	jassert (existingComponentToUpdate == nullptr); // indicates a failure in the code the recycles the components
	return nullptr;
}

/*** End of inlined file: juce_TableListBox.cpp ***/


/*** Start of inlined file: juce_TextEditor.cpp ***/
// a word or space that can't be broken down any further
struct TextAtom
{

	String atomText;
	float width;
	int numChars;

	bool isWhitespace() const       { return CharacterFunctions::isWhitespace (atomText[0]); }
	bool isNewLine() const          { return atomText[0] == '\r' || atomText[0] == '\n'; }

	String getText (const juce_wchar passwordCharacter) const
	{
		if (passwordCharacter == 0)
			return atomText;
		else
			return String::repeatedString (String::charToString (passwordCharacter),
										   atomText.length());
	}

	String getTrimmedText (const juce_wchar passwordCharacter) const
	{
		if (passwordCharacter == 0)
			return atomText.substring (0, numChars);
		else if (isNewLine())
			return String::empty;
		else
			return String::repeatedString (String::charToString (passwordCharacter), numChars);
	}
};

// a run of text with a single font and colour
class TextEditor::UniformTextSection
{
public:

	UniformTextSection (const String& text,
						const Font& font_,
						const Colour& colour_,
						const juce_wchar passwordCharacter)
	  : font (font_),
		colour (colour_)
	{
		initialiseAtoms (text, passwordCharacter);
	}

	UniformTextSection (const UniformTextSection& other)
	  : font (other.font),
		colour (other.colour)
	{
		atoms.ensureStorageAllocated (other.atoms.size());

		for (int i = 0; i < other.atoms.size(); ++i)
			atoms.add (new TextAtom (*other.atoms.getUnchecked(i)));
	}

	~UniformTextSection()
	{
		// (no need to delete the atoms, as they're explicitly deleted by the caller)
	}

	void clear()
	{
		for (int i = atoms.size(); --i >= 0;)
			delete getAtom(i);

		atoms.clear();
	}

	int getNumAtoms() const
	{
		return atoms.size();
	}

	TextAtom* getAtom (const int index) const noexcept
	{
		return atoms.getUnchecked (index);
	}

	void append (const UniformTextSection& other, const juce_wchar passwordCharacter)
	{
		if (other.atoms.size() > 0)
		{
			TextAtom* const lastAtom = atoms.getLast();
			int i = 0;

			if (lastAtom != nullptr)
			{
				if (! CharacterFunctions::isWhitespace (lastAtom->atomText.getLastCharacter()))
				{
					TextAtom* const first = other.getAtom(0);

					if (! CharacterFunctions::isWhitespace (first->atomText[0]))
					{
						lastAtom->atomText += first->atomText;
						lastAtom->numChars = (uint16) (lastAtom->numChars + first->numChars);
						lastAtom->width = font.getStringWidthFloat (lastAtom->getText (passwordCharacter));
						delete first;
						++i;
					}
				}
			}

			atoms.ensureStorageAllocated (atoms.size() + other.atoms.size() - i);

			while (i < other.atoms.size())
			{
				atoms.add (other.getAtom(i));
				++i;
			}
		}
	}

	UniformTextSection* split (const int indexToBreakAt,
							   const juce_wchar passwordCharacter)
	{
		UniformTextSection* const section2 = new UniformTextSection (String::empty,
																	 font, colour,
																	 passwordCharacter);
		int index = 0;

		for (int i = 0; i < atoms.size(); ++i)
		{
			TextAtom* const atom = getAtom(i);

			const int nextIndex = index + atom->numChars;

			if (index == indexToBreakAt)
			{
				int j;
				for (j = i; j < atoms.size(); ++j)
					section2->atoms.add (getAtom (j));

				for (j = atoms.size(); --j >= i;)
					atoms.remove (j);

				break;
			}
			else if (indexToBreakAt >= index && indexToBreakAt < nextIndex)
			{
				TextAtom* const secondAtom = new TextAtom();

				secondAtom->atomText = atom->atomText.substring (indexToBreakAt - index);
				secondAtom->width = font.getStringWidthFloat (secondAtom->getText (passwordCharacter));
				secondAtom->numChars = (uint16) secondAtom->atomText.length();

				section2->atoms.add (secondAtom);

				atom->atomText = atom->atomText.substring (0, indexToBreakAt - index);
				atom->width = font.getStringWidthFloat (atom->getText (passwordCharacter));
				atom->numChars = (uint16) (indexToBreakAt - index);

				int j;
				for (j = i + 1; j < atoms.size(); ++j)
					section2->atoms.add (getAtom (j));

				for (j = atoms.size(); --j > i;)
					atoms.remove (j);

				break;
			}

			index = nextIndex;
		}

		return section2;
	}

	void appendAllText (MemoryOutputStream& mo) const
	{
		for (int i = 0; i < atoms.size(); ++i)
			mo << getAtom(i)->atomText;
	}

	void appendSubstring (MemoryOutputStream& mo, const Range<int>& range) const
	{
		int index = 0;
		for (int i = 0; i < atoms.size(); ++i)
		{
			const TextAtom* const atom = getAtom (i);
			const int nextIndex = index + atom->numChars;

			if (range.getStart() < nextIndex)
			{
				if (range.getEnd() <= index)
					break;

				const Range<int> r ((range - index).getIntersectionWith (Range<int> (0, (int) atom->numChars)));

				if (! r.isEmpty())
					mo << atom->atomText.substring (r.getStart(), r.getEnd());
			}

			index = nextIndex;
		}
	}

	int getTotalLength() const
	{
		int total = 0;

		for (int i = atoms.size(); --i >= 0;)
			total += getAtom(i)->numChars;

		return total;
	}

	void setFont (const Font& newFont,
				  const juce_wchar passwordCharacter)
	{
		if (font != newFont)
		{
			font = newFont;

			for (int i = atoms.size(); --i >= 0;)
			{
				TextAtom* const atom = atoms.getUnchecked(i);
				atom->width = newFont.getStringWidthFloat (atom->getText (passwordCharacter));
			}
		}
	}

	Font font;
	Colour colour;

private:
	Array <TextAtom*> atoms;

	void initialiseAtoms (const String& textToParse,
						  const juce_wchar passwordCharacter)
	{
		String::CharPointerType text (textToParse.getCharPointer());

		while (! text.isEmpty())
		{
			size_t numChars = 0;
			String::CharPointerType start (text);

			// create a whitespace atom unless it starts with non-ws
			if (text.isWhitespace() && *text != '\r' && *text != '\n')
			{
				do
				{
					++text;
					++numChars;
				}
				while (text.isWhitespace() && *text != '\r' && *text != '\n');
			}
			else
			{
				if (*text == '\r')
				{
					++text;
					++numChars;

					if (*text == '\n')
					{
						++start;
						++text;
					}
				}
				else if (*text == '\n')
				{
					++text;
					++numChars;
				}
				else
				{
					while (! (text.isEmpty() || text.isWhitespace()))
					{
						++text;
						++numChars;
					}
				}
			}

			TextAtom* const atom = new TextAtom();
			atom->atomText = String (start, numChars);

			atom->width = font.getStringWidthFloat (atom->getText (passwordCharacter));
			atom->numChars = (uint16) numChars;

			atoms.add (atom);
		}
	}

	UniformTextSection& operator= (const UniformTextSection& other);
	JUCE_LEAK_DETECTOR (UniformTextSection);
};

class TextEditor::Iterator
{
public:

	Iterator (const Array <UniformTextSection*>& sections_,
			  const float wordWrapWidth_,
			  const juce_wchar passwordCharacter_)
	  : indexInText (0),
		lineY (0),
		lineHeight (0),
		maxDescent (0),
		atomX (0),
		atomRight (0),
		atom (0),
		currentSection (nullptr),
		sections (sections_),
		sectionIndex (0),
		atomIndex (0),
		wordWrapWidth (wordWrapWidth_),
		passwordCharacter (passwordCharacter_)
	{
		jassert (wordWrapWidth_ > 0);

		if (sections.size() > 0)
		{
			currentSection = sections.getUnchecked (sectionIndex);

			if (currentSection != nullptr)
				beginNewLine();
		}
	}

	Iterator (const Iterator& other)
	  : indexInText (other.indexInText),
		lineY (other.lineY),
		lineHeight (other.lineHeight),
		maxDescent (other.maxDescent),
		atomX (other.atomX),
		atomRight (other.atomRight),
		atom (other.atom),
		currentSection (other.currentSection),
		sections (other.sections),
		sectionIndex (other.sectionIndex),
		atomIndex (other.atomIndex),
		wordWrapWidth (other.wordWrapWidth),
		passwordCharacter (other.passwordCharacter),
		tempAtom (other.tempAtom)
	{
	}

	bool next()
	{
		if (atom == &tempAtom)
		{
			const int numRemaining = tempAtom.atomText.length() - tempAtom.numChars;

			if (numRemaining > 0)
			{
				tempAtom.atomText = tempAtom.atomText.substring (tempAtom.numChars);

				atomX = 0;

				if (tempAtom.numChars > 0)
					lineY += lineHeight;

				indexInText += tempAtom.numChars;

				GlyphArrangement g;
				g.addLineOfText (currentSection->font, atom->getText (passwordCharacter), 0.0f, 0.0f);

				int split;
				for (split = 0; split < g.getNumGlyphs(); ++split)
					if (shouldWrap (g.getGlyph (split).getRight()))
						break;

				if (split > 0 && split <= numRemaining)
				{
					tempAtom.numChars = (uint16) split;
					tempAtom.width = g.getGlyph (split - 1).getRight();
					atomRight = atomX + tempAtom.width;
					return true;
				}
			}
		}

		bool forceNewLine = false;

		if (sectionIndex >= sections.size())
		{
			moveToEndOfLastAtom();
			return false;
		}
		else if (atomIndex >= currentSection->getNumAtoms() - 1)
		{
			if (atomIndex >= currentSection->getNumAtoms())
			{
				if (++sectionIndex >= sections.size())
				{
					moveToEndOfLastAtom();
					return false;
				}

				atomIndex = 0;
				currentSection = sections.getUnchecked (sectionIndex);
			}
			else
			{
				const TextAtom* const lastAtom = currentSection->getAtom (atomIndex);

				if (! lastAtom->isWhitespace())
				{
					// handle the case where the last atom in a section is actually part of the same
					// word as the first atom of the next section...
					float right = atomRight + lastAtom->width;
					float lineHeight2 = lineHeight;
					float maxDescent2 = maxDescent;

					for (int section = sectionIndex + 1; section < sections.size(); ++section)
					{
						const UniformTextSection* const s = sections.getUnchecked (section);

						if (s->getNumAtoms() == 0)
							break;

						const TextAtom* const nextAtom = s->getAtom (0);

						if (nextAtom->isWhitespace())
							break;

						right += nextAtom->width;

						lineHeight2 = jmax (lineHeight2, s->font.getHeight());
						maxDescent2 = jmax (maxDescent2, s->font.getDescent());

						if (shouldWrap (right))
						{
							lineHeight = lineHeight2;
							maxDescent = maxDescent2;

							forceNewLine = true;
							break;
						}

						if (s->getNumAtoms() > 1)
							break;
					}
				}
			}
		}

		if (atom != nullptr)
		{
			atomX = atomRight;
			indexInText += atom->numChars;

			if (atom->isNewLine())
				beginNewLine();
		}

		atom = currentSection->getAtom (atomIndex);
		atomRight = atomX + atom->width;
		++atomIndex;

		if (shouldWrap (atomRight) || forceNewLine)
		{
			if (atom->isWhitespace())
			{
				// leave whitespace at the end of a line, but truncate it to avoid scrolling
				atomRight = jmin (atomRight, wordWrapWidth);
			}
			else
			{
				atomRight = atom->width;

				if (shouldWrap (atomRight))  // atom too big to fit on a line, so break it up..
				{
					tempAtom = *atom;
					tempAtom.width = 0;
					tempAtom.numChars = 0;
					atom = &tempAtom;

					if (atomX > 0)
						beginNewLine();

					return next();
				}

				beginNewLine();
				return true;
			}
		}

		return true;
	}

	void beginNewLine()
	{
		atomX = 0;
		lineY += lineHeight;

		int tempSectionIndex = sectionIndex;
		int tempAtomIndex = atomIndex;
		const UniformTextSection* section = sections.getUnchecked (tempSectionIndex);

		lineHeight = section->font.getHeight();
		maxDescent = section->font.getDescent();

		float x = (atom != nullptr) ? atom->width : 0;

		while (! shouldWrap (x))
		{
			if (tempSectionIndex >= sections.size())
				break;

			bool checkSize = false;

			if (tempAtomIndex >= section->getNumAtoms())
			{
				if (++tempSectionIndex >= sections.size())
					break;

				tempAtomIndex = 0;
				section = sections.getUnchecked (tempSectionIndex);
				checkSize = true;
			}

			const TextAtom* const nextAtom = section->getAtom (tempAtomIndex);

			if (nextAtom == nullptr)
				break;

			x += nextAtom->width;

			if (shouldWrap (x) || nextAtom->isNewLine())
				break;

			if (checkSize)
			{
				lineHeight = jmax (lineHeight, section->font.getHeight());
				maxDescent = jmax (maxDescent, section->font.getDescent());
			}

			++tempAtomIndex;
		}
	}

	void draw (Graphics& g, const UniformTextSection*& lastSection) const
	{
		if (passwordCharacter != 0 || ! atom->isWhitespace())
		{
			if (lastSection != currentSection)
			{
				lastSection = currentSection;
				g.setColour (currentSection->colour);
				g.setFont (currentSection->font);
			}

			jassert (atom->getTrimmedText (passwordCharacter).isNotEmpty());

			GlyphArrangement ga;
			ga.addLineOfText (currentSection->font,
							  atom->getTrimmedText (passwordCharacter),
							  atomX,
							  (float) roundToInt (lineY + lineHeight - maxDescent));
			ga.draw (g);
		}
	}

	void drawSelection (Graphics& g, const Range<int>& selection) const
	{
		const int startX = roundToInt (indexToX (selection.getStart()));
		const int endX   = roundToInt (indexToX (selection.getEnd()));

		const int y = roundToInt (lineY);
		const int nextY = roundToInt (lineY + lineHeight);

		g.fillRect (startX, y, endX - startX, nextY - y);
	}

	void drawUnderline (Graphics& g, const Range<int>& underline, const Colour& colour) const
	{
		const int startX    = roundToInt (indexToX (underline.getStart()));
		const int endX      = roundToInt (indexToX (underline.getEnd()));
		const int baselineY = roundToInt (lineY + currentSection->font.getAscent() + 0.5f);

		Graphics::ScopedSaveState state (g);
		g.reduceClipRegion (Rectangle<int> (startX, baselineY, endX - startX, 1));
		g.fillCheckerBoard (Rectangle<int> (endX, baselineY + 1), 3, 1, colour, Colours::transparentBlack);
	}

	void drawSelectedText (Graphics& g,
						   const Range<int>& selection,
						   const Colour& selectedTextColour) const
	{
		if (passwordCharacter != 0 || ! atom->isWhitespace())
		{
			GlyphArrangement ga;
			ga.addLineOfText (currentSection->font,
							  atom->getTrimmedText (passwordCharacter),
							  atomX,
							  (float) roundToInt (lineY + lineHeight - maxDescent));

			if (selection.getEnd() < indexInText + atom->numChars)
			{
				GlyphArrangement ga2 (ga);
				ga2.removeRangeOfGlyphs (0, selection.getEnd() - indexInText);
				ga.removeRangeOfGlyphs (selection.getEnd() - indexInText, -1);

				g.setColour (currentSection->colour);
				ga2.draw (g);
			}

			if (selection.getStart() > indexInText)
			{
				GlyphArrangement ga2 (ga);
				ga2.removeRangeOfGlyphs (selection.getStart() - indexInText, -1);
				ga.removeRangeOfGlyphs (0, selection.getStart() - indexInText);

				g.setColour (currentSection->colour);
				ga2.draw (g);
			}

			g.setColour (selectedTextColour);
			ga.draw (g);
		}
	}

	float indexToX (const int indexToFind) const
	{
		if (indexToFind <= indexInText)
			return atomX;

		if (indexToFind >= indexInText + atom->numChars)
			return atomRight;

		GlyphArrangement g;
		g.addLineOfText (currentSection->font,
						 atom->getText (passwordCharacter),
						 atomX, 0.0f);

		if (indexToFind - indexInText >= g.getNumGlyphs())
			return atomRight;

		return jmin (atomRight, g.getGlyph (indexToFind - indexInText).getLeft());
	}

	int xToIndex (const float xToFind) const
	{
		if (xToFind <= atomX || atom->isNewLine())
			return indexInText;

		if (xToFind >= atomRight)
			return indexInText + atom->numChars;

		GlyphArrangement g;
		g.addLineOfText (currentSection->font,
						 atom->getText (passwordCharacter),
						 atomX, 0.0f);

		int j;
		for (j = 0; j < g.getNumGlyphs(); ++j)
			if ((g.getGlyph(j).getLeft() + g.getGlyph(j).getRight()) / 2 > xToFind)
				break;

		return indexInText + j;
	}

	bool getCharPosition (const int index, float& cx, float& cy, float& lineHeight_)
	{
		while (next())
		{
			if (indexInText + atom->numChars > index)
			{
				cx = indexToX (index);
				cy = lineY;
				lineHeight_ = lineHeight;
				return true;
			}
		}

		cx = atomX;
		cy = lineY;
		lineHeight_ = lineHeight;
		return false;
	}

	int indexInText;
	float lineY, lineHeight, maxDescent;
	float atomX, atomRight;
	const TextAtom* atom;
	const UniformTextSection* currentSection;

private:
	const Array <UniformTextSection*>& sections;
	int sectionIndex, atomIndex;
	const float wordWrapWidth;
	const juce_wchar passwordCharacter;
	TextAtom tempAtom;

	Iterator& operator= (const Iterator&);

	void moveToEndOfLastAtom()
	{
		if (atom != nullptr)
		{
			atomX = atomRight;

			if (atom->isNewLine())
			{
				atomX = 0.0f;
				lineY += lineHeight;
			}
		}
	}

	bool shouldWrap (const float x) const
	{
		return (x - 0.0001f) >= wordWrapWidth;
	}

	JUCE_LEAK_DETECTOR (Iterator);
};

class TextEditor::InsertAction  : public UndoableAction
{
public:
	InsertAction (TextEditor& owner_,
				  const String& text_,
				  const int insertIndex_,
				  const Font& font_,
				  const Colour& colour_,
				  const int oldCaretPos_,
				  const int newCaretPos_)
		: owner (owner_),
		  text (text_),
		  insertIndex (insertIndex_),
		  oldCaretPos (oldCaretPos_),
		  newCaretPos (newCaretPos_),
		  font (font_),
		  colour (colour_)
	{
	}

	bool perform()
	{
		owner.insert (text, insertIndex, font, colour, 0, newCaretPos);
		return true;
	}

	bool undo()
	{
		owner.remove (Range<int> (insertIndex, insertIndex + text.length()), 0, oldCaretPos);
		return true;
	}

	int getSizeInUnits()
	{
		return text.length() + 16;
	}

private:
	TextEditor& owner;
	const String text;
	const int insertIndex, oldCaretPos, newCaretPos;
	const Font font;
	const Colour colour;

	JUCE_DECLARE_NON_COPYABLE (InsertAction);
};

class TextEditor::RemoveAction  : public UndoableAction
{
public:
	RemoveAction (TextEditor& owner_,
				  const Range<int> range_,
				  const int oldCaretPos_,
				  const int newCaretPos_,
				  const Array <UniformTextSection*>& removedSections_)
		: owner (owner_),
		  range (range_),
		  oldCaretPos (oldCaretPos_),
		  newCaretPos (newCaretPos_),
		  removedSections (removedSections_)
	{
	}

	~RemoveAction()
	{
		for (int i = removedSections.size(); --i >= 0;)
		{
			UniformTextSection* const section = removedSections.getUnchecked (i);
			section->clear();
			delete section;
		}
	}

	bool perform()
	{
		owner.remove (range, 0, newCaretPos);
		return true;
	}

	bool undo()
	{
		owner.reinsert (range.getStart(), removedSections);
		owner.moveCaretTo (oldCaretPos, false);
		return true;
	}

	int getSizeInUnits()
	{
		int n = 0;

		for (int i = removedSections.size(); --i >= 0;)
			n += removedSections.getUnchecked (i)->getTotalLength();

		return n + 16;
	}

private:
	TextEditor& owner;
	const Range<int> range;
	const int oldCaretPos, newCaretPos;
	Array <UniformTextSection*> removedSections;

	JUCE_DECLARE_NON_COPYABLE (RemoveAction);
};

class TextEditor::TextHolderComponent  : public Component,
										 public Timer,
										 public ValueListener
{
public:
	TextHolderComponent (TextEditor& owner_)
		: owner (owner_)
	{
		setWantsKeyboardFocus (false);
		setInterceptsMouseClicks (false, true);

		owner.getTextValue().addListener (this);
	}

	~TextHolderComponent()
	{
		owner.getTextValue().removeListener (this);
	}

	void paint (Graphics& g)
	{
		owner.drawContent (g);
	}

	void restartTimer()
	{
		startTimer (350);
	}

	void timerCallback()
	{
		owner.timerCallbackInt();
	}

	MouseCursor getMouseCursor()
	{
		return owner.getMouseCursor();
	}

	void valueChanged (Value&)
	{
		owner.textWasChangedByValue();
	}

private:
	TextEditor& owner;

	JUCE_DECLARE_NON_COPYABLE (TextHolderComponent);
};

class TextEditorViewport  : public Viewport
{
public:
	TextEditorViewport (TextEditor& owner_)
		: owner (owner_), lastWordWrapWidth (0), rentrant (false)
	{
	}

	void visibleAreaChanged (const Rectangle<int>&)
	{
		if (! rentrant) // it's rare, but possible to get into a feedback loop as the viewport's scrollbars
						// appear and disappear, causing the wrap width to change.
		{
			const float wordWrapWidth = owner.getWordWrapWidth();

			if (wordWrapWidth != lastWordWrapWidth)
			{
				lastWordWrapWidth = wordWrapWidth;

				rentrant = true;
				owner.updateTextHolderSize();
				rentrant = false;
			}
		}
	}

private:
	TextEditor& owner;
	float lastWordWrapWidth;
	bool rentrant;

	JUCE_DECLARE_NON_COPYABLE (TextEditorViewport);
};

namespace TextEditorDefs
{
	const int textChangeMessageId = 0x10003001;
	const int returnKeyMessageId  = 0x10003002;
	const int escapeKeyMessageId  = 0x10003003;
	const int focusLossMessageId  = 0x10003004;

	const int maxActionsPerTransaction = 100;

	static int getCharacterCategory (const juce_wchar character)
	{
		return CharacterFunctions::isLetterOrDigit (character)
					? 2 : (CharacterFunctions::isWhitespace (character) ? 0 : 1);
	}
}

TextEditor::TextEditor (const String& name,
						const juce_wchar passwordCharacter_)
	: Component (name),
	  borderSize (1, 1, 1, 3),
	  readOnly (false),
	  multiline (false),
	  wordWrap (false),
	  returnKeyStartsNewLine (false),
	  popupMenuEnabled (true),
	  selectAllTextWhenFocused (false),
	  scrollbarVisible (true),
	  wasFocused (false),
	  keepCaretOnScreen (true),
	  tabKeyUsed (false),
	  menuActive (false),
	  valueTextNeedsUpdating (false),
	  maxTextLength (0),
	  leftIndent (4),
	  topIndent (4),
	  lastTransactionTime (0),
	  currentFont (14.0f),
	  totalNumChars (0),
	  caretPosition (0),
	  passwordCharacter (passwordCharacter_),
	  dragType (notDragging)
{
	setOpaque (true);

	addAndMakeVisible (viewport = new TextEditorViewport (*this));
	viewport->setViewedComponent (textHolder = new TextHolderComponent (*this));
	viewport->setWantsKeyboardFocus (false);
	viewport->setScrollBarsShown (false, false);

	setWantsKeyboardFocus (true);
	setCaretVisible (true);
}

TextEditor::~TextEditor()
{
	if (wasFocused)
	{
		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->dismissPendingTextInput();
	}

	textValue.referTo (Value());
	clearInternal (0);
	viewport = nullptr;
	textHolder = nullptr;
}

void TextEditor::newTransaction()
{
	lastTransactionTime = Time::getApproximateMillisecondCounter();
	undoManager.beginNewTransaction();
}

bool TextEditor::undoOrRedo (const bool shouldUndo)
{
	if (! isReadOnly())
	{
		newTransaction();

		if (shouldUndo ? undoManager.undo()
					   : undoManager.redo())
		{
			scrollToMakeSureCursorIsVisible();
			repaint();
			textChanged();
			return true;
		}
	}

	return false;
}

bool TextEditor::undo()     { return undoOrRedo (true); }
bool TextEditor::redo()     { return undoOrRedo (false); }

void TextEditor::setMultiLine (const bool shouldBeMultiLine,
							   const bool shouldWordWrap)
{
	if (multiline != shouldBeMultiLine
		 || wordWrap != (shouldWordWrap && shouldBeMultiLine))
	{
		multiline = shouldBeMultiLine;
		wordWrap = shouldWordWrap && shouldBeMultiLine;

		viewport->setScrollBarsShown (scrollbarVisible && multiline,
									  scrollbarVisible && multiline);
		viewport->setViewPosition (0, 0);
		resized();
		scrollToMakeSureCursorIsVisible();
	}
}

bool TextEditor::isMultiLine() const
{
	return multiline;
}

void TextEditor::setScrollbarsShown (bool shown)
{
	if (scrollbarVisible != shown)
	{
		scrollbarVisible = shown;
		shown = shown && isMultiLine();
		viewport->setScrollBarsShown (shown, shown);
	}
}

void TextEditor::setReadOnly (const bool shouldBeReadOnly)
{
	if (readOnly != shouldBeReadOnly)
	{
		readOnly = shouldBeReadOnly;
		enablementChanged();
	}
}

bool TextEditor::isReadOnly() const
{
	return readOnly || ! isEnabled();
}

bool TextEditor::isTextInputActive() const
{
	return ! isReadOnly();
}

void TextEditor::setReturnKeyStartsNewLine (const bool shouldStartNewLine)
{
	returnKeyStartsNewLine = shouldStartNewLine;
}

void TextEditor::setTabKeyUsedAsCharacter (const bool shouldTabKeyBeUsed)
{
	tabKeyUsed = shouldTabKeyBeUsed;
}

void TextEditor::setPopupMenuEnabled (const bool b)
{
	popupMenuEnabled = b;
}

void TextEditor::setSelectAllWhenFocused (const bool b)
{
	selectAllTextWhenFocused = b;
}

const Font& TextEditor::getFont() const
{
	return currentFont;
}

void TextEditor::setFont (const Font& newFont)
{
	currentFont = newFont;
	scrollToMakeSureCursorIsVisible();
}

void TextEditor::applyFontToAllText (const Font& newFont)
{
	currentFont = newFont;

	const Colour overallColour (findColour (textColourId));

	for (int i = sections.size(); --i >= 0;)
	{
		UniformTextSection* const uts = sections.getUnchecked (i);
		uts->setFont (newFont, passwordCharacter);
		uts->colour = overallColour;
	}

	coalesceSimilarSections();
	updateTextHolderSize();
	scrollToMakeSureCursorIsVisible();
	repaint();
}

void TextEditor::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	repaint();
}

void TextEditor::lookAndFeelChanged()
{
	if (isCaretVisible())
	{
		setCaretVisible (false);
		setCaretVisible (true);
	}
}

void TextEditor::setCaretVisible (const bool shouldCaretBeVisible)
{
	if (shouldCaretBeVisible && ! isReadOnly())
	{
		if (caret == nullptr)
			textHolder->addChildComponent (caret = getLookAndFeel().createCaretComponent (this));
	}
	else
	{
		caret = nullptr;
	}

	setMouseCursor (shouldCaretBeVisible ? MouseCursor::IBeamCursor
										 : MouseCursor::NormalCursor);
}

void TextEditor::updateCaretPosition()
{
	if (caret != nullptr)
		caret->setCaretPosition (getCaretRectangle().translated (leftIndent, topIndent));
}

void TextEditor::setInputRestrictions (const int maxLen,
									   const String& chars)
{
	maxTextLength = jmax (0, maxLen);
	allowedCharacters = chars;
}

void TextEditor::setTextToShowWhenEmpty (const String& text, const Colour& colourToUse)
{
	textToShowWhenEmpty = text;
	colourForTextWhenEmpty = colourToUse;
}

void TextEditor::setPasswordCharacter (const juce_wchar newPasswordCharacter)
{
	if (passwordCharacter != newPasswordCharacter)
	{
		passwordCharacter = newPasswordCharacter;
		applyFontToAllText (currentFont);
	}
}

void TextEditor::setScrollBarThickness (const int newThicknessPixels)
{
	viewport->setScrollBarThickness (newThicknessPixels);
}

void TextEditor::setScrollBarButtonVisibility (const bool buttonsVisible)
{
	viewport->setScrollBarButtonVisibility (buttonsVisible);
}

void TextEditor::clear()
{
	clearInternal (0);
	updateTextHolderSize();
	undoManager.clearUndoHistory();
}

void TextEditor::setText (const String& newText,
						  const bool sendTextChangeMessage)
{
	const int newLength = newText.length();

	if (newLength != getTotalNumChars() || getText() != newText)
	{
		textValue = newText;

		int oldCursorPos = caretPosition;
		const bool cursorWasAtEnd = oldCursorPos >= getTotalNumChars();

		clearInternal (0);
		insert (newText, 0, currentFont, findColour (textColourId), 0, caretPosition);

		// if you're adding text with line-feeds to a single-line text editor, it
		// ain't gonna look right!
		jassert (multiline || ! newText.containsAnyOf ("\r\n"));

		if (cursorWasAtEnd && ! isMultiLine())
			oldCursorPos = getTotalNumChars();

		moveCaretTo (oldCursorPos, false);

		if (sendTextChangeMessage)
			textChanged();

		updateTextHolderSize();
		scrollToMakeSureCursorIsVisible();
		undoManager.clearUndoHistory();

		repaint();
	}
}

void TextEditor::updateValueFromText()
{
	if (valueTextNeedsUpdating)
	{
		valueTextNeedsUpdating = false;
		textValue = getText();
	}
}

Value& TextEditor::getTextValue()
{
	updateValueFromText();
	return textValue;
}

void TextEditor::textWasChangedByValue()
{
	if (textValue.getValueSource().getReferenceCount() > 1)
		setText (textValue.getValue());
}

void TextEditor::textChanged()
{
	updateTextHolderSize();

	if (listeners.size() > 0)
		postCommandMessage (TextEditorDefs::textChangeMessageId);

	if (textValue.getValueSource().getReferenceCount() > 1)
	{
		valueTextNeedsUpdating = false;
		textValue = getText();
	}
}

void TextEditor::returnPressed()
{
	postCommandMessage (TextEditorDefs::returnKeyMessageId);
}

void TextEditor::escapePressed()
{
	postCommandMessage (TextEditorDefs::escapeKeyMessageId);
}

void TextEditor::addListener (TextEditorListener* const newListener)
{
	listeners.add (newListener);
}

void TextEditor::removeListener (TextEditorListener* const listenerToRemove)
{
	listeners.remove (listenerToRemove);
}

void TextEditor::timerCallbackInt()
{
	if (hasKeyboardFocus (false) && ! isCurrentlyBlockedByAnotherModalComponent())
		wasFocused = true;

	const unsigned int now = Time::getApproximateMillisecondCounter();

	if (now > lastTransactionTime + 200)
		newTransaction();
}

void TextEditor::repaintText (const Range<int>& range)
{
	if (! range.isEmpty())
	{
		float x = 0, y = 0, lh = currentFont.getHeight();

		const float wordWrapWidth = getWordWrapWidth();

		if (wordWrapWidth > 0)
		{
			Iterator i (sections, wordWrapWidth, passwordCharacter);

			i.getCharPosition (range.getStart(), x, y, lh);

			const int y1 = (int) y;
			int y2;

			if (range.getEnd() >= getTotalNumChars())
			{
				y2 = textHolder->getHeight();
			}
			else
			{
				i.getCharPosition (range.getEnd(), x, y, lh);
				y2 = (int) (y + lh * 2.0f);
			}

			textHolder->repaint (0, y1, textHolder->getWidth(), y2 - y1);
		}
	}
}

void TextEditor::moveCaret (int newCaretPos)
{
	if (newCaretPos < 0)
		newCaretPos = 0;
	else if (newCaretPos > getTotalNumChars())
		newCaretPos = getTotalNumChars();

	if (newCaretPos != getCaretPosition())
	{
		caretPosition = newCaretPos;
		textHolder->restartTimer();
		scrollToMakeSureCursorIsVisible();
		updateCaretPosition();
	}
}

int TextEditor::getCaretPosition() const
{
	return caretPosition;
}

void TextEditor::setCaretPosition (const int newIndex)
{
	moveCaretTo (newIndex, false);
}

void TextEditor::moveCaretToEnd()
{
	moveCaretTo (std::numeric_limits<int>::max(), false);
}

void TextEditor::scrollEditorToPositionCaret (const int desiredCaretX,
											  const int desiredCaretY)

{
	updateCaretPosition();

	const Rectangle<int> caretPos (getCaretRectangle());

	int vx = caretPos.getX() - desiredCaretX;
	int vy = caretPos.getY() - desiredCaretY;

	if (desiredCaretX < jmax (1, proportionOfWidth (0.05f)))
		vx += desiredCaretX - proportionOfWidth (0.2f);
	else if (desiredCaretX > jmax (0, viewport->getMaximumVisibleWidth() - (wordWrap ? 2 : 10)))
		vx += desiredCaretX + (isMultiLine() ? proportionOfWidth (0.2f) : 10) - viewport->getMaximumVisibleWidth();

	vx = jlimit (0, jmax (0, textHolder->getWidth() + 8 - viewport->getMaximumVisibleWidth()), vx);

	if (! isMultiLine())
	{
		vy = viewport->getViewPositionY();
	}
	else
	{
		vy = jlimit (0, jmax (0, textHolder->getHeight() - viewport->getMaximumVisibleHeight()), vy);

		if (desiredCaretY < 0)
			vy = jmax (0, desiredCaretY + vy);
		else if (desiredCaretY > jmax (0, viewport->getMaximumVisibleHeight() - topIndent - caretPos.getHeight()))
			vy += desiredCaretY + 2 + caretPos.getHeight() + topIndent - viewport->getMaximumVisibleHeight();
	}

	viewport->setViewPosition (vx, vy);
}

Rectangle<int> TextEditor::getCaretRectangle()
{
	float cursorX, cursorY;
	float cursorHeight = currentFont.getHeight(); // (in case the text is empty and the call below doesn't set this value)
	getCharPosition (caretPosition, cursorX, cursorY, cursorHeight);

	return Rectangle<int> (roundToInt (cursorX), roundToInt (cursorY), 2, roundToInt (cursorHeight));
}

float TextEditor::getWordWrapWidth() const
{
	return wordWrap ? (float) (viewport->getMaximumVisibleWidth() - leftIndent - leftIndent / 2)
					: std::numeric_limits<float>::max();
}

void TextEditor::updateTextHolderSize()
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		float maxWidth = 0.0f;

		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.next())
			maxWidth = jmax (maxWidth, i.atomRight);

		const int w = leftIndent + roundToInt (maxWidth);
		const int h = topIndent + roundToInt (jmax (i.lineY + i.lineHeight,
													currentFont.getHeight()));

		textHolder->setSize (w + 2, h + 1); // (the +2 allows a bit of space for the cursor to be at the right-hand-edge)
	}
}

int TextEditor::getTextWidth() const
{
	return textHolder->getWidth();
}

int TextEditor::getTextHeight() const
{
	return textHolder->getHeight();
}

void TextEditor::setIndents (const int newLeftIndent,
							 const int newTopIndent)
{
	leftIndent = newLeftIndent;
	topIndent = newTopIndent;
}

void TextEditor::setBorder (const BorderSize<int>& border)
{
	borderSize = border;
	resized();
}

BorderSize<int> TextEditor::getBorder() const
{
	return borderSize;
}

void TextEditor::setScrollToShowCursor (const bool shouldScrollToShowCursor)
{
	keepCaretOnScreen = shouldScrollToShowCursor;
}

void TextEditor::scrollToMakeSureCursorIsVisible()
{
	updateCaretPosition();

	if (keepCaretOnScreen)
	{
		int x = viewport->getViewPositionX();
		int y = viewport->getViewPositionY();

		const Rectangle<int> caretPos (getCaretRectangle());

		const int relativeCursorX = caretPos.getX() - x;
		const int relativeCursorY = caretPos.getY() - y;

		if (relativeCursorX < jmax (1, proportionOfWidth (0.05f)))
		{
			x += relativeCursorX - proportionOfWidth (0.2f);
		}
		else if (relativeCursorX > jmax (0, viewport->getMaximumVisibleWidth() - (wordWrap ? 2 : 10)))
		{
			x += relativeCursorX + (isMultiLine() ? proportionOfWidth (0.2f) : 10) - viewport->getMaximumVisibleWidth();
		}

		x = jlimit (0, jmax (0, textHolder->getWidth() + 8 - viewport->getMaximumVisibleWidth()), x);

		if (! isMultiLine())
		{
			y = (getHeight() - textHolder->getHeight() - topIndent) / -2;
		}
		else
		{
			if (relativeCursorY < 0)
			{
				y = jmax (0, relativeCursorY + y);
			}
			else if (relativeCursorY > jmax (0, viewport->getMaximumVisibleHeight() - topIndent - caretPos.getHeight()))
			{
				y += relativeCursorY + 2 + caretPos.getHeight() + topIndent - viewport->getMaximumVisibleHeight();
			}
		}

		viewport->setViewPosition (x, y);
	}
}

void TextEditor::moveCaretTo (const int newPosition,
							  const bool isSelecting)
{
	if (isSelecting)
	{
		moveCaret (newPosition);

		const Range<int> oldSelection (selection);

		if (dragType == notDragging)
		{
			if (abs (getCaretPosition() - selection.getStart()) < abs (getCaretPosition() - selection.getEnd()))
				dragType = draggingSelectionStart;
			else
				dragType = draggingSelectionEnd;
		}

		if (dragType == draggingSelectionStart)
		{
			if (getCaretPosition() >= selection.getEnd())
				dragType = draggingSelectionEnd;

			selection = Range<int>::between (getCaretPosition(), selection.getEnd());
		}
		else
		{
			if (getCaretPosition() < selection.getStart())
				dragType = draggingSelectionStart;

			selection = Range<int>::between (getCaretPosition(), selection.getStart());
		}

		repaintText (selection.getUnionWith (oldSelection));
	}
	else
	{
		dragType = notDragging;

		repaintText (selection);

		moveCaret (newPosition);
		selection = Range<int>::emptyRange (getCaretPosition());
	}
}

int TextEditor::getTextIndexAt (const int x,
								const int y)
{
	return indexAtPosition ((float) (x + viewport->getViewPositionX() - leftIndent),
							(float) (y + viewport->getViewPositionY() - topIndent));
}

void TextEditor::insertTextAtCaret (const String& newText_)
{
	String newText (newText_);

	if (allowedCharacters.isNotEmpty())
		newText = newText.retainCharacters (allowedCharacters);

	if (! isMultiLine())
		newText = newText.replaceCharacters ("\r\n", "  ");
	else
		newText = newText.replace ("\r\n", "\n");

	const int newCaretPos = selection.getStart() + newText.length();
	const int insertIndex = selection.getStart();

	remove (selection, getUndoManager(),
			newText.isNotEmpty() ? newCaretPos - 1 : newCaretPos);

	if (maxTextLength > 0)
		newText = newText.substring (0, maxTextLength - getTotalNumChars());

	if (newText.isNotEmpty())
		insert (newText,
				insertIndex,
				currentFont,
				findColour (textColourId),
				getUndoManager(),
				newCaretPos);

	textChanged();
}

void TextEditor::setHighlightedRegion (const Range<int>& newSelection)
{
	moveCaretTo (newSelection.getStart(), false);
	moveCaretTo (newSelection.getEnd(), true);
}

void TextEditor::copy()
{
	if (passwordCharacter == 0)
	{
		const String selectedText (getHighlightedText());

		if (selectedText.isNotEmpty())
			SystemClipboard::copyTextToClipboard (selectedText);
	}
}

void TextEditor::paste()
{
	if (! isReadOnly())
	{
		const String clip (SystemClipboard::getTextFromClipboard());

		if (clip.isNotEmpty())
			insertTextAtCaret (clip);
	}
}

void TextEditor::cut()
{
	if (! isReadOnly())
	{
		moveCaret (selection.getEnd());
		insertTextAtCaret (String::empty);
	}
}

void TextEditor::drawContent (Graphics& g)
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		g.setOrigin (leftIndent, topIndent);
		const Rectangle<int> clip (g.getClipBounds());
		Colour selectedTextColour;

		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.lineY + 200.0 < clip.getY() && i.next())
		{}

		if (! selection.isEmpty())
		{
			g.setColour (findColour (highlightColourId).withMultipliedAlpha (hasKeyboardFocus (true) ? 1.0f : 0.5f));

			selectedTextColour = findColour (highlightedTextColourId);

			Iterator i2 (i);

			while (i2.next() && i2.lineY < clip.getBottom())
			{
				if (i2.lineY + i2.lineHeight >= clip.getY()
					 && selection.intersects (Range<int> (i2.indexInText, i2.indexInText + i2.atom->numChars)))
				{
					i2.drawSelection (g, selection);
				}
			}
		}

		const UniformTextSection* lastSection = nullptr;

		while (i.next() && i.lineY < clip.getBottom())
		{
			if (i.lineY + i.lineHeight >= clip.getY())
			{
				if (selection.intersects (Range<int> (i.indexInText, i.indexInText + i.atom->numChars)))
				{
					i.drawSelectedText (g, selection, selectedTextColour);
					lastSection = nullptr;
				}
				else
				{
					i.draw (g, lastSection);
				}
			}
		}

		for (int j = underlinedSections.size(); --j >= 0;)
		{
			const Range<int>& underlinedSection = underlinedSections.getReference (j);

			Iterator i2 (sections, wordWrapWidth, passwordCharacter);

			while (i2.next() && i2.lineY < clip.getBottom())
			{
				if (i2.lineY + i2.lineHeight >= clip.getY()
					 && underlinedSection.intersects (Range<int> (i2.indexInText, i2.indexInText + i2.atom->numChars)))
				{
					i2.drawUnderline (g, underlinedSection, findColour (textColourId));
				}
			}
		}
	}
}

void TextEditor::paint (Graphics& g)
{
	getLookAndFeel().fillTextEditorBackground (g, getWidth(), getHeight(), *this);
}

void TextEditor::paintOverChildren (Graphics& g)
{
	if (textToShowWhenEmpty.isNotEmpty()
		 && (! hasKeyboardFocus (false))
		 && getTotalNumChars() == 0)
	{
		g.setColour (colourForTextWhenEmpty);
		g.setFont (getFont());

		if (isMultiLine())
		{
			g.drawText (textToShowWhenEmpty,
						0, 0, getWidth(), getHeight(),
						Justification::centred, true);
		}
		else
		{
			g.drawText (textToShowWhenEmpty,
						leftIndent, 0, viewport->getWidth() - leftIndent, getHeight(),
						Justification::centredLeft, true);
		}
	}

	getLookAndFeel().drawTextEditorOutline (g, getWidth(), getHeight(), *this);
}

static void textEditorMenuCallback (int menuResult, TextEditor* editor)
{
	if (editor != nullptr && menuResult != 0)
		editor->performPopupMenuAction (menuResult);
}

void TextEditor::mouseDown (const MouseEvent& e)
{
	beginDragAutoRepeat (100);
	newTransaction();

	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaretTo (getTextIndexAt (e.x, e.y),
						 e.mods.isShiftDown());
		}
		else
		{
			PopupMenu m;
			m.setLookAndFeel (&getLookAndFeel());
			addPopupMenuItems (m, &e);

			m.showMenuAsync (PopupMenu::Options(),
							 ModalCallbackFunction::forComponent (textEditorMenuCallback, this));
		}
	}
}

void TextEditor::mouseDrag (const MouseEvent& e)
{
	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaretTo (getTextIndexAt (e.x, e.y), true);
		}
	}
}

void TextEditor::mouseUp (const MouseEvent& e)
{
	newTransaction();
	textHolder->restartTimer();

	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (e.mouseWasClicked() && ! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaret (getTextIndexAt (e.x, e.y));
		}
	}

	wasFocused = true;
}

void TextEditor::mouseDoubleClick (const MouseEvent& e)
{
	int tokenEnd = getTextIndexAt (e.x, e.y);
	int tokenStart = tokenEnd;

	if (e.getNumberOfClicks() > 3)
	{
		tokenStart = 0;
		tokenEnd = getTotalNumChars();
	}
	else
	{
		const String t (getText());
		const int totalLength = getTotalNumChars();

		while (tokenEnd < totalLength)
		{
			// (note the slight bodge here - it's because iswalnum only checks for alphabetic chars in the current locale)
			const juce_wchar c = t [tokenEnd];
			if (CharacterFunctions::isLetterOrDigit (c) || c > 128)
				++tokenEnd;
			else
				break;
		}

		tokenStart = tokenEnd;

		while (tokenStart > 0)
		{
			// (note the slight bodge here - it's because iswalnum only checks for alphabetic chars in the current locale)
			const juce_wchar c = t [tokenStart - 1];
			if (CharacterFunctions::isLetterOrDigit (c) || c > 128)
				--tokenStart;
			else
				break;
		}

		if (e.getNumberOfClicks() > 2)
		{
			while (tokenEnd < totalLength)
			{
				const juce_wchar c = t [tokenEnd];
				if (c != '\r' && c != '\n')
					++tokenEnd;
				else
					break;
			}

			while (tokenStart > 0)
			{
				const juce_wchar c = t [tokenStart - 1];
				if (c != '\r' && c != '\n')
					--tokenStart;
				else
					break;
			}
		}
	}

	moveCaretTo (tokenEnd, false);
	moveCaretTo (tokenStart, true);
}

void TextEditor::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (! viewport->useMouseWheelMoveIfNeeded (e, wheelIncrementX, wheelIncrementY))
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

bool TextEditor::moveCaretWithTransation (const int newPos, const bool selecting)
{
	newTransaction();
	moveCaretTo (newPos, selecting);
	return true;
}

bool TextEditor::moveCaretLeft (bool moveInWholeWordSteps, bool selecting)
{
	int pos = getCaretPosition();

	if (moveInWholeWordSteps)
		pos = findWordBreakBefore (pos);
	else
		--pos;

	return moveCaretWithTransation (pos, selecting);
}

bool TextEditor::moveCaretRight (bool moveInWholeWordSteps, bool selecting)
{
	int pos = getCaretPosition();

	if (moveInWholeWordSteps)
		pos = findWordBreakAfter (pos);
	else
		++pos;

	return moveCaretWithTransation (pos, selecting);
}

bool TextEditor::moveCaretUp (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToStartOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getY() - 1.0f), selecting);
}

bool TextEditor::moveCaretDown (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToEndOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getBottom() + 1.0f), selecting);
}

bool TextEditor::pageUp (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToStartOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getY() - viewport->getViewHeight()), selecting);
}

bool TextEditor::pageDown (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToEndOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getBottom() + viewport->getViewHeight()), selecting);
}

void TextEditor::scrollByLines (int deltaLines)
{
	ScrollBar* scrollbar = viewport->getVerticalScrollBar();

	if (scrollbar != nullptr)
		scrollbar->moveScrollbarInSteps (deltaLines);
}

bool TextEditor::scrollDown()
{
	scrollByLines (-1);
	return true;
}

bool TextEditor::scrollUp()
{
	scrollByLines (1);
	return true;
}

bool TextEditor::moveCaretToTop (bool selecting)
{
	return moveCaretWithTransation (0, selecting);
}

bool TextEditor::moveCaretToStartOfLine (bool selecting)
{
	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (0.0f, caretPos.getY()), selecting);
}

bool TextEditor::moveCaretToEnd (bool selecting)
{
	return moveCaretWithTransation (getTotalNumChars(), selecting);
}

bool TextEditor::moveCaretToEndOfLine (bool selecting)
{
	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition ((float) textHolder->getWidth(), caretPos.getY()), selecting);
}

bool TextEditor::deleteBackwards (bool moveInWholeWordSteps)
{
	if (moveInWholeWordSteps)
		moveCaretTo (findWordBreakBefore (getCaretPosition()), true);
	else if (selection.isEmpty() && selection.getStart() > 0)
		selection.setStart (selection.getEnd() - 1);

	cut();
	return true;
}

bool TextEditor::deleteForwards (bool /*moveInWholeWordSteps*/)
{
	if (selection.isEmpty() && selection.getStart() < getTotalNumChars())
		selection.setEnd (selection.getStart() + 1);

	cut();
	return true;
}

bool TextEditor::copyToClipboard()
{
	newTransaction();
	copy();
	return true;
}

bool TextEditor::cutToClipboard()
{
	newTransaction();
	copy();
	cut();
	return true;
}

bool TextEditor::pasteFromClipboard()
{
	newTransaction();
	paste();
	return true;
}

bool TextEditor::selectAll()
{
	newTransaction();
	moveCaretTo (getTotalNumChars(), false);
	moveCaretTo (0, true);
	return true;
}

bool TextEditor::keyPressed (const KeyPress& key)
{
	if (isReadOnly() && key != KeyPress ('c', ModifierKeys::commandModifier, 0))
		return false;

	if (! TextEditorKeyMapper<TextEditor>::invokeKeyFunction (*this, key))
	{
		if (key == KeyPress::returnKey)
		{
			newTransaction();

			if (returnKeyStartsNewLine)
				insertTextAtCaret ("\n");
			else
				returnPressed();
		}
		else if (key.isKeyCode (KeyPress::escapeKey))
		{
			newTransaction();
			moveCaretTo (getCaretPosition(), false);
			escapePressed();
		}
		else if (key.getTextCharacter() >= ' '
				  || (tabKeyUsed && (key.getTextCharacter() == '\t')))
		{
			insertTextAtCaret (String::charToString (key.getTextCharacter()));

			lastTransactionTime = Time::getApproximateMillisecondCounter();
		}
		else
		{
			return false;
		}
	}

	return true;
}

bool TextEditor::keyStateChanged (const bool isKeyDown)
{
	if (! isKeyDown)
		return false;

   #if JUCE_WINDOWS
	if (KeyPress (KeyPress::F4Key, ModifierKeys::altModifier, 0).isCurrentlyDown())
		return false;  // We need to explicitly allow alt-F4 to pass through on Windows
   #endif

	// (overridden to avoid forwarding key events to the parent)
	return ! ModifierKeys::getCurrentModifiers().isCommandDown();
}

const int baseMenuItemID = 0x7fff0000;

void TextEditor::addPopupMenuItems (PopupMenu& m, const MouseEvent*)
{
	const bool writable = ! isReadOnly();

	if (passwordCharacter == 0)
	{
		m.addItem (baseMenuItemID + 1, TRANS("cut"), writable);
		m.addItem (baseMenuItemID + 2, TRANS("copy"), ! selection.isEmpty());
		m.addItem (baseMenuItemID + 3, TRANS("paste"), writable);
	}

	m.addItem (baseMenuItemID + 4, TRANS("delete"), writable);
	m.addSeparator();
	m.addItem (baseMenuItemID + 5, TRANS("select all"));
	m.addSeparator();

	if (getUndoManager() != nullptr)
	{
		m.addItem (baseMenuItemID + 6, TRANS("undo"), undoManager.canUndo());
		m.addItem (baseMenuItemID + 7, TRANS("redo"), undoManager.canRedo());
	}
}

void TextEditor::performPopupMenuAction (const int menuItemID)
{
	switch (menuItemID)
	{
		case baseMenuItemID + 1:    cutToClipboard(); break;
		case baseMenuItemID + 2:    copyToClipboard(); break;
		case baseMenuItemID + 3:    pasteFromClipboard(); break;
		case baseMenuItemID + 4:    cut(); break;
		case baseMenuItemID + 5:    selectAll(); break;
		case baseMenuItemID + 6:    undo(); break;
		case baseMenuItemID + 7:    redo(); break;
		default: break;
	}
}

void TextEditor::focusGained (FocusChangeType)
{
	newTransaction();

	if (selectAllTextWhenFocused)
	{
		moveCaretTo (0, false);
		moveCaretTo (getTotalNumChars(), true);
	}

	repaint();
	updateCaretPosition();

	ComponentPeer* const peer = getPeer();
	if (peer != nullptr && ! isReadOnly())
		peer->textInputRequired (getScreenPosition() - peer->getScreenPosition());
}

void TextEditor::focusLost (FocusChangeType)
{
	newTransaction();

	wasFocused = false;
	textHolder->stopTimer();

	underlinedSections.clear();

	ComponentPeer* const peer = getPeer();
	if (peer != nullptr)
		peer->dismissPendingTextInput();

	updateCaretPosition();

	postCommandMessage (TextEditorDefs::focusLossMessageId);
	repaint();
}

void TextEditor::resized()
{
	viewport->setBoundsInset (borderSize);
	viewport->setSingleStepSizes (16, roundToInt (currentFont.getHeight()));

	updateTextHolderSize();

	if (! isMultiLine())
	{
		scrollToMakeSureCursorIsVisible();
	}
	else
	{
		updateCaretPosition();
	}
}

void TextEditor::handleCommandMessage (const int commandId)
{
	Component::BailOutChecker checker (this);

	switch (commandId)
	{
	case TextEditorDefs::textChangeMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorTextChanged, (TextEditor&) *this);
		break;

	case TextEditorDefs::returnKeyMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorReturnKeyPressed, (TextEditor&) *this);
		break;

	case TextEditorDefs::escapeKeyMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorEscapeKeyPressed, (TextEditor&) *this);
		break;

	case TextEditorDefs::focusLossMessageId:
		updateValueFromText();
		listeners.callChecked (checker, &TextEditorListener::textEditorFocusLost, (TextEditor&) *this);
		break;

	default:
		jassertfalse;
		break;
	}
}

void TextEditor::enablementChanged()
{
	setMouseCursor (isReadOnly() ? MouseCursor::NormalCursor
								 : MouseCursor::IBeamCursor);
	repaint();
}

void TextEditor::setTemporaryUnderlining (const Array <Range<int> >& newUnderlinedSections)
{
	underlinedSections = newUnderlinedSections;
	repaint();
}

UndoManager* TextEditor::getUndoManager() noexcept
{
	return isReadOnly() ? 0 : &undoManager;
}

void TextEditor::clearInternal (UndoManager* const um)
{
	remove (Range<int> (0, getTotalNumChars()), um, caretPosition);
}

void TextEditor::insert (const String& text,
						 const int insertIndex,
						 const Font& font,
						 const Colour& colour,
						 UndoManager* const um,
						 const int caretPositionToMoveTo)
{
	if (text.isNotEmpty())
	{
		if (um != nullptr)
		{
			if (um->getNumActionsInCurrentTransaction() > TextEditorDefs::maxActionsPerTransaction)
				newTransaction();

			um->perform (new InsertAction (*this, text, insertIndex, font, colour,
										   caretPosition, caretPositionToMoveTo));
		}
		else
		{
			repaintText (Range<int> (insertIndex, getTotalNumChars())); // must do this before and after changing the data, in case
																		// a line gets moved due to word wrap

			int index = 0;
			int nextIndex = 0;

			for (int i = 0; i < sections.size(); ++i)
			{
				nextIndex = index + sections.getUnchecked (i)->getTotalLength();

				if (insertIndex == index)
				{
					sections.insert (i, new UniformTextSection (text,
																font, colour,
																passwordCharacter));
					break;
				}
				else if (insertIndex > index && insertIndex < nextIndex)
				{
					splitSection (i, insertIndex - index);
					sections.insert (i + 1, new UniformTextSection (text,
																	font, colour,
																	passwordCharacter));
					break;
				}

				index = nextIndex;
			}

			if (nextIndex == insertIndex)
				sections.add (new UniformTextSection (text,
													  font, colour,
													  passwordCharacter));

			coalesceSimilarSections();
			totalNumChars = -1;
			valueTextNeedsUpdating = true;

			updateTextHolderSize();
			moveCaretTo (caretPositionToMoveTo, false);

			repaintText (Range<int> (insertIndex, getTotalNumChars()));
		}
	}
}

void TextEditor::reinsert (const int insertIndex,
						   const Array <UniformTextSection*>& sectionsToInsert)
{
	int index = 0;
	int nextIndex = 0;

	for (int i = 0; i < sections.size(); ++i)
	{
		nextIndex = index + sections.getUnchecked (i)->getTotalLength();

		if (insertIndex == index)
		{
			for (int j = sectionsToInsert.size(); --j >= 0;)
				sections.insert (i, new UniformTextSection (*sectionsToInsert.getUnchecked(j)));

			break;
		}
		else if (insertIndex > index && insertIndex < nextIndex)
		{
			splitSection (i, insertIndex - index);

			for (int j = sectionsToInsert.size(); --j >= 0;)
				sections.insert (i + 1, new UniformTextSection (*sectionsToInsert.getUnchecked(j)));

			break;
		}

		index = nextIndex;
	}

	if (nextIndex == insertIndex)
	{
		for (int j = 0; j < sectionsToInsert.size(); ++j)
			sections.add (new UniformTextSection (*sectionsToInsert.getUnchecked(j)));
	}

	coalesceSimilarSections();
	totalNumChars = -1;
	valueTextNeedsUpdating = true;
}

void TextEditor::remove (const Range<int>& range,
						 UndoManager* const um,
						 const int caretPositionToMoveTo)
{
	if (! range.isEmpty())
	{
		int index = 0;

		for (int i = 0; i < sections.size(); ++i)
		{
			const int nextIndex = index + sections.getUnchecked(i)->getTotalLength();

			if (range.getStart() > index && range.getStart() < nextIndex)
			{
				splitSection (i, range.getStart() - index);
				--i;
			}
			else if (range.getEnd() > index && range.getEnd() < nextIndex)
			{
				splitSection (i, range.getEnd() - index);
				--i;
			}
			else
			{
				index = nextIndex;

				if (index > range.getEnd())
					break;
			}
		}

		index = 0;

		if (um != nullptr)
		{
			Array <UniformTextSection*> removedSections;

			for (int i = 0; i < sections.size(); ++i)
			{
				if (range.getEnd() <= range.getStart())
					break;

				UniformTextSection* const section = sections.getUnchecked (i);

				const int nextIndex = index + section->getTotalLength();

				if (range.getStart() <= index && range.getEnd() >= nextIndex)
					removedSections.add (new UniformTextSection (*section));

				index = nextIndex;
			}

			if (um->getNumActionsInCurrentTransaction() > TextEditorDefs::maxActionsPerTransaction)
				newTransaction();

			um->perform (new RemoveAction (*this, range, caretPosition,
										   caretPositionToMoveTo, removedSections));
		}
		else
		{
			Range<int> remainingRange (range);

			for (int i = 0; i < sections.size(); ++i)
			{
				UniformTextSection* const section = sections.getUnchecked (i);

				const int nextIndex = index + section->getTotalLength();

				if (remainingRange.getStart() <= index && remainingRange.getEnd() >= nextIndex)
				{
					sections.remove(i);
					section->clear();
					delete section;

					remainingRange.setEnd (remainingRange.getEnd() - (nextIndex - index));
					if (remainingRange.isEmpty())
						break;

					--i;
				}
				else
				{
					index = nextIndex;
				}
			}

			coalesceSimilarSections();
			totalNumChars = -1;
			valueTextNeedsUpdating = true;

			moveCaretTo (caretPositionToMoveTo, false);

			repaintText (Range<int> (range.getStart(), getTotalNumChars()));
		}
	}
}

String TextEditor::getText() const
{
	MemoryOutputStream mo;
	mo.preallocate ((size_t) getTotalNumChars());

	for (int i = 0; i < sections.size(); ++i)
		sections.getUnchecked (i)->appendAllText (mo);

	return mo.toString();
}

String TextEditor::getTextInRange (const Range<int>& range) const
{
	if (range.isEmpty())
		return String::empty;

	MemoryOutputStream mo;
	mo.preallocate ((size_t) jmin (getTotalNumChars(), range.getLength()));

	int index = 0;

	for (int i = 0; i < sections.size(); ++i)
	{
		const UniformTextSection* const s = sections.getUnchecked (i);
		const int nextIndex = index + s->getTotalLength();

		if (range.getStart() < nextIndex)
		{
			if (range.getEnd() <= index)
				break;

			s->appendSubstring (mo, range - index);
		}

		index = nextIndex;
	}

	return mo.toString();
}

String TextEditor::getHighlightedText() const
{
	return getTextInRange (selection);
}

int TextEditor::getTotalNumChars() const
{
	if (totalNumChars < 0)
	{
		totalNumChars = 0;

		for (int i = sections.size(); --i >= 0;)
			totalNumChars += sections.getUnchecked (i)->getTotalLength();
	}

	return totalNumChars;
}

bool TextEditor::isEmpty() const
{
	return getTotalNumChars() == 0;
}

void TextEditor::getCharPosition (const int index, float& cx, float& cy, float& lineHeight) const
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0 && sections.size() > 0)
	{
		Iterator i (sections, wordWrapWidth, passwordCharacter);

		i.getCharPosition (index, cx, cy, lineHeight);
	}
	else
	{
		cx = cy = 0;
		lineHeight = currentFont.getHeight();
	}
}

int TextEditor::indexAtPosition (const float x, const float y)
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.next())
		{
			if (i.lineY + i.lineHeight > y)
			{
				if (i.lineY > y)
					return jmax (0, i.indexInText - 1);

				if (i.atomX >= x)
					return i.indexInText;

				if (x < i.atomRight)
					return i.xToIndex (x);
			}
		}
	}

	return getTotalNumChars();
}

int TextEditor::findWordBreakAfter (const int position) const
{
	const String t (getTextInRange (Range<int> (position, position + 512)));
	const int totalLength = t.length();
	int i = 0;

	while (i < totalLength && CharacterFunctions::isWhitespace (t[i]))
		++i;

	const int type = TextEditorDefs::getCharacterCategory (t[i]);

	while (i < totalLength && type == TextEditorDefs::getCharacterCategory (t[i]))
		++i;

	while (i < totalLength && CharacterFunctions::isWhitespace (t[i]))
		++i;

	return position + i;
}

int TextEditor::findWordBreakBefore (const int position) const
{
	if (position <= 0)
		return 0;

	const int startOfBuffer = jmax (0, position - 512);
	const String t (getTextInRange (Range<int> (startOfBuffer, position)));

	int i = position - startOfBuffer;

	while (i > 0 && CharacterFunctions::isWhitespace (t [i - 1]))
		--i;

	if (i > 0)
	{
		const int type = TextEditorDefs::getCharacterCategory (t [i - 1]);

		while (i > 0 && type == TextEditorDefs::getCharacterCategory (t [i - 1]))
			--i;
	}

	jassert (startOfBuffer + i >= 0);
	return startOfBuffer + i;
}

void TextEditor::splitSection (const int sectionIndex,
							   const int charToSplitAt)
{
	jassert (sections[sectionIndex] != nullptr);

	sections.insert (sectionIndex + 1,
					 sections.getUnchecked (sectionIndex)->split (charToSplitAt, passwordCharacter));
}

void TextEditor::coalesceSimilarSections()
{
	for (int i = 0; i < sections.size() - 1; ++i)
	{
		UniformTextSection* const s1 = sections.getUnchecked (i);
		UniformTextSection* const s2 = sections.getUnchecked (i + 1);

		if (s1->font == s2->font
			 && s1->colour == s2->colour)
		{
			s1->append (*s2, passwordCharacter);
			sections.remove (i + 1);
			delete s2;
			--i;
		}
	}
}

void TextEditor::Listener::textEditorTextChanged (TextEditor&) {}
void TextEditor::Listener::textEditorReturnKeyPressed (TextEditor&) {}
void TextEditor::Listener::textEditorEscapeKeyPressed (TextEditor&) {}
void TextEditor::Listener::textEditorFocusLost (TextEditor&) {}

const Identifier TextEditor::Ids::tagType ("TEXTEDITOR");
const Identifier TextEditor::Ids::text ("text");
const Identifier TextEditor::Ids::font ("font");
const Identifier TextEditor::Ids::mode ("mode");
const Identifier TextEditor::Ids::readOnly ("readOnly");
const Identifier TextEditor::Ids::scrollbarsShown ("scrollbarsShown");
const Identifier TextEditor::Ids::caretVisible ("caretVisible");
const Identifier TextEditor::Ids::popupMenuEnabled ("popupMenuEnabled");

void TextEditor::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setReadOnly (state [Ids::readOnly]);
	setScrollbarsShown (state [Ids::scrollbarsShown]);
	setCaretVisible (state [Ids::caretVisible]);
	setPopupMenuEnabled (state [Ids::popupMenuEnabled]);
	const int mode = state [Ids::mode];
	setMultiLine (mode > 1, true);
	setReturnKeyStartsNewLine (mode != 3);

	const Font font (Font::fromString (state [Ids::font]));
	if (getFont() != font)
		applyFontToAllText (font);

	setText (state [Ids::text].toString());
}

/*** End of inlined file: juce_TextEditor.cpp ***/


/*** Start of inlined file: juce_Toolbar.cpp ***/
const char* const Toolbar::toolbarDragDescriptor = "_toolbarItem_";

class ToolbarSpacerComp  : public ToolbarItemComponent
{
public:
	ToolbarSpacerComp (const int itemId_, const float fixedSize_, const bool drawBar_)
		: ToolbarItemComponent (itemId_, String::empty, false),
		  fixedSize (fixedSize_),
		  drawBar (drawBar_)
	{
	}

	~ToolbarSpacerComp()
	{
	}

	bool getToolbarItemSizes (int toolbarThickness, bool /*isToolbarVertical*/,
							  int& preferredSize, int& minSize, int& maxSize)
	{
		if (fixedSize <= 0)
		{
			preferredSize = toolbarThickness * 2;
			minSize = 4;
			maxSize = 32768;
		}
		else
		{
			maxSize = roundToInt (toolbarThickness * fixedSize);
			minSize = drawBar ? maxSize : jmin (4, maxSize);
			preferredSize = maxSize;

			if (getEditingMode() == editableOnPalette)
				preferredSize = maxSize = toolbarThickness / (drawBar ? 3 : 2);
		}

		return true;
	}

	void paintButtonArea (Graphics&, int, int, bool, bool)
	{
	}

	void contentAreaChanged (const Rectangle<int>&)
	{
	}

	int getResizeOrder() const noexcept
	{
		return fixedSize <= 0 ? 0 : 1;
	}

	void paint (Graphics& g)
	{
		const int w = getWidth();
		const int h = getHeight();

		if (drawBar)
		{
			g.setColour (findColour (Toolbar::separatorColourId, true));

			const float thickness = 0.2f;

			if (isToolbarVertical())
				g.fillRect (w * 0.1f, h * (0.5f - thickness * 0.5f), w * 0.8f, h * thickness);
			else
				g.fillRect (w * (0.5f - thickness * 0.5f), h * 0.1f, w * thickness, h * 0.8f);
		}

		if (getEditingMode() != normalMode && ! drawBar)
		{
			g.setColour (findColour (Toolbar::separatorColourId, true));

			const int indentX = jmin (2, (w - 3) / 2);
			const int indentY = jmin (2, (h - 3) / 2);
			g.drawRect (indentX, indentY, w - indentX * 2, h - indentY * 2, 1);

			if (fixedSize <= 0)
			{
				float x1, y1, x2, y2, x3, y3, x4, y4, hw, hl;

				if (isToolbarVertical())
				{
					x1 = w * 0.5f;
					y1 = h * 0.4f;
					x2 = x1;
					y2 = indentX * 2.0f;

					x3 = x1;
					y3 = h * 0.6f;
					x4 = x1;
					y4 = h - y2;

					hw = w * 0.15f;
					hl = w * 0.2f;
				}
				else
				{
					x1 = w * 0.4f;
					y1 = h * 0.5f;
					x2 = indentX * 2.0f;
					y2 = y1;

					x3 = w * 0.6f;
					y3 = y1;
					x4 = w - x2;
					y4 = y1;

					hw = h * 0.15f;
					hl = h * 0.2f;
				}

				Path p;
				p.addArrow (Line<float> (x1, y1, x2, y2), 1.5f, hw, hl);
				p.addArrow (Line<float> (x3, y3, x4, y4), 1.5f, hw, hl);
				g.fillPath (p);
			}
		}
	}

private:
	const float fixedSize;
	const bool drawBar;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToolbarSpacerComp);
};

class Toolbar::MissingItemsComponent  : public PopupMenu::CustomComponent
{
public:
	MissingItemsComponent (Toolbar& owner_, const int height_)
		: PopupMenu::CustomComponent (true),
		  owner (&owner_),
		  height (height_)
	{
		for (int i = owner_.items.size(); --i >= 0;)
		{
			ToolbarItemComponent* const tc = owner_.items.getUnchecked(i);

			if (dynamic_cast <ToolbarSpacerComp*> (tc) == nullptr && ! tc->isVisible())
			{
				oldIndexes.insert (0, i);
				addAndMakeVisible (tc, 0);
			}
		}

		layout (400);
	}

	~MissingItemsComponent()
	{
		if (owner != nullptr)
		{
			for (int i = 0; i < getNumChildComponents(); ++i)
			{
				ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getChildComponent (i));

				if (tc != nullptr)
				{
					tc->setVisible (false);
					const int index = oldIndexes.remove (i);
					owner->addChildComponent (tc, index);
					--i;
				}
			}

			owner->resized();
		}
	}

	void layout (const int preferredWidth)
	{
		const int indent = 8;
		int x = indent;
		int y = indent;
		int maxX = 0;

		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getChildComponent (i));

			if (tc != nullptr)
			{
				int preferredSize = 1, minSize = 1, maxSize = 1;

				if (tc->getToolbarItemSizes (height, false, preferredSize, minSize, maxSize))
				{
					if (x + preferredSize > preferredWidth && x > indent)
					{
						x = indent;
						y += height;
					}

					tc->setBounds (x, y, preferredSize, height);

					x += preferredSize;
					maxX = jmax (maxX, x);
				}
			}
		}

		setSize (maxX + 8, y + height + 8);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		idealWidth = getWidth();
		idealHeight = getHeight();
	}

private:
	Component::SafePointer<Toolbar> owner;
	const int height;
	Array <int> oldIndexes;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MissingItemsComponent);
};

Toolbar::Toolbar()
	: vertical (false),
	  isEditingActive (false),
	  toolbarStyle (Toolbar::iconsOnly)
{
	addChildComponent (missingItemsButton = getLookAndFeel().createToolbarMissingItemsButton (*this));

	missingItemsButton->setAlwaysOnTop (true);
	missingItemsButton->addListener (this);
}

Toolbar::~Toolbar()
{
	items.clear();
}

void Toolbar::setVertical (const bool shouldBeVertical)
{
	if (vertical != shouldBeVertical)
	{
		vertical = shouldBeVertical;
		resized();
	}
}

void Toolbar::clear()
{
	items.clear();
	resized();
}

ToolbarItemComponent* Toolbar::createItem (ToolbarItemFactory& factory, const int itemId)
{
	if (itemId == ToolbarItemFactory::separatorBarId)
		return new ToolbarSpacerComp (itemId, 0.1f, true);
	else if (itemId == ToolbarItemFactory::spacerId)
		return new ToolbarSpacerComp (itemId, 0.5f, false);
	else if (itemId == ToolbarItemFactory::flexibleSpacerId)
		return new ToolbarSpacerComp (itemId, 0, false);

	return factory.createItem (itemId);
}

void Toolbar::addItemInternal (ToolbarItemFactory& factory,
							   const int itemId,
							   const int insertIndex)
{
	// An ID can't be zero - this might indicate a mistake somewhere?
	jassert (itemId != 0);

	ToolbarItemComponent* const tc = createItem (factory, itemId);

	if (tc != nullptr)
	{
#if JUCE_DEBUG
		Array <int> allowedIds;
		factory.getAllToolbarItemIds (allowedIds);

		// If your factory can create an item for a given ID, it must also return
		// that ID from its getAllToolbarItemIds() method!
		jassert (allowedIds.contains (itemId));
#endif

		items.insert (insertIndex, tc);
		addAndMakeVisible (tc, insertIndex);
	}
}

void Toolbar::addItem (ToolbarItemFactory& factory,
					   const int itemId,
					   const int insertIndex)
{
	addItemInternal (factory, itemId, insertIndex);
	resized();
}

void Toolbar::addDefaultItems (ToolbarItemFactory& factoryToUse)
{
	Array <int> ids;
	factoryToUse.getDefaultItemSet (ids);

	clear();

	for (int i = 0; i < ids.size(); ++i)
		addItemInternal (factoryToUse, ids.getUnchecked (i), -1);

	resized();
}

void Toolbar::removeToolbarItem (const int itemIndex)
{
	items.remove (itemIndex);
	resized();
}

int Toolbar::getNumItems() const noexcept
{
	return items.size();
}

int Toolbar::getItemId (const int itemIndex) const noexcept
{
	ToolbarItemComponent* const tc = getItemComponent (itemIndex);
	return tc != nullptr ? tc->getItemId() : 0;
}

ToolbarItemComponent* Toolbar::getItemComponent (const int itemIndex) const noexcept
{
	return items [itemIndex];
}

ToolbarItemComponent* Toolbar::getNextActiveComponent (int index, const int delta) const
{
	for (;;)
	{
		index += delta;
		ToolbarItemComponent* const tc = getItemComponent (index);

		if (tc == nullptr)
			break;

		if (tc->isActive)
			return tc;
	}

	return nullptr;
}

void Toolbar::setStyle (const ToolbarItemStyle& newStyle)
{
	if (toolbarStyle != newStyle)
	{
		toolbarStyle = newStyle;
		updateAllItemPositions (false);
	}
}

String Toolbar::toString() const
{
	String s ("TB:");

	for (int i = 0; i < getNumItems(); ++i)
		s << getItemId(i) << ' ';

	return s.trimEnd();
}

bool Toolbar::restoreFromString (ToolbarItemFactory& factoryToUse,
								 const String& savedVersion)
{
	if (! savedVersion.startsWith ("TB:"))
		return false;

	StringArray tokens;
	tokens.addTokens (savedVersion.substring (3), false);

	clear();

	for (int i = 0; i < tokens.size(); ++i)
		addItemInternal (factoryToUse, tokens[i].getIntValue(), -1);

	resized();
	return true;
}

void Toolbar::paint (Graphics& g)
{
	getLookAndFeel().paintToolbarBackground (g, getWidth(), getHeight(), *this);
}

int Toolbar::getThickness() const noexcept
{
	return vertical ? getWidth() : getHeight();
}

int Toolbar::getLength() const noexcept
{
	return vertical ? getHeight() : getWidth();
}

void Toolbar::setEditingActive (const bool active)
{
	if (isEditingActive != active)
	{
		isEditingActive = active;
		updateAllItemPositions (false);
	}
}

void Toolbar::resized()
{
	updateAllItemPositions (false);
}

void Toolbar::updateAllItemPositions (const bool animate)
{
	if (getWidth() > 0 && getHeight() > 0)
	{
		StretchableObjectResizer resizer;

		int i;
		for (i = 0; i < items.size(); ++i)
		{
			ToolbarItemComponent* const tc = items.getUnchecked(i);

			tc->setEditingMode (isEditingActive ? ToolbarItemComponent::editableOnToolbar
												: ToolbarItemComponent::normalMode);

			tc->setStyle (toolbarStyle);

			ToolbarSpacerComp* const spacer = dynamic_cast <ToolbarSpacerComp*> (tc);

			int preferredSize = 1, minSize = 1, maxSize = 1;

			if (tc->getToolbarItemSizes (getThickness(), isVertical(),
										 preferredSize, minSize, maxSize))
			{
				tc->isActive = true;
				resizer.addItem (preferredSize, minSize, maxSize,
								 spacer != nullptr ? spacer->getResizeOrder() : 2);
			}
			else
			{
				tc->isActive = false;
				tc->setVisible (false);
			}
		}

		resizer.resizeToFit (getLength());

		int totalLength = 0;

		for (i = 0; i < resizer.getNumItems(); ++i)
			totalLength += (int) resizer.getItemSize (i);

		const bool itemsOffTheEnd = totalLength > getLength();

		const int extrasButtonSize = getThickness() / 2;
		missingItemsButton->setSize (extrasButtonSize, extrasButtonSize);
		missingItemsButton->setVisible (itemsOffTheEnd);
		missingItemsButton->setEnabled (! isEditingActive);

		if (vertical)
			missingItemsButton->setCentrePosition (getWidth() / 2,
												   getHeight() - 4 - extrasButtonSize / 2);
		else
			missingItemsButton->setCentrePosition (getWidth() - 4 - extrasButtonSize / 2,
												   getHeight() / 2);

		const int maxLength = itemsOffTheEnd ? (vertical ? missingItemsButton->getY()
														 : missingItemsButton->getX()) - 4
											 : getLength();

		int pos = 0, activeIndex = 0;
		for (i = 0; i < items.size(); ++i)
		{
			ToolbarItemComponent* const tc = items.getUnchecked(i);

			if (tc->isActive)
			{
				const int size = (int) resizer.getItemSize (activeIndex++);

				Rectangle<int> newBounds;
				if (vertical)
					newBounds.setBounds (0, pos, getWidth(), size);
				else
					newBounds.setBounds (pos, 0, size, getHeight());

				if (animate)
				{
					Desktop::getInstance().getAnimator().animateComponent (tc, newBounds, 1.0f, 200, false, 3.0, 0.0);
				}
				else
				{
					Desktop::getInstance().getAnimator().cancelAnimation (tc, false);
					tc->setBounds (newBounds);
				}

				pos += size;
				tc->setVisible (pos <= maxLength
								 && ((! tc->isBeingDragged)
									  || tc->getEditingMode() == ToolbarItemComponent::editableOnPalette));
			}
		}
	}
}

void Toolbar::buttonClicked (Button*)
{
	jassert (missingItemsButton->isShowing());

	if (missingItemsButton->isShowing())
	{
		PopupMenu m;
		m.addCustomItem (1, new MissingItemsComponent (*this, getThickness()));
		m.showMenuAsync (PopupMenu::Options().withTargetComponent (missingItemsButton), nullptr);
	}
}

bool Toolbar::isInterestedInDragSource (const SourceDetails& dragSourceDetails)
{
	return dragSourceDetails.description == toolbarDragDescriptor && isEditingActive;
}

void Toolbar::itemDragMove (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr)
	{
		if (! items.contains (tc))
		{
			if (tc->getEditingMode() == ToolbarItemComponent::editableOnPalette)
			{
				ToolbarItemPalette* const palette = tc->findParentComponentOfClass<ToolbarItemPalette>();

				if (palette != nullptr)
					palette->replaceComponent (tc);
			}
			else
			{
				jassert (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar);
			}

			items.add (tc);
			addChildComponent (tc);
			updateAllItemPositions (true);
		}

		for (int i = getNumItems(); --i >= 0;)
		{
			const int currentIndex = items.indexOf (tc);
			int newIndex = currentIndex;

			const int dragObjectLeft = vertical ? (dragSourceDetails.localPosition.getY() - tc->dragOffsetY)
												: (dragSourceDetails.localPosition.getX() - tc->dragOffsetX);
			const int dragObjectRight = dragObjectLeft + (vertical ? tc->getHeight() : tc->getWidth());

			const Rectangle<int> current (Desktop::getInstance().getAnimator()
											.getComponentDestination (getChildComponent (newIndex)));
			ToolbarItemComponent* const prev = getNextActiveComponent (newIndex, -1);

			if (prev != nullptr)
			{
				const Rectangle<int> previousPos (Desktop::getInstance().getAnimator().getComponentDestination (prev));

				if (abs (dragObjectLeft - (vertical ? previousPos.getY() : previousPos.getX())
					  < abs (dragObjectRight - (vertical ? current.getBottom() : current.getRight()))))
				{
					newIndex = getIndexOfChildComponent (prev);
				}
			}

			ToolbarItemComponent* const next = getNextActiveComponent (newIndex, 1);
			if (next != nullptr)
			{
				const Rectangle<int> nextPos (Desktop::getInstance().getAnimator().getComponentDestination (next));

				if (abs (dragObjectLeft - (vertical ? current.getY() : current.getX())
					 > abs (dragObjectRight - (vertical ? nextPos.getBottom() : nextPos.getRight()))))
				{
					newIndex = getIndexOfChildComponent (next) + 1;
				}
			}

			if (newIndex == currentIndex)
				break;

			items.removeObject (tc, false);
			removeChildComponent (tc);
			addChildComponent (tc, newIndex);
			items.insert (newIndex, tc);
			updateAllItemPositions (true);
		}
	}
}

void Toolbar::itemDragExit (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr && isParentOf (tc))
	{
		items.removeObject (tc, false);
		removeChildComponent (tc);
		updateAllItemPositions (true);
	}
}

void Toolbar::itemDropped (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr)
		tc->setState (Button::buttonNormal);
}

void Toolbar::mouseDown (const MouseEvent&)
{
}

class ToolbarCustomisationDialog   : public DialogWindow
{
public:
	ToolbarCustomisationDialog (ToolbarItemFactory& factory,
								Toolbar* const toolbar_,
								const int optionFlags)
		: DialogWindow (TRANS("Add/remove items from toolbar"), Colours::white, true, true),
		  toolbar (toolbar_)
	{
		setContentOwned (new CustomiserPanel (factory, toolbar, optionFlags), true);
		setResizable (true, true);
		setResizeLimits (400, 300, 1500, 1000);
		positionNearBar();
	}

	~ToolbarCustomisationDialog()
	{
		toolbar->setEditingActive (false);
	}

	void closeButtonPressed()
	{
		setVisible (false);
	}

	bool canModalEventBeSentToComponent (const Component* comp)
	{
		return toolbar->isParentOf (comp);
	}

	void positionNearBar()
	{
		const Rectangle<int> screenSize (toolbar->getParentMonitorArea());
		const int tbx = toolbar->getScreenX();
		const int tby = toolbar->getScreenY();
		const int gap = 8;

		int x, y;

		if (toolbar->isVertical())
		{
			y = tby;

			if (tbx > screenSize.getCentreX())
				x = tbx - getWidth() - gap;
			else
				x = tbx + toolbar->getWidth() + gap;
		}
		else
		{
			x = tbx + (toolbar->getWidth() - getWidth()) / 2;

			if (tby > screenSize.getCentreY())
				y = tby - getHeight() - gap;
			else
				y = tby + toolbar->getHeight() + gap;
		}

		setTopLeftPosition (x, y);
	}

private:
	Toolbar* const toolbar;

	class CustomiserPanel  : public Component,
							 private ComboBoxListener, // (can't use ComboBox::Listener due to idiotic VC2005 bug)
							 private ButtonListener
	{
	public:
		CustomiserPanel (ToolbarItemFactory& factory_,
						 Toolbar* const toolbar_,
						 const int optionFlags)
		  : factory (factory_),
			toolbar (toolbar_),
			palette (factory_, toolbar_),
			instructions (String::empty, TRANS ("You can drag the items above and drop them onto a toolbar to add them.\n\n"
												"Items on the toolbar can also be dragged around to change their order, or dragged off the edge to delete them.")),
			defaultButton (TRANS ("Restore to default set of items"))
		{
			addAndMakeVisible (&palette);

			if ((optionFlags & (Toolbar::allowIconsOnlyChoice
								 | Toolbar::allowIconsWithTextChoice
								 | Toolbar::allowTextOnlyChoice)) != 0)
			{
				addAndMakeVisible (&styleBox);
				styleBox.setEditableText (false);

				if ((optionFlags & Toolbar::allowIconsOnlyChoice) != 0)     styleBox.addItem (TRANS("Show icons only"), 1);
				if ((optionFlags & Toolbar::allowIconsWithTextChoice) != 0) styleBox.addItem (TRANS("Show icons and descriptions"), 2);
				if ((optionFlags & Toolbar::allowTextOnlyChoice) != 0)      styleBox.addItem (TRANS("Show descriptions only"), 3);

				int selectedStyle = 0;
				switch (toolbar_->getStyle())
				{
					case Toolbar::iconsOnly:        selectedStyle = 1; break;
					case Toolbar::iconsWithText:    selectedStyle = 2; break;
					case Toolbar::textOnly:         selectedStyle = 3; break;
				}

				styleBox.setSelectedId (selectedStyle);

				styleBox.addListener (this);
			}

			if ((optionFlags & Toolbar::showResetToDefaultsButton) != 0)
			{
				addAndMakeVisible (&defaultButton);
				defaultButton.addListener (this);
			}

			addAndMakeVisible (&instructions);
			instructions.setFont (Font (13.0f));

			setSize (500, 300);
		}

		void comboBoxChanged (ComboBox*)
		{
			switch (styleBox.getSelectedId())
			{
				case 1:   toolbar->setStyle (Toolbar::iconsOnly); break;
				case 2:   toolbar->setStyle (Toolbar::iconsWithText); break;
				case 3:   toolbar->setStyle (Toolbar::textOnly); break;
			}

			palette.resized(); // to make it update the styles
		}

		void buttonClicked (Button*)
		{
			toolbar->addDefaultItems (factory);
		}

		void paint (Graphics& g)
		{
			Colour background;

			DialogWindow* const dw = findParentComponentOfClass<DialogWindow>();

			if (dw != nullptr)
				background = dw->getBackgroundColour();

			g.setColour (background.contrasting().withAlpha (0.3f));
			g.fillRect (palette.getX(), palette.getBottom() - 1, palette.getWidth(), 1);
		}

		void resized()
		{
			palette.setBounds (0, 0, getWidth(), getHeight() - 120);
			styleBox.setBounds (10, getHeight() - 110, 200, 22);

			defaultButton.changeWidthToFitText (22);
			defaultButton.setTopLeftPosition (240, getHeight() - 110);

			instructions.setBounds (10, getHeight() - 80, getWidth() - 20, 80);
		}

	private:
		ToolbarItemFactory& factory;
		Toolbar* const toolbar;

		ToolbarItemPalette palette;
		Label instructions;
		ComboBox styleBox;
		TextButton defaultButton;
	};
};

void Toolbar::showCustomisationDialog (ToolbarItemFactory& factory, const int optionFlags)
{
	setEditingActive (true);

	(new ToolbarCustomisationDialog (factory, this, optionFlags))
		->enterModalState (true, 0, true);
}

/*** End of inlined file: juce_Toolbar.cpp ***/


/*** Start of inlined file: juce_ToolbarItemComponent.cpp ***/
ToolbarItemFactory::ToolbarItemFactory()
{
}

ToolbarItemFactory::~ToolbarItemFactory()
{
}

class ItemDragAndDropOverlayComponent    : public Component
{
public:
	ItemDragAndDropOverlayComponent()
		: isDragging (false)
	{
		setAlwaysOnTop (true);
		setRepaintsOnMouseActivity (true);
		setMouseCursor (MouseCursor::DraggingHandCursor);
	}

	void paint (Graphics& g)
	{
		ToolbarItemComponent* const tc = getToolbarItemComponent();

		if (isMouseOverOrDragging()
			  && tc != nullptr
			  && tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
		{
			g.setColour (findColour (Toolbar::editingModeOutlineColourId, true));
			g.drawRect (0, 0, getWidth(), getHeight(),
						jmin (2, (getWidth() - 1) / 2, (getHeight() - 1) / 2));
		}
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		ToolbarItemComponent* const tc = getToolbarItemComponent();

		if (tc != nullptr)
		{
			tc->dragOffsetX = e.x;
			tc->dragOffsetY = e.y;
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (! (isDragging || e.mouseWasClicked()))
		{
			isDragging = true;
			DragAndDropContainer* const dnd = DragAndDropContainer::findParentDragContainerFor (this);

			if (dnd != nullptr)
			{
				dnd->startDragging (Toolbar::toolbarDragDescriptor, getParentComponent(), Image::null, true);

				ToolbarItemComponent* const tc = getToolbarItemComponent();

				if (tc != nullptr)
				{
					tc->isBeingDragged = true;

					if (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
						tc->setVisible (false);
				}
			}
		}
	}

	void mouseUp (const MouseEvent&)
	{
		isDragging = false;
		ToolbarItemComponent* const tc = getToolbarItemComponent();

		if (tc != nullptr)
		{
			tc->isBeingDragged = false;

			Toolbar* const tb = tc->getToolbar();

			if (tb != nullptr)
				tb->updateAllItemPositions (true);
			else if (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
				delete tc;
		}
	}

	void parentSizeChanged()
	{
		setBounds (0, 0, getParentWidth(), getParentHeight());
	}

private:

	bool isDragging;

	ToolbarItemComponent* getToolbarItemComponent() const noexcept
	{
		return dynamic_cast <ToolbarItemComponent*> (getParentComponent());
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ItemDragAndDropOverlayComponent);
};

ToolbarItemComponent::ToolbarItemComponent (const int itemId_,
											const String& labelText,
											const bool isBeingUsedAsAButton_)
	: Button (labelText),
	  itemId (itemId_),
	  mode (normalMode),
	  toolbarStyle (Toolbar::iconsOnly),
	  dragOffsetX (0),
	  dragOffsetY (0),
	  isActive (true),
	  isBeingDragged (false),
	  isBeingUsedAsAButton (isBeingUsedAsAButton_)
{
	// Your item ID can't be 0!
	jassert (itemId_ != 0);
}

ToolbarItemComponent::~ToolbarItemComponent()
{
	overlayComp = nullptr;
}

Toolbar* ToolbarItemComponent::getToolbar() const
{
	return dynamic_cast <Toolbar*> (getParentComponent());
}

bool ToolbarItemComponent::isToolbarVertical() const
{
	const Toolbar* const t = getToolbar();
	return t != nullptr && t->isVertical();
}

void ToolbarItemComponent::setStyle (const Toolbar::ToolbarItemStyle& newStyle)
{
	if (toolbarStyle != newStyle)
	{
		toolbarStyle = newStyle;
		repaint();
		resized();
	}
}

void ToolbarItemComponent::paintButton (Graphics& g, const bool over, const bool down)
{
	if (isBeingUsedAsAButton)
		getLookAndFeel().paintToolbarButtonBackground (g, getWidth(), getHeight(),
													   over, down, *this);

	if (toolbarStyle != Toolbar::iconsOnly)
	{
		const int indent = contentArea.getX();
		int y = indent;
		int h = getHeight() - indent * 2;

		if (toolbarStyle == Toolbar::iconsWithText)
		{
			y = contentArea.getBottom() + indent / 2;
			h -= contentArea.getHeight();
		}

		getLookAndFeel().paintToolbarButtonLabel (g, indent, y, getWidth() - indent * 2, h,
												  getButtonText(), *this);
	}

	if (! contentArea.isEmpty())
	{
		Graphics::ScopedSaveState ss (g);

		g.reduceClipRegion (contentArea);
		g.setOrigin (contentArea.getX(), contentArea.getY());

		paintButtonArea (g, contentArea.getWidth(), contentArea.getHeight(), over, down);
	}
}

void ToolbarItemComponent::resized()
{
	if (toolbarStyle != Toolbar::textOnly)
	{
		const int indent = jmin (proportionOfWidth (0.08f),
								 proportionOfHeight (0.08f));

		contentArea = Rectangle<int> (indent, indent,
									  getWidth() - indent * 2,
									  toolbarStyle == Toolbar::iconsWithText ? proportionOfHeight (0.55f)
																			 : (getHeight() - indent * 2));
	}
	else
	{
		contentArea = Rectangle<int>();
	}

	contentAreaChanged (contentArea);
}

void ToolbarItemComponent::setEditingMode (const ToolbarEditingMode newMode)
{
	if (mode != newMode)
	{
		mode = newMode;
		repaint();

		if (mode == normalMode)
		{
			overlayComp = nullptr;
		}
		else if (overlayComp == nullptr)
		{
			addAndMakeVisible (overlayComp = new ItemDragAndDropOverlayComponent());
			overlayComp->parentSizeChanged();
		}

		resized();
	}
}

/*** End of inlined file: juce_ToolbarItemComponent.cpp ***/


/*** Start of inlined file: juce_ToolbarItemPalette.cpp ***/
ToolbarItemPalette::ToolbarItemPalette (ToolbarItemFactory& factory_,
										Toolbar* const toolbar_)
	: factory (factory_),
	  toolbar (toolbar_)
{
	Component* const itemHolder = new Component();
	viewport.setViewedComponent (itemHolder);

	Array <int> allIds;
	factory.getAllToolbarItemIds (allIds);

	for (int i = 0; i < allIds.size(); ++i)
		addComponent (allIds.getUnchecked (i), -1);

	addAndMakeVisible (&viewport);
}

ToolbarItemPalette::~ToolbarItemPalette()
{
}

void ToolbarItemPalette::addComponent (const int itemId, const int index)
{
	ToolbarItemComponent* const tc = Toolbar::createItem (factory, itemId);
	jassert (tc != nullptr);

	if (tc != nullptr)
	{
		items.insert (index, tc);
		viewport.getViewedComponent()->addAndMakeVisible (tc, index);
		tc->setEditingMode (ToolbarItemComponent::editableOnPalette);
	}
}

void ToolbarItemPalette::replaceComponent (ToolbarItemComponent* const comp)
{
	const int index = items.indexOf (comp);
	jassert (index >= 0);
	items.removeObject (comp, false);

	addComponent (comp->getItemId(), index);
	resized();
}

void ToolbarItemPalette::resized()
{
	viewport.setBoundsInset (BorderSize<int> (1));

	Component* const itemHolder = viewport.getViewedComponent();

	const int indent = 8;
	const int preferredWidth = viewport.getWidth() - viewport.getScrollBarThickness() - indent;
	const int height = toolbar->getThickness();
	int x = indent;
	int y = indent;
	int maxX = 0;

	for (int i = 0; i < items.size(); ++i)
	{
		ToolbarItemComponent* const tc = items.getUnchecked(i);

		tc->setStyle (toolbar->getStyle());

		int preferredSize = 1, minSize = 1, maxSize = 1;

		if (tc->getToolbarItemSizes (height, false, preferredSize, minSize, maxSize))
		{
			if (x + preferredSize > preferredWidth && x > indent)
			{
				x = indent;
				y += height;
			}

			tc->setBounds (x, y, preferredSize, height);

			x += preferredSize + 8;
			maxX = jmax (maxX, x);
		}
	}

	itemHolder->setSize (maxX, y + height + 8);
}

/*** End of inlined file: juce_ToolbarItemPalette.cpp ***/


/*** Start of inlined file: juce_TreeView.cpp ***/
class TreeViewContentComponent  : public Component,
								  public TooltipClient,
								  public AsyncUpdater
{
public:
	TreeViewContentComponent (TreeView& owner_)
		: owner (owner_),
		  buttonUnderMouse (nullptr),
		  isDragging (false)
	{
	}

	void mouseDown (const MouseEvent& e)
	{
		updateButtonUnderMouse (e);

		isDragging = false;
		needSelectionOnMouseUp = false;

		Rectangle<int> pos;
		TreeViewItem* const item = findItemAt (e.y, pos);

		if (item != nullptr)
		{
			// (if the open/close buttons are hidden, we'll treat clicks to the left of the item
			// as selection clicks)
			if (e.x < pos.getX() && owner.openCloseButtonsVisible)
			{
				if (e.x >= pos.getX() - owner.getIndentSize())
					item->setOpen (! item->isOpen());

				// (clicks to the left of an open/close button are ignored)
			}
			else
			{
				// mouse-down inside the body of the item..
				if (! owner.isMultiSelectEnabled())
					item->setSelected (true, true);
				else if (item->isSelected())
					needSelectionOnMouseUp = ! e.mods.isPopupMenu();
				else
					selectBasedOnModifiers (item, e.mods);

				if (e.x >= pos.getX())
					item->itemClicked (e.withNewPosition (e.getPosition() - pos.getPosition()));
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		updateButtonUnderMouse (e);

		if (needSelectionOnMouseUp && e.mouseWasClicked())
		{
			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.y, pos);

			if (item != nullptr)
				selectBasedOnModifiers (item, e.mods);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (e.getNumberOfClicks() != 3)  // ignore triple clicks
		{
			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.y, pos);

			if (item != nullptr && (e.x >= pos.getX() || ! owner.openCloseButtonsVisible))
				item->itemDoubleClicked (e.withNewPosition (e.getPosition() - pos.getPosition()));
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled()
			 && ! (isDragging || e.mouseWasClicked()
					|| e.getDistanceFromDragStart() < 5
					|| e.mods.isPopupMenu()))
		{
			isDragging = true;

			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.getMouseDownY(), pos);

			if (item != nullptr && e.getMouseDownX() >= pos.getX())
			{
				const var dragDescription (item->getDragSourceDescription());

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					DragAndDropContainer* const dragContainer
						= DragAndDropContainer::findParentDragContainerFor (this);

					if (dragContainer != nullptr)
					{
						pos.setSize (pos.getWidth(), item->itemHeight);
						Image dragImage (Component::createComponentSnapshot (pos, true));
						dragImage.multiplyAllAlphas (0.6f);

						Point<int> imageOffset (pos.getPosition() - e.getPosition());
						dragContainer->startDragging (dragDescription, &owner, dragImage, true, &imageOffset);
					}
					else
					{
						// to be able to do a drag-and-drop operation, the treeview needs to
						// be inside a component which is also a DragAndDropContainer.
						jassertfalse;
					}
				}
			}
		}
	}

	void mouseMove (const MouseEvent& e)    { updateButtonUnderMouse (e); }
	void mouseExit (const MouseEvent& e)    { updateButtonUnderMouse (e); }

	void paint (Graphics& g)
	{
		if (owner.rootItem != nullptr)
		{
			owner.recalculateIfNeeded();

			if (! owner.rootItemVisible)
				g.setOrigin (0, -owner.rootItem->itemHeight);

			owner.rootItem->paintRecursively (g, getWidth());
		}
	}

	TreeViewItem* findItemAt (int y, Rectangle<int>& itemPosition) const
	{
		if (owner.rootItem == nullptr)
			return nullptr;

		owner.recalculateIfNeeded();

		if (! owner.rootItemVisible)
			y += owner.rootItem->itemHeight;

		TreeViewItem* const ti = owner.rootItem->findItemRecursively (y);

		if (ti != nullptr)
			itemPosition = ti->getItemPosition (false);

		return ti;
	}

	void updateComponents()
	{
		const int visibleTop = -getY();
		const int visibleBottom = visibleTop + getParentHeight();

		{
			for (int i = items.size(); --i >= 0;)
				items.getUnchecked(i)->shouldKeep = false;
		}

		{
			TreeViewItem* item = owner.rootItem;
			int y = (item != nullptr && ! owner.rootItemVisible) ? -item->itemHeight : 0;

			while (item != nullptr && y < visibleBottom)
			{
				y += item->itemHeight;

				if (y >= visibleTop)
				{
					RowItem* const ri = findItem (item->uid);

					if (ri != nullptr)
					{
						ri->shouldKeep = true;
					}
					else
					{
						Component* const comp = item->createItemComponent();

						if (comp != nullptr)
						{
							items.add (new RowItem (item, comp, item->uid));
							addAndMakeVisible (comp);
						}
					}
				}

				item = item->getNextVisibleItem (true);
			}
		}

		for (int i = items.size(); --i >= 0;)
		{
			RowItem* const ri = items.getUnchecked(i);
			bool keep = false;

			if (isParentOf (ri->component))
			{
				if (ri->shouldKeep)
				{
					Rectangle<int> pos (ri->item->getItemPosition (false));
					pos.setSize (pos.getWidth(), ri->item->itemHeight);

					if (pos.getBottom() >= visibleTop && pos.getY() < visibleBottom)
					{
						keep = true;
						ri->component->setBounds (pos);
					}
				}

				if ((! keep) && isMouseDraggingInChildCompOf (ri->component))
				{
					keep = true;
					ri->component->setSize (0, 0);
				}
			}

			if (! keep)
				items.remove (i);
		}
	}

	bool isMouseOverButton (TreeViewItem* const item) const noexcept
	{
		return item == buttonUnderMouse;
	}

	void resized()
	{
		owner.itemsChanged();
	}

	String getTooltip()
	{
		Rectangle<int> pos;
		TreeViewItem* const item = findItemAt (getMouseXYRelative().getY(), pos);

		if (item != nullptr)
			return item->getTooltip();

		return owner.getTooltip();
	}

private:

	TreeView& owner;

	struct RowItem
	{
		RowItem (TreeViewItem* const item_, Component* const component_, const int itemUID)
			: component (component_), item (item_), uid (itemUID), shouldKeep (true)
		{
		}

		~RowItem()
		{
			delete component.get();
		}

		WeakReference<Component> component;
		TreeViewItem* item;
		int uid;
		bool shouldKeep;
	};

	OwnedArray <RowItem> items;

	TreeViewItem* buttonUnderMouse;
	bool isDragging, needSelectionOnMouseUp;

	void selectBasedOnModifiers (TreeViewItem* const item, const ModifierKeys& modifiers)
	{
		TreeViewItem* firstSelected = nullptr;

		if (modifiers.isShiftDown() && ((firstSelected = owner.getSelectedItem (0)) != nullptr))
		{
			TreeViewItem* const lastSelected = owner.getSelectedItem (owner.getNumSelectedItems() - 1);
			jassert (lastSelected != nullptr);

			int rowStart = firstSelected->getRowNumberInTree();
			int rowEnd = lastSelected->getRowNumberInTree();
			if (rowStart > rowEnd)
				std::swap (rowStart, rowEnd);

			int ourRow = item->getRowNumberInTree();
			int otherEnd = ourRow < rowEnd ? rowStart : rowEnd;

			if (ourRow > otherEnd)
				std::swap (ourRow, otherEnd);

			for (int i = ourRow; i <= otherEnd; ++i)
				owner.getItemOnRow (i)->setSelected (true, false);
		}
		else
		{
			const bool cmd = modifiers.isCommandDown();
			item->setSelected ((! cmd) || ! item->isSelected(), ! cmd);
		}
	}

	bool containsItem (TreeViewItem* const item) const noexcept
	{
		for (int i = items.size(); --i >= 0;)
			if (items.getUnchecked(i)->item == item)
				return true;

		return false;
	}

	RowItem* findItem (const int uid) const noexcept
	{
		for (int i = items.size(); --i >= 0;)
		{
			RowItem* const ri = items.getUnchecked(i);
			if (ri->uid == uid)
				return ri;
		}

		return nullptr;
	}

	void updateButtonUnderMouse (const MouseEvent& e)
	{
		TreeViewItem* newItem = nullptr;

		if (owner.openCloseButtonsVisible)
		{
			Rectangle<int> pos;
			TreeViewItem* item = findItemAt (e.y, pos);

			if (item != nullptr && e.x < pos.getX() && e.x >= pos.getX() - owner.getIndentSize())
			{
				newItem = item;

				if (! newItem->mightContainSubItems())
					newItem = nullptr;
			}
		}

		if (buttonUnderMouse != newItem)
		{
			repaintButtonUnderMouse();
			buttonUnderMouse = newItem;
			repaintButtonUnderMouse();
		}
	}

	void repaintButtonUnderMouse()
	{
		if (buttonUnderMouse != nullptr && containsItem (buttonUnderMouse))
		{
			const Rectangle<int> r (buttonUnderMouse->getItemPosition (false));
			repaint (0, r.getY(), r.getX(), buttonUnderMouse->getItemHeight());
		}
	}

	static bool isMouseDraggingInChildCompOf (Component* const comp)
	{
		for (int i = Desktop::getInstance().getNumMouseSources(); --i >= 0;)
		{
			MouseInputSource* const source = Desktop::getInstance().getMouseSource(i);

			if (source->isDragging())
			{
				Component* const underMouse = source->getComponentUnderMouse();

				if (underMouse != nullptr && (comp == underMouse || comp->isParentOf (underMouse)))
					return true;
			}
		}

		return false;
	}

	void handleAsyncUpdate()
	{
		owner.recalculateIfNeeded();
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeViewContentComponent);
};

class TreeView::TreeViewport  : public Viewport
{
public:
	TreeViewport() noexcept : lastX (-1)    {}

	void updateComponents (const bool triggerResize)
	{
		TreeViewContentComponent* const tvc = getContentComp();

		if (tvc != nullptr)
		{
			if (triggerResize)
				tvc->resized();
			else
				tvc->updateComponents();
		}

		repaint();
	}

	void visibleAreaChanged (const Rectangle<int>& newVisibleArea)
	{
		const bool hasScrolledSideways = (newVisibleArea.getX() != lastX);
		lastX = newVisibleArea.getX();
		updateComponents (hasScrolledSideways);
	}

	TreeViewContentComponent* getContentComp() const noexcept
	{
		return static_cast <TreeViewContentComponent*> (getViewedComponent());
	}

	bool keyPressed (const KeyPress& key)
	{
		Component* const tree = getParentComponent();

		return (tree != nullptr && tree->keyPressed (key))
				 || Viewport::keyPressed (key);
	}

private:
	int lastX;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeViewport);
};

TreeView::TreeView (const String& name)
	: Component (name),
	  viewport (new TreeViewport()),
	  rootItem (nullptr),
	  indentSize (24),
	  defaultOpenness (false),
	  needsRecalculating (true),
	  rootItemVisible (true),
	  multiSelectEnabled (false),
	  openCloseButtonsVisible (true)
{
	addAndMakeVisible (viewport);
	viewport->setViewedComponent (new TreeViewContentComponent (*this));
	setWantsKeyboardFocus (true);
}

TreeView::~TreeView()
{
	if (rootItem != nullptr)
		rootItem->setOwnerView (nullptr);
}

void TreeView::setRootItem (TreeViewItem* const newRootItem)
{
	if (rootItem != newRootItem)
	{
		if (newRootItem != nullptr)
		{
			jassert (newRootItem->ownerView == nullptr); // can't use a tree item in more than one tree at once..

			if (newRootItem->ownerView != nullptr)
				newRootItem->ownerView->setRootItem (nullptr);
		}

		if (rootItem != nullptr)
			rootItem->setOwnerView (nullptr);

		rootItem = newRootItem;

		if (newRootItem != nullptr)
			newRootItem->setOwnerView (this);

		needsRecalculating = true;
		recalculateIfNeeded();

		if (rootItem != nullptr && (defaultOpenness || ! rootItemVisible))
		{
			rootItem->setOpen (false); // force a re-open
			rootItem->setOpen (true);
		}
	}
}

void TreeView::deleteRootItem()
{
	const ScopedPointer <TreeViewItem> deleter (rootItem);
	setRootItem (nullptr);
}

void TreeView::setRootItemVisible (const bool shouldBeVisible)
{
	rootItemVisible = shouldBeVisible;

	if (rootItem != nullptr && (defaultOpenness || ! rootItemVisible))
	{
		rootItem->setOpen (false); // force a re-open
		rootItem->setOpen (true);
	}

	itemsChanged();
}

void TreeView::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	repaint();
}

void TreeView::setIndentSize (const int newIndentSize)
{
	if (indentSize != newIndentSize)
	{
		indentSize = newIndentSize;
		resized();
	}
}

void TreeView::setDefaultOpenness (const bool isOpenByDefault)
{
	if (defaultOpenness != isOpenByDefault)
	{
		defaultOpenness = isOpenByDefault;
		itemsChanged();
	}
}

void TreeView::setMultiSelectEnabled (const bool canMultiSelect)
{
	multiSelectEnabled = canMultiSelect;
}

void TreeView::setOpenCloseButtonsVisible (const bool shouldBeVisible)
{
	if (openCloseButtonsVisible != shouldBeVisible)
	{
		openCloseButtonsVisible = shouldBeVisible;
		itemsChanged();
	}
}

Viewport* TreeView::getViewport() const noexcept
{
	return viewport;
}

void TreeView::clearSelectedItems()
{
	if (rootItem != nullptr)
		rootItem->deselectAllRecursively();
}

int TreeView::getNumSelectedItems (int maximumDepthToSearchTo) const noexcept
{
	return rootItem != nullptr ? rootItem->countSelectedItemsRecursively (maximumDepthToSearchTo) : 0;
}

TreeViewItem* TreeView::getSelectedItem (const int index) const noexcept
{
	return rootItem != nullptr ? rootItem->getSelectedItemWithIndex (index) : 0;
}

int TreeView::getNumRowsInTree() const
{
	if (rootItem != nullptr)
		return rootItem->getNumRows() - (rootItemVisible ? 0 : 1);

	return 0;
}

TreeViewItem* TreeView::getItemOnRow (int index) const
{
	if (! rootItemVisible)
		++index;

	if (rootItem != nullptr && index >= 0)
		return rootItem->getItemOnRow (index);

	return nullptr;
}

TreeViewItem* TreeView::getItemAt (int y) const noexcept
{
	TreeViewContentComponent* const tc = viewport->getContentComp();
	Rectangle<int> pos;
	return tc->findItemAt (tc->getLocalPoint (this, Point<int> (0, y)).getY(), pos);
}

TreeViewItem* TreeView::findItemFromIdentifierString (const String& identifierString) const
{
	if (rootItem == nullptr)
		return nullptr;

	return rootItem->findItemFromIdentifierString (identifierString);
}

static void addAllSelectedItemIds (TreeViewItem* item, XmlElement& parent)
{
	if (item->isSelected())
		parent.createNewChildElement ("SELECTED")->setAttribute ("id", item->getItemIdentifierString());

	const int numSubItems = item->getNumSubItems();

	for (int i = 0; i < numSubItems; ++i)
		addAllSelectedItemIds (item->getSubItem(i), parent);
}

XmlElement* TreeView::getOpennessState (const bool alsoIncludeScrollPosition) const
{
	XmlElement* e = nullptr;

	if (rootItem != nullptr)
	{
		e = rootItem->getOpennessState();

		if (e != nullptr)
		{
			if (alsoIncludeScrollPosition)
				e->setAttribute ("scrollPos", viewport->getViewPositionY());

			addAllSelectedItemIds (rootItem, *e);
		}
	}

	return e;
}

void TreeView::restoreOpennessState (const XmlElement& newState, const bool restoreStoredSelection)
{
	if (rootItem != nullptr)
	{
		rootItem->restoreOpennessState (newState);

		if (newState.hasAttribute ("scrollPos"))
			viewport->setViewPosition (viewport->getViewPositionX(),
									   newState.getIntAttribute ("scrollPos"));

		if (restoreStoredSelection)
		{
			clearSelectedItems();

			forEachXmlChildElementWithTagName (newState, e, "SELECTED")
			{
				TreeViewItem* const item = rootItem->findItemFromIdentifierString (e->getStringAttribute ("id"));

				if (item != nullptr)
					item->setSelected (true, false);
			}
		}
	}
}

void TreeView::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));
}

void TreeView::resized()
{
	viewport->setBounds (getLocalBounds());

	itemsChanged();
	recalculateIfNeeded();
}

void TreeView::enablementChanged()
{
	repaint();
}

void TreeView::moveSelectedRow (const int delta)
{
	int rowSelected = 0;

	TreeViewItem* const firstSelected = getSelectedItem (0);
	if (firstSelected != nullptr)
		rowSelected = firstSelected->getRowNumberInTree();

	rowSelected = jlimit (0, getNumRowsInTree() - 1, rowSelected + delta);

	for (;;)
	{
		TreeViewItem* item = getItemOnRow (rowSelected);

		if (item != nullptr)
		{
			if (! item->canBeSelected())
			{
				// if the row we want to highlight doesn't allow it, try skipping
				// to the next item..
				const int nextRowToTry = jlimit (0, getNumRowsInTree() - 1,
												 rowSelected + (delta < 0 ? -1 : 1));

				if (rowSelected != nextRowToTry)
				{
					rowSelected = nextRowToTry;
					continue;
				}
				else
				{
					break;
				}
			}

			item->setSelected (true, true);

			scrollToKeepItemVisible (item);
		}

		break;
	}
}

void TreeView::scrollToKeepItemVisible (TreeViewItem* item)
{
	if (item != nullptr && item->ownerView == this)
	{
		recalculateIfNeeded();

		item = item->getDeepestOpenParentItem();

		const int y = item->y;
		const int viewTop = viewport->getViewPositionY();

		if (y < viewTop)
		{
			viewport->setViewPosition (viewport->getViewPositionX(), y);
		}
		else if (y + item->itemHeight > viewTop + viewport->getViewHeight())
		{
			viewport->setViewPosition (viewport->getViewPositionX(),
									   (y + item->itemHeight) - viewport->getViewHeight());
		}
	}
}

bool TreeView::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::upKey))
	{
		moveSelectedRow (-1);
	}
	else if (key.isKeyCode (KeyPress::downKey))
	{
		moveSelectedRow (1);
	}
	else if (key.isKeyCode (KeyPress::pageDownKey) || key.isKeyCode (KeyPress::pageUpKey))
	{
		if (rootItem != nullptr)
		{
			int rowsOnScreen = getHeight() / jmax (1, rootItem->itemHeight);

			if (key.isKeyCode (KeyPress::pageUpKey))
				rowsOnScreen = -rowsOnScreen;

			if (rowsOnScreen != 0)
				moveSelectedRow (rowsOnScreen);
		}
	}
	else if (key.isKeyCode (KeyPress::homeKey))
	{
		moveSelectedRow (-0x3fffffff);
	}
	else if (key.isKeyCode (KeyPress::endKey))
	{
		moveSelectedRow (0x3fffffff);
	}
	else if (key.isKeyCode (KeyPress::returnKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);
		if (firstSelected != nullptr)
			firstSelected->setOpen (! firstSelected->isOpen());
	}
	else if (key.isKeyCode (KeyPress::leftKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);

		if (firstSelected != nullptr)
		{
			if (firstSelected->isOpen())
			{
				firstSelected->setOpen (false);
			}
			else
			{
				TreeViewItem* parent = firstSelected->parentItem;

				if ((! rootItemVisible) && parent == rootItem)
					parent = nullptr;

				if (parent != nullptr)
				{
					parent->setSelected (true, true);
					scrollToKeepItemVisible (parent);
				}
			}
		}
	}
	else if (key.isKeyCode (KeyPress::rightKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);

		if (firstSelected != nullptr)
		{
			if (firstSelected->isOpen() || ! firstSelected->mightContainSubItems())
				moveSelectedRow (1);
			else
				firstSelected->setOpen (true);
		}
	}
	else
	{
		return false;
	}

	return true;
}

void TreeView::itemsChanged() noexcept
{
	needsRecalculating = true;
	repaint();
	viewport->getContentComp()->triggerAsyncUpdate();
}

void TreeView::recalculateIfNeeded()
{
	if (needsRecalculating)
	{
		needsRecalculating = false;

		const ScopedLock sl (nodeAlterationLock);

		if (rootItem != nullptr)
			rootItem->updatePositions (rootItemVisible ? 0 : -rootItem->itemHeight);

		viewport->updateComponents (false);

		if (rootItem != nullptr)
		{
			viewport->getViewedComponent()
				->setSize (jmax (viewport->getMaximumVisibleWidth(), rootItem->totalWidth),
						   rootItem->totalHeight - (rootItemVisible ? 0 : rootItem->itemHeight));
		}
		else
		{
			viewport->getViewedComponent()->setSize (0, 0);
		}
	}
}

class TreeView::InsertPointHighlight   : public Component
{
public:
	InsertPointHighlight()
		: lastItem (nullptr)
	{
		setSize (100, 12);
		setAlwaysOnTop (true);
		setInterceptsMouseClicks (false, false);
	}

	void setTargetPosition (TreeViewItem* const item, int insertIndex, const int x, const int y, const int width) noexcept
	{
		lastItem = item;
		lastIndex = insertIndex;
		const int offset = getHeight() / 2;
		setBounds (x - offset, y - offset, width - (x - offset), getHeight());
	}

	void paint (Graphics& g)
	{
		Path p;
		const float h = (float) getHeight();
		p.addEllipse (2.0f, 2.0f, h - 4.0f, h - 4.0f);
		p.startNewSubPath (h - 2.0f, h / 2.0f);
		p.lineTo ((float) getWidth(), h / 2.0f);

		g.setColour (findColour (TreeView::dragAndDropIndicatorColourId, true));
		g.strokePath (p, PathStrokeType (2.0f));
	}

	TreeViewItem* lastItem;
	int lastIndex;

private:
	JUCE_DECLARE_NON_COPYABLE (InsertPointHighlight);
};

class TreeView::TargetGroupHighlight   : public Component
{
public:
	TargetGroupHighlight()
	{
		setAlwaysOnTop (true);
		setInterceptsMouseClicks (false, false);
	}

	void setTargetPosition (TreeViewItem* const item) noexcept
	{
		Rectangle<int> r (item->getItemPosition (true));
		r.setHeight (item->getItemHeight());
		setBounds (r);
	}

	void paint (Graphics& g)
	{
		g.setColour (findColour (TreeView::dragAndDropIndicatorColourId, true));
		g.drawRoundedRectangle (1.0f, 1.0f, getWidth() - 2.0f, getHeight() - 2.0f, 3.0f, 2.0f);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (TargetGroupHighlight);
};

void TreeView::showDragHighlight (TreeViewItem* item, int insertIndex, int x, int y) noexcept
{
	beginDragAutoRepeat (100);

	if (dragInsertPointHighlight == nullptr)
	{
		addAndMakeVisible (dragInsertPointHighlight = new InsertPointHighlight());
		addAndMakeVisible (dragTargetGroupHighlight = new TargetGroupHighlight());
	}

	dragInsertPointHighlight->setTargetPosition (item, insertIndex, x, y, viewport->getViewWidth());
	dragTargetGroupHighlight->setTargetPosition (item);
}

void TreeView::hideDragHighlight() noexcept
{
	dragInsertPointHighlight = nullptr;
	dragTargetGroupHighlight = nullptr;
}

TreeViewItem* TreeView::getInsertPosition (int& x, int& y, int& insertIndex,
										   const StringArray& files, const SourceDetails& dragSourceDetails) const noexcept
{
	x = dragSourceDetails.localPosition.getX();
	y = dragSourceDetails.localPosition.getY();
	insertIndex = 0;
	TreeViewItem* item = getItemAt (y);

	if (item == nullptr)
		return nullptr;

	Rectangle<int> itemPos (item->getItemPosition (true));
	insertIndex = item->getIndexInParent();
	const int oldY = y;
	y = itemPos.getY();

	if (item->getNumSubItems() == 0 || ! item->isOpen())
	{
		if (files.size() > 0 ? item->isInterestedInFileDrag (files)
							 : item->isInterestedInDragSource (dragSourceDetails))
		{
			// Check if we're trying to drag into an empty group item..
			if (oldY > itemPos.getY() + itemPos.getHeight() / 4
				 && oldY < itemPos.getBottom() - itemPos.getHeight() / 4)
			{
				insertIndex = 0;
				x = itemPos.getX() + getIndentSize();
				y = itemPos.getBottom();
				return item;
			}
		}
	}

	if (oldY > itemPos.getCentreY())
	{
		y += item->getItemHeight();

		while (item->isLastOfSiblings() && item->parentItem != nullptr
				&& item->parentItem->parentItem != nullptr)
		{
			if (x > itemPos.getX())
				break;

			item = item->parentItem;
			itemPos = item->getItemPosition (true);
			insertIndex = item->getIndexInParent();
		}

		++insertIndex;
	}

	x = itemPos.getX();
	return item->parentItem;
}

void TreeView::handleDrag (const StringArray& files, const SourceDetails& dragSourceDetails)
{
	const bool scrolled = viewport->autoScroll (dragSourceDetails.localPosition.getX(),
												dragSourceDetails.localPosition.getY(), 20, 10);

	int insertIndex, x, y;
	TreeViewItem* const item = getInsertPosition (x, y, insertIndex, files, dragSourceDetails);

	if (item != nullptr)
	{
		if (scrolled || dragInsertPointHighlight == nullptr
			 || dragInsertPointHighlight->lastItem != item
			 || dragInsertPointHighlight->lastIndex != insertIndex)
		{
			if (files.size() > 0 ? item->isInterestedInFileDrag (files)
								 : item->isInterestedInDragSource (dragSourceDetails))
				showDragHighlight (item, insertIndex, x, y);
			else
				hideDragHighlight();
		}
	}
	else
	{
		hideDragHighlight();
	}
}

void TreeView::handleDrop (const StringArray& files, const SourceDetails& dragSourceDetails)
{
	hideDragHighlight();

	int insertIndex, x, y;
	TreeViewItem* item = getInsertPosition (x, y, insertIndex, files, dragSourceDetails);

	if (item == nullptr)
	{
		insertIndex = 0;
		item = rootItem;
	}

	if (item != nullptr)
	{
		if (files.size() > 0)
		{
			if (item->isInterestedInFileDrag (files))
				item->filesDropped (files, insertIndex);
		}
		else
		{
			if (item->isInterestedInDragSource (dragSourceDetails))
				item->itemDropped (dragSourceDetails, insertIndex);
		}
	}
}

bool TreeView::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void TreeView::fileDragEnter (const StringArray& files, int x, int y)
{
	fileDragMove (files, x, y);
}

void TreeView::fileDragMove (const StringArray& files, int x, int y)
{
	handleDrag (files, SourceDetails (String::empty, 0, Point<int> (x, y)));
}

void TreeView::fileDragExit (const StringArray&)
{
	hideDragHighlight();
}

void TreeView::filesDropped (const StringArray& files, int x, int y)
{
	handleDrop (files, SourceDetails (String::empty, 0, Point<int> (x, y)));
}

bool TreeView::isInterestedInDragSource (const SourceDetails& /*dragSourceDetails*/)
{
	return true;
}

void TreeView::itemDragEnter (const SourceDetails& dragSourceDetails)
{
	itemDragMove (dragSourceDetails);
}

void TreeView::itemDragMove (const SourceDetails& dragSourceDetails)
{
	handleDrag (StringArray(), dragSourceDetails);
}

void TreeView::itemDragExit (const SourceDetails& /*dragSourceDetails*/)
{
	hideDragHighlight();
}

void TreeView::itemDropped (const SourceDetails& dragSourceDetails)
{
	handleDrop (StringArray(), dragSourceDetails);
}

enum TreeViewOpenness
{
	opennessDefault = 0,
	opennessClosed = 1,
	opennessOpen = 2
};

TreeViewItem::TreeViewItem()
	: ownerView (nullptr),
	  parentItem (nullptr),
	  y (0),
	  itemHeight (0),
	  totalHeight (0),
	  selected (false),
	  redrawNeeded (true),
	  drawLinesInside (true),
	  drawsInLeftMargin (false),
	  openness (opennessDefault)
{
	static int nextUID = 0;
	uid = nextUID++;
}

TreeViewItem::~TreeViewItem()
{
}

String TreeViewItem::getUniqueName() const
{
	return String::empty;
}

void TreeViewItem::itemOpennessChanged (bool)
{
}

int TreeViewItem::getNumSubItems() const noexcept
{
	return subItems.size();
}

TreeViewItem* TreeViewItem::getSubItem (const int index) const noexcept
{
	return subItems [index];
}

void TreeViewItem::clearSubItems()
{
	if (subItems.size() > 0)
	{
		if (ownerView != nullptr)
		{
			const ScopedLock sl (ownerView->nodeAlterationLock);
			subItems.clear();
			treeHasChanged();
		}
		else
		{
			subItems.clear();
		}
	}
}

void TreeViewItem::addSubItem (TreeViewItem* const newItem, const int insertPosition)
{
	if (newItem != nullptr)
	{
		newItem->parentItem = this;
		newItem->setOwnerView (ownerView);
		newItem->y = 0;
		newItem->itemHeight = newItem->getItemHeight();
		newItem->totalHeight = 0;
		newItem->itemWidth = newItem->getItemWidth();
		newItem->totalWidth = 0;

		if (ownerView != nullptr)
		{
			const ScopedLock sl (ownerView->nodeAlterationLock);
			subItems.insert (insertPosition, newItem);
			treeHasChanged();

			if (newItem->isOpen())
				newItem->itemOpennessChanged (true);
		}
		else
		{
			subItems.insert (insertPosition, newItem);

			if (newItem->isOpen())
				newItem->itemOpennessChanged (true);
		}
	}
}

void TreeViewItem::removeSubItem (const int index, const bool deleteItem)
{
	if (ownerView != nullptr)
	{
		const ScopedLock sl (ownerView->nodeAlterationLock);

		if (isPositiveAndBelow (index, subItems.size()))
		{
			subItems.remove (index, deleteItem);
			treeHasChanged();
		}
	}
	else
	{
		subItems.remove (index, deleteItem);
	}
}

bool TreeViewItem::isOpen() const noexcept
{
	if (openness == opennessDefault)
		return ownerView != nullptr && ownerView->defaultOpenness;
	else
		return openness == opennessOpen;
}

void TreeViewItem::setOpen (const bool shouldBeOpen)
{
	if (isOpen() != shouldBeOpen)
	{
		openness = shouldBeOpen ? opennessOpen
								: opennessClosed;
		treeHasChanged();

		itemOpennessChanged (isOpen());
	}
}

bool TreeViewItem::isSelected() const noexcept
{
	return selected;
}

void TreeViewItem::deselectAllRecursively()
{
	setSelected (false, false);

	for (int i = 0; i < subItems.size(); ++i)
		subItems.getUnchecked(i)->deselectAllRecursively();
}

void TreeViewItem::setSelected (const bool shouldBeSelected,
								const bool deselectOtherItemsFirst)
{
	if (shouldBeSelected && ! canBeSelected())
		return;

	if (deselectOtherItemsFirst)
		getTopLevelItem()->deselectAllRecursively();

	if (shouldBeSelected != selected)
	{
		selected = shouldBeSelected;
		if (ownerView != nullptr)
			ownerView->repaint();

		itemSelectionChanged (shouldBeSelected);
	}
}

void TreeViewItem::paintItem (Graphics&, int, int)
{
}

void TreeViewItem::paintOpenCloseButton (Graphics& g, int width, int height, bool isMouseOver)
{
	ownerView->getLookAndFeel()
	   .drawTreeviewPlusMinusBox (g, 0, 0, width, height, ! isOpen(), isMouseOver);
}

void TreeViewItem::itemClicked (const MouseEvent&)
{
}

void TreeViewItem::itemDoubleClicked (const MouseEvent&)
{
	if (mightContainSubItems())
		setOpen (! isOpen());
}

void TreeViewItem::itemSelectionChanged (bool)
{
}

String TreeViewItem::getTooltip()
{
	return String::empty;
}

var TreeViewItem::getDragSourceDescription()
{
	return var::null;
}

bool TreeViewItem::isInterestedInFileDrag (const StringArray&)
{
	return false;
}

void TreeViewItem::filesDropped (const StringArray& /*files*/, int /*insertIndex*/)
{
}

bool TreeViewItem::isInterestedInDragSource (const DragAndDropTarget::SourceDetails& /*dragSourceDetails*/)
{
	return false;
}

void TreeViewItem::itemDropped (const DragAndDropTarget::SourceDetails& /*dragSourceDetails*/, int /*insertIndex*/)
{
}

Rectangle<int> TreeViewItem::getItemPosition (const bool relativeToTreeViewTopLeft) const noexcept
{
	const int indentX = getIndentX();
	int width = itemWidth;

	if (ownerView != nullptr && width < 0)
		width = ownerView->viewport->getViewWidth() - indentX;

	Rectangle<int> r (indentX, y, jmax (0, width), totalHeight);

	if (relativeToTreeViewTopLeft)
		r -= ownerView->viewport->getViewPosition();

	return r;
}

void TreeViewItem::treeHasChanged() const noexcept
{
	if (ownerView != nullptr)
		ownerView->itemsChanged();
}

void TreeViewItem::repaintItem() const
{
	if (ownerView != nullptr && areAllParentsOpen())
	{
		Rectangle<int> r (getItemPosition (true));
		r.setLeft (0);
		ownerView->viewport->repaint (r);
	}
}

bool TreeViewItem::areAllParentsOpen() const noexcept
{
	return parentItem == nullptr
			|| (parentItem->isOpen() && parentItem->areAllParentsOpen());
}

void TreeViewItem::updatePositions (int newY)
{
	y = newY;
	itemHeight = getItemHeight();
	totalHeight = itemHeight;
	itemWidth = getItemWidth();
	totalWidth = jmax (itemWidth, 0) + getIndentX();

	if (isOpen())
	{
		newY += totalHeight;

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const ti = subItems.getUnchecked(i);

			ti->updatePositions (newY);
			newY += ti->totalHeight;
			totalHeight += ti->totalHeight;
			totalWidth = jmax (totalWidth, ti->totalWidth);
		}
	}
}

TreeViewItem* TreeViewItem::getDeepestOpenParentItem() noexcept
{
	TreeViewItem* result = this;
	TreeViewItem* item = this;

	while (item->parentItem != nullptr)
	{
		item = item->parentItem;

		if (! item->isOpen())
			result = item;
	}

	return result;
}

void TreeViewItem::setOwnerView (TreeView* const newOwner) noexcept
{
	ownerView = newOwner;

	for (int i = subItems.size(); --i >= 0;)
		subItems.getUnchecked(i)->setOwnerView (newOwner);
}

int TreeViewItem::getIndentX() const noexcept
{
	const int indentWidth = ownerView->getIndentSize();
	int x = ownerView->rootItemVisible ? indentWidth : 0;

	if (! ownerView->openCloseButtonsVisible)
		x -= indentWidth;

	TreeViewItem* p = parentItem;

	while (p != nullptr)
	{
		x += indentWidth;
		p = p->parentItem;
	}

	return x;
}

void TreeViewItem::setDrawsInLeftMargin (bool canDrawInLeftMargin) noexcept
{
	drawsInLeftMargin = canDrawInLeftMargin;
}

namespace TreeViewHelpers
{
	static int calculateDepth (const TreeViewItem* item, const bool rootIsVisible) noexcept
	{
		jassert (item != nullptr);
		int depth = rootIsVisible ? 0 : -1;

		for (const TreeViewItem* p = item->getParentItem(); p != nullptr; p = p->getParentItem())
			++depth;

		return depth;
	}
}

void TreeViewItem::paintRecursively (Graphics& g, int width)
{
	jassert (ownerView != nullptr);
	if (ownerView == nullptr)
		return;

	const int indent = getIndentX();
	const int itemW = itemWidth < 0 ? width - indent : itemWidth;

	{
		Graphics::ScopedSaveState ss (g);
		g.setOrigin (indent, 0);

		if (g.reduceClipRegion (drawsInLeftMargin ? -indent : 0, 0,
								drawsInLeftMargin ? itemW + indent : itemW, itemHeight))
			paintItem (g, itemW, itemHeight);
	}

	g.setColour (ownerView->findColour (TreeView::linesColourId));

	const float halfH = itemHeight * 0.5f;
	const int indentWidth = ownerView->getIndentSize();
	const int depth = TreeViewHelpers::calculateDepth (this, ownerView->rootItemVisible);

	if (depth >= 0 && ownerView->openCloseButtonsVisible)
	{
		float x = (depth + 0.5f) * indentWidth;

		if (parentItem != nullptr && parentItem->drawLinesInside)
			g.drawLine (x, 0, x, isLastOfSiblings() ? halfH : (float) itemHeight);

		if ((parentItem != nullptr && parentItem->drawLinesInside)
			 || (parentItem == nullptr && drawLinesInside))
			g.drawLine (x, halfH, x + indentWidth / 2, halfH);

		{
			TreeViewItem* p = parentItem;
			int d = depth;

			while (p != nullptr && --d >= 0)
			{
				x -= (float) indentWidth;

				if ((p->parentItem == nullptr || p->parentItem->drawLinesInside)
					 && ! p->isLastOfSiblings())
				{
					g.drawLine (x, 0, x, (float) itemHeight);
				}

				p = p->parentItem;
			}
		}

		if (mightContainSubItems())
		{
			Graphics::ScopedSaveState ss (g);

			g.setOrigin (depth * indentWidth, 0);
			g.reduceClipRegion (0, 0, indentWidth, itemHeight);

			paintOpenCloseButton (g, indentWidth, itemHeight,
								  ownerView->viewport->getContentComp()->isMouseOverButton (this));
		}
	}

	if (isOpen())
	{
		const Rectangle<int> clip (g.getClipBounds());

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const ti = subItems.getUnchecked(i);

			const int relY = ti->y - y;

			if (relY >= clip.getBottom())
				break;

			if (relY + ti->totalHeight >= clip.getY())
			{
				Graphics::ScopedSaveState ss (g);

				g.setOrigin (0, relY);

				if (g.reduceClipRegion (0, 0, width, ti->totalHeight))
					ti->paintRecursively (g, width);
			}
		}
	}
}

bool TreeViewItem::isLastOfSiblings() const noexcept
{
	return parentItem == nullptr
			|| parentItem->subItems.getLast() == this;
}

int TreeViewItem::getIndexInParent() const noexcept
{
	return parentItem == nullptr ? 0
								 : parentItem->subItems.indexOf (this);
}

TreeViewItem* TreeViewItem::getTopLevelItem() noexcept
{
	return parentItem == nullptr ? this
								 : parentItem->getTopLevelItem();
}

int TreeViewItem::getNumRows() const noexcept
{
	int num = 1;

	if (isOpen())
	{
		for (int i = subItems.size(); --i >= 0;)
			num += subItems.getUnchecked(i)->getNumRows();
	}

	return num;
}

TreeViewItem* TreeViewItem::getItemOnRow (int index) noexcept
{
	if (index == 0)
		return this;

	if (index > 0 && isOpen())
	{
		--index;

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const item = subItems.getUnchecked(i);

			if (index == 0)
				return item;

			const int numRows = item->getNumRows();

			if (numRows > index)
				return item->getItemOnRow (index);

			index -= numRows;
		}
	}

	return nullptr;
}

TreeViewItem* TreeViewItem::findItemRecursively (int targetY) noexcept
{
	if (isPositiveAndBelow (targetY, totalHeight))
	{
		const int h = itemHeight;

		if (targetY < h)
			return this;

		if (isOpen())
		{
			targetY -= h;

			for (int i = 0; i < subItems.size(); ++i)
			{
				TreeViewItem* const ti = subItems.getUnchecked(i);

				if (targetY < ti->totalHeight)
					return ti->findItemRecursively (targetY);

				targetY -= ti->totalHeight;
			}
		}
	}

	return nullptr;
}

int TreeViewItem::countSelectedItemsRecursively (int depth) const noexcept
{
	int total = isSelected() ? 1 : 0;

	if (depth != 0)
		for (int i = subItems.size(); --i >= 0;)
			total += subItems.getUnchecked(i)->countSelectedItemsRecursively (depth - 1);

	return total;
}

TreeViewItem* TreeViewItem::getSelectedItemWithIndex (int index) noexcept
{
	if (isSelected())
	{
		if (index == 0)
			return this;

		--index;
	}

	if (index >= 0)
	{
		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const item = subItems.getUnchecked(i);

			TreeViewItem* const found = item->getSelectedItemWithIndex (index);

			if (found != nullptr)
				return found;

			index -= item->countSelectedItemsRecursively (-1);
		}
	}

	return nullptr;
}

int TreeViewItem::getRowNumberInTree() const noexcept
{
	if (parentItem != nullptr && ownerView != nullptr)
	{
		int n = 1 + parentItem->getRowNumberInTree();

		int ourIndex = parentItem->subItems.indexOf (this);
		jassert (ourIndex >= 0);

		while (--ourIndex >= 0)
			n += parentItem->subItems [ourIndex]->getNumRows();

		if (parentItem->parentItem == nullptr
			 && ! ownerView->rootItemVisible)
			--n;

		return n;
	}
	else
	{
		return 0;
	}
}

void TreeViewItem::setLinesDrawnForSubItems (const bool drawLines) noexcept
{
	drawLinesInside = drawLines;
}

TreeViewItem* TreeViewItem::getNextVisibleItem (const bool recurse) const noexcept
{
	if (recurse && isOpen() && subItems.size() > 0)
		return subItems [0];

	if (parentItem != nullptr)
	{
		const int nextIndex = parentItem->subItems.indexOf (this) + 1;

		if (nextIndex >= parentItem->subItems.size())
			return parentItem->getNextVisibleItem (false);

		return parentItem->subItems [nextIndex];
	}

	return nullptr;
}

String TreeViewItem::getItemIdentifierString() const
{
	String s;

	if (parentItem != nullptr)
		s = parentItem->getItemIdentifierString();

	return s + "/" + getUniqueName().replaceCharacter ('/', '\\');
}

TreeViewItem* TreeViewItem::findItemFromIdentifierString (const String& identifierString)
{
	const String thisId (getUniqueName());

	if (thisId == identifierString)
		return this;

	if (identifierString.startsWith (thisId + "/"))
	{
		const String remainingPath (identifierString.substring (thisId.length() + 1));

		const bool wasOpen = isOpen();
		setOpen (true);

		for (int i = subItems.size(); --i >= 0;)
		{
			TreeViewItem* item = subItems.getUnchecked(i)->findItemFromIdentifierString (remainingPath);

			if (item != nullptr)
				return item;
		}

		setOpen (wasOpen);
	}

	return nullptr;
}

void TreeViewItem::restoreOpennessState (const XmlElement& e) noexcept
{
	if (e.hasTagName ("CLOSED"))
	{
		setOpen (false);
	}
	else if (e.hasTagName ("OPEN"))
	{
		setOpen (true);

		forEachXmlChildElement (e, n)
		{
			const String id (n->getStringAttribute ("id"));

			for (int i = 0; i < subItems.size(); ++i)
			{
				TreeViewItem* const ti = subItems.getUnchecked(i);

				if (ti->getUniqueName() == id)
				{
					ti->restoreOpennessState (*n);
					break;
				}
			}
		}
	}
}

XmlElement* TreeViewItem::getOpennessState() const noexcept
{
	const String name (getUniqueName());

	if (name.isNotEmpty())
	{
		XmlElement* e;

		if (isOpen())
		{
			e = new XmlElement ("OPEN");

			for (int i = 0; i < subItems.size(); ++i)
				e->addChildElement (subItems.getUnchecked(i)->getOpennessState());
		}
		else
		{
			e = new XmlElement ("CLOSED");
		}

		e->setAttribute ("id", name);

		return e;
	}
	else
	{
		// trying to save the openness for an element that has no name - this won't
		// work because it needs the names to identify what to open.
		jassertfalse;
	}

	return nullptr;
}

TreeViewItem::OpennessRestorer::OpennessRestorer (TreeViewItem& treeViewItem_)
	: treeViewItem (treeViewItem_),
	  oldOpenness (treeViewItem_.getOpennessState())
{
}

TreeViewItem::OpennessRestorer::~OpennessRestorer()
{
	if (oldOpenness != nullptr)
		treeViewItem.restoreOpennessState (*oldOpenness);
}

/*** End of inlined file: juce_TreeView.cpp ***/


/*** Start of inlined file: juce_AlertWindow.cpp ***/
class AlertWindowTextEditor  : public TextEditor
{
public:
	AlertWindowTextEditor (const String& name, const bool isPasswordBox)
		: TextEditor (name, isPasswordBox ? getDefaultPasswordChar() :  0)
	{
		setSelectAllWhenFocused (true);
	}

	void returnPressed()
	{
		// pass these up the component hierarchy to be trigger the buttons
		getParentComponent()->keyPressed (KeyPress (KeyPress::returnKey, 0, '\n'));
	}

	void escapePressed()
	{
		// pass these up the component hierarchy to be trigger the buttons
		getParentComponent()->keyPressed (KeyPress (KeyPress::escapeKey, 0, 0));
	}

private:
	JUCE_DECLARE_NON_COPYABLE (AlertWindowTextEditor);

	static juce_wchar getDefaultPasswordChar() noexcept
	{
	  #if JUCE_LINUX
		return 0x2022;
	  #else
		return 0x25cf;
	  #endif
	}
};

AlertWindow::AlertWindow (const String& title,
						  const String& message,
						  AlertIconType iconType,
						  Component* associatedComponent_)
   : TopLevelWindow (title, true),
	 alertIconType (iconType),
	 associatedComponent (associatedComponent_),
	 escapeKeyCancels (true)
{
	if (message.isEmpty())
		text = " "; // to force an update if the message is empty

	setMessage (message);

	for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
	{
		Component* const c = Desktop::getInstance().getComponent (i);

		if (c != nullptr && c->isAlwaysOnTop() && c->isShowing())
		{
			setAlwaysOnTop (true);
			break;
		}
	}

	if (! JUCEApplication::isStandaloneApp())
		setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

	AlertWindow::lookAndFeelChanged();

	constrainer.setMinimumOnscreenAmounts (0x10000, 0x10000, 0x10000, 0x10000);
}

AlertWindow::~AlertWindow()
{
	removeAllChildren();
}

void AlertWindow::userTriedToCloseWindow()
{
	if (escapeKeyCancels || buttons.size() > 0)
		exitModalState (0);
}

void AlertWindow::setMessage (const String& message)
{
	const String newMessage (message.substring (0, 2048));

	if (text != newMessage)
	{
		text = newMessage;
		updateLayout (true);
		repaint();
	}
}

void AlertWindow::buttonClicked (Button* button)
{
	if (button->getParentComponent() != nullptr)
		button->getParentComponent()->exitModalState (button->getCommandID());
}

void AlertWindow::addButton (const String& name,
							 const int returnValue,
							 const KeyPress& shortcutKey1,
							 const KeyPress& shortcutKey2)
{
	TextButton* const b = new TextButton (name, String::empty);
	buttons.add (b);

	b->setWantsKeyboardFocus (true);
	b->setMouseClickGrabsKeyboardFocus (false);
	b->setCommandToTrigger (0, returnValue, false);
	b->addShortcut (shortcutKey1);
	b->addShortcut (shortcutKey2);
	b->addListener (this);
	b->changeWidthToFitText (getLookAndFeel().getAlertWindowButtonHeight());

	addAndMakeVisible (b, 0);

	updateLayout (false);
}

int AlertWindow::getNumButtons() const
{
	return buttons.size();
}

void AlertWindow::triggerButtonClick (const String& buttonName)
{
	for (int i = buttons.size(); --i >= 0;)
	{
		TextButton* const b = buttons.getUnchecked(i);

		if (buttonName == b->getName())
		{
			b->triggerClick();
			break;
		}
	}
}

void AlertWindow::setEscapeKeyCancels (bool shouldEscapeKeyCancel)
{
	escapeKeyCancels = shouldEscapeKeyCancel;
}

void AlertWindow::addTextEditor (const String& name,
								 const String& initialContents,
								 const String& onScreenLabel,
								 const bool isPasswordBox)
{
	AlertWindowTextEditor* const tc = new AlertWindowTextEditor (name, isPasswordBox);
	textBoxes.add (tc);
	allComps.add (tc);

	tc->setColour (TextEditor::outlineColourId, findColour (ComboBox::outlineColourId));
	tc->setFont (getLookAndFeel().getAlertWindowMessageFont());
	tc->setText (initialContents);
	tc->setCaretPosition (initialContents.length());
	addAndMakeVisible (tc);
	textboxNames.add (onScreenLabel);

	updateLayout (false);
}

TextEditor* AlertWindow::getTextEditor (const String& nameOfTextEditor) const
{
	for (int i = textBoxes.size(); --i >= 0;)
		if (textBoxes.getUnchecked(i)->getName() == nameOfTextEditor)
			return textBoxes.getUnchecked(i);

	return nullptr;
}

String AlertWindow::getTextEditorContents (const String& nameOfTextEditor) const
{
	TextEditor* const t = getTextEditor (nameOfTextEditor);
	return t != nullptr ? t->getText() : String::empty;
}

void AlertWindow::addComboBox (const String& name,
							   const StringArray& items,
							   const String& onScreenLabel)
{
	ComboBox* const cb = new ComboBox (name);
	comboBoxes.add (cb);
	allComps.add (cb);

	cb->addItemList (items, 1);

	addAndMakeVisible (cb);
	cb->setSelectedItemIndex (0);

	comboBoxNames.add (onScreenLabel);
	updateLayout (false);
}

ComboBox* AlertWindow::getComboBoxComponent (const String& nameOfList) const
{
	for (int i = comboBoxes.size(); --i >= 0;)
		if (comboBoxes.getUnchecked(i)->getName() == nameOfList)
			return comboBoxes.getUnchecked(i);

	return nullptr;
}

class AlertTextComp : public TextEditor
{
public:
	AlertTextComp (const String& message,
				   const Font& font)
	{
		setReadOnly (true);
		setMultiLine (true, true);
		setCaretVisible (false);
		setScrollbarsShown (true);
		lookAndFeelChanged();
		setWantsKeyboardFocus (false);

		setFont (font);
		setText (message, false);

		bestWidth = 2 * (int) std::sqrt (font.getHeight() * font.getStringWidth (message));

		setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
		setColour (TextEditor::outlineColourId, Colours::transparentBlack);
		setColour (TextEditor::shadowColourId, Colours::transparentBlack);
	}

	int getPreferredWidth() const noexcept   { return bestWidth; }

	void updateLayout (const int width)
	{
		AttributedString s;
		s.setJustification (Justification::topLeft);
		s.append (getText(), getFont());

		TextLayout text;
		text.createLayoutWithBalancedLineLengths (s, width - 8.0f);
		setSize (width, jmin (width, (int) (text.getHeight() + getFont().getHeight())));
	}

private:
	int bestWidth;

	JUCE_DECLARE_NON_COPYABLE (AlertTextComp);
};

void AlertWindow::addTextBlock (const String& textBlock)
{
	AlertTextComp* const c = new AlertTextComp (textBlock, getLookAndFeel().getAlertWindowMessageFont());
	textBlocks.add (c);
	allComps.add (c);

	addAndMakeVisible (c);

	updateLayout (false);
}

void AlertWindow::addProgressBarComponent (double& progressValue)
{
	ProgressBar* const pb = new ProgressBar (progressValue);
	progressBars.add (pb);
	allComps.add (pb);

	addAndMakeVisible (pb);

	updateLayout (false);
}

void AlertWindow::addCustomComponent (Component* const component)
{
	customComps.add (component);
	allComps.add (component);

	addAndMakeVisible (component);

	updateLayout (false);
}

int AlertWindow::getNumCustomComponents() const
{
	return customComps.size();
}

Component* AlertWindow::getCustomComponent (const int index) const
{
	return customComps [index];
}

Component* AlertWindow::removeCustomComponent (const int index)
{
	Component* const c = getCustomComponent (index);

	if (c != nullptr)
	{
		customComps.removeValue (c);
		allComps.removeValue (c);
		removeChildComponent (c);

		updateLayout (false);
	}

	return c;
}

void AlertWindow::paint (Graphics& g)
{
	getLookAndFeel().drawAlertBox (g, *this, textArea, textLayout);

	g.setColour (findColour (textColourId));
	g.setFont (getLookAndFeel().getAlertWindowFont());

	int i;
	for (i = textBoxes.size(); --i >= 0;)
	{
		const TextEditor* const te = textBoxes.getUnchecked(i);

		g.drawFittedText (textboxNames[i],
						  te->getX(), te->getY() - 14,
						  te->getWidth(), 14,
						  Justification::centredLeft, 1);
	}

	for (i = comboBoxNames.size(); --i >= 0;)
	{
		const ComboBox* const cb = comboBoxes.getUnchecked(i);

		g.drawFittedText (comboBoxNames[i],
						  cb->getX(), cb->getY() - 14,
						  cb->getWidth(), 14,
						  Justification::centredLeft, 1);
	}

	for (i = customComps.size(); --i >= 0;)
	{
		const Component* const c = customComps.getUnchecked(i);

		g.drawFittedText (c->getName(),
						  c->getX(), c->getY() - 14,
						  c->getWidth(), 14,
						  Justification::centredLeft, 1);
	}
}

void AlertWindow::updateLayout (const bool onlyIncreaseSize)
{
	const int titleH = 24;
	const int iconWidth = 80;

	const Font font (getLookAndFeel().getAlertWindowMessageFont());

	const int wid = jmax (font.getStringWidth (text),
						  font.getStringWidth (getName()));

	const int sw = (int) std::sqrt (font.getHeight() * wid);
	int w = jmin (300 + sw * 2, (int) (getParentWidth() * 0.7f));
	const int edgeGap = 10;
	const int labelHeight = 18;
	int iconSpace = 0;

	AttributedString attributedText;
	attributedText.append (getName(), Font (font.getHeight() * 1.1f, Font::bold));

	if (text.isNotEmpty())
		attributedText.append ("\n\n" + text, font);

	attributedText.setColour (findColour (textColourId));

	if (alertIconType == NoIcon)
	{
		attributedText.setJustification (Justification::centredTop);
		textLayout.createLayoutWithBalancedLineLengths (attributedText, (float) w);
	}
	else
	{
		attributedText.setJustification (Justification::topLeft);
		textLayout.createLayoutWithBalancedLineLengths (attributedText, (float) w);
		iconSpace = iconWidth;
	}

	w = jmax (350, (int) textLayout.getWidth() + iconSpace + edgeGap * 4);
	w = jmin (w, (int) (getParentWidth() * 0.7f));

	const int textLayoutH = (int) textLayout.getHeight();
	const int textBottom = 16 + titleH + textLayoutH;
	int h = textBottom;

	int buttonW = 40;
	int i;
	for (i = 0; i < buttons.size(); ++i)
		buttonW += 16 + buttons.getUnchecked(i)->getWidth();

	w = jmax (buttonW, w);

	h += (textBoxes.size() + comboBoxes.size() + progressBars.size()) * 50;

	if (buttons.size() > 0)
		h += 20 + buttons.getUnchecked(0)->getHeight();

	for (i = customComps.size(); --i >= 0;)
	{
		Component* c = customComps.getUnchecked(i);
		w = jmax (w, (c->getWidth() * 100) / 80);
		h += 10 + c->getHeight();

		if (c->getName().isNotEmpty())
			h += labelHeight;
	}

	for (i = textBlocks.size(); --i >= 0;)
	{
		const AlertTextComp* const ac = static_cast <const AlertTextComp*> (textBlocks.getUnchecked(i));
		w = jmax (w, ac->getPreferredWidth());
	}

	w = jmin (w, (int) (getParentWidth() * 0.7f));

	for (i = textBlocks.size(); --i >= 0;)
	{
		AlertTextComp* const ac = static_cast <AlertTextComp*> (textBlocks.getUnchecked(i));
		ac->updateLayout ((int) (w * 0.8f));
		h += ac->getHeight() + 10;
	}

	h = jmin (getParentHeight() - 50, h);

	if (onlyIncreaseSize)
	{
		w = jmax (w, getWidth());
		h = jmax (h, getHeight());
	}

	if (! isVisible())
	{
		centreAroundComponent (associatedComponent, w, h);
	}
	else
	{
		const int cx = getX() + getWidth() / 2;
		const int cy = getY() + getHeight() / 2;

		setBounds (cx - w / 2,
				   cy - h / 2,
				   w, h);
	}

	textArea.setBounds (edgeGap, edgeGap, w - (edgeGap * 2), h - edgeGap);

	const int spacer = 16;
	int totalWidth = -spacer;

	for (i = buttons.size(); --i >= 0;)
		totalWidth += buttons.getUnchecked(i)->getWidth() + spacer;

	int x = (w - totalWidth) / 2;
	int y = (int) (getHeight() * 0.95f);

	for (i = 0; i < buttons.size(); ++i)
	{
		TextButton* const c = buttons.getUnchecked(i);
		int ny = proportionOfHeight (0.95f) - c->getHeight();
		c->setTopLeftPosition (x, ny);
		if (ny < y)
			y = ny;

		x += c->getWidth() + spacer;

		c->toFront (false);
	}

	y = textBottom;

	for (i = 0; i < allComps.size(); ++i)
	{
		Component* const c = allComps.getUnchecked(i);
		h = 22;

		const int comboIndex = comboBoxes.indexOf (dynamic_cast <ComboBox*> (c));
		if (comboIndex >= 0 && comboBoxNames [comboIndex].isNotEmpty())
			y += labelHeight;

		const int tbIndex = textBoxes.indexOf (dynamic_cast <TextEditor*> (c));
		if (tbIndex >= 0 && textboxNames[tbIndex].isNotEmpty())
			y += labelHeight;

		if (customComps.contains (c))
		{
			if (c->getName().isNotEmpty())
				y += labelHeight;

			c->setTopLeftPosition (proportionOfWidth (0.1f), y);
			h = c->getHeight();
		}
		else if (textBlocks.contains (c))
		{
			c->setTopLeftPosition ((getWidth() - c->getWidth()) / 2, y);
			h = c->getHeight();
		}
		else
		{
			c->setBounds (proportionOfWidth (0.1f), y, proportionOfWidth (0.8f), h);
		}

		y += h + 10;
	}

	setWantsKeyboardFocus (getNumChildComponents() == 0);
}

bool AlertWindow::containsAnyExtraComponents() const
{
	return allComps.size() > 0;
}

void AlertWindow::mouseDown (const MouseEvent& e)
{
	dragger.startDraggingComponent (this, e);
}

void AlertWindow::mouseDrag (const MouseEvent& e)
{
	dragger.dragComponent (this, e, &constrainer);
}

bool AlertWindow::keyPressed (const KeyPress& key)
{
	for (int i = buttons.size(); --i >= 0;)
	{
		TextButton* const b = buttons.getUnchecked(i);

		if (b->isRegisteredForShortcut (key))
		{
			b->triggerClick();
			return true;
		}
	}

	if (key.isKeyCode (KeyPress::escapeKey) && escapeKeyCancels && buttons.size() == 0)
	{
		exitModalState (0);
		return true;
	}
	else if (key.isKeyCode (KeyPress::returnKey) && buttons.size() == 1)
	{
		buttons.getUnchecked(0)->triggerClick();
		return true;
	}

	return false;
}

void AlertWindow::lookAndFeelChanged()
{
	const int newFlags = getLookAndFeel().getAlertBoxWindowFlags();

	setUsingNativeTitleBar ((newFlags & ComponentPeer::windowHasTitleBar) != 0);
	setDropShadowEnabled (isOpaque() && (newFlags & ComponentPeer::windowHasDropShadow) != 0);
	updateLayout (false);
}

int AlertWindow::getDesktopWindowStyleFlags() const
{
	return getLookAndFeel().getAlertBoxWindowFlags();
}

class AlertWindowInfo
{
public:
	AlertWindowInfo (const String& title_, const String& message_, Component* component,
					 AlertWindow::AlertIconType iconType_, int numButtons_,
					 ModalComponentManager::Callback* callback_, bool modal_)
		: title (title_), message (message_), iconType (iconType_),
		  numButtons (numButtons_), returnValue (0), associatedComponent (component),
		  callback (callback_), modal (modal_)
	{
	}

	String title, message, button1, button2, button3;

	int invoke() const
	{
		MessageManager::getInstance()->callFunctionOnMessageThread (showCallback, (void*) this);
		return returnValue;
	}

private:
	AlertWindow::AlertIconType iconType;
	int numButtons, returnValue;
	WeakReference<Component> associatedComponent;
	ModalComponentManager::Callback* callback;
	bool modal;

	void show()
	{
		LookAndFeel& lf = associatedComponent != nullptr ? associatedComponent->getLookAndFeel()
														 : LookAndFeel::getDefaultLookAndFeel();

		ScopedPointer <Component> alertBox (lf.createAlertWindow (title, message, button1, button2, button3,
																  iconType, numButtons, associatedComponent));

		jassert (alertBox != nullptr); // you have to return one of these!

	   #if JUCE_MODAL_LOOPS_PERMITTED
		if (modal)
		{
			returnValue = alertBox->runModalLoop();
		}
		else
	   #endif
		{
			alertBox->enterModalState (true, callback, true);
			alertBox.release();
		}
	}

	static void* showCallback (void* userData)
	{
		static_cast <AlertWindowInfo*> (userData)->show();
		return nullptr;
	}
};

#if JUCE_MODAL_LOOPS_PERMITTED
void AlertWindow::showMessageBox (AlertIconType iconType,
								  const String& title,
								  const String& message,
								  const String& buttonText,
								  Component* associatedComponent)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		NativeMessageBox::showMessageBox (iconType, title, message, associatedComponent);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 1, 0, true);
		info.button1 = buttonText.isEmpty() ? TRANS("ok") : buttonText;

		info.invoke();
	}
}
#endif

void AlertWindow::showMessageBoxAsync (AlertIconType iconType,
									   const String& title,
									   const String& message,
									   const String& buttonText,
									   Component* associatedComponent)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showMessageBoxAsync (iconType, title, message, associatedComponent);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 1, 0, false);
		info.button1 = buttonText.isEmpty() ? TRANS("ok") : buttonText;

		info.invoke();
	}
}

bool AlertWindow::showOkCancelBox (AlertIconType iconType,
								   const String& title,
								   const String& message,
								   const String& button1Text,
								   const String& button2Text,
								   Component* associatedComponent,
								   ModalComponentManager::Callback* callback)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showOkCancelBox (iconType, title, message, associatedComponent, callback);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 2, callback, callback == nullptr);
		info.button1 = button1Text.isEmpty() ? TRANS("ok")     : button1Text;
		info.button2 = button2Text.isEmpty() ? TRANS("cancel") : button2Text;

		return info.invoke() != 0;
	}
}

int AlertWindow::showYesNoCancelBox (AlertIconType iconType,
									 const String& title,
									 const String& message,
									 const String& button1Text,
									 const String& button2Text,
									 const String& button3Text,
									 Component* associatedComponent,
									 ModalComponentManager::Callback* callback)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showYesNoCancelBox (iconType, title, message, associatedComponent, callback);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 3, callback, callback == nullptr);
		info.button1 = button1Text.isEmpty() ? TRANS("yes")     : button1Text;
		info.button2 = button2Text.isEmpty() ? TRANS("no")      : button2Text;
		info.button3 = button3Text.isEmpty() ? TRANS("cancel")  : button3Text;

		return info.invoke();
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool AlertWindow::showNativeDialogBox (const String& title,
									   const String& bodyText,
									   bool isOkCancel)
{
	if (isOkCancel)
	{
		return NativeMessageBox::showOkCancelBox (AlertWindow::NoIcon, title, bodyText);
	}
	else
	{
		NativeMessageBox::showMessageBox (AlertWindow::NoIcon, title, bodyText);
		return true;
	}
}
#endif

/*** End of inlined file: juce_AlertWindow.cpp ***/


/*** Start of inlined file: juce_CallOutBox.cpp ***/
CallOutBox::CallOutBox (Component& contentComponent,
						Component& componentToPointTo,
						Component* const parent)
	: borderSpace (20), arrowSize (16.0f), content (contentComponent)
{
	addAndMakeVisible (&content);

	if (parent != nullptr)
	{
		parent->addChildComponent (this);

		updatePosition (parent->getLocalArea (&componentToPointTo, componentToPointTo.getLocalBounds()),
						parent->getLocalBounds());

		setVisible (true);
	}
	else
	{
		if (! JUCEApplication::isStandaloneApp())
			setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

		updatePosition (componentToPointTo.getScreenBounds(),
						componentToPointTo.getParentMonitorArea());

		addToDesktop (ComponentPeer::windowIsTemporary);
	}
}

CallOutBox::~CallOutBox()
{
}

void CallOutBox::setArrowSize (const float newSize)
{
	arrowSize = newSize;
	borderSpace = jmax (20, (int) arrowSize);
	refreshPath();
}

void CallOutBox::paint (Graphics& g)
{
	if (background.isNull())
	{
		background = Image (Image::ARGB, getWidth(), getHeight(), true);
		Graphics g2 (background);
		getLookAndFeel().drawCallOutBoxBackground (*this, g2, outline);
	}

	g.setColour (Colours::black);
	g.drawImageAt (background, 0, 0);
}

void CallOutBox::resized()
{
	content.setTopLeftPosition (borderSpace, borderSpace);
	refreshPath();
}

void CallOutBox::moved()
{
	refreshPath();
}

void CallOutBox::childBoundsChanged (Component*)
{
	updatePosition (targetArea, availableArea);
}

bool CallOutBox::hitTest (int x, int y)
{
	return outline.contains ((float) x, (float) y);
}

enum { callOutBoxDismissCommandId = 0x4f83a04b };

void CallOutBox::inputAttemptWhenModal()
{
	const Point<int> mousePos (getMouseXYRelative() + getBounds().getPosition());

	if (targetArea.contains (mousePos))
	{
		// if you click on the area that originally popped-up the callout, you expect it
		// to get rid of the box, but deleting the box here allows the click to pass through and
		// probably re-trigger it, so we need to dismiss the box asynchronously to consume the click..
		postCommandMessage (callOutBoxDismissCommandId);
	}
	else
	{
		exitModalState (0);
		setVisible (false);
	}
}

void CallOutBox::handleCommandMessage (int commandId)
{
	Component::handleCommandMessage (commandId);

	if (commandId == callOutBoxDismissCommandId)
	{
		exitModalState (0);
		setVisible (false);
	}
}

bool CallOutBox::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::escapeKey))
	{
		inputAttemptWhenModal();
		return true;
	}

	return false;
}

void CallOutBox::updatePosition (const Rectangle<int>& newAreaToPointTo, const Rectangle<int>& newAreaToFitIn)
{
	targetArea = newAreaToPointTo;
	availableArea = newAreaToFitIn;

	Rectangle<int> newBounds (0, 0,
							  content.getWidth() + borderSpace * 2,
							  content.getHeight() + borderSpace * 2);

	const int hw = newBounds.getWidth() / 2;
	const int hh = newBounds.getHeight() / 2;
	const float hwReduced = (float) (hw - borderSpace * 3);
	const float hhReduced = (float) (hh - borderSpace * 3);
	const float arrowIndent = borderSpace - arrowSize;

	Point<float> targets[4] = { Point<float> ((float) targetArea.getCentreX(), (float) targetArea.getBottom()),
								Point<float> ((float) targetArea.getRight(),   (float) targetArea.getCentreY()),
								Point<float> ((float) targetArea.getX(),       (float) targetArea.getCentreY()),
								Point<float> ((float) targetArea.getCentreX(), (float) targetArea.getY()) };

	Line<float> lines[4] = { Line<float> (targets[0].translated (-hwReduced, hh - arrowIndent),    targets[0].translated (hwReduced, hh - arrowIndent)),
							 Line<float> (targets[1].translated (hw - arrowIndent, -hhReduced),    targets[1].translated (hw - arrowIndent, hhReduced)),
							 Line<float> (targets[2].translated (-(hw - arrowIndent), -hhReduced), targets[2].translated (-(hw - arrowIndent), hhReduced)),
							 Line<float> (targets[3].translated (-hwReduced, -(hh - arrowIndent)), targets[3].translated (hwReduced, -(hh - arrowIndent))) };

	const Rectangle<float> centrePointArea (newAreaToFitIn.reduced (hw, hh).toFloat());

	float nearest = 1.0e9f;

	for (int i = 0; i < 4; ++i)
	{
		Line<float> constrainedLine (centrePointArea.getConstrainedPoint (lines[i].getStart()),
									 centrePointArea.getConstrainedPoint (lines[i].getEnd()));

		const Point<float> centre (constrainedLine.findNearestPointTo (centrePointArea.getCentre()));
		float distanceFromCentre = centre.getDistanceFrom (centrePointArea.getCentre());

		if (! (centrePointArea.contains (lines[i].getStart()) || centrePointArea.contains (lines[i].getEnd())))
			distanceFromCentre *= 2.0f;

		if (distanceFromCentre < nearest)
		{
			nearest = distanceFromCentre;

			targetPoint = targets[i];
			newBounds.setPosition ((int) (centre.getX() - hw),
								   (int) (centre.getY() - hh));
		}
	}

	setBounds (newBounds);
}

void CallOutBox::refreshPath()
{
	repaint();
	background = Image::null;
	outline.clear();

	const float gap = 4.5f;
	const float cornerSize = 9.0f;
	const float cornerSize2 = 2.0f * cornerSize;
	const float arrowBaseWidth = arrowSize * 0.7f;

	const Rectangle<float> area (content.getBounds().toFloat().expanded (gap, gap));
	const Point<float> target (targetPoint - getPosition().toFloat());

	outline.startNewSubPath (area.getX() + cornerSize, area.getY());

	const float targetLimitX = area.getX() + cornerSize + arrowBaseWidth;
	const float targetLimitW = area.getWidth() - cornerSize2 - arrowBaseWidth * 2.0f;

	const float targetLimitY = area.getY() + cornerSize + arrowBaseWidth;
	const float targetLimitH = area.getHeight() - cornerSize2 - arrowBaseWidth * 2.0f;

	if (Rectangle<float> (targetLimitX, 1.0f,
						  targetLimitW, area.getY() - 2.0f).contains (target))
	{
		outline.lineTo (target.x - arrowBaseWidth, area.getY());
		outline.lineTo (target.x, target.y);
		outline.lineTo (target.x + arrowBaseWidth, area.getY());
	}

	outline.lineTo (area.getRight() - cornerSize, area.getY());
	outline.addArc (area.getRight() - cornerSize2, area.getY(), cornerSize2, cornerSize2, 0, float_Pi * 0.5f);

	if (Rectangle<float> (area.getRight() + 1.0f, targetLimitY,
						  getWidth() - area.getRight() - 2.0f, targetLimitH).contains (target))
	{
		outline.lineTo (area.getRight(), target.y - arrowBaseWidth);
		outline.lineTo (target.x, target.y);
		outline.lineTo (area.getRight(), target.y + arrowBaseWidth);
	}

	outline.lineTo (area.getRight(), area.getBottom() - cornerSize);
	outline.addArc (area.getRight() - cornerSize2, area.getBottom() - cornerSize2, cornerSize2, cornerSize2, float_Pi * 0.5f, float_Pi);

	if (Rectangle<float> (targetLimitX, area.getBottom() + 1.0f,
						  targetLimitW, getHeight() - area.getBottom() - 2.0f).contains (target))
	{
		outline.lineTo (target.x + arrowBaseWidth, area.getBottom());
		outline.lineTo (target.x, target.y);
		outline.lineTo (target.x - arrowBaseWidth, area.getBottom());
	}

	outline.lineTo (area.getX() + cornerSize, area.getBottom());
	outline.addArc (area.getX(), area.getBottom() - cornerSize2, cornerSize2, cornerSize2, float_Pi, float_Pi * 1.5f);

	if (Rectangle<float> (1.0f, targetLimitY, area.getX() - 2.0f, targetLimitH).contains (target))
	{
		outline.lineTo (area.getX(), target.y + arrowBaseWidth);
		outline.lineTo (target.x, target.y);
		outline.lineTo (area.getX(), target.y - arrowBaseWidth);
	}

	outline.lineTo (area.getX(), area.getY() + cornerSize);
	outline.addArc (area.getX(), area.getY(), cornerSize2, cornerSize2, float_Pi * 1.5f, float_Pi * 2.0f - 0.05f);

	outline.closeSubPath();
}

/*** End of inlined file: juce_CallOutBox.cpp ***/


/*** Start of inlined file: juce_ComponentPeer.cpp ***/
//#define JUCE_ENABLE_REPAINT_DEBUGGING 1

static Array <ComponentPeer*> heavyweightPeers;
static uint32 lastUniqueID = 1;

ComponentPeer::ComponentPeer (Component* const component_, const int styleFlags_)
	: component (component_),
	  styleFlags (styleFlags_),
	  lastPaintTime (0),
	  constrainer (nullptr),
	  lastDragAndDropCompUnderMouse (nullptr),
	  uniqueID (lastUniqueID += 2), // increment by 2 so that this can never hit 0
	  fakeMouseMessageSent (false),
	  isWindowMinimised (false)
{
	heavyweightPeers.add (this);
}

ComponentPeer::~ComponentPeer()
{
	heavyweightPeers.removeValue (this);
	Desktop::getInstance().triggerFocusCallback();
}

int ComponentPeer::getNumPeers() noexcept
{
	return heavyweightPeers.size();
}

ComponentPeer* ComponentPeer::getPeer (const int index) noexcept
{
	return heavyweightPeers [index];
}

ComponentPeer* ComponentPeer::getPeerFor (const Component* const component) noexcept
{
	for (int i = heavyweightPeers.size(); --i >= 0;)
	{
		ComponentPeer* const peer = heavyweightPeers.getUnchecked(i);

		if (peer->getComponent() == component)
			return peer;
	}

	return nullptr;
}

bool ComponentPeer::isValidPeer (const ComponentPeer* const peer) noexcept
{
	return heavyweightPeers.contains (const_cast <ComponentPeer*> (peer));
}

void ComponentPeer::updateCurrentModifiers() noexcept
{
	ModifierKeys::updateCurrentModifiers();
}

void ComponentPeer::handleMouseEvent (const int touchIndex, const Point<int>& positionWithinPeer, const ModifierKeys& newMods, const int64 time)
{
	MouseInputSource* const mouse = Desktop::getInstance().getMouseSource (touchIndex);
	jassert (mouse != nullptr); // not enough sources!

	mouse->handleEvent (this, positionWithinPeer, time, newMods);
}

void ComponentPeer::handleMouseWheel (const int touchIndex, const Point<int>& positionWithinPeer, const int64 time, const float x, const float y)
{
	MouseInputSource* const mouse = Desktop::getInstance().getMouseSource (touchIndex);
	jassert (mouse != nullptr); // not enough sources!

	mouse->handleWheel (this, positionWithinPeer, time, x, y);
}

void ComponentPeer::handlePaint (LowLevelGraphicsContext& contextToPaintTo)
{
	Graphics g (&contextToPaintTo);

   #if JUCE_ENABLE_REPAINT_DEBUGGING
	g.saveState();
   #endif

	JUCE_TRY
	{
		component->paintEntireComponent (g, true);
	}
	JUCE_CATCH_EXCEPTION

   #if JUCE_ENABLE_REPAINT_DEBUGGING
	// enabling this code will fill all areas that get repainted with a colour overlay, to show
	// clearly when things are being repainted.
	g.restoreState();

	static Random rng;

	g.fillAll (Colour ((uint8) rng.nextInt (255),
					   (uint8) rng.nextInt (255),
					   (uint8) rng.nextInt (255),
					   (uint8) 0x50));
   #endif

	/** If this fails, it's probably be because your CPU floating-point precision mode has
		been set to low.. This setting is sometimes changed by things like Direct3D, and can
		mess up a lot of the calculations that the library needs to do.
	*/
	jassert (roundToInt (10.1f) == 10);
}

bool ComponentPeer::handleKeyPress (const int keyCode,
									const juce_wchar textCharacter)
{
	updateCurrentModifiers();

	Component* target = Component::getCurrentlyFocusedComponent() != nullptr
							? Component::getCurrentlyFocusedComponent()
							: component;

	if (target->isCurrentlyBlockedByAnotherModalComponent())
	{
		Component* const currentModalComp = Component::getCurrentlyModalComponent();

		if (currentModalComp != nullptr)
			target = currentModalComp;
	}

	const KeyPress keyInfo (keyCode,
							ModifierKeys::getCurrentModifiers().getRawFlags()
							   & ModifierKeys::allKeyboardModifiers,
							textCharacter);

	bool keyWasUsed = false;

	while (target != nullptr)
	{
		const WeakReference<Component> deletionChecker (target);
		const Array <KeyListener*>* const keyListeners = target->keyListeners;

		if (keyListeners != nullptr)
		{
			for (int i = keyListeners->size(); --i >= 0;)
			{
				keyWasUsed = keyListeners->getUnchecked(i)->keyPressed (keyInfo, target);

				if (keyWasUsed || deletionChecker == nullptr)
					return keyWasUsed;

				i = jmin (i, keyListeners->size());
			}
		}

		keyWasUsed = target->keyPressed (keyInfo);

		if (keyWasUsed || deletionChecker == nullptr)
			break;

		Component* const currentlyFocused = Component::getCurrentlyFocusedComponent();

		if (currentlyFocused != nullptr)
		{
			const bool isTab      = (keyInfo == KeyPress (KeyPress::tabKey, ModifierKeys::noModifiers, 0));
			const bool isShiftTab = (keyInfo == KeyPress (KeyPress::tabKey, ModifierKeys::shiftModifier, 0));

			if (isTab || isShiftTab)
			{
				currentlyFocused->moveKeyboardFocusToSibling (isTab);
				keyWasUsed = (currentlyFocused != Component::getCurrentlyFocusedComponent());
				break;
			}
		}

		target = target->getParentComponent();
	}

	return keyWasUsed;
}

bool ComponentPeer::handleKeyUpOrDown (const bool isKeyDown)
{
	updateCurrentModifiers();

	Component* target = Component::getCurrentlyFocusedComponent() != nullptr
							? Component::getCurrentlyFocusedComponent()
							: component;

	if (target->isCurrentlyBlockedByAnotherModalComponent())
	{
		Component* const currentModalComp = Component::getCurrentlyModalComponent();

		if (currentModalComp != nullptr)
			target = currentModalComp;
	}

	bool keyWasUsed = false;

	while (target != nullptr)
	{
		const WeakReference<Component> deletionChecker (target);

		keyWasUsed = target->keyStateChanged (isKeyDown);

		if (keyWasUsed || deletionChecker == nullptr)
			break;

		const Array <KeyListener*>* const keyListeners = target->keyListeners;

		if (keyListeners != nullptr)
		{
			for (int i = keyListeners->size(); --i >= 0;)
			{
				keyWasUsed = keyListeners->getUnchecked(i)->keyStateChanged (isKeyDown, target);

				if (keyWasUsed || deletionChecker == nullptr)
					return keyWasUsed;

				i = jmin (i, keyListeners->size());
			}
		}

		target = target->getParentComponent();
	}

	return keyWasUsed;
}

void ComponentPeer::handleModifierKeysChange()
{
	updateCurrentModifiers();

	Component* target = Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();

	if (target == nullptr)
		target = Component::getCurrentlyFocusedComponent();

	if (target == nullptr)
		target = component;

	if (target != nullptr)
		target->internalModifierKeysChanged();
}

TextInputTarget* ComponentPeer::findCurrentTextInputTarget()
{
	Component* const c = Component::getCurrentlyFocusedComponent();
	if (component->isParentOf (c))
	{
		TextInputTarget* const ti = dynamic_cast <TextInputTarget*> (c);
		if (ti != nullptr && ti->isTextInputActive())
			return ti;
	}

	return nullptr;
}

void ComponentPeer::dismissPendingTextInput()
{
}

void ComponentPeer::handleBroughtToFront()
{
	updateCurrentModifiers();

	if (component != nullptr)
		component->internalBroughtToFront();
}

void ComponentPeer::setConstrainer (ComponentBoundsConstrainer* const newConstrainer) noexcept
{
	constrainer = newConstrainer;
}

void ComponentPeer::handleMovedOrResized()
{
	updateCurrentModifiers();

	const bool nowMinimised = isMinimised();

	if (component->flags.hasHeavyweightPeerFlag && ! nowMinimised)
	{
		const WeakReference<Component> deletionChecker (component);

		const Rectangle<int> newBounds (getBounds());
		const bool wasMoved   = (component->getPosition() != newBounds.getPosition());
		const bool wasResized = (component->getWidth() != newBounds.getWidth() || component->getHeight() != newBounds.getHeight());

		if (wasMoved || wasResized)
		{
			component->bounds = newBounds;

			if (wasResized)
				component->repaint();

			component->sendMovedResizedMessages (wasMoved, wasResized);

			if (deletionChecker == nullptr)
				return;
		}
	}

	if (isWindowMinimised != nowMinimised)
	{
		isWindowMinimised = nowMinimised;
		component->minimisationStateChanged (nowMinimised);
		component->sendVisibilityChangeMessage();
	}

	if (! isFullScreen())
		lastNonFullscreenBounds = component->getBounds();
}

void ComponentPeer::handleFocusGain()
{
	updateCurrentModifiers();

	if (component->isParentOf (lastFocusedComponent))
	{
		Component::currentlyFocusedComponent = lastFocusedComponent;
		Desktop::getInstance().triggerFocusCallback();
		lastFocusedComponent->internalFocusGain (Component::focusChangedDirectly);
	}
	else
	{
		if (! component->isCurrentlyBlockedByAnotherModalComponent())
			component->grabKeyboardFocus();
		else
			ModalComponentManager::getInstance()->bringModalComponentsToFront();
	}
}

void ComponentPeer::handleFocusLoss()
{
	updateCurrentModifiers();

	if (component->hasKeyboardFocus (true))
	{
		lastFocusedComponent = Component::currentlyFocusedComponent;

		if (lastFocusedComponent != nullptr)
		{
			Component::currentlyFocusedComponent = nullptr;
			Desktop::getInstance().triggerFocusCallback();
			lastFocusedComponent->internalFocusLoss (Component::focusChangedByMouseClick);
		}
	}
}

Component* ComponentPeer::getLastFocusedSubcomponent() const noexcept
{
	return (component->isParentOf (lastFocusedComponent) && lastFocusedComponent->isShowing())
				? static_cast <Component*> (lastFocusedComponent)
				: component;
}

void ComponentPeer::handleScreenSizeChange()
{
	updateCurrentModifiers();

	component->parentSizeChanged();
	handleMovedOrResized();
}

void ComponentPeer::setNonFullScreenBounds (const Rectangle<int>& newBounds) noexcept
{
	lastNonFullscreenBounds = newBounds;
}

const Rectangle<int>& ComponentPeer::getNonFullScreenBounds() const noexcept
{
	return lastNonFullscreenBounds;
}

Rectangle<int> ComponentPeer::localToGlobal (const Rectangle<int>& relativePosition)
{
	return relativePosition.withPosition (localToGlobal (relativePosition.getPosition()));
}

Rectangle<int> ComponentPeer::globalToLocal (const Rectangle<int>& screenPosition)
{
	return screenPosition.withPosition (globalToLocal (screenPosition.getPosition()));
}

namespace ComponentPeerHelpers
{
	static FileDragAndDropTarget* findDragAndDropTarget (Component* c,
														 const StringArray& files,
														 FileDragAndDropTarget* const lastOne)
	{
		while (c != nullptr)
		{
			FileDragAndDropTarget* const t = dynamic_cast <FileDragAndDropTarget*> (c);

			if (t != nullptr && (t == lastOne || t->isInterestedInFileDrag (files)))
				return t;

			c = c->getParentComponent();
		}

		return nullptr;
	}
}

bool ComponentPeer::handleFileDragMove (const StringArray& files, const Point<int>& position)
{
	updateCurrentModifiers();

	FileDragAndDropTarget* lastTarget
		= dynamic_cast<FileDragAndDropTarget*> (dragAndDropTargetComponent.get());

	FileDragAndDropTarget* newTarget = nullptr;

	Component* const compUnderMouse = component->getComponentAt (position);

	if (compUnderMouse != lastDragAndDropCompUnderMouse)
	{
		lastDragAndDropCompUnderMouse = compUnderMouse;
		newTarget = ComponentPeerHelpers::findDragAndDropTarget (compUnderMouse, files, lastTarget);

		if (newTarget != lastTarget)
		{
			if (lastTarget != nullptr)
				lastTarget->fileDragExit (files);

			dragAndDropTargetComponent = nullptr;

			if (newTarget != nullptr)
			{
				dragAndDropTargetComponent = dynamic_cast <Component*> (newTarget);
				const Point<int> pos (dragAndDropTargetComponent->getLocalPoint (component, position));
				newTarget->fileDragEnter (files, pos.getX(), pos.getY());
			}
		}
	}
	else
	{
		newTarget = lastTarget;
	}

	if (newTarget == nullptr)
		return false;

	const Point<int> pos (dragAndDropTargetComponent->getLocalPoint (component, position));
	newTarget->fileDragMove (files, pos.getX(), pos.getY());
	return true;
}

bool ComponentPeer::handleFileDragExit (const StringArray& files)
{
	const bool used = handleFileDragMove (files, Point<int> (-1, -1));

	jassert (dragAndDropTargetComponent == nullptr);
	lastDragAndDropCompUnderMouse = nullptr;
	return used;
}

// We'll use an async message to deliver the drop, because if the target decides
// to run a modal loop, it can gum-up the operating system..
class AsyncFileDropMessage  : public CallbackMessage
{
public:
	AsyncFileDropMessage (Component* target_, FileDragAndDropTarget* dropTarget_,
						  const Point<int>& position_, const StringArray& files_)
		: target (target_), dropTarget (dropTarget_), position (position_), files (files_)
	{
	}

	void messageCallback()
	{
		if (target.get() != nullptr)
			dropTarget->filesDropped (files, position.getX(), position.getY());
	}

private:
	WeakReference<Component> target;
	FileDragAndDropTarget* const dropTarget;
	const Point<int> position;
	const StringArray files;

	JUCE_DECLARE_NON_COPYABLE (AsyncFileDropMessage);
};

bool ComponentPeer::handleFileDragDrop (const StringArray& files, const Point<int>& position)
{
	handleFileDragMove (files, position);

	if (dragAndDropTargetComponent != nullptr)
	{
		Component* const targetComp = dragAndDropTargetComponent;
		FileDragAndDropTarget* const target = dynamic_cast<FileDragAndDropTarget*> (targetComp);

		dragAndDropTargetComponent = nullptr;
		lastDragAndDropCompUnderMouse = nullptr;

		if (target != nullptr)
		{
			if (targetComp->isCurrentlyBlockedByAnotherModalComponent())
			{
				targetComp->internalModalInputAttempt();

				if (targetComp->isCurrentlyBlockedByAnotherModalComponent())
					return true;
			}

			(new AsyncFileDropMessage (targetComp, target, targetComp->getLocalPoint (component, position), files))->post();
			return true;
		}
	}

	return false;
}

void ComponentPeer::handleUserClosingWindow()
{
	updateCurrentModifiers();
	component->userTriedToCloseWindow();
}

void ComponentPeer::clearMaskedRegion()
{
	maskedRegion.clear();
}

void ComponentPeer::addMaskedRegion (const Rectangle<int>& area)
{
	maskedRegion.add (area);
}

StringArray ComponentPeer::getAvailableRenderingEngines()
{
	return StringArray ("Software Renderer");
}

int ComponentPeer::getCurrentRenderingEngine() const
{
	return 0;
}

void ComponentPeer::setCurrentRenderingEngine (int /*index*/)
{
}

/*** End of inlined file: juce_ComponentPeer.cpp ***/


/*** Start of inlined file: juce_DialogWindow.cpp ***/
DialogWindow::DialogWindow (const String& name,
							const Colour& backgroundColour_,
							const bool escapeKeyTriggersCloseButton_,
							const bool addToDesktop_)
	: DocumentWindow (name, backgroundColour_, DocumentWindow::closeButton, addToDesktop_),
	  escapeKeyTriggersCloseButton (escapeKeyTriggersCloseButton_)
{
}

DialogWindow::~DialogWindow()
{
}

void DialogWindow::resized()
{
	DocumentWindow::resized();

	const KeyPress esc (KeyPress::escapeKey, 0, 0);

	if (escapeKeyTriggersCloseButton
		 && getCloseButton() != nullptr
		 && ! getCloseButton()->isRegisteredForShortcut (esc))
	{
		getCloseButton()->addShortcut (esc);
	}
}

class TempDialogWindow : public DialogWindow
{
public:
	TempDialogWindow (const String& title,
					  Component* contentComponent_,
					  Component* componentToCentreAround,
					  const Colour& colour,
					  const bool escapeKeyTriggersCloseButton_,
					  const bool shouldBeResizable,
					  const bool useBottomRightCornerResizer)
		: DialogWindow (title, colour, escapeKeyTriggersCloseButton_, true)
	{
		if (! JUCEApplication::isStandaloneApp())
			setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

		setContentNonOwned (contentComponent_, true);
		centreAroundComponent (componentToCentreAround, getWidth(), getHeight());
		setResizable (shouldBeResizable, useBottomRightCornerResizer);
	}

	void closeButtonPressed()
	{
		setVisible (false);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (TempDialogWindow);
};

void DialogWindow::showDialog (const String& dialogTitle,
							   Component* const contentComponent,
							   Component* const componentToCentreAround,
							   const Colour& backgroundColour,
							   const bool escapeKeyTriggersCloseButton,
							   const bool shouldBeResizable,
							   const bool useBottomRightCornerResizer)
{
	TempDialogWindow* dw = new TempDialogWindow (dialogTitle, contentComponent, componentToCentreAround,
												 backgroundColour, escapeKeyTriggersCloseButton,
												 shouldBeResizable, useBottomRightCornerResizer);

	dw->enterModalState (true, 0, true);
}

#if JUCE_MODAL_LOOPS_PERMITTED
int DialogWindow::showModalDialog (const String& dialogTitle,
								   Component* const contentComponent,
								   Component* const componentToCentreAround,
								   const Colour& backgroundColour,
								   const bool escapeKeyTriggersCloseButton,
								   const bool shouldBeResizable,
								   const bool useBottomRightCornerResizer)
{
	TempDialogWindow dw (dialogTitle, contentComponent, componentToCentreAround,
						 backgroundColour, escapeKeyTriggersCloseButton,
						 shouldBeResizable, useBottomRightCornerResizer);

	return dw.runModalLoop();
}
#endif

/*** End of inlined file: juce_DialogWindow.cpp ***/


/*** Start of inlined file: juce_DocumentWindow.cpp ***/
class DocumentWindow::ButtonListenerProxy  : public ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:
	ButtonListenerProxy (DocumentWindow& owner_)
		: owner (owner_)
	{
	}

	void buttonClicked (Button* button)
	{
		if      (button == owner.getMinimiseButton())  owner.minimiseButtonPressed();
		else if (button == owner.getMaximiseButton())  owner.maximiseButtonPressed();
		else if (button == owner.getCloseButton())     owner.closeButtonPressed();
	}

private:
	DocumentWindow& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ButtonListenerProxy);
};

DocumentWindow::DocumentWindow (const String& title,
								const Colour& backgroundColour,
								const int requiredButtons_,
								const bool addToDesktop_)
	: ResizableWindow (title, backgroundColour, addToDesktop_),
	  titleBarHeight (26),
	  menuBarHeight (24),
	  requiredButtons (requiredButtons_),
	#if JUCE_MAC
	  positionTitleBarButtonsOnLeft (true),
	#else
	  positionTitleBarButtonsOnLeft (false),
	#endif
	  drawTitleTextCentred (true),
	  menuBarModel (nullptr)
{
	setResizeLimits (128, 128, 32768, 32768);

	DocumentWindow::lookAndFeelChanged();
}

DocumentWindow::~DocumentWindow()
{
	// Don't delete or remove the resizer components yourself! They're managed by the
	// DocumentWindow, and you should leave them alone! You may have deleted them
	// accidentally by careless use of deleteAllChildren()..?
	jassert (menuBar == nullptr || getIndexOfChildComponent (menuBar) >= 0);
	jassert (titleBarButtons[0] == nullptr || getIndexOfChildComponent (titleBarButtons[0]) >= 0);
	jassert (titleBarButtons[1] == nullptr || getIndexOfChildComponent (titleBarButtons[1]) >= 0);
	jassert (titleBarButtons[2] == nullptr || getIndexOfChildComponent (titleBarButtons[2]) >= 0);

	for (int i = numElementsInArray (titleBarButtons); --i >= 0;)
		titleBarButtons[i] = nullptr;

	menuBar = nullptr;
}

void DocumentWindow::repaintTitleBar()
{
	repaint (getTitleBarArea());
}

void DocumentWindow::setName (const String& newName)
{
	if (newName != getName())
	{
		Component::setName (newName);
		repaintTitleBar();
	}
}

void DocumentWindow::setIcon (const Image& imageToUse)
{
	titleBarIcon = imageToUse;
	repaintTitleBar();
}

void DocumentWindow::setTitleBarHeight (const int newHeight)
{
	titleBarHeight = newHeight;
	resized();
	repaintTitleBar();
}

void DocumentWindow::setTitleBarButtonsRequired (const int requiredButtons_,
												 const bool positionTitleBarButtonsOnLeft_)
{
	requiredButtons = requiredButtons_;
	positionTitleBarButtonsOnLeft = positionTitleBarButtonsOnLeft_;
	lookAndFeelChanged();
}

void DocumentWindow::setTitleBarTextCentred (const bool textShouldBeCentred)
{
	drawTitleTextCentred = textShouldBeCentred;
	repaintTitleBar();
}

void DocumentWindow::setMenuBar (MenuBarModel* newMenuBarModel, const int newMenuBarHeight)
{
	if (menuBarModel != newMenuBarModel)
	{
		menuBar = nullptr;

		menuBarModel = newMenuBarModel;
		menuBarHeight = newMenuBarHeight > 0 ? newMenuBarHeight
											 : getLookAndFeel().getDefaultMenuBarHeight();

		if (menuBarModel != nullptr)
			setMenuBarComponent (new MenuBarComponent (menuBarModel));

		resized();
	}
}

Component* DocumentWindow::getMenuBarComponent() const noexcept
{
	return menuBar;
}

void DocumentWindow::setMenuBarComponent (Component* newMenuBarComponent)
{
	// (call the Component method directly to avoid the assertion in ResizableWindow)
	Component::addAndMakeVisible (menuBar = newMenuBarComponent);

	if (menuBar != nullptr)
		menuBar->setEnabled (isActiveWindow());

	resized();
}

void DocumentWindow::closeButtonPressed()
{
	/*  If you've got a close button, you have to override this method to get
		rid of your window!

		If the window is just a pop-up, you should override this method and make
		it delete the window in whatever way is appropriate for your app. E.g. you
		might just want to call "delete this".

		If your app is centred around this window such that the whole app should quit when
		the window is closed, then you will probably want to use this method as an opportunity
		to call JUCEApplication::quit(), and leave the window to be deleted later by your
		JUCEApplication::shutdown() method. (Doing it this way means that your window will
		still get cleaned-up if the app is quit by some other means (e.g. a cmd-Q on the mac
		or closing it via the taskbar icon on Windows).
	*/
	jassertfalse;
}

void DocumentWindow::minimiseButtonPressed()
{
	setMinimised (true);
}

void DocumentWindow::maximiseButtonPressed()
{
	setFullScreen (! isFullScreen());
}

void DocumentWindow::paint (Graphics& g)
{
	ResizableWindow::paint (g);

	if (resizableBorder == nullptr)
	{
		g.setColour (getBackgroundColour().overlaidWith (Colour (0x80000000)));

		const BorderSize<int> border (getBorderThickness());

		g.fillRect (0, 0, getWidth(), border.getTop());
		g.fillRect (0, border.getTop(), border.getLeft(), getHeight() - border.getTopAndBottom());
		g.fillRect (getWidth() - border.getRight(), border.getTop(), border.getRight(), getHeight() - border.getTopAndBottom());
		g.fillRect (0, getHeight() - border.getBottom(), getWidth(), border.getBottom());
	}

	const Rectangle<int> titleBarArea (getTitleBarArea());
	g.reduceClipRegion (titleBarArea);
	g.setOrigin (titleBarArea.getX(), titleBarArea.getY());

	int titleSpaceX1 = 6;
	int titleSpaceX2 = titleBarArea.getWidth() - 6;

	for (int i = 0; i < 3; ++i)
	{
		if (titleBarButtons[i] != nullptr)
		{
			if (positionTitleBarButtonsOnLeft)
				titleSpaceX1 = jmax (titleSpaceX1, titleBarButtons[i]->getRight() + (getWidth() - titleBarButtons[i]->getRight()) / 8);
			else
				titleSpaceX2 = jmin (titleSpaceX2, titleBarButtons[i]->getX() - (titleBarButtons[i]->getX() / 8));
		}
	}

	getLookAndFeel().drawDocumentWindowTitleBar (*this, g,
												 titleBarArea.getWidth(),
												 titleBarArea.getHeight(),
												 titleSpaceX1,
												 jmax (1, titleSpaceX2 - titleSpaceX1),
												 titleBarIcon.isValid() ? &titleBarIcon : 0,
												 ! drawTitleTextCentred);
}

void DocumentWindow::resized()
{
	ResizableWindow::resized();

	if (titleBarButtons[1] != nullptr)
		titleBarButtons[1]->setToggleState (isFullScreen(), false);

	const Rectangle<int> titleBarArea (getTitleBarArea());

	getLookAndFeel()
		.positionDocumentWindowButtons (*this,
										titleBarArea.getX(), titleBarArea.getY(),
										titleBarArea.getWidth(), titleBarArea.getHeight(),
										titleBarButtons[0],
										titleBarButtons[1],
										titleBarButtons[2],
										positionTitleBarButtonsOnLeft);

	if (menuBar != nullptr)
		menuBar->setBounds (titleBarArea.getX(), titleBarArea.getBottom(),
							titleBarArea.getWidth(), menuBarHeight);
}

BorderSize<int> DocumentWindow::getBorderThickness()
{
	return BorderSize<int> ((isFullScreen() || isUsingNativeTitleBar())
								? 0 : (resizableBorder != nullptr ? 4 : 1));
}

BorderSize<int> DocumentWindow::getContentComponentBorder()
{
	BorderSize<int> border (getBorderThickness());

	border.setTop (border.getTop()
					+ (isUsingNativeTitleBar() ? 0 : titleBarHeight)
					+ (menuBar != nullptr ? menuBarHeight : 0));

	return border;
}

int DocumentWindow::getTitleBarHeight() const
{
	return isUsingNativeTitleBar() ? 0 : jmin (titleBarHeight, getHeight() - 4);
}

Rectangle<int> DocumentWindow::getTitleBarArea()
{
	const BorderSize<int> border (getBorderThickness());

	return Rectangle<int> (border.getLeft(), border.getTop(),
						   getWidth() - border.getLeftAndRight(),
						   getTitleBarHeight());
}

Button* DocumentWindow::getCloseButton() const noexcept     { return titleBarButtons[2]; }
Button* DocumentWindow::getMinimiseButton() const noexcept  { return titleBarButtons[0]; }
Button* DocumentWindow::getMaximiseButton() const noexcept  { return titleBarButtons[1]; }

int DocumentWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = ResizableWindow::getDesktopWindowStyleFlags();

	if ((requiredButtons & minimiseButton) != 0)  styleFlags |= ComponentPeer::windowHasMinimiseButton;
	if ((requiredButtons & maximiseButton) != 0)  styleFlags |= ComponentPeer::windowHasMaximiseButton;
	if ((requiredButtons & closeButton) != 0)     styleFlags |= ComponentPeer::windowHasCloseButton;

	return styleFlags;
}

void DocumentWindow::lookAndFeelChanged()
{
	int i;
	for (i = numElementsInArray (titleBarButtons); --i >= 0;)
		titleBarButtons[i] = nullptr;

	if (! isUsingNativeTitleBar())
	{
		LookAndFeel& lf = getLookAndFeel();

		if ((requiredButtons & minimiseButton) != 0)
			titleBarButtons[0] = lf.createDocumentWindowButton (minimiseButton);

		if ((requiredButtons & maximiseButton) != 0)
			titleBarButtons[1] = lf.createDocumentWindowButton (maximiseButton);

		if ((requiredButtons & closeButton) != 0)
			titleBarButtons[2] = lf.createDocumentWindowButton (closeButton);

		for (i = 0; i < 3; ++i)
		{
			if (titleBarButtons[i] != nullptr)
			{
				if (buttonListener == nullptr)
					buttonListener = new ButtonListenerProxy (*this);

				titleBarButtons[i]->addListener (buttonListener);
				titleBarButtons[i]->setWantsKeyboardFocus (false);

				// (call the Component method directly to avoid the assertion in ResizableWindow)
				Component::addAndMakeVisible (titleBarButtons[i]);
			}
		}

		if (getCloseButton() != nullptr)
		{
		   #if JUCE_MAC
			getCloseButton()->addShortcut (KeyPress ('w', ModifierKeys::commandModifier, 0));
		   #else
			getCloseButton()->addShortcut (KeyPress (KeyPress::F4Key, ModifierKeys::altModifier, 0));
		   #endif
		}
	}

	activeWindowStatusChanged();

	ResizableWindow::lookAndFeelChanged();
}

void DocumentWindow::parentHierarchyChanged()
{
	lookAndFeelChanged();
}

void DocumentWindow::activeWindowStatusChanged()
{
	ResizableWindow::activeWindowStatusChanged();

	for (int i = numElementsInArray (titleBarButtons); --i >= 0;)
		if (titleBarButtons[i] != nullptr)
			titleBarButtons[i]->setEnabled (isActiveWindow());

	if (menuBar != nullptr)
		menuBar->setEnabled (isActiveWindow());
}

void DocumentWindow::mouseDoubleClick (const MouseEvent& e)
{
	if (getTitleBarArea().contains (e.x, e.y)
		 && getMaximiseButton() != nullptr)
	{
		getMaximiseButton()->triggerClick();
	}
}

void DocumentWindow::userTriedToCloseWindow()
{
	closeButtonPressed();
}

/*** End of inlined file: juce_DocumentWindow.cpp ***/


/*** Start of inlined file: juce_ResizableWindow.cpp ***/
ResizableWindow::ResizableWindow (const String& name,
								  const bool addToDesktop_)
	: TopLevelWindow (name, addToDesktop_),
	  ownsContentComponent (false),
	  resizeToFitContent (false),
	  fullscreen (false),
	  constrainer (nullptr)
	 #if JUCE_DEBUG
	  , hasBeenResized (false)
	 #endif
{
	initialise (addToDesktop_);
}

ResizableWindow::ResizableWindow (const String& name,
								  const Colour& backgroundColour_,
								  const bool addToDesktop_)
	: TopLevelWindow (name, addToDesktop_),
	  ownsContentComponent (false),
	  resizeToFitContent (false),
	  fullscreen (false),
	  constrainer (nullptr)
	 #if JUCE_DEBUG
	  , hasBeenResized (false)
	 #endif
{
	setBackgroundColour (backgroundColour_);

	initialise (addToDesktop_);
}

ResizableWindow::~ResizableWindow()
{
	// Don't delete or remove the resizer components yourself! They're managed by the
	// ResizableWindow, and you should leave them alone! You may have deleted them
	// accidentally by careless use of deleteAllChildren()..?
	jassert (resizableCorner == nullptr || getIndexOfChildComponent (resizableCorner) >= 0);
	jassert (resizableBorder == nullptr || getIndexOfChildComponent (resizableBorder) >= 0);

	resizableCorner = nullptr;
	resizableBorder = nullptr;
	clearContentComponent();

	// have you been adding your own components directly to this window..? tut tut tut.
	// Read the instructions for using a ResizableWindow!
	jassert (getNumChildComponents() == 0);
}

void ResizableWindow::initialise (const bool shouldAddToDesktop)
{
	defaultConstrainer.setMinimumOnscreenAmounts (0x10000, 16, 24, 16);

	lastNonFullScreenPos.setBounds (50, 50, 256, 256);

	if (shouldAddToDesktop)
		addToDesktop();
}

int ResizableWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = TopLevelWindow::getDesktopWindowStyleFlags();

	if (isResizable() && (styleFlags & ComponentPeer::windowHasTitleBar) != 0)
		styleFlags |= ComponentPeer::windowIsResizable;

	return styleFlags;
}

void ResizableWindow::addToDesktop()
{
	Component::addToDesktop (ResizableWindow::getDesktopWindowStyleFlags());
	setDropShadowEnabled (isDropShadowEnabled()); // force an update to clear away any fake shadows if necessary.
}

void ResizableWindow::clearContentComponent()
{
	if (ownsContentComponent)
	{
		contentComponent.deleteAndZero();
	}
	else
	{
		removeChildComponent (contentComponent);
		contentComponent = nullptr;
	}
}

void ResizableWindow::setContent (Component* newContentComponent,
								  const bool takeOwnership,
								  const bool resizeToFitWhenContentChangesSize)
{
	if (newContentComponent != contentComponent)
	{
		clearContentComponent();

		contentComponent = newContentComponent;
		Component::addAndMakeVisible (contentComponent);
	}

	ownsContentComponent = takeOwnership;
	resizeToFitContent = resizeToFitWhenContentChangesSize;

	if (resizeToFitWhenContentChangesSize)
		childBoundsChanged (contentComponent);

	resized(); // must always be called to position the new content comp
}

void ResizableWindow::setContentOwned (Component* newContentComponent, const bool resizeToFitWhenContentChangesSize)
{
	setContent (newContentComponent, true, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentNonOwned (Component* newContentComponent, const bool resizeToFitWhenContentChangesSize)
{
	setContent (newContentComponent, false, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentComponent (Component* const newContentComponent,
										   const bool deleteOldOne,
										   const bool resizeToFitWhenContentChangesSize)
{
	if (newContentComponent != contentComponent)
	{
		if (deleteOldOne)
		{
			contentComponent.deleteAndZero();
		}
		else
		{
			removeChildComponent (contentComponent);
			contentComponent = nullptr;
		}
	}

	setContent (newContentComponent, true, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentComponentSize (int width, int height)
{
	jassert (width > 0 && height > 0); // not a great idea to give it a zero size..

	const BorderSize<int> border (getContentComponentBorder());

	setSize (width + border.getLeftAndRight(),
			 height + border.getTopAndBottom());
}

BorderSize<int> ResizableWindow::getBorderThickness()
{
	return BorderSize<int> (isUsingNativeTitleBar() ? 0 : ((resizableBorder != nullptr && ! isFullScreen()) ? 5 : 3));
}

BorderSize<int> ResizableWindow::getContentComponentBorder()
{
	return getBorderThickness();
}

void ResizableWindow::moved()
{
	updateLastPos();
}

void ResizableWindow::visibilityChanged()
{
	TopLevelWindow::visibilityChanged();

	updateLastPos();
}

void ResizableWindow::resized()
{
	if (resizableBorder != nullptr)
	{
	   #if JUCE_WINDOWS || JUCE_LINUX
		// hide the resizable border if the OS already provides one..
		resizableBorder->setVisible (! (isFullScreen() || isUsingNativeTitleBar()));
	   #else
		resizableBorder->setVisible (! isFullScreen());
	   #endif

		resizableBorder->setBorderThickness (getBorderThickness());
		resizableBorder->setSize (getWidth(), getHeight());
		resizableBorder->toBack();
	}

	if (resizableCorner != nullptr)
	{
	   #if JUCE_MAC
		// hide the resizable border if the OS already provides one..
		resizableCorner->setVisible (! (isFullScreen() || isUsingNativeTitleBar()));
	   #else
		resizableCorner->setVisible (! isFullScreen());
	   #endif

		const int resizerSize = 18;
		resizableCorner->setBounds (getWidth() - resizerSize,
									getHeight() - resizerSize,
									resizerSize, resizerSize);
	}

	if (contentComponent != nullptr)
	{
		// The window expects to be able to be able to manage the size and position
		// of its content component, so you can't arbitrarily add a transform to it!
		jassert (! contentComponent->isTransformed());

		contentComponent->setBoundsInset (getContentComponentBorder());
	}

	updateLastPos();

   #if JUCE_DEBUG
	hasBeenResized = true;
   #endif
}

void ResizableWindow::childBoundsChanged (Component* child)
{
	if ((child == contentComponent) && (child != nullptr) && resizeToFitContent)
	{
		// not going to look very good if this component has a zero size..
		jassert (child->getWidth() > 0);
		jassert (child->getHeight() > 0);

		const BorderSize<int> borders (getContentComponentBorder());

		setSize (child->getWidth() + borders.getLeftAndRight(),
				 child->getHeight() + borders.getTopAndBottom());
	}
}

void ResizableWindow::activeWindowStatusChanged()
{
	const BorderSize<int> border (getContentComponentBorder());

	Rectangle<int> area (getLocalBounds());
	repaint (area.removeFromTop (border.getTop()));
	repaint (area.removeFromLeft (border.getLeft()));
	repaint (area.removeFromRight (border.getRight()));
	repaint (area.removeFromBottom (border.getBottom()));
}

void ResizableWindow::setResizable (const bool shouldBeResizable,
									const bool useBottomRightCornerResizer)
{
	if (shouldBeResizable)
	{
		if (useBottomRightCornerResizer)
		{
			resizableBorder = nullptr;

			if (resizableCorner == nullptr)
			{
				Component::addChildComponent (resizableCorner = new ResizableCornerComponent (this, constrainer));
				resizableCorner->setAlwaysOnTop (true);
			}
		}
		else
		{
			resizableCorner = nullptr;

			if (resizableBorder == nullptr)
				Component::addChildComponent (resizableBorder = new ResizableBorderComponent (this, constrainer));
		}
	}
	else
	{
		resizableCorner = nullptr;
		resizableBorder = nullptr;
	}

	if (isUsingNativeTitleBar())
		recreateDesktopWindow();

	childBoundsChanged (contentComponent);
	resized();
}

bool ResizableWindow::isResizable() const noexcept
{
	return resizableCorner != nullptr
		|| resizableBorder != nullptr;
}

void ResizableWindow::setResizeLimits (const int newMinimumWidth,
									   const int newMinimumHeight,
									   const int newMaximumWidth,
									   const int newMaximumHeight) noexcept
{
	// if you've set up a custom constrainer then these settings won't have any effect..
	jassert (constrainer == &defaultConstrainer || constrainer == nullptr);

	if (constrainer == nullptr)
		setConstrainer (&defaultConstrainer);

	defaultConstrainer.setSizeLimits (newMinimumWidth, newMinimumHeight,
									  newMaximumWidth, newMaximumHeight);

	setBoundsConstrained (getBounds());
}

void ResizableWindow::setConstrainer (ComponentBoundsConstrainer* newConstrainer)
{
	if (constrainer != newConstrainer)
	{
		constrainer = newConstrainer;

		const bool useBottomRightCornerResizer = resizableCorner != nullptr;
		const bool shouldBeResizable = useBottomRightCornerResizer || resizableBorder != nullptr;

		resizableCorner = nullptr;
		resizableBorder = nullptr;

		setResizable (shouldBeResizable, useBottomRightCornerResizer);

		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->setConstrainer (newConstrainer);
	}
}

void ResizableWindow::setBoundsConstrained (const Rectangle<int>& newBounds)
{
	if (constrainer != nullptr)
		constrainer->setBoundsForComponent (this, newBounds, false, false, false, false);
	else
		setBounds (newBounds);
}

void ResizableWindow::paint (Graphics& g)
{
	getLookAndFeel().fillResizableWindowBackground (g, getWidth(), getHeight(),
													getBorderThickness(), *this);

	if (! isFullScreen())
	{
		getLookAndFeel().drawResizableWindowBorder (g, getWidth(), getHeight(),
													getBorderThickness(), *this);
	}

   #if JUCE_DEBUG
	/* If this fails, then you've probably written a subclass with a resized()
	   callback but forgotten to make it call its parent class's resized() method.

	   It's important when you override methods like resized(), moved(),
	   etc., that you make sure the base class methods also get called.

	   Of course you shouldn't really be overriding ResizableWindow::resized() anyway,
	   because your content should all be inside the content component - and it's the
	   content component's resized() method that you should be using to do your
	   layout.
	*/
	jassert (hasBeenResized || (getWidth() == 0 && getHeight() == 0));
   #endif
}

void ResizableWindow::lookAndFeelChanged()
{
	resized();

	if (isOnDesktop())
	{
		Component::addToDesktop (getDesktopWindowStyleFlags());

		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->setConstrainer (constrainer);
	}
}

Colour ResizableWindow::getBackgroundColour() const noexcept
{
	return findColour (backgroundColourId, false);
}

void ResizableWindow::setBackgroundColour (const Colour& newColour)
{
	Colour backgroundColour (newColour);

	if (! Desktop::canUseSemiTransparentWindows())
		backgroundColour = newColour.withAlpha (1.0f);

	setColour (backgroundColourId, backgroundColour);

	setOpaque (backgroundColour.isOpaque());
	repaint();
}

bool ResizableWindow::isFullScreen() const
{
	if (isOnDesktop())
	{
		ComponentPeer* const peer = getPeer();
		return peer != nullptr && peer->isFullScreen();
	}

	return fullscreen;
}

void ResizableWindow::setFullScreen (const bool shouldBeFullScreen)
{
	if (shouldBeFullScreen != isFullScreen())
	{
		updateLastPos();
		fullscreen = shouldBeFullScreen;

		if (isOnDesktop())
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
			{
				// keep a copy of this intact in case the real one gets messed-up while we're un-maximising
				const Rectangle<int> lastPos (lastNonFullScreenPos);

				peer->setFullScreen (shouldBeFullScreen);

				if ((! shouldBeFullScreen) && ! lastPos.isEmpty())
					setBounds (lastPos);
			}
			else
			{
				jassertfalse;
			}
		}
		else
		{
			if (shouldBeFullScreen)
				setBounds (0, 0, getParentWidth(), getParentHeight());
			else
				setBounds (lastNonFullScreenPos);
		}

		resized();
	}
}

bool ResizableWindow::isMinimised() const
{
	ComponentPeer* const peer = getPeer();

	return (peer != nullptr) && peer->isMinimised();
}

void ResizableWindow::setMinimised (const bool shouldMinimise)
{
	if (shouldMinimise != isMinimised())
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			updateLastPos();
			peer->setMinimised (shouldMinimise);
		}
		else
		{
			jassertfalse;
		}
	}
}

void ResizableWindow::updateLastPos()
{
	if (isShowing() && ! (isFullScreen() || isMinimised()))
		lastNonFullScreenPos = getBounds();
}

void ResizableWindow::parentSizeChanged()
{
	if (isFullScreen() && getParentComponent() != nullptr)
		setBounds (0, 0, getParentWidth(), getParentHeight());
}

String ResizableWindow::getWindowStateAsString()
{
	updateLastPos();
	return (isFullScreen() ? "fs " : "") + lastNonFullScreenPos.toString();
}

bool ResizableWindow::restoreWindowStateFromString (const String& s)
{
	StringArray tokens;
	tokens.addTokens (s, false);
	tokens.removeEmptyStrings();
	tokens.trim();

	const bool fs = tokens[0].startsWithIgnoreCase ("fs");
	const int firstCoord = fs ? 1 : 0;

	if (tokens.size() != firstCoord + 4)
		return false;

	Rectangle<int> newPos (tokens[firstCoord].getIntValue(),
						   tokens[firstCoord + 1].getIntValue(),
						   tokens[firstCoord + 2].getIntValue(),
						   tokens[firstCoord + 3].getIntValue());

	if (newPos.isEmpty())
		return false;

	ComponentPeer* const peer = isOnDesktop() ? getPeer() : nullptr;
	if (peer != nullptr)
		peer->getFrameSize().addTo (newPos);

	{
		Desktop& desktop = Desktop::getInstance();
		RectangleList allMonitors (desktop.getDisplays().getRectangleList (true));
		allMonitors.clipTo (newPos);
		const Rectangle<int> onScreenArea (allMonitors.getBounds());

		if (onScreenArea.getWidth() * onScreenArea.getHeight() < 32 * 32)
		{
			const Rectangle<int> screen (desktop.getDisplays().getDisplayContaining (newPos.getCentre()).userArea);

			newPos.setSize (jmin (newPos.getWidth(),  screen.getWidth()),
							jmin (newPos.getHeight(), screen.getHeight()));

			newPos.setPosition (jlimit (screen.getX(), screen.getRight()  - newPos.getWidth(),  newPos.getX()),
								jlimit (screen.getY(), screen.getBottom() - newPos.getHeight(), newPos.getY()));
		}
	}

	if (peer != nullptr)
	{
		peer->getFrameSize().subtractFrom (newPos);
		peer->setNonFullScreenBounds (newPos);
	}

	lastNonFullScreenPos = newPos;
	setFullScreen (fs);

	if (! fs)
		setBoundsConstrained (newPos);

	return true;
}

void ResizableWindow::mouseDown (const MouseEvent& e)
{
	if (! isFullScreen())
		dragger.startDraggingComponent (this, e);
}

void ResizableWindow::mouseDrag (const MouseEvent& e)
{
	if (! isFullScreen())
		dragger.dragComponent (this, e, constrainer);
}

#if JUCE_DEBUG
void ResizableWindow::addChildComponent (Component* const child, int zOrder)
{
	/* Agh! You shouldn't add components directly to a ResizableWindow - this class
	   manages its child components automatically, and if you add your own it'll cause
	   trouble. Instead, use setContentComponent() to give it a component which
	   will be automatically resized and kept in the right place - then you can add
	   subcomponents to the content comp. See the notes for the ResizableWindow class
	   for more info.

	   If you really know what you're doing and want to avoid this assertion, just call
	   Component::addChildComponent directly.
	*/
	jassertfalse;

	Component::addChildComponent (child, zOrder);
}

void ResizableWindow::addAndMakeVisible (Component* const child, int zOrder)
{
	/* Agh! You shouldn't add components directly to a ResizableWindow - this class
	   manages its child components automatically, and if you add your own it'll cause
	   trouble. Instead, use setContentComponent() to give it a component which
	   will be automatically resized and kept in the right place - then you can add
	   subcomponents to the content comp. See the notes for the ResizableWindow class
	   for more info.

	   If you really know what you're doing and want to avoid this assertion, just call
	   Component::addAndMakeVisible directly.
	*/
	jassertfalse;

	Component::addAndMakeVisible (child, zOrder);
}
#endif

/*** End of inlined file: juce_ResizableWindow.cpp ***/


/*** Start of inlined file: juce_ThreadWithProgressWindow.cpp ***/
ThreadWithProgressWindow::ThreadWithProgressWindow (const String& title,
													const bool hasProgressBar,
													const bool hasCancelButton,
													const int timeOutMsWhenCancelling_,
													const String& cancelButtonText)
  : Thread ("Juce Progress Window"),
	progress (0.0),
	timeOutMsWhenCancelling (timeOutMsWhenCancelling_)
{
	alertWindow = LookAndFeel::getDefaultLookAndFeel()
					.createAlertWindow (title, String::empty, cancelButtonText,
										String::empty, String::empty,
										AlertWindow::NoIcon, hasCancelButton ? 1 : 0, 0);

	// if there are no buttons, we won't allow the user to interrupt the thread.
	alertWindow->setEscapeKeyCancels (false);

	if (hasProgressBar)
		alertWindow->addProgressBarComponent (progress);
}

ThreadWithProgressWindow::~ThreadWithProgressWindow()
{
	stopThread (timeOutMsWhenCancelling);
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool ThreadWithProgressWindow::runThread (const int priority)
{
	jassert (MessageManager::getInstance()->isThisTheMessageThread());

	startThread (priority);
	startTimer (100);

	{
		const ScopedLock sl (messageLock);
		alertWindow->setMessage (message);
	}

	const bool finishedNaturally = alertWindow->runModalLoop() != 0;

	stopThread (timeOutMsWhenCancelling);

	alertWindow->setVisible (false);

	return finishedNaturally;
}
#endif

void ThreadWithProgressWindow::setProgress (const double newProgress)
{
	progress = newProgress;
}

void ThreadWithProgressWindow::setStatusMessage (const String& newStatusMessage)
{
	const ScopedLock sl (messageLock);
	message = newStatusMessage;
}

void ThreadWithProgressWindow::timerCallback()
{
	if (! isThreadRunning())
	{
		// thread has finished normally..
		alertWindow->exitModalState (1);
		alertWindow->setVisible (false);
	}
	else
	{
		const ScopedLock sl (messageLock);
		alertWindow->setMessage (message);
	}
}

/*** End of inlined file: juce_ThreadWithProgressWindow.cpp ***/


/*** Start of inlined file: juce_TooltipWindow.cpp ***/
TooltipWindow::TooltipWindow (Component* const parent_,
							  const int millisecondsBeforeTipAppears_)
	: Component ("tooltip"),
	  millisecondsBeforeTipAppears (millisecondsBeforeTipAppears_),
	  mouseClicks (0),
	  lastHideTime (0),
	  lastComponentUnderMouse (nullptr),
	  changedCompsSinceShown (true)
{
	if (Desktop::getInstance().getMainMouseSource().canHover())
		startTimer (123);

	setAlwaysOnTop (true);
	setOpaque (true);

	if (parent_ != nullptr)
		parent_->addChildComponent (this);
}

TooltipWindow::~TooltipWindow()
{
	hide();
}

void TooltipWindow::setMillisecondsBeforeTipAppears (const int newTimeMs) noexcept
{
	millisecondsBeforeTipAppears = newTimeMs;
}

void TooltipWindow::paint (Graphics& g)
{
	getLookAndFeel().drawTooltip (g, tipShowing, getWidth(), getHeight());
}

void TooltipWindow::mouseEnter (const MouseEvent&)
{
	hide();
}

void TooltipWindow::showFor (const String& tip)
{
	jassert (tip.isNotEmpty());
	if (tipShowing != tip)
		repaint();

	tipShowing = tip;

	Point<int> mousePos (Desktop::getMousePosition());
	Rectangle<int> parentArea;
	Component* const parent = getParentComponent();

	if (parent != nullptr)
	{
		mousePos   = parent->getLocalPoint (nullptr, mousePos);
		parentArea = parent->getLocalBounds();
	}
	else
	{
		parentArea = Desktop::getInstance().getDisplays().getDisplayContaining (mousePos).userArea;
	}

	int w, h;
	getLookAndFeel().getTooltipSize (tip, w, h);

	int x = mousePos.x;
	if (x > parentArea.getCentreX())
		x -= (w + 12);
	else
		x += 24;

	int y = mousePos.y;
	if (y > parentArea.getCentreY())
		y -= (h + 6);
	else
		y += 6;

	x = jlimit (parentArea.getX(), parentArea.getRight()  - w, x);
	y = jlimit (parentArea.getY(), parentArea.getBottom() - h, y);

	setBounds (x, y, w, h);
	setVisible (true);

	if (parent == nullptr)
		addToDesktop (ComponentPeer::windowHasDropShadow
						| ComponentPeer::windowIsTemporary
						| ComponentPeer::windowIgnoresKeyPresses);

	toFront (false);
}

String TooltipWindow::getTipFor (Component* const c)
{
	if (c != nullptr
		 && Process::isForegroundProcess()
		 && ! Component::isMouseButtonDownAnywhere())
	{
		TooltipClient* const ttc = dynamic_cast <TooltipClient*> (c);

		if (ttc != nullptr && ! c->isCurrentlyBlockedByAnotherModalComponent())
			return ttc->getTooltip();
	}

	return String::empty;
}

void TooltipWindow::hide()
{
	tipShowing = String::empty;
	removeFromDesktop();
	setVisible (false);
}

void TooltipWindow::timerCallback()
{
	const unsigned int now = Time::getApproximateMillisecondCounter();
	Component* const newComp = Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();
	const String newTip (getTipFor (newComp));

	const bool tipChanged = (newTip != lastTipUnderMouse || newComp != lastComponentUnderMouse);
	lastComponentUnderMouse = newComp;
	lastTipUnderMouse = newTip;

	const int clickCount = Desktop::getInstance().getMouseButtonClickCounter();
	const bool mouseWasClicked = clickCount > mouseClicks;
	mouseClicks = clickCount;

	const Point<int> mousePos (Desktop::getMousePosition());
	const bool mouseMovedQuickly = mousePos.getDistanceFrom (lastMousePos) > 12;
	lastMousePos = mousePos;

	if (tipChanged || mouseWasClicked || mouseMovedQuickly)
		lastCompChangeTime = now;

	if (isVisible() || now < lastHideTime + 500)
	{
		// if a tip is currently visible (or has just disappeared), update to a new one
		// immediately if needed..
		if (newComp == nullptr || mouseWasClicked || newTip.isEmpty())
		{
			if (isVisible())
			{
				lastHideTime = now;
				hide();
			}
		}
		else if (tipChanged)
		{
			showFor (newTip);
		}
	}
	else
	{
		// if there isn't currently a tip, but one is needed, only let it
		// appear after a timeout..
		if (newTip.isNotEmpty()
			 && newTip != tipShowing
			 && now > lastCompChangeTime + millisecondsBeforeTipAppears)
		{
			showFor (newTip);
		}
	}
}

/*** End of inlined file: juce_TooltipWindow.cpp ***/


/*** Start of inlined file: juce_TopLevelWindow.cpp ***/
/** Keeps track of the active top level window. */
class TopLevelWindowManager  : public Timer,
							   public DeletedAtShutdown
{
public:

	TopLevelWindowManager()
		: currentActive (nullptr)
	{
	}

	~TopLevelWindowManager()
	{
		clearSingletonInstance();
	}

	juce_DeclareSingleton_SingleThreaded_Minimal (TopLevelWindowManager);

	void timerCallback()
	{
		startTimer (jmin (1731, getTimerInterval() * 2));

		TopLevelWindow* active = nullptr;

		if (Process::isForegroundProcess())
		{
			active = currentActive;

			Component* const c = Component::getCurrentlyFocusedComponent();
			TopLevelWindow* tlw = dynamic_cast <TopLevelWindow*> (c);

			if (tlw == nullptr && c != nullptr)
				tlw = c->findParentComponentOfClass<TopLevelWindow>();

			if (tlw != nullptr)
				active = tlw;
		}

		if (active != currentActive)
		{
			currentActive = active;

			for (int i = windows.size(); --i >= 0;)
			{
				TopLevelWindow* const tlw = windows.getUnchecked (i);
				tlw->setWindowActive (isWindowActive (tlw));

				i = jmin (i, windows.size() - 1);
			}

			Desktop::getInstance().triggerFocusCallback();
		}
	}

	bool addWindow (TopLevelWindow* const w)
	{
		windows.add (w);
		startTimer (10);

		return isWindowActive (w);
	}

	void removeWindow (TopLevelWindow* const w)
	{
		startTimer (10);

		if (currentActive == w)
			currentActive = nullptr;

		windows.removeValue (w);

		if (windows.size() == 0)
			deleteInstance();
	}

	Array <TopLevelWindow*> windows;

private:
	TopLevelWindow* currentActive;

	bool isWindowActive (TopLevelWindow* const tlw) const
	{
		return (tlw == currentActive
				 || tlw->isParentOf (currentActive)
				 || tlw->hasKeyboardFocus (true))
				&& tlw->isShowing();
	}

	JUCE_DECLARE_NON_COPYABLE (TopLevelWindowManager);
};

juce_ImplementSingleton_SingleThreaded (TopLevelWindowManager)

void juce_CheckCurrentlyFocusedTopLevelWindow();
void juce_CheckCurrentlyFocusedTopLevelWindow()
{
	if (TopLevelWindowManager::getInstanceWithoutCreating() != nullptr)
		TopLevelWindowManager::getInstanceWithoutCreating()->startTimer (20);
}

TopLevelWindow::TopLevelWindow (const String& name,
								const bool addToDesktop_)
	: Component (name),
	  useDropShadow (true),
	  useNativeTitleBar (false),
	  windowIsActive_ (false)
{
	setOpaque (true);

	if (addToDesktop_)
		Component::addToDesktop (TopLevelWindow::getDesktopWindowStyleFlags());
	else
		setDropShadowEnabled (true);

	setWantsKeyboardFocus (true);
	setBroughtToFrontOnMouseClick (true);
	windowIsActive_ = TopLevelWindowManager::getInstance()->addWindow (this);
}

TopLevelWindow::~TopLevelWindow()
{
	shadower = nullptr;
	TopLevelWindowManager::getInstance()->removeWindow (this);
}

void TopLevelWindow::focusOfChildComponentChanged (FocusChangeType)
{
	if (hasKeyboardFocus (true))
		TopLevelWindowManager::getInstance()->timerCallback();
	else
		TopLevelWindowManager::getInstance()->startTimer (10);
}

void TopLevelWindow::setWindowActive (const bool isNowActive)
{
	if (windowIsActive_ != isNowActive)
	{
		windowIsActive_ = isNowActive;
		activeWindowStatusChanged();
	}
}

void TopLevelWindow::activeWindowStatusChanged()
{
}

void TopLevelWindow::visibilityChanged()
{
	if (isShowing()
		 && (getPeer()->getStyleFlags() & (ComponentPeer::windowIsTemporary
											| ComponentPeer::windowIgnoresKeyPresses)) == 0)
	{
		toFront (true);
	}
}

void TopLevelWindow::parentHierarchyChanged()
{
	setDropShadowEnabled (useDropShadow);
}

int TopLevelWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = ComponentPeer::windowAppearsOnTaskbar;

	if (useDropShadow)
		styleFlags |= ComponentPeer::windowHasDropShadow;

	if (useNativeTitleBar)
		styleFlags |= ComponentPeer::windowHasTitleBar;

	return styleFlags;
}

void TopLevelWindow::setDropShadowEnabled (const bool useShadow)
{
	useDropShadow = useShadow;

	if (isOnDesktop())
	{
		shadower = nullptr;
		Component::addToDesktop (getDesktopWindowStyleFlags());
	}
	else
	{
		if (useShadow && isOpaque())
		{
			if (shadower == nullptr)
			{
				shadower = getLookAndFeel().createDropShadowerForComponent (this);

				if (shadower != nullptr)
					shadower->setOwner (this);
			}
		}
		else
		{
			shadower = nullptr;
		}
	}
}

void TopLevelWindow::setUsingNativeTitleBar (const bool useNativeTitleBar_)
{
	if (useNativeTitleBar != useNativeTitleBar_)
	{
		useNativeTitleBar = useNativeTitleBar_;
		recreateDesktopWindow();
		sendLookAndFeelChange();
	}
}

void TopLevelWindow::recreateDesktopWindow()
{
	if (isOnDesktop())
	{
		Component::addToDesktop (getDesktopWindowStyleFlags());
		toFront (true);
	}
}

void TopLevelWindow::addToDesktop (int windowStyleFlags, void* nativeWindowToAttachTo)
{
	/* It's not recommended to change the desktop window flags directly for a TopLevelWindow,
	   because this class needs to make sure its layout corresponds with settings like whether
	   it's got a native title bar or not.

	   If you need custom flags for your window, you can override the getDesktopWindowStyleFlags()
	   method. If you do this, it's best to call the base class's getDesktopWindowStyleFlags()
	   method, then add or remove whatever flags are necessary from this value before returning it.
	*/

	jassert ((windowStyleFlags & ~ComponentPeer::windowIsSemiTransparent)
			   == (getDesktopWindowStyleFlags() & ~ComponentPeer::windowIsSemiTransparent));

	Component::addToDesktop (windowStyleFlags, nativeWindowToAttachTo);

	if (windowStyleFlags != getDesktopWindowStyleFlags())
		sendLookAndFeelChange();
}

void TopLevelWindow::centreAroundComponent (Component* c, const int width, const int height)
{
	if (c == nullptr)
		c = TopLevelWindow::getActiveTopLevelWindow();

	if (c == nullptr || c->getBounds().isEmpty())
	{
		centreWithSize (width, height);
	}
	else
	{
		Point<int> targetCentre (c->localPointToGlobal (c->getLocalBounds().getCentre()));
		Rectangle<int> parentArea (c->getParentMonitorArea());

		if (getParentComponent() != nullptr)
		{
			targetCentre = getParentComponent()->getLocalPoint (nullptr, targetCentre);
			parentArea = getParentComponent()->getLocalBounds();
		}

		parentArea.reduce (12, 12);

		setBounds (jlimit (parentArea.getX(), jmax (parentArea.getX(), parentArea.getRight() - width), targetCentre.getX() - width / 2),
				   jlimit (parentArea.getY(), jmax (parentArea.getY(), parentArea.getBottom() - height), targetCentre.getY() - height / 2),
				   width, height);
	}
}

int TopLevelWindow::getNumTopLevelWindows() noexcept
{
	return TopLevelWindowManager::getInstance()->windows.size();
}

TopLevelWindow* TopLevelWindow::getTopLevelWindow (const int index) noexcept
{
	return static_cast <TopLevelWindow*> (TopLevelWindowManager::getInstance()->windows [index]);
}

TopLevelWindow* TopLevelWindow::getActiveTopLevelWindow() noexcept
{
	TopLevelWindow* best = nullptr;
	int bestNumTWLParents = -1;

	for (int i = TopLevelWindow::getNumTopLevelWindows(); --i >= 0;)
	{
		TopLevelWindow* const tlw = TopLevelWindow::getTopLevelWindow (i);

		if (tlw->isActiveWindow())
		{
			int numTWLParents = 0;

			const Component* c = tlw->getParentComponent();

			while (c != nullptr)
			{
				if (dynamic_cast <const TopLevelWindow*> (c) != nullptr)
					++numTWLParents;

				c = c->getParentComponent();
			}

			if (bestNumTWLParents < numTWLParents)
			{
				best = tlw;
				bestNumTWLParents = numTWLParents;
			}
		}
	}

	return best;
}

/*** End of inlined file: juce_TopLevelWindow.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandInfo.cpp ***/
ApplicationCommandInfo::ApplicationCommandInfo (const CommandID commandID_) noexcept
	: commandID (commandID_),
	  flags (0)
{
}

void ApplicationCommandInfo::setInfo (const String& shortName_,
									  const String& description_,
									  const String& categoryName_,
									  const int flags_) noexcept
{
	shortName = shortName_;
	description = description_;
	categoryName = categoryName_;
	flags = flags_;
}

void ApplicationCommandInfo::setActive (const bool b) noexcept
{
	if (b)
		flags &= ~isDisabled;
	else
		flags |= isDisabled;
}

void ApplicationCommandInfo::setTicked (const bool b) noexcept
{
	if (b)
		flags |= isTicked;
	else
		flags &= ~isTicked;
}

void ApplicationCommandInfo::addDefaultKeypress (const int keyCode, const ModifierKeys& modifiers) noexcept
{
	defaultKeypresses.add (KeyPress (keyCode, modifiers, 0));
}

/*** End of inlined file: juce_ApplicationCommandInfo.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandManager.cpp ***/
ApplicationCommandManager::ApplicationCommandManager()
	: firstTarget (nullptr)
{
	keyMappings = new KeyPressMappingSet (this);

	Desktop::getInstance().addFocusChangeListener (this);
}

ApplicationCommandManager::~ApplicationCommandManager()
{
	Desktop::getInstance().removeFocusChangeListener (this);
	keyMappings = nullptr;
}

void ApplicationCommandManager::clearCommands()
{
	commands.clear();
	keyMappings->clearAllKeyPresses();
	triggerAsyncUpdate();
}

void ApplicationCommandManager::registerCommand (const ApplicationCommandInfo& newCommand)
{
	// zero isn't a valid command ID!
	jassert (newCommand.commandID != 0);

	// the name isn't optional!
	jassert (newCommand.shortName.isNotEmpty());

	if (getCommandForID (newCommand.commandID) == 0)
	{
		ApplicationCommandInfo* const newInfo = new ApplicationCommandInfo (newCommand);
		newInfo->flags &= ~ApplicationCommandInfo::isTicked;
		commands.add (newInfo);

		keyMappings->resetToDefaultMapping (newCommand.commandID);

		triggerAsyncUpdate();
	}
	else
	{
		// trying to re-register the same command with different parameters?
		jassert (newCommand.shortName == getCommandForID (newCommand.commandID)->shortName
				  && (newCommand.description == getCommandForID (newCommand.commandID)->description || newCommand.description.isEmpty())
				  && newCommand.categoryName == getCommandForID (newCommand.commandID)->categoryName
				  && newCommand.defaultKeypresses == getCommandForID (newCommand.commandID)->defaultKeypresses
				  && (newCommand.flags & (ApplicationCommandInfo::wantsKeyUpDownCallbacks | ApplicationCommandInfo::hiddenFromKeyEditor | ApplicationCommandInfo::readOnlyInKeyEditor))
					   == (getCommandForID (newCommand.commandID)->flags & (ApplicationCommandInfo::wantsKeyUpDownCallbacks | ApplicationCommandInfo::hiddenFromKeyEditor | ApplicationCommandInfo::readOnlyInKeyEditor)));
	}
}

void ApplicationCommandManager::registerAllCommandsForTarget (ApplicationCommandTarget* target)
{
	if (target != nullptr)
	{
		Array <CommandID> commandIDs;
		target->getAllCommands (commandIDs);

		for (int i = 0; i < commandIDs.size(); ++i)
		{
			ApplicationCommandInfo info (commandIDs.getUnchecked(i));
			target->getCommandInfo (info.commandID, info);

			registerCommand (info);
		}
	}
}

void ApplicationCommandManager::removeCommand (const CommandID commandID)
{
	for (int i = commands.size(); --i >= 0;)
	{
		if (commands.getUnchecked (i)->commandID == commandID)
		{
			commands.remove (i);
			triggerAsyncUpdate();

			const Array <KeyPress> keys (keyMappings->getKeyPressesAssignedToCommand (commandID));

			for (int j = keys.size(); --j >= 0;)
				keyMappings->removeKeyPress (keys.getReference (j));
		}
	}
}

void ApplicationCommandManager::commandStatusChanged()
{
	triggerAsyncUpdate();
}

const ApplicationCommandInfo* ApplicationCommandManager::getCommandForID (const CommandID commandID) const noexcept
{
	for (int i = commands.size(); --i >= 0;)
		if (commands.getUnchecked(i)->commandID == commandID)
			return commands.getUnchecked(i);

	return nullptr;
}

String ApplicationCommandManager::getNameOfCommand (const CommandID commandID) const noexcept
{
	const ApplicationCommandInfo* const ci = getCommandForID (commandID);

	return ci != nullptr ? ci->shortName : String::empty;
}

String ApplicationCommandManager::getDescriptionOfCommand (const CommandID commandID) const noexcept
{
	const ApplicationCommandInfo* const ci = getCommandForID (commandID);

	return ci != nullptr ? (ci->description.isNotEmpty() ? ci->description : ci->shortName)
						 : String::empty;
}

StringArray ApplicationCommandManager::getCommandCategories() const
{
	StringArray s;

	for (int i = 0; i < commands.size(); ++i)
		s.addIfNotAlreadyThere (commands.getUnchecked(i)->categoryName, false);

	return s;
}

Array<CommandID> ApplicationCommandManager::getCommandsInCategory (const String& categoryName) const
{
	Array <CommandID> results;

	for (int i = 0; i < commands.size(); ++i)
		if (commands.getUnchecked(i)->categoryName == categoryName)
			results.add (commands.getUnchecked(i)->commandID);

	return results;
}

bool ApplicationCommandManager::invokeDirectly (const CommandID commandID, const bool asynchronously)
{
	ApplicationCommandTarget::InvocationInfo info (commandID);
	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::direct;

	return invoke (info, asynchronously);
}

bool ApplicationCommandManager::invoke (const ApplicationCommandTarget::InvocationInfo& info_, const bool asynchronously)
{
	// This call isn't thread-safe for use from a non-UI thread without locking the message
	// manager first..
	jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

	ApplicationCommandInfo commandInfo (0);
	ApplicationCommandTarget* const target = getTargetForCommand (info_.commandID, commandInfo);

	if (target == nullptr)
		return false;

	ApplicationCommandTarget::InvocationInfo info (info_);
	info.commandFlags = commandInfo.flags;

	sendListenerInvokeCallback (info);

	const bool ok = target->invoke (info, asynchronously);

	commandStatusChanged();

	return ok;
}

ApplicationCommandTarget* ApplicationCommandManager::getFirstCommandTarget (const CommandID)
{
	return firstTarget != nullptr ? firstTarget
								  : findDefaultComponentTarget();
}

void ApplicationCommandManager::setFirstCommandTarget (ApplicationCommandTarget* const newTarget) noexcept
{
	firstTarget = newTarget;
}

ApplicationCommandTarget* ApplicationCommandManager::getTargetForCommand (const CommandID commandID,
																		  ApplicationCommandInfo& upToDateInfo)
{
	ApplicationCommandTarget* target = getFirstCommandTarget (commandID);

	if (target == nullptr)
		target = JUCEApplication::getInstance();

	if (target != nullptr)
		target = target->getTargetForCommand (commandID);

	if (target != nullptr)
		target->getCommandInfo (commandID, upToDateInfo);

	return target;
}

ApplicationCommandTarget* ApplicationCommandManager::findTargetForComponent (Component* c)
{
	ApplicationCommandTarget* target = dynamic_cast <ApplicationCommandTarget*> (c);

	if (target == nullptr && c != nullptr)
		target = c->findParentComponentOfClass<ApplicationCommandTarget>();

	return target;
}

ApplicationCommandTarget* ApplicationCommandManager::findDefaultComponentTarget()
{
	Component* c = Component::getCurrentlyFocusedComponent();

	if (c == nullptr)
	{
		TopLevelWindow* const activeWindow = TopLevelWindow::getActiveTopLevelWindow();

		if (activeWindow != nullptr)
		{
			c = activeWindow->getPeer()->getLastFocusedSubcomponent();

			if (c == nullptr)
				c = activeWindow;
		}
	}

	if (c == nullptr && Process::isForegroundProcess())
	{
		// getting a bit desperate now - try all desktop comps..
		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			ApplicationCommandTarget* const target
				= findTargetForComponent (Desktop::getInstance().getComponent (i)
											  ->getPeer()->getLastFocusedSubcomponent());

			if (target != nullptr)
				return target;
		}
	}

	if (c != nullptr)
	{
		ResizableWindow* const resizableWindow = dynamic_cast <ResizableWindow*> (c);

		// if we're focused on a ResizableWindow, chances are that it's the content
		// component that really should get the event. And if not, the event will
		// still be passed up to the top level window anyway, so let's send it to the
		// content comp.
		if (resizableWindow != nullptr && resizableWindow->getContentComponent() != nullptr)
			c = resizableWindow->getContentComponent();

		ApplicationCommandTarget* const target = findTargetForComponent (c);

		if (target != nullptr)
			return target;
	}

	return JUCEApplication::getInstance();
}

void ApplicationCommandManager::addListener (ApplicationCommandManagerListener* const listener)
{
	listeners.add (listener);
}

void ApplicationCommandManager::removeListener (ApplicationCommandManagerListener* const listener)
{
	listeners.remove (listener);
}

void ApplicationCommandManager::sendListenerInvokeCallback (const ApplicationCommandTarget::InvocationInfo& info)
{
	listeners.call (&ApplicationCommandManagerListener::applicationCommandInvoked, info);
}

void ApplicationCommandManager::handleAsyncUpdate()
{
	listeners.call (&ApplicationCommandManagerListener::applicationCommandListChanged);
}

void ApplicationCommandManager::globalFocusChanged (Component*)
{
	commandStatusChanged();
}

/*** End of inlined file: juce_ApplicationCommandManager.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandTarget.cpp ***/
class ApplicationCommandTarget::CommandMessage  : public MessageManager::MessageBase
{
public:
	CommandMessage (ApplicationCommandTarget* const owner_, const InvocationInfo& info_)
		: owner (owner_), info (info_)
	{
	}

	void messageCallback()
	{
		ApplicationCommandTarget* const target = owner;
		if (target != nullptr)
			target->tryToInvoke (info, false);
	}

private:
	WeakReference<ApplicationCommandTarget> owner;
	const InvocationInfo info;

	JUCE_DECLARE_NON_COPYABLE (CommandMessage);
};

ApplicationCommandTarget::ApplicationCommandTarget()
{
}

ApplicationCommandTarget::~ApplicationCommandTarget()
{
	masterReference.clear();
}

bool ApplicationCommandTarget::tryToInvoke (const InvocationInfo& info, const bool async)
{
	if (isCommandActive (info.commandID))
	{
		if (async)
		{
			(new CommandMessage (this, info))->post();
			return true;
		}
		else
		{
			const bool success = perform (info);

			jassert (success);  // hmm - your target should have been able to perform this command. If it can't
								// do it at the moment for some reason, it should clear the 'isActive' flag when it
								// returns the command's info.
			return success;
		}
	}

	return false;
}

ApplicationCommandTarget* ApplicationCommandTarget::findFirstTargetParentComponent()
{
	Component* c = dynamic_cast <Component*> (this);

	if (c != nullptr)
		return c->findParentComponentOfClass<ApplicationCommandTarget>();

	return nullptr;
}

ApplicationCommandTarget* ApplicationCommandTarget::getTargetForCommand (const CommandID commandID)
{
	ApplicationCommandTarget* target = this;
	int depth = 0;

	while (target != nullptr)
	{
		Array <CommandID> commandIDs;
		target->getAllCommands (commandIDs);

		if (commandIDs.contains (commandID))
			return target;

		target = target->getNextCommandTarget();

		++depth;
		jassert (depth < 100); // could be a recursive command chain??
		jassert (target != this); // definitely a recursive command chain!

		if (depth > 100 || target == this)
			break;
	}

	if (target == nullptr)
	{
		target = JUCEApplication::getInstance();

		if (target != nullptr)
		{
			Array <CommandID> commandIDs;
			target->getAllCommands (commandIDs);

			if (commandIDs.contains (commandID))
				return target;
		}
	}

	return nullptr;
}

bool ApplicationCommandTarget::isCommandActive (const CommandID commandID)
{
	ApplicationCommandInfo info (commandID);
	info.flags = ApplicationCommandInfo::isDisabled;

	getCommandInfo (commandID, info);

	return (info.flags & ApplicationCommandInfo::isDisabled) == 0;
}

bool ApplicationCommandTarget::invoke (const InvocationInfo& info, const bool async)
{
	ApplicationCommandTarget* target = this;
	int depth = 0;

	while (target != nullptr)
	{
		if (target->tryToInvoke (info, async))
			return true;

		target = target->getNextCommandTarget();

		++depth;
		jassert (depth < 100); // could be a recursive command chain??
		jassert (target != this); // definitely a recursive command chain!

		if (depth > 100 || target == this)
			break;
	}

	if (target == nullptr)
	{
		target = JUCEApplication::getInstance();

		if (target != nullptr)
			return target->tryToInvoke (info, async);
	}

	return false;
}

bool ApplicationCommandTarget::invokeDirectly (const CommandID commandID, const bool asynchronously)
{
	ApplicationCommandTarget::InvocationInfo info (commandID);
	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::direct;

	return invoke (info, asynchronously);
}

ApplicationCommandTarget::InvocationInfo::InvocationInfo (const CommandID commandID_)
	: commandID (commandID_),
	  commandFlags (0),
	  invocationMethod (direct),
	  originatingComponent (nullptr),
	  isKeyDown (false),
	  millisecsSinceKeyPressed (0)
{
}

/*** End of inlined file: juce_ApplicationCommandTarget.cpp ***/


/*** Start of inlined file: juce_KeyPressMappingSet.cpp ***/
KeyPressMappingSet::KeyPressMappingSet (ApplicationCommandManager* const commandManager_)
	: commandManager (commandManager_)
{
	// A manager is needed to get the descriptions of commands, and will be called when
	// a command is invoked. So you can't leave this null..
	jassert (commandManager_ != nullptr);

	Desktop::getInstance().addFocusChangeListener (this);
}

KeyPressMappingSet::KeyPressMappingSet (const KeyPressMappingSet& other)
	: commandManager (other.commandManager)
{
	Desktop::getInstance().addFocusChangeListener (this);
}

KeyPressMappingSet::~KeyPressMappingSet()
{
	Desktop::getInstance().removeFocusChangeListener (this);
}

Array<KeyPress> KeyPressMappingSet::getKeyPressesAssignedToCommand (const CommandID commandID) const
{
	for (int i = 0; i < mappings.size(); ++i)
		if (mappings.getUnchecked(i)->commandID == commandID)
			return mappings.getUnchecked (i)->keypresses;

	return Array<KeyPress>();
}

void KeyPressMappingSet::addKeyPress (const CommandID commandID,
									  const KeyPress& newKeyPress,
									  int insertIndex)
{
	// If you specify an upper-case letter but no shift key, how is the user supposed to press it!?
	// Stick to lower-case letters when defining a keypress, to avoid ambiguity.
	jassert (! (CharacterFunctions::isUpperCase (newKeyPress.getTextCharacter())
				 && ! newKeyPress.getModifiers().isShiftDown()));

	if (findCommandForKeyPress (newKeyPress) != commandID)
	{
		if (newKeyPress.isValid())
		{
			for (int i = mappings.size(); --i >= 0;)
			{
				if (mappings.getUnchecked(i)->commandID == commandID)
				{
					mappings.getUnchecked(i)->keypresses.insert (insertIndex, newKeyPress);

					sendChangeMessage();
					return;
				}
			}

			const ApplicationCommandInfo* const ci = commandManager->getCommandForID (commandID);

			if (ci != nullptr)
			{
				CommandMapping* const cm = new CommandMapping();
				cm->commandID = commandID;
				cm->keypresses.add (newKeyPress);
				cm->wantsKeyUpDownCallbacks = (ci->flags & ApplicationCommandInfo::wantsKeyUpDownCallbacks) != 0;

				mappings.add (cm);
				sendChangeMessage();
			}
		}
	}
}

void KeyPressMappingSet::resetToDefaultMappings()
{
	mappings.clear();

	for (int i = 0; i < commandManager->getNumCommands(); ++i)
	{
		const ApplicationCommandInfo* const ci = commandManager->getCommandForIndex (i);

		for (int j = 0; j < ci->defaultKeypresses.size(); ++j)
		{
			addKeyPress (ci->commandID,
						 ci->defaultKeypresses.getReference (j));
		}
	}

	sendChangeMessage();
}

void KeyPressMappingSet::resetToDefaultMapping (const CommandID commandID)
{
	clearAllKeyPresses (commandID);

	const ApplicationCommandInfo* const ci = commandManager->getCommandForID (commandID);

	for (int j = 0; j < ci->defaultKeypresses.size(); ++j)
	{
		addKeyPress (ci->commandID,
					 ci->defaultKeypresses.getReference (j));
	}
}

void KeyPressMappingSet::clearAllKeyPresses()
{
	if (mappings.size() > 0)
	{
		sendChangeMessage();
		mappings.clear();
	}
}

void KeyPressMappingSet::clearAllKeyPresses (const CommandID commandID)
{
	for (int i = mappings.size(); --i >= 0;)
	{
		if (mappings.getUnchecked(i)->commandID == commandID)
		{
			mappings.remove (i);
			sendChangeMessage();
		}
	}
}

void KeyPressMappingSet::removeKeyPress (const KeyPress& keypress)
{
	if (keypress.isValid())
	{
		for (int i = mappings.size(); --i >= 0;)
		{
			CommandMapping* const cm = mappings.getUnchecked(i);

			for (int j = cm->keypresses.size(); --j >= 0;)
			{
				if (keypress == cm->keypresses [j])
				{
					cm->keypresses.remove (j);
					sendChangeMessage();
				}
			}
		}
	}
}

void KeyPressMappingSet::removeKeyPress (const CommandID commandID, const int keyPressIndex)
{
	for (int i = mappings.size(); --i >= 0;)
	{
		if (mappings.getUnchecked(i)->commandID == commandID)
		{
			mappings.getUnchecked(i)->keypresses.remove (keyPressIndex);
			sendChangeMessage();
			break;
		}
	}
}

CommandID KeyPressMappingSet::findCommandForKeyPress (const KeyPress& keyPress) const noexcept
{
	for (int i = 0; i < mappings.size(); ++i)
		if (mappings.getUnchecked(i)->keypresses.contains (keyPress))
			return mappings.getUnchecked(i)->commandID;

	return 0;
}

bool KeyPressMappingSet::containsMapping (const CommandID commandID, const KeyPress& keyPress) const noexcept
{
	for (int i = mappings.size(); --i >= 0;)
		if (mappings.getUnchecked(i)->commandID == commandID)
			return mappings.getUnchecked(i)->keypresses.contains (keyPress);

	return false;
}

void KeyPressMappingSet::invokeCommand (const CommandID commandID,
										const KeyPress& key,
										const bool isKeyDown,
										const int millisecsSinceKeyPressed,
										Component* const originatingComponent) const
{
	ApplicationCommandTarget::InvocationInfo info (commandID);

	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromKeyPress;
	info.isKeyDown = isKeyDown;
	info.keyPress = key;
	info.millisecsSinceKeyPressed = millisecsSinceKeyPressed;
	info.originatingComponent = originatingComponent;

	commandManager->invoke (info, false);
}

bool KeyPressMappingSet::restoreFromXml (const XmlElement& xmlVersion)
{
	if (xmlVersion.hasTagName ("KEYMAPPINGS"))
	{
		if (xmlVersion.getBoolAttribute ("basedOnDefaults", true))
		{
			// if the XML was created as a set of differences from the default mappings,
			// (i.e. by calling createXml (true)), then we need to first restore the defaults.
			resetToDefaultMappings();
		}
		else
		{
			// if the XML was created calling createXml (false), then we need to clear all
			// the keys and treat the xml as describing the entire set of mappings.
			clearAllKeyPresses();
		}

		forEachXmlChildElement (xmlVersion, map)
		{
			const CommandID commandId = map->getStringAttribute ("commandId").getHexValue32();

			if (commandId != 0)
			{
				const KeyPress key (KeyPress::createFromDescription (map->getStringAttribute ("key")));

				if (map->hasTagName ("MAPPING"))
				{
					addKeyPress (commandId, key);
				}
				else if (map->hasTagName ("UNMAPPING"))
				{
					if (containsMapping (commandId, key))
						removeKeyPress (key);
				}
			}
		}

		return true;
	}

	return false;
}

XmlElement* KeyPressMappingSet::createXml (const bool saveDifferencesFromDefaultSet) const
{
	ScopedPointer <KeyPressMappingSet> defaultSet;

	if (saveDifferencesFromDefaultSet)
	{
		defaultSet = new KeyPressMappingSet (commandManager);
		defaultSet->resetToDefaultMappings();
	}

	XmlElement* const doc = new XmlElement ("KEYMAPPINGS");

	doc->setAttribute ("basedOnDefaults", saveDifferencesFromDefaultSet);

	int i;
	for (i = 0; i < mappings.size(); ++i)
	{
		const CommandMapping* const cm = mappings.getUnchecked(i);

		for (int j = 0; j < cm->keypresses.size(); ++j)
		{
			if (defaultSet == nullptr
				 || ! defaultSet->containsMapping (cm->commandID, cm->keypresses.getReference (j)))
			{
				XmlElement* const map = doc->createNewChildElement ("MAPPING");

				map->setAttribute ("commandId", String::toHexString ((int) cm->commandID));
				map->setAttribute ("description", commandManager->getDescriptionOfCommand (cm->commandID));
				map->setAttribute ("key", cm->keypresses.getReference (j).getTextDescription());
			}
		}
	}

	if (defaultSet != nullptr)
	{
		for (i = 0; i < defaultSet->mappings.size(); ++i)
		{
			const CommandMapping* const cm = defaultSet->mappings.getUnchecked(i);

			for (int j = 0; j < cm->keypresses.size(); ++j)
			{
				if (! containsMapping (cm->commandID, cm->keypresses.getReference (j)))
				{
					XmlElement* const map = doc->createNewChildElement ("UNMAPPING");

					map->setAttribute ("commandId", String::toHexString ((int) cm->commandID));
					map->setAttribute ("description", commandManager->getDescriptionOfCommand (cm->commandID));
					map->setAttribute ("key", cm->keypresses.getReference (j).getTextDescription());
				}
			}
		}
	}

	return doc;
}

bool KeyPressMappingSet::keyPressed (const KeyPress& key,
									 Component* originatingComponent)
{
	bool commandWasDisabled = false;

	for (int i = 0; i < mappings.size(); ++i)
	{
		CommandMapping* const cm =  mappings.getUnchecked(i);

		if (cm->keypresses.contains (key))
		{
			const ApplicationCommandInfo* const ci = commandManager->getCommandForID (cm->commandID);

			if (ci != nullptr
				 && (ci->flags & ApplicationCommandInfo::wantsKeyUpDownCallbacks) == 0)
			{
				ApplicationCommandInfo info (0);

				if (commandManager->getTargetForCommand (cm->commandID, info) != 0)
				{
					if ((info.flags & ApplicationCommandInfo::isDisabled) == 0)
					{
						invokeCommand (cm->commandID, key, true, 0, originatingComponent);
						return true;
					}
					else
					{
						commandWasDisabled = true;
					}
				}
			}
		}
	}

	if (originatingComponent != nullptr && commandWasDisabled)
		originatingComponent->getLookAndFeel().playAlertSound();

	return false;
}

bool KeyPressMappingSet::keyStateChanged (const bool /*isKeyDown*/, Component* originatingComponent)
{
	bool used = false;
	const uint32 now = Time::getMillisecondCounter();

	for (int i = mappings.size(); --i >= 0;)
	{
		CommandMapping* const cm =  mappings.getUnchecked(i);

		if (cm->wantsKeyUpDownCallbacks)
		{
			for (int j = cm->keypresses.size(); --j >= 0;)
			{
				const KeyPress key (cm->keypresses.getReference (j));
				const bool isDown = key.isCurrentlyDown();

				int keyPressEntryIndex = 0;
				bool wasDown = false;

				for (int k = keysDown.size(); --k >= 0;)
				{
					if (key == keysDown.getUnchecked(k)->key)
					{
						keyPressEntryIndex = k;
						wasDown = true;
						used = true;
						break;
					}
				}

				if (isDown != wasDown)
				{
					int millisecs = 0;

					if (isDown)
					{
						KeyPressTime* const k = new KeyPressTime();
						k->key = key;
						k->timeWhenPressed = now;

						keysDown.add (k);
					}
					else
					{
						const uint32 pressTime = keysDown.getUnchecked (keyPressEntryIndex)->timeWhenPressed;

						if (now > pressTime)
							millisecs = (int) (now - pressTime);

						keysDown.remove (keyPressEntryIndex);
					}

					invokeCommand (cm->commandID, key, isDown, millisecs, originatingComponent);
					used = true;
				}
			}
		}
	}

	return used;
}

void KeyPressMappingSet::globalFocusChanged (Component* focusedComponent)
{
	if (focusedComponent != nullptr)
		focusedComponent->keyStateChanged (false);
}

/*** End of inlined file: juce_KeyPressMappingSet.cpp ***/


/*** Start of inlined file: juce_Application.cpp ***/
#if JUCE_MAC
 extern void juce_initialiseMacMainMenu();
#endif

class AppBroadcastCallback  : public ActionListener
{
public:
	AppBroadcastCallback()    { MessageManager::getInstance()->registerBroadcastListener (this); }
	~AppBroadcastCallback()   { MessageManager::getInstance()->deregisterBroadcastListener (this); }

	void actionListenerCallback (const String& message)
	{
		JUCEApplication* const app = JUCEApplication::getInstance();

		if (app != 0 && message.startsWith (app->getApplicationName() + "/"))
			app->anotherInstanceStarted (message.substring (app->getApplicationName().length() + 1));
	}
};

JUCEApplication::JUCEApplication()
	: appReturnValue (0),
	  stillInitialising (true)
{
}

JUCEApplication::~JUCEApplication()
{
	if (appLock != nullptr)
	{
		appLock->exit();
		appLock = nullptr;
	}
}

bool JUCEApplication::moreThanOneInstanceAllowed()
{
	return true;
}

void JUCEApplication::anotherInstanceStarted (const String&)
{
}

void JUCEApplication::systemRequestedQuit()
{
	quit();
}

void JUCEApplication::quit()
{
	MessageManager::getInstance()->stopDispatchLoop();
}

void JUCEApplication::setApplicationReturnValue (const int newReturnValue) noexcept
{
	appReturnValue = newReturnValue;
}

void JUCEApplication::unhandledException (const std::exception*,
										  const String&,
										  const int)
{
	jassertfalse;
}

void JUCEApplication::sendUnhandledException (const std::exception* const e,
											  const char* const sourceFile,
											  const int lineNumber)
{
	if (JUCEApplicationBase::getInstance() != nullptr)
		JUCEApplicationBase::getInstance()->unhandledException (e, sourceFile, lineNumber);
}

ApplicationCommandTarget* JUCEApplication::getNextCommandTarget()
{
	return nullptr;
}

void JUCEApplication::getAllCommands (Array <CommandID>& commands)
{
	commands.add (StandardApplicationCommandIDs::quit);
}

void JUCEApplication::getCommandInfo (const CommandID commandID, ApplicationCommandInfo& result)
{
	if (commandID == StandardApplicationCommandIDs::quit)
	{
		result.setInfo (TRANS("Quit"),
						TRANS("Quits the application"),
						"Application",
						0);

		result.defaultKeypresses.add (KeyPress ('q', ModifierKeys::commandModifier, 0));
	}
}

bool JUCEApplication::perform (const InvocationInfo& info)
{
	if (info.commandID == StandardApplicationCommandIDs::quit)
	{
		systemRequestedQuit();
		return true;
	}

	return false;
}

bool JUCEApplication::initialiseApp (const String& commandLine)
{
	commandLineParameters = commandLine.trim();

   #if ! (JUCE_IOS || JUCE_ANDROID)
	jassert (appLock == nullptr); // initialiseApp must only be called once!

	if (! moreThanOneInstanceAllowed())
	{
		appLock = new InterProcessLock ("juceAppLock_" + getApplicationName());

		if (! appLock->enter(0))
		{
			appLock = nullptr;
			MessageManager::broadcastMessage (getApplicationName() + "/" + commandLineParameters);

			DBG ("Another instance is running - quitting...");
			return false;
		}
	}
   #endif

	// let the app do its setting-up..
	initialise (commandLineParameters);

   #if JUCE_MAC
	juce_initialiseMacMainMenu(); // needs to be called after the app object has created, to get its name
   #endif

   #if ! (JUCE_IOS || JUCE_ANDROID)
	broadcastCallback = new AppBroadcastCallback();
   #endif

	stillInitialising = false;
	return true;
}

int JUCEApplication::shutdownApp()
{
	jassert (JUCEApplicationBase::getInstance() == this);

	broadcastCallback = nullptr;

	JUCE_TRY
	{
		// give the app a chance to clean up..
		shutdown();
	}
	JUCE_CATCH_EXCEPTION

	return getApplicationReturnValue();
}

#if ! JUCE_ANDROID
int JUCEApplication::main (const String& commandLine)
{
	ScopedJuceInitialiser_GUI libraryInitialiser;
	jassert (createInstance != nullptr);
	int returnCode = 0;

	{
		const ScopedPointer<JUCEApplication> app (dynamic_cast <JUCEApplication*> (createInstance()));

		jassert (app != nullptr);

		if (! app->initialiseApp (commandLine))
			return 0;

		JUCE_TRY
		{
			// loop until a quit message is received..
			MessageManager::getInstance()->runDispatchLoop();
		}
		JUCE_CATCH_EXCEPTION

		returnCode = app->shutdownApp();
	}

	return returnCode;
}

#if JUCE_IOS
 extern int juce_iOSMain (int argc, const char* argv[]);
#endif

#if ! JUCE_WINDOWS
 extern const char* juce_Argv0;
#endif

#if JUCE_MAC
 extern void initialiseNSApplication();
#endif

int JUCEApplication::main (int argc, const char* argv[])
{
	JUCE_AUTORELEASEPOOL

   #if JUCE_MAC
	initialiseNSApplication();
   #endif

   #if ! JUCE_WINDOWS
	jassert (createInstance != nullptr);
	juce_Argv0 = argv[0];
   #endif

   #if JUCE_IOS
	return juce_iOSMain (argc, argv);
   #else
	String cmd;
	for (int i = 1; i < argc; ++i)
	{
		String arg (argv[i]);
		if (arg.containsChar (' ') && ! arg.isQuotedString())
			arg = arg.quoted ('"');

		cmd << arg << ' ';
	}

	return JUCEApplication::main (cmd);
   #endif
}
#endif

/*** End of inlined file: juce_Application.cpp ***/


/*** Start of inlined file: juce_BubbleComponent.cpp ***/
BubbleComponent::BubbleComponent()
  : side (0),
	allowablePlacements (above | below | left | right),
	arrowTipX (0.0f),
	arrowTipY (0.0f)
{
	setInterceptsMouseClicks (false, false);

	shadow.setShadowProperties (5.0f, 0.35f, 0, 0);
	setComponentEffect (&shadow);
}

BubbleComponent::~BubbleComponent()
{
}

void BubbleComponent::paint (Graphics& g)
{
	int x = content.getX();
	int y = content.getY();
	int w = content.getWidth();
	int h = content.getHeight();

	int cw, ch;
	getContentSize (cw, ch);

	if (side == 3)
		x += w - cw;
	else if (side != 1)
		x += (w - cw) / 2;

	w = cw;

	if (side == 2)
		y += h - ch;
	else if (side != 0)
		y += (h - ch) / 2;

	h = ch;

	getLookAndFeel().drawBubble (g, arrowTipX, arrowTipY,
								 (float) x, (float) y,
								 (float) w, (float) h);

	const int cx = x + (w - cw) / 2;
	const int cy = y + (h - ch) / 2;

	const int indent = 3;

	g.setOrigin (cx + indent, cy + indent);
	g.reduceClipRegion (0, 0, cw - indent * 2, ch - indent * 2);

	paintContent (g, cw - indent * 2, ch - indent * 2);
}

void BubbleComponent::setAllowedPlacement (const int newPlacement)
{
	allowablePlacements = newPlacement;
}

void BubbleComponent::setPosition (Component* componentToPointTo)
{
	jassert (componentToPointTo != nullptr);

	Point<int> pos;

	if (getParentComponent() != nullptr)
		pos = getParentComponent()->getLocalPoint (componentToPointTo, pos);
	else
		pos = componentToPointTo->localPointToGlobal (pos);

	setPosition (Rectangle<int> (pos.x, pos.y, componentToPointTo->getWidth(), componentToPointTo->getHeight()));
}

void BubbleComponent::setPosition (const int arrowTipX_,
								   const int arrowTipY_)
{
	setPosition (Rectangle<int> (arrowTipX_, arrowTipY_, 1, 1));
}

void BubbleComponent::setPosition (const Rectangle<int>& rectangleToPointTo)
{
	Rectangle<int> availableSpace (getParentComponent() != nullptr ? getParentComponent()->getLocalBounds()
																   : getParentMonitorArea());
	int x = 0;
	int y = 0;
	int w = 150;
	int h = 30;

	getContentSize (w, h);
	w += 30;
	h += 30;

	const float edgeIndent = 2.0f;
	const int arrowLength = jmin (10, h / 3, w / 3);

	int spaceAbove = ((allowablePlacements & above) != 0) ? jmax (0, rectangleToPointTo.getY() - availableSpace.getY()) : -1;
	int spaceBelow = ((allowablePlacements & below) != 0) ? jmax (0, availableSpace.getBottom() - rectangleToPointTo.getBottom()) : -1;
	int spaceLeft  = ((allowablePlacements & left)  != 0) ? jmax (0, rectangleToPointTo.getX() - availableSpace.getX()) : -1;
	int spaceRight = ((allowablePlacements & right) != 0) ? jmax (0, availableSpace.getRight() - rectangleToPointTo.getRight()) : -1;

	// look at whether the component is elongated, and if so, try to position next to its longer dimension.
	if (rectangleToPointTo.getWidth() > rectangleToPointTo.getHeight() * 2
		 && (spaceAbove > h + 20 || spaceBelow > h + 20))
	{
		spaceLeft = spaceRight = 0;
	}
	else if (rectangleToPointTo.getWidth() < rectangleToPointTo.getHeight() / 2
			  && (spaceLeft > w + 20 || spaceRight > w + 20))
	{
		spaceAbove = spaceBelow = 0;
	}

	if (jmax (spaceAbove, spaceBelow) >= jmax (spaceLeft, spaceRight))
	{
		x = rectangleToPointTo.getX() + (rectangleToPointTo.getWidth() - w) / 2;
		arrowTipX = w * 0.5f;
		content.setSize (w, h - arrowLength);

		if (spaceAbove >= spaceBelow)
		{
			// above
			y = rectangleToPointTo.getY() - h;
			content.setPosition (0, 0);
			arrowTipY = h - edgeIndent;
			side = 2;
		}
		else
		{
			// below
			y = rectangleToPointTo.getBottom();
			content.setPosition (0, arrowLength);
			arrowTipY = edgeIndent;
			side = 0;
		}
	}
	else
	{
		y = rectangleToPointTo.getY() + (rectangleToPointTo.getHeight() - h) / 2;
		arrowTipY = h * 0.5f;
		content.setSize (w - arrowLength, h);

		if (spaceLeft > spaceRight)
		{
			// on the left
			x = rectangleToPointTo.getX() - w;
			content.setPosition (0, 0);
			arrowTipX = w - edgeIndent;
			side = 3;
		}
		else
		{
			// on the right
			x = rectangleToPointTo.getRight();
			content.setPosition (arrowLength, 0);
			arrowTipX = edgeIndent;
			side = 1;
		}
	}

	setBounds (x, y, w, h);
}

/*** End of inlined file: juce_BubbleComponent.cpp ***/


/*** Start of inlined file: juce_DropShadower.cpp ***/
class ShadowWindow  : public Component
{
public:
	ShadowWindow (Component& owner, const int type_, const Image shadowImageSections [12])
		: topLeft (shadowImageSections [type_ * 3]),
		  bottomRight (shadowImageSections [type_ * 3 + 1]),
		  filler (shadowImageSections [type_ * 3 + 2]),
		  type (type_)
	{
		setInterceptsMouseClicks (false, false);

		if (owner.isOnDesktop())
		{
			setSize (1, 1); // to keep the OS happy by not having zero-size windows
			addToDesktop (ComponentPeer::windowIgnoresMouseClicks
							| ComponentPeer::windowIsTemporary
							| ComponentPeer::windowIgnoresKeyPresses);
		}
		else if (owner.getParentComponent() != nullptr)
		{
			owner.getParentComponent()->addChildComponent (this);
		}
	}

	void paint (Graphics& g)
	{
		g.setOpacity (1.0f);

		if (type < 2)
		{
			int imH = jmin (topLeft.getHeight(), getHeight() / 2);
			g.drawImage (topLeft,
						 0, 0, topLeft.getWidth(), imH,
						 0, 0, topLeft.getWidth(), imH);

			imH = jmin (bottomRight.getHeight(), getHeight() - getHeight() / 2);
			g.drawImage (bottomRight,
						 0, getHeight() - imH, bottomRight.getWidth(), imH,
						 0, bottomRight.getHeight() - imH, bottomRight.getWidth(), imH);

			g.setTiledImageFill (filler, 0, 0, 1.0f);
			g.fillRect (0, topLeft.getHeight(), getWidth(), getHeight() - (topLeft.getHeight() + bottomRight.getHeight()));
		}
		else
		{
			int imW = jmin (topLeft.getWidth(), getWidth() / 2);
			g.drawImage (topLeft,
						 0, 0, imW, topLeft.getHeight(),
						 0, 0, imW, topLeft.getHeight());

			imW = jmin (bottomRight.getWidth(), getWidth() - getWidth() / 2);
			g.drawImage (bottomRight,
						 getWidth() - imW, 0, imW, bottomRight.getHeight(),
						 bottomRight.getWidth() - imW, 0, imW, bottomRight.getHeight());

			g.setTiledImageFill (filler, 0, 0, 1.0f);
			g.fillRect (topLeft.getWidth(), 0, getWidth() - (topLeft.getWidth() + bottomRight.getWidth()), getHeight());
		}
	}

	void resized()
	{
		repaint();  // (needed for correct repainting)
	}

private:
	const Image topLeft, bottomRight, filler;
	const int type;   // 0 = left, 1 = right, 2 = top, 3 = bottom. left + right are full-height

	JUCE_DECLARE_NON_COPYABLE (ShadowWindow);
};

DropShadower::DropShadower (const float alpha_,
							const int xOffset_,
							const int yOffset_,
							const float blurRadius_)
   : owner (nullptr),
	 xOffset (xOffset_),
	 yOffset (yOffset_),
	 alpha (alpha_),
	 blurRadius (blurRadius_),
	 reentrant (false)
{
}

DropShadower::~DropShadower()
{
	if (owner != nullptr)
		owner->removeComponentListener (this);

	reentrant = true;
	shadowWindows.clear();
}

void DropShadower::setOwner (Component* componentToFollow)
{
	if (componentToFollow != owner)
	{
		if (owner != nullptr)
			owner->removeComponentListener (this);

		// (the component can't be null)
		jassert (componentToFollow != nullptr);

		owner = componentToFollow;

		jassert (owner != nullptr);
		jassert (owner->isOpaque()); // doesn't work properly for semi-transparent comps!

		owner->addComponentListener (this);

		updateShadows();
	}
}

void DropShadower::componentMovedOrResized (Component&, bool /*wasMoved*/, bool /*wasResized*/)
{
	updateShadows();
}

void DropShadower::componentBroughtToFront (Component&)
{
	bringShadowWindowsToFront();
}

void DropShadower::componentParentHierarchyChanged (Component&)
{
	shadowWindows.clear();
	updateShadows();
}

void DropShadower::componentVisibilityChanged (Component&)
{
	updateShadows();
}

void DropShadower::updateShadows()
{
	if (reentrant || owner == nullptr)
		return;

	ComponentPeer* const peer = owner->getPeer();
	const bool isOwnerVisible = owner->isVisible() && (peer == nullptr || ! peer->isMinimised());

	const bool createShadowWindows  = shadowWindows.size() == 0
										 && owner->getWidth() > 0
										 && owner->getHeight() > 0
										 && isOwnerVisible
										 && (Desktop::canUseSemiTransparentWindows()
											  || owner->getParentComponent() != nullptr);

	{
		const ScopedValueSetter<bool> setter (reentrant, true, false);

		const int shadowEdge = jmax (xOffset, yOffset) + (int) blurRadius;

		if (createShadowWindows)
		{
			// keep a cached version of the image to save doing the gaussian too often
			String imageId;
			imageId << shadowEdge << ',' << xOffset << ',' << yOffset << ',' << alpha;

			const int hash = imageId.hashCode();

			Image bigIm (ImageCache::getFromHashCode (hash));

			if (bigIm.isNull())
			{
				bigIm = Image (Image::ARGB, shadowEdge * 5, shadowEdge * 5, true);

				Graphics bigG (bigIm);
				bigG.setColour (Colours::black.withAlpha (alpha));
				bigG.fillRect (shadowEdge + xOffset,
							   shadowEdge + yOffset,
							   bigIm.getWidth() - (shadowEdge * 2),
							   bigIm.getHeight() - (shadowEdge * 2));

				ImageConvolutionKernel blurKernel (roundToInt (blurRadius * 2.0f));
				blurKernel.createGaussianBlur (blurRadius);

				blurKernel.applyToImage (bigIm, bigIm,
										 Rectangle<int> (xOffset, yOffset,
														 bigIm.getWidth(), bigIm.getHeight()));

				ImageCache::addImageToCache (bigIm, hash);
			}

			const int iw = bigIm.getWidth();
			const int ih = bigIm.getHeight();
			const int shadowEdge2 = shadowEdge * 2;

			setShadowImage (bigIm, 0, shadowEdge, shadowEdge2, 0, 0);
			setShadowImage (bigIm, 1, shadowEdge, shadowEdge2, 0, ih - shadowEdge2);
			setShadowImage (bigIm, 2, shadowEdge, shadowEdge, 0, shadowEdge2);
			setShadowImage (bigIm, 3, shadowEdge, shadowEdge2, iw - shadowEdge, 0);
			setShadowImage (bigIm, 4, shadowEdge, shadowEdge2, iw - shadowEdge, ih - shadowEdge2);
			setShadowImage (bigIm, 5, shadowEdge, shadowEdge, iw - shadowEdge, shadowEdge2);
			setShadowImage (bigIm, 6, shadowEdge, shadowEdge, shadowEdge, 0);
			setShadowImage (bigIm, 7, shadowEdge, shadowEdge, iw - shadowEdge2, 0);
			setShadowImage (bigIm, 8, shadowEdge, shadowEdge, shadowEdge2, 0);
			setShadowImage (bigIm, 9, shadowEdge, shadowEdge, shadowEdge, ih - shadowEdge);
			setShadowImage (bigIm, 10, shadowEdge, shadowEdge, iw - shadowEdge2, ih - shadowEdge);
			setShadowImage (bigIm, 11, shadowEdge, shadowEdge, shadowEdge2, ih - shadowEdge);

			for (int i = 0; i < 4; ++i)
				shadowWindows.add (new ShadowWindow (*owner, i, shadowImageSections));
		}

		if (shadowWindows.size() >= 4)
		{
			const int x = owner->getX();
			const int y = owner->getY() - shadowEdge;
			const int w = owner->getWidth();
			const int h = owner->getHeight() + shadowEdge + shadowEdge;

			for (int i = shadowWindows.size(); --i >= 0;)
			{
				// there seem to be rare situations where the dropshadower may be deleted by
				// callbacks during this loop, so use a weak ref to watch out for this..
				WeakReference<Component> sw (shadowWindows[i]);

				if (sw != nullptr)
					sw->setAlwaysOnTop (owner->isAlwaysOnTop());

				if (sw != nullptr)
					sw->setVisible (isOwnerVisible);

				if (sw != nullptr)
				{
					switch (i)
					{
						case 0: sw->setBounds (x - shadowEdge, y, shadowEdge, h); break;
						case 1: sw->setBounds (x + w, y, shadowEdge, h); break;
						case 2: sw->setBounds (x, y, w, shadowEdge); break;
						case 3: sw->setBounds (x, owner->getBottom(), w, shadowEdge); break;
						default: break;
					}
				}

				if (sw == nullptr)
					return;
			}
		}
	}

	if (createShadowWindows)
		bringShadowWindowsToFront();
}

void DropShadower::setShadowImage (const Image& src, const int num, const int w, const int h,
								   const int sx, const int sy)
{
	shadowImageSections[num] = Image (Image::ARGB, w, h, true);

	Graphics g (shadowImageSections[num]);
	g.drawImage (src, 0, 0, w, h, sx, sy, w, h);
}

void DropShadower::bringShadowWindowsToFront()
{
	if (! reentrant)
	{
		updateShadows();

		const ScopedValueSetter<bool> setter (reentrant, true, false);

		for (int i = shadowWindows.size(); --i >= 0;)
			shadowWindows.getUnchecked(i)->toBehind (owner);
	}
}

/*** End of inlined file: juce_DropShadower.cpp ***/

// END_AUTOINCLUDE

}

using namespace juce;

namespace juce
{
#if JUCE_IOS || JUCE_WINDOWS

/*** Start of inlined file: juce_MultiTouchMapper.h ***/
#ifndef __JUCE_MULTITOUCHMAPPER_JUCEHEADER__
#define __JUCE_MULTITOUCHMAPPER_JUCEHEADER__

template <typename IDType>
class MultiTouchMapper
{
public:
	MultiTouchMapper() {}

	int getIndexOfTouch (IDType touchID)
	{
		jassert (touchID != 0); // need to rethink this if IDs can be 0!

		int touchIndex = currentTouches.indexOf (touchID);

		if (touchIndex < 0)
		{
			for (touchIndex = 0; touchIndex < currentTouches.size(); ++touchIndex)
				if (currentTouches.getUnchecked (touchIndex) == 0)
					break;

			currentTouches.set (touchIndex, touchID);
		}

		return touchIndex;
	}

	void clear()
	{
		currentTouches.clear();
	}

	void clearTouch (int index)
	{
		currentTouches.set (index, 0);
	}

	bool areAnyTouchesActive() const noexcept
	{
		for (int i = currentTouches.size(); --i >= 0;)
			if (currentTouches.getUnchecked(i) != 0)
				return true;

		return false;
	}

private:
	Array<IDType> currentTouches;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MultiTouchMapper);
};

#endif   // __JUCE_MULTITOUCHMAPPER_JUCEHEADER__

/*** End of inlined file: juce_MultiTouchMapper.h ***/


#endif

#if JUCE_MAC || JUCE_IOS

/*** Start of inlined file: juce_osx_ObjCHelpers.h ***/
#ifndef __JUCE_OSX_OBJCHELPERS_JUCEHEADER__
#define __JUCE_OSX_OBJCHELPERS_JUCEHEADER__

/* This file contains a few helper functions that are used internally but which
   need to be kept away from the public headers because they use obj-C symbols.
*/
namespace
{

	String nsStringToJuce (NSString* s)
	{
		return CharPointer_UTF8 ([s UTF8String]);
	}

	NSString* juceStringToNS (const String& s)
	{
		return [NSString stringWithUTF8String: s.toUTF8()];
	}

	NSString* nsStringLiteral (const char* const s) noexcept
	{
		return [NSString stringWithUTF8String: s];
	}

	NSString* nsEmptyString() noexcept
	{
		return [NSString string];
	}
}

#endif   // __JUCE_OSX_OBJCHELPERS_JUCEHEADER__

/*** End of inlined file: juce_osx_ObjCHelpers.h ***/



/*** Start of inlined file: juce_mac_ObjCSuffix.h ***/
#ifndef __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__
#define __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__

/** This suffix is used for naming all Obj-C classes that are used inside juce.

	Because of the flat naming structure used by Obj-C, you can get horrible situations where
	two DLLs are loaded into a host, each of which uses classes with the same names, and these get
	cross-linked so that when you make a call to a class that you thought was private, it ends up
	actually calling into a similarly named class in the other module's address space.

	By changing this macro to a unique value, you ensure that all the obj-C classes in your app
	have unique names, and should avoid this problem.

	If you're using the amalgamated version, you can just set this macro to something unique before
	you include juce_amalgamated.cpp.
*/
#ifndef JUCE_ObjCExtraSuffix
 #define JUCE_ObjCExtraSuffix 3
#endif

#ifndef DOXYGEN
 #define appendMacro1(a, b, c, d, e) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e
 #define appendMacro2(a, b, c, d, e) appendMacro1(a, b, c, d, e)
 #define MakeObjCClassName(rootName) appendMacro2 (rootName, JUCE_MAJOR_VERSION, JUCE_MINOR_VERSION, JUCE_BUILDNUMBER, JUCE_ObjCExtraSuffix)
#endif

#endif   // __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__

/*** End of inlined file: juce_mac_ObjCSuffix.h ***/


/*** Start of inlined file: juce_mac_CoreGraphicsHelpers.h ***/
#ifndef __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__
#define __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__

namespace
{
	template <class RectType>
	Rectangle<int> convertToRectInt (const RectType& r) noexcept
	{
		return Rectangle<int> ((int) r.origin.x, (int) r.origin.y, (int) r.size.width, (int) r.size.height);
	}

	template <class RectType>
	Rectangle<float> convertToRectFloat (const RectType& r) noexcept
	{
		return Rectangle<float> (r.origin.x, r.origin.y, r.size.width, r.size.height);
	}

	template <class RectType>
	CGRect convertToCGRect (const RectType& r) noexcept
	{
		return CGRectMake ((CGFloat) r.getX(), (CGFloat) r.getY(), (CGFloat) r.getWidth(), (CGFloat) r.getHeight());
	}
}

extern CGImageRef juce_createCoreGraphicsImage (const Image&, const bool forAlpha, CGColorSpaceRef, const bool mustOutliveSource);

extern CGContextRef juce_getImageContext (const Image&);

#endif   // __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__

/*** End of inlined file: juce_mac_CoreGraphicsHelpers.h ***/


/*** Start of inlined file: juce_mac_CoreGraphicsContext.h ***/
#ifndef __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__
#define __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__

class CoreGraphicsContext   : public LowLevelGraphicsContext
{
public:
	CoreGraphicsContext (CGContextRef context_, const float flipHeight_);
	~CoreGraphicsContext();

	bool isVectorDevice() const         { return false; }

	void setOrigin (int x, int y);
	void addTransform (const AffineTransform& transform);
	float getScaleFactor();
	bool clipToRectangle (const Rectangle<int>& r);
	bool clipToRectangleList (const RectangleList& clipRegion);
	void excludeClipRectangle (const Rectangle<int>& r);
	void clipToPath (const Path& path, const AffineTransform& transform);
	void clipToImageAlpha (const Image& sourceImage, const AffineTransform& transform);
	bool clipRegionIntersects (const Rectangle<int>& r);
	Rectangle<int> getClipBounds() const;
	bool isClipEmpty() const;

	void saveState();
	void restoreState();
	void beginTransparencyLayer (float opacity);
	void endTransparencyLayer();

	void setFill (const FillType& fillType);
	void setOpacity (float newOpacity);
	void setInterpolationQuality (Graphics::ResamplingQuality quality);

	void fillRect (const Rectangle<int>& r, const bool replaceExistingContents);
	void fillCGRect (const CGRect& cgRect, const bool replaceExistingContents);
	void fillPath (const Path& path, const AffineTransform& transform);
	void drawImage (const Image& sourceImage, const AffineTransform& transform);

	void drawLine (const Line<float>& line);
	void drawVerticalLine (const int x, float top, float bottom);
	void drawHorizontalLine (const int y, float left, float right);
	void setFont (const Font& newFont);
	const Font& getFont();
	void drawGlyph (int glyphNumber, const AffineTransform& transform);
	bool drawTextLayout (const AttributedString& text, const Rectangle<float>&);

private:
	CGContextRef context;
	const CGFloat flipHeight;
	CGColorSpaceRef rgbColourSpace, greyColourSpace;
	CGFunctionCallbacks gradientCallbacks;
	mutable Rectangle<int> lastClipRect;
	mutable bool lastClipRectIsValid;

	struct SavedState
	{
		SavedState();
		SavedState (const SavedState& other);
		~SavedState();

		void setFill (const FillType& newFill);
		CGShadingRef getShading (CoreGraphicsContext& owner);

		static void gradientCallback (void* info, const CGFloat* inData, CGFloat* outData);

		FillType fillType;
		Font font;
		CGFontRef fontRef;
		CGAffineTransform fontTransform;

	private:
		CGShadingRef shading;
		HeapBlock <PixelARGB> gradientLookupTable;
		int numGradientLookupEntries;
	};

	ScopedPointer <SavedState> state;
	OwnedArray <SavedState> stateStack;

	void drawGradient();
	void createPath (const Path& path) const;
	void createPath (const Path& path, const AffineTransform& transform) const;
	void flip() const;
	void applyTransform (const AffineTransform& transform) const;
	void drawImage (const Image& sourceImage, const AffineTransform& transform, bool fillEntireClipAsTiles);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CoreGraphicsContext);
};

#endif   // __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_mac_CoreGraphicsContext.h ***/

 #if JUCE_IOS

/*** Start of inlined file: juce_ios_UIViewComponentPeer.mm ***/
class UIViewComponentPeer;

} // (juce namespace)

#define JuceUIView MakeObjCClassName(JuceUIView)

@interface JuceUIView : UIView <UITextViewDelegate>
{
@public
	UIViewComponentPeer* owner;
	UITextView* hiddenTextView;
}

- (JuceUIView*) initWithOwner: (UIViewComponentPeer*) owner withFrame: (CGRect) frame;
- (void) dealloc;

- (void) drawRect: (CGRect) r;

- (void) touchesBegan: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesMoved: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesEnded: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesCancelled: (NSSet*) touches withEvent: (UIEvent*) event;

- (BOOL) becomeFirstResponder;
- (BOOL) resignFirstResponder;
- (BOOL) canBecomeFirstResponder;

- (BOOL) textView: (UITextView*) textView shouldChangeTextInRange: (NSRange) range replacementText: (NSString*) text;
@end

#define JuceUIViewController MakeObjCClassName(JuceUIViewController)

@interface JuceUIViewController : UIViewController
{
}

- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) interfaceOrientation;
- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) fromInterfaceOrientation;
@end

#define JuceUIWindow MakeObjCClassName(JuceUIWindow)

@interface JuceUIWindow : UIWindow
{
@private
	UIViewComponentPeer* owner;
	bool isZooming;
}

- (void) setOwner: (UIViewComponentPeer*) owner;
- (void) becomeKeyWindow;
@end

namespace juce
{

class UIViewComponentPeer  : public ComponentPeer,
							 public FocusChangeListener
{
public:
	UIViewComponentPeer (Component* const component,
						 const int windowStyleFlags,
						 UIView* viewToAttachTo);

	~UIViewComponentPeer();

	void* getNativeHandle() const;
	void setVisible (bool shouldBeVisible);
	void setTitle (const String& title);
	void setPosition (int x, int y);
	void setSize (int w, int h);
	void setBounds (int x, int y, int w, int h, bool isNowFullScreen);

	Rectangle<int> getBounds() const;
	Rectangle<int> getBounds (const bool global) const;
	Point<int> getScreenPosition() const;
	Point<int> localToGlobal (const Point<int>& relativePosition);
	Point<int> globalToLocal (const Point<int>& screenPosition);
	void setAlpha (float newAlpha);
	void setMinimised (bool shouldBeMinimised);
	bool isMinimised() const;
	void setFullScreen (bool shouldBeFullScreen);
	bool isFullScreen() const;
	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const;
	BorderSize<int> getFrameSize() const;
	bool setAlwaysOnTop (bool alwaysOnTop);
	void toFront (bool makeActiveWindow);
	void toBehind (ComponentPeer* other);
	void setIcon (const Image& newIcon);

	virtual void drawRect (CGRect r);

	virtual bool canBecomeKeyWindow();
	virtual bool windowShouldClose();

	virtual void redirectMovedOrResized();
	virtual CGRect constrainRect (CGRect r);

	virtual void viewFocusGain();
	virtual void viewFocusLoss();
	bool isFocused() const;
	void grabFocus();
	void textInputRequired (const Point<int>& position);

	virtual BOOL textViewReplaceCharacters (const Range<int>& range, const String& text);
	void updateHiddenTextContent (TextInputTarget* target);
	void globalFocusChanged (Component*);

	virtual BOOL shouldRotate (UIInterfaceOrientation interfaceOrientation);
	virtual void displayRotated();

	void handleTouches (UIEvent* e, bool isDown, bool isUp, bool isCancel);

	void repaint (const Rectangle<int>& area);
	void performAnyPendingRepaintsNow();

	UIWindow* window;
	JuceUIView* view;
	JuceUIViewController* controller;
	bool isSharedWindow, fullScreen, insideDrawRect;
	static ModifierKeys currentModifiers;

	static int64 getMouseTime (UIEvent* e)
	{
		return (Time::currentTimeMillis() - Time::getMillisecondCounter())
				+ (int64) ([e timestamp] * 1000.0);
	}

	static Rectangle<int> rotatedScreenPosToReal (const Rectangle<int>& r)
	{
		const Rectangle<int> screen (convertToRectInt ([UIScreen mainScreen].bounds));

		switch ([[UIApplication sharedApplication] statusBarOrientation])
		{
			case UIInterfaceOrientationPortrait:
				return r;

			case UIInterfaceOrientationPortraitUpsideDown:
				return Rectangle<int> (screen.getWidth() - r.getRight(), screen.getHeight() - r.getBottom(),
									   r.getWidth(), r.getHeight());

			case UIInterfaceOrientationLandscapeLeft:
				return Rectangle<int> (r.getY(), screen.getHeight() - r.getRight(),
									   r.getHeight(), r.getWidth());

			case UIInterfaceOrientationLandscapeRight:
				return Rectangle<int> (screen.getWidth() - r.getBottom(), r.getX(),
									   r.getHeight(), r.getWidth());

			default: jassertfalse; // unknown orientation!
		}

		return r;
	}

	static Rectangle<int> realScreenPosToRotated (const Rectangle<int>& r)
	{
		const Rectangle<int> screen (convertToRectInt ([UIScreen mainScreen].bounds));

		switch ([[UIApplication sharedApplication] statusBarOrientation])
		{
			case UIInterfaceOrientationPortrait:
				return r;

			case UIInterfaceOrientationPortraitUpsideDown:
				return Rectangle<int> (screen.getWidth() - r.getRight(), screen.getHeight() - r.getBottom(),
									   r.getWidth(), r.getHeight());

			case UIInterfaceOrientationLandscapeLeft:
				return Rectangle<int> (screen.getHeight() - r.getBottom(), r.getX(),
									   r.getHeight(), r.getWidth());

			case UIInterfaceOrientationLandscapeRight:
				return Rectangle<int> (r.getY(), screen.getWidth() - r.getRight(),
									   r.getHeight(), r.getWidth());

			default: jassertfalse; // unknown orientation!
		}

		return r;
	}

	MultiTouchMapper<UITouch*> currentTouches;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (UIViewComponentPeer);
};

} // (juce namespace)

@implementation JuceUIViewController

- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) interfaceOrientation
{
	JuceUIView* juceView = (JuceUIView*) [self view];
	jassert (juceView != nil && juceView->owner != nullptr);
	return juceView->owner->shouldRotate (interfaceOrientation);
}

- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) fromInterfaceOrientation
{
	JuceUIView* juceView = (JuceUIView*) [self view];
	jassert (juceView != nil && juceView->owner != nullptr);
	juceView->owner->displayRotated();
}

@end

@implementation JuceUIView

- (JuceUIView*) initWithOwner: (UIViewComponentPeer*) owner_
					withFrame: (CGRect) frame
{
	[super initWithFrame: frame];
	owner = owner_;

	hiddenTextView = [[UITextView alloc] initWithFrame: CGRectMake (0, 0, 0, 0)];
	[self addSubview: hiddenTextView];
	hiddenTextView.delegate = self;

	hiddenTextView.autocapitalizationType = UITextAutocapitalizationTypeNone;
	hiddenTextView.autocorrectionType = UITextAutocorrectionTypeNo;

	return self;
}

- (void) dealloc
{
	[hiddenTextView removeFromSuperview];
	[hiddenTextView release];

	[super dealloc];
}

- (void) drawRect: (CGRect) r
{
	if (owner != nullptr)
		owner->drawRect (r);
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	return false;
}

ModifierKeys UIViewComponentPeer::currentModifiers;

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	return UIViewComponentPeer::currentModifiers;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = UIViewComponentPeer::currentModifiers;
}

juce::Point<int> juce_lastMousePos;

- (void) touchesBegan: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, true, false, false);
}

- (void) touchesMoved: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, false, false);
}

- (void) touchesEnded: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, true, false);
}

- (void) touchesCancelled: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, true, true);

	[self touchesEnded: touches withEvent: event];
}

- (BOOL) becomeFirstResponder
{
	if (owner != nullptr)
		owner->viewFocusGain();

	return true;
}

- (BOOL) resignFirstResponder
{
	if (owner != nullptr)
		owner->viewFocusLoss();

	return true;
}

- (BOOL) canBecomeFirstResponder
{
	return owner != nullptr && owner->canBecomeKeyWindow();
}

- (BOOL) textView: (UITextView*) textView shouldChangeTextInRange: (NSRange) range replacementText: (NSString*) text
{
	return owner->textViewReplaceCharacters (Range<int> (range.location, range.location + range.length),
											 nsStringToJuce (text));
}

@end

@implementation JuceUIWindow

- (void) setOwner: (UIViewComponentPeer*) owner_
{
	owner = owner_;
	isZooming = false;
}

- (void) becomeKeyWindow
{
	[super becomeKeyWindow];

	if (owner != nullptr)
		owner->grabFocus();
}

@end

namespace juce
{

UIViewComponentPeer::UIViewComponentPeer (Component* const component,
										  const int windowStyleFlags,
										  UIView* viewToAttachTo)
	: ComponentPeer (component, windowStyleFlags),
	  window (nil),
	  view (nil),
	  controller (nil),
	  isSharedWindow (viewToAttachTo != nil),
	  fullScreen (false),
	  insideDrawRect (false)
{
	CGRect r = convertToCGRect (component->getLocalBounds());

	view = [[JuceUIView alloc] initWithOwner: this withFrame: r];

	view.multipleTouchEnabled = YES;
	view.hidden = ! component->isVisible();
	view.opaque = component->isOpaque();
	view.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent: 0];

	if (isSharedWindow)
	{
		window = [viewToAttachTo window];
		[viewToAttachTo addSubview: view];
	}
	else
	{
		controller = [[JuceUIViewController alloc] init];
		controller.view = view;

		r = convertToCGRect (rotatedScreenPosToReal (component->getBounds()));
		r.origin.y = [UIScreen mainScreen].bounds.size.height - (r.origin.y + r.size.height);

		window = [[JuceUIWindow alloc] init];
		window.frame = r;
		window.opaque = component->isOpaque();
		window.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent: 0];

		[((JuceUIWindow*) window) setOwner: this];

		if (component->isAlwaysOnTop())
			window.windowLevel = UIWindowLevelAlert;

		[window addSubview: view];
		view.frame = CGRectMake (0, 0, r.size.width, r.size.height);

		window.hidden = view.hidden;
	}

	setTitle (component->getName());

	Desktop::getInstance().addFocusChangeListener (this);
}

UIViewComponentPeer::~UIViewComponentPeer()
{
	Desktop::getInstance().removeFocusChangeListener (this);

	view->owner = nullptr;
	[view removeFromSuperview];
	[view release];
	[controller release];

	if (! isSharedWindow)
	{
		[((JuceUIWindow*) window) setOwner: nil];
		[window release];
	}
}

void* UIViewComponentPeer::getNativeHandle() const
{
	return view;
}

void UIViewComponentPeer::setVisible (bool shouldBeVisible)
{
	view.hidden = ! shouldBeVisible;

	if (! isSharedWindow)
		window.hidden = ! shouldBeVisible;
}

void UIViewComponentPeer::setTitle (const String& title)
{
	// xxx is this possible?
}

void UIViewComponentPeer::setPosition (int x, int y)
{
	setBounds (x, y, component->getWidth(), component->getHeight(), false);
}

void UIViewComponentPeer::setSize (int w, int h)
{
	setBounds (component->getX(), component->getY(), w, h, false);
}

void UIViewComponentPeer::setBounds (int x, int y, int w, int h, const bool isNowFullScreen)
{
	fullScreen = isNowFullScreen;
	w = jmax (0, w);
	h = jmax (0, h);

	if (isSharedWindow)
	{
		CGRect r = CGRectMake ((CGFloat) x, (CGFloat) y, (CGFloat) w, (CGFloat) h);

		if (view.frame.size.width != r.size.width
			 || view.frame.size.height != r.size.height)
			[view setNeedsDisplay];

		view.frame = r;
	}
	else
	{
		const Rectangle<int> bounds (rotatedScreenPosToReal (Rectangle<int> (x, y, w, h)));
		window.frame = convertToCGRect (bounds);
		view.frame = CGRectMake (0, 0, (CGFloat) bounds.getWidth(), (CGFloat) bounds.getHeight());

		handleMovedOrResized();
	}
}

Rectangle<int> UIViewComponentPeer::getBounds (const bool global) const
{
	CGRect r = view.frame;

	if (global && view.window != nil)
	{
		r = [view convertRect: r toView: nil];
		CGRect wr = view.window.frame;

		const Rectangle<int> windowBounds (realScreenPosToRotated (convertToRectInt (wr)));

		r.origin.x += windowBounds.getX();
		r.origin.y += windowBounds.getY();
	}

	return convertToRectInt (r);
}

Rectangle<int> UIViewComponentPeer::getBounds() const
{
	return getBounds (! isSharedWindow);
}

Point<int> UIViewComponentPeer::getScreenPosition() const
{
	return getBounds (true).getPosition();
}

Point<int> UIViewComponentPeer::localToGlobal (const Point<int>& relativePosition)
{
	return relativePosition + getScreenPosition();
}

Point<int> UIViewComponentPeer::globalToLocal (const Point<int>& screenPosition)
{
	return screenPosition - getScreenPosition();
}

CGRect UIViewComponentPeer::constrainRect (CGRect r)
{
	if (constrainer != nullptr)
	{
		CGRect mainScreen = [UIScreen mainScreen].bounds;

		CGRect current = window.frame;
		current.origin.y = mainScreen.size.height - current.origin.y - current.size.height;

		r.origin.y = mainScreen.size.height - r.origin.y - r.size.height;

		Rectangle<int> pos (convertToRectInt (r));
		Rectangle<int> original (convertToRectInt (current));

		constrainer->checkBounds (pos, original,
								  Desktop::getInstance().getDisplays().getTotalBounds (true),
								  pos.getY() != original.getY() && pos.getBottom() == original.getBottom(),
								  pos.getX() != original.getX() && pos.getRight()  == original.getRight(),
								  pos.getY() == original.getY() && pos.getBottom() != original.getBottom(),
								  pos.getX() == original.getX() && pos.getRight()  != original.getRight());

		r.origin.x = pos.getX();
		r.origin.y = mainScreen.size.height - r.size.height - pos.getY();
		r.size.width = pos.getWidth();
		r.size.height = pos.getHeight();
	}

	return r;
}

void UIViewComponentPeer::setAlpha (float newAlpha)
{
	[view.window setAlpha: (CGFloat) newAlpha];
}

void UIViewComponentPeer::setMinimised (bool shouldBeMinimised)
{
}

bool UIViewComponentPeer::isMinimised() const
{
	return false;
}

void UIViewComponentPeer::setFullScreen (bool shouldBeFullScreen)
{
	if (! isSharedWindow)
	{
		Rectangle<int> r (shouldBeFullScreen ? Desktop::getInstance().getDisplays().getMainDisplay().userArea
											 : lastNonFullscreenBounds);

		if ((! shouldBeFullScreen) && r.isEmpty())
			r = getBounds();

		// (can't call the component's setBounds method because that'll reset our fullscreen flag)
		if (! r.isEmpty())
			setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

		component->repaint();
	}
}

bool UIViewComponentPeer::isFullScreen() const
{
	return fullScreen;
}

namespace
{
	Desktop::DisplayOrientation convertToJuceOrientation (UIInterfaceOrientation interfaceOrientation)
	{
		switch (interfaceOrientation)
		{
			case UIInterfaceOrientationPortrait:            return Desktop::upright;
			case UIInterfaceOrientationPortraitUpsideDown:  return Desktop::upsideDown;
			case UIInterfaceOrientationLandscapeLeft:       return Desktop::rotatedClockwise;
			case UIInterfaceOrientationLandscapeRight:      return Desktop::rotatedAntiClockwise;
			default:                                        jassertfalse; // unknown orientation!
		}

		return Desktop::upright;
	}
}

BOOL UIViewComponentPeer::shouldRotate (UIInterfaceOrientation interfaceOrientation)
{
	return Desktop::getInstance().isOrientationEnabled (convertToJuceOrientation (interfaceOrientation));
}

void UIViewComponentPeer::displayRotated()
{
	Desktop& desktop = Desktop::getInstance();
	const Rectangle<int> oldArea (component->getBounds());
	const Rectangle<int> oldDesktop (desktop.getDisplays().getMainDisplay().userArea);

	const_cast <Desktop::Displays&> (desktop.getDisplays()).refresh();

	if (fullScreen)
	{
		fullScreen = false;
		setFullScreen (true);
	}
	else if (! isSharedWindow)
	{
		const float l = oldArea.getX() / (float) oldDesktop.getWidth();
		const float r = oldArea.getRight() / (float) oldDesktop.getWidth();
		const float t = oldArea.getY() / (float) oldDesktop.getHeight();
		const float b = oldArea.getBottom() / (float) oldDesktop.getHeight();

		const Rectangle<int> newDesktop (desktop.getDisplays().getMainDisplay().userArea);

		setBounds ((int) (l * newDesktop.getWidth()),
				   (int) (t * newDesktop.getHeight()),
				   (int) ((r - l) * newDesktop.getWidth()),
				   (int) ((b - t) * newDesktop.getHeight()),
				   false);
	}
}

bool UIViewComponentPeer::contains (const Point<int>& position, bool trueIfInAChildWindow) const
{
	if (! (isPositiveAndBelow (position.getX(), component->getWidth())
			&& isPositiveAndBelow (position.getY(), component->getHeight())))
		return false;

	UIView* v = [view hitTest: CGPointMake ((CGFloat) position.getX(), (CGFloat) position.getY())
					withEvent: nil];

	if (trueIfInAChildWindow)
		return v != nil;

	return v == view;
}

BorderSize<int> UIViewComponentPeer::getFrameSize() const
{
	return BorderSize<int>();
}

bool UIViewComponentPeer::setAlwaysOnTop (bool alwaysOnTop)
{
	if (! isSharedWindow)
		window.windowLevel = alwaysOnTop ? UIWindowLevelAlert : UIWindowLevelNormal;

	return true;
}

void UIViewComponentPeer::toFront (bool makeActiveWindow)
{
	if (isSharedWindow)
		[[view superview] bringSubviewToFront: view];

	if (window != nil && component->isVisible())
		[window makeKeyAndVisible];
}

void UIViewComponentPeer::toBehind (ComponentPeer* other)
{
	UIViewComponentPeer* const otherPeer = dynamic_cast <UIViewComponentPeer*> (other);
	jassert (otherPeer != nullptr); // wrong type of window?

	if (otherPeer != nullptr)
	{
		if (isSharedWindow)
		{
			[[view superview] insertSubview: view belowSubview: otherPeer->view];
		}
		else
		{
			// don't know how to do this
		}
	}
}

void UIViewComponentPeer::setIcon (const Image& /*newIcon*/)
{
	// to do..
}

void UIViewComponentPeer::handleTouches (UIEvent* event, const bool isDown, const bool isUp, bool isCancel)
{
	NSArray* touches = [[event touchesForView: view] allObjects];

	for (unsigned int i = 0; i < [touches count]; ++i)
	{
		UITouch* touch = [touches objectAtIndex: i];

		if ([touch phase] == UITouchPhaseStationary)
			continue;

		CGPoint p = [touch locationInView: view];
		const Point<int> pos ((int) p.x, (int) p.y);
		juce_lastMousePos = pos + getScreenPosition();

		const int64 time = getMouseTime (event);
		const int touchIndex = currentTouches.getIndexOfTouch (touch);

		ModifierKeys modsToSend (currentModifiers);

		if (isDown)
		{
			if ([touch phase] != UITouchPhaseBegan)
				continue;

			currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
			modsToSend = currentModifiers;

			// this forces a mouse-enter/up event, in case for some reason we didn't get a mouse-up before.
			handleMouseEvent (touchIndex, pos, modsToSend.withoutMouseButtons(), time);
			if (! isValidPeer (this)) // (in case this component was deleted by the event)
				return;
		}
		else if (isUp)
		{
			if (! ([touch phase] == UITouchPhaseEnded || [touch phase] == UITouchPhaseCancelled))
				continue;

			modsToSend = modsToSend.withoutMouseButtons();
			currentTouches.clearTouch (touchIndex);

			if (! currentTouches.areAnyTouchesActive())
				isCancel = true;
		}

		if (isCancel)
		{
			currentTouches.clear();
			currentModifiers = currentModifiers.withoutMouseButtons();
		}

		handleMouseEvent (touchIndex, pos, modsToSend, time);
		if (! isValidPeer (this)) // (in case this component was deleted by the event)
			return;

		if (isUp || isCancel)
		{
			handleMouseEvent (touchIndex, Point<int> (-1, -1), currentModifiers, time);
			if (! isValidPeer (this))
				return;
		}
	}
}

static UIViewComponentPeer* currentlyFocusedPeer = nullptr;

void UIViewComponentPeer::viewFocusGain()
{
	if (currentlyFocusedPeer != this)
	{
		if (ComponentPeer::isValidPeer (currentlyFocusedPeer))
			currentlyFocusedPeer->handleFocusLoss();

		currentlyFocusedPeer = this;

		handleFocusGain();
	}
}

void UIViewComponentPeer::viewFocusLoss()
{
	if (currentlyFocusedPeer == this)
	{
		currentlyFocusedPeer = nullptr;
		handleFocusLoss();
	}
}

bool UIViewComponentPeer::isFocused() const
{
	return isSharedWindow ? this == currentlyFocusedPeer
						  : (window != nil && [window isKeyWindow]);
}

void UIViewComponentPeer::grabFocus()
{
	if (window != nil)
	{
		[window makeKeyWindow];
		viewFocusGain();
	}
}

void UIViewComponentPeer::textInputRequired (const Point<int>&)
{
}

void UIViewComponentPeer::updateHiddenTextContent (TextInputTarget* target)
{
	view->hiddenTextView.text = juceStringToNS (target->getTextInRange (Range<int> (0, target->getHighlightedRegion().getStart())));
	view->hiddenTextView.selectedRange = NSMakeRange (target->getHighlightedRegion().getStart(), 0);
}

BOOL UIViewComponentPeer::textViewReplaceCharacters (const Range<int>& range, const String& text)
{
	TextInputTarget* const target = findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> currentSelection (target->getHighlightedRegion());

		if (range.getLength() == 1 && text.isEmpty()) // (detect backspace)
			if (currentSelection.isEmpty())
				target->setHighlightedRegion (currentSelection.withStart (currentSelection.getStart() - 1));

		if (text == "\r" || text == "\n" || text == "\r\n")
			handleKeyPress (KeyPress::returnKey, text[0]);
		else
			target->insertTextAtCaret (text);

		updateHiddenTextContent (target);
	}

	return NO;
}

void UIViewComponentPeer::globalFocusChanged (Component*)
{
	TextInputTarget* const target = findCurrentTextInputTarget();

	if (target != nullptr)
	{
		Component* comp = dynamic_cast<Component*> (target);

		Point<int> pos (component->getLocalPoint (comp, Point<int>()));
		view->hiddenTextView.frame = CGRectMake (pos.getX(), pos.getY(), 0, 0);

		updateHiddenTextContent (target);
		[view->hiddenTextView becomeFirstResponder];
	}
	else
	{
		[view->hiddenTextView resignFirstResponder];
	}
}

void UIViewComponentPeer::drawRect (CGRect r)
{
	if (r.size.width < 1.0f || r.size.height < 1.0f)
		return;

	CGContextRef cg = UIGraphicsGetCurrentContext();

	if (! component->isOpaque())
		CGContextClearRect (cg, CGContextGetClipBoundingBox (cg));

	CGContextConcatCTM (cg, CGAffineTransformMake (1, 0, 0, -1, 0, view.bounds.size.height));
	CoreGraphicsContext g (cg, view.bounds.size.height);

	insideDrawRect = true;
	handlePaint (g);
	insideDrawRect = false;
}

bool UIViewComponentPeer::canBecomeKeyWindow()
{
	return (getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0;
}

bool UIViewComponentPeer::windowShouldClose()
{
	if (! isValidPeer (this))
		return YES;

	handleUserClosingWindow();
	return NO;
}

void UIViewComponentPeer::redirectMovedOrResized()
{
	handleMovedOrResized();
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	[[UIApplication sharedApplication] setStatusBarHidden: enableOrDisable
											withAnimation: UIStatusBarAnimationSlide];

	displays.refresh();

	ComponentPeer* const peer = kioskModeComponent->getPeer();

	if (peer != nullptr)
		peer->setFullScreen (enableOrDisable);
}

class AsyncRepaintMessage  : public CallbackMessage
{
public:
	UIViewComponentPeer* const peer;
	const Rectangle<int> rect;

	AsyncRepaintMessage (UIViewComponentPeer* const peer_, const Rectangle<int>& rect_)
		: peer (peer_), rect (rect_)
	{
	}

	void messageCallback()
	{
		if (ComponentPeer::isValidPeer (peer))
			peer->repaint (rect);
	}
};

void UIViewComponentPeer::repaint (const Rectangle<int>& area)
{
	if (insideDrawRect || ! MessageManager::getInstance()->isThisTheMessageThread())
	{
		(new AsyncRepaintMessage (this, area))->post();
	}
	else
	{
		[view setNeedsDisplayInRect: convertToCGRect (area)];
	}
}

void UIViewComponentPeer::performAnyPendingRepaintsNow()
{
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* windowToAttachTo)
{
	return new UIViewComponentPeer (this, styleFlags, (UIView*) windowToAttachTo);
}

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = 0x1000;
const int KeyPress::rightKey        = 0x1001;
const int KeyPress::upKey           = 0x1002;
const int KeyPress::downKey         = 0x1003;
const int KeyPress::pageUpKey       = 0x1004;
const int KeyPress::pageDownKey     = 0x1005;
const int KeyPress::endKey          = 0x1006;
const int KeyPress::homeKey         = 0x1007;
const int KeyPress::deleteKey       = 0x1008;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = 0x2001;
const int KeyPress::F2Key           = 0x2002;
const int KeyPress::F3Key           = 0x2003;
const int KeyPress::F4Key           = 0x2004;
const int KeyPress::F5Key           = 0x2005;
const int KeyPress::F6Key           = 0x2006;
const int KeyPress::F7Key           = 0x2007;
const int KeyPress::F8Key           = 0x2008;
const int KeyPress::F9Key           = 0x2009;
const int KeyPress::F10Key          = 0x200a;
const int KeyPress::F11Key          = 0x200b;
const int KeyPress::F12Key          = 0x200c;
const int KeyPress::F13Key          = 0x200d;
const int KeyPress::F14Key          = 0x200e;
const int KeyPress::F15Key          = 0x200f;
const int KeyPress::F16Key          = 0x2010;
const int KeyPress::numberPad0      = 0x30020;
const int KeyPress::numberPad1      = 0x30021;
const int KeyPress::numberPad2      = 0x30022;
const int KeyPress::numberPad3      = 0x30023;
const int KeyPress::numberPad4      = 0x30024;
const int KeyPress::numberPad5      = 0x30025;
const int KeyPress::numberPad6      = 0x30026;
const int KeyPress::numberPad7      = 0x30027;
const int KeyPress::numberPad8      = 0x30028;
const int KeyPress::numberPad9      = 0x30029;
const int KeyPress::numberPadAdd            = 0x3002a;
const int KeyPress::numberPadSubtract       = 0x3002b;
const int KeyPress::numberPadMultiply       = 0x3002c;
const int KeyPress::numberPadDivide         = 0x3002d;
const int KeyPress::numberPadSeparator      = 0x3002e;
const int KeyPress::numberPadDecimalPoint   = 0x3002f;
const int KeyPress::numberPadEquals         = 0x30030;
const int KeyPress::numberPadDelete         = 0x30031;
const int KeyPress::playKey         = 0x30000;
const int KeyPress::stopKey         = 0x30001;
const int KeyPress::fastForwardKey  = 0x30002;
const int KeyPress::rewindKey       = 0x30003;

/*** End of inlined file: juce_ios_UIViewComponentPeer.mm ***/



/*** Start of inlined file: juce_ios_Windowing.mm ***/
} // (juce namespace)

@interface JuceAppStartupDelegate : NSObject <UIApplicationDelegate>
{
}

- (void) applicationDidFinishLaunching: (UIApplication*) application;
- (void) applicationWillTerminate: (UIApplication*) application;

@end

@implementation JuceAppStartupDelegate

- (void) applicationDidFinishLaunching: (UIApplication*) application
{
	initialiseJuce_GUI();

	JUCEApplication* app = dynamic_cast <JUCEApplication*> (JUCEApplicationBase::createInstance());
	if (! app->initialiseApp (String::empty))
		exit (0);
}

- (void) applicationWillTerminate: (UIApplication*) application
{
	JUCEApplicationBase::appWillTerminateByForce();
}

@end

namespace juce
{

int juce_iOSMain (int argc, const char* argv[])
{
	return UIApplicationMain (argc, const_cast<char**> (argv), nil, @"JuceAppStartupDelegate");
}

void LookAndFeel::playAlertSound()
{
	//xxx
	//AudioServicesPlaySystemSound ();
}

class iOSMessageBox;

} // (juce namespace)

@interface JuceAlertBoxDelegate  : NSObject
{
@public
	iOSMessageBox* owner;
}

- (void) alertView: (UIAlertView*) alertView clickedButtonAtIndex: (NSInteger) buttonIndex;

@end

namespace juce
{

class iOSMessageBox
{
public:
	iOSMessageBox (const String& title, const String& message,
				   NSString* button1, NSString* button2, NSString* button3,
				   ModalComponentManager::Callback* callback_, const bool isAsync_)
		: result (0), delegate (nil), alert (nil),
		  callback (callback_), isYesNo (button3 != nil), isAsync (isAsync_)
	{
		delegate = [[JuceAlertBoxDelegate alloc] init];
		delegate->owner = this;

		alert = [[UIAlertView alloc] initWithTitle: juceStringToNS (title)
										   message: juceStringToNS (message)
										  delegate: delegate
								 cancelButtonTitle: button1
								 otherButtonTitles: button2, button3, nil];
		[alert retain];
		[alert show];
	}

	~iOSMessageBox()
	{
		[alert release];
		[delegate release];
	}

	int getResult()
	{
		jassert (callback == nullptr);
		JUCE_AUTORELEASEPOOL

		while (! alert.hidden && alert.superview != nil)
			[[NSRunLoop mainRunLoop] runUntilDate: [NSDate dateWithTimeIntervalSinceNow: 0.01]];

		return result;
	}

	void buttonClicked (const int buttonIndex) noexcept
	{
		result = buttonIndex;

		if (callback != nullptr)
			callback->modalStateFinished (result);

		if (isAsync)
			delete this;
	}

private:
	int result;
	JuceAlertBoxDelegate* delegate;
	UIAlertView* alert;
	ModalComponentManager::Callback* callback;
	const bool isYesNo, isAsync;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (iOSMessageBox);
};

} // (juce namespace)

@implementation JuceAlertBoxDelegate

- (void) alertView: (UIAlertView*) alertView clickedButtonAtIndex: (NSInteger) buttonIndex
{
	owner->buttonClicked (buttonIndex);
	alertView.hidden = true;
}

@end

namespace juce
{

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	JUCE_AUTORELEASEPOOL
	iOSMessageBox mb (title, message, @"OK", nil, nil, 0, false);
	(void) mb.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	JUCE_AUTORELEASEPOOL
	new iOSMessageBox (title, message, @"OK", nil, nil, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<iOSMessageBox> mb (new iOSMessageBox (title, message, @"Cancel", @"OK", nil, callback, callback != nullptr));

	if (callback == nullptr)
		return mb->getResult() == 1;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<iOSMessageBox> mb (new iOSMessageBox (title, message, @"Cancel", @"Yes", @"No", callback, callback != nullptr));

	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
{
	jassertfalse;    // no such thing on the iphone!
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	jassertfalse;    // no such thing on the iphone!
	return false;
}

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	[[UIApplication sharedApplication] setIdleTimerDisabled: ! isEnabled];
}

bool Desktop::isScreenSaverEnabled()
{
	return ! [[UIApplication sharedApplication] isIdleTimerDisabled];
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	[[UIPasteboard generalPasteboard] setValue: juceStringToNS (text)
							 forPasteboardType: @"public.text"];
}

String SystemClipboard::getTextFromClipboard()
{
	NSString* text = [[UIPasteboard generalPasteboard] valueForPasteboardType: @"public.text"];

	return text == nil ? String::empty
					   : nsStringToJuce (text);
}

void Desktop::createMouseInputSources()
{
	for (int i = 0; i < 10; ++i)
		mouseSources.add (new MouseInputSource (i, false));
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	return juce_lastMousePos;
}

void Desktop::setMousePosition (const Point<int>&)
{
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return convertToJuceOrientation ([[UIApplication sharedApplication] statusBarOrientation]);
}

void Desktop::Displays::findDisplays()
{
	JUCE_AUTORELEASEPOOL

	UIScreen* s = [UIScreen mainScreen];

	Display d;
	d.userArea  = UIViewComponentPeer::realScreenPosToRotated (convertToRectInt ([s applicationFrame]));
	d.totalArea = UIViewComponentPeer::realScreenPosToRotated (convertToRectInt ([s bounds]));
	d.isMain = true;

	if ([s respondsToSelector: @selector (scale)])
		d.scale = s.scale;
	else
		d.scale = 1.0;

	displays.add (d);
}

/*** End of inlined file: juce_ios_Windowing.mm ***/

 #else

/*** Start of inlined file: juce_mac_NSViewComponentPeer.mm ***/
class NSViewComponentPeer;

typedef void (*AppFocusChangeCallback)();
extern AppFocusChangeCallback appFocusChangeCallback;
typedef bool (*CheckEventBlockedByModalComps) (NSEvent*);
extern CheckEventBlockedByModalComps isEventBlockedByModalComps;

} // (juce namespace)

@interface NSEvent (JuceDeviceDelta)
 - (CGFloat) deviceDeltaX;
 - (CGFloat) deviceDeltaY;

#if ! (defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7)
 - (CGFloat) scrollingDeltaX;
 - (CGFloat) scrollingDeltaX;
 - (BOOL) hasPreciseScrollingDeltas;
#endif
@end

#define JuceNSView MakeObjCClassName(JuceNSView)

@interface JuceNSView : NSView<NSTextInput>
{
@public
	NSViewComponentPeer* owner;
	NSNotificationCenter* notificationCenter;
	String* stringBeingComposed;
	bool textWasInserted;
}

- (JuceNSView*) initWithOwner: (NSViewComponentPeer*) owner withFrame: (NSRect) frame;
- (void) dealloc;

- (BOOL) isOpaque;
- (void) drawRect: (NSRect) r;

- (void) mouseDown: (NSEvent*) ev;
- (void) asyncMouseDown: (NSEvent*) ev;
- (void) mouseUp: (NSEvent*) ev;
- (void) asyncMouseUp: (NSEvent*) ev;
- (void) mouseDragged: (NSEvent*) ev;
- (void) mouseMoved: (NSEvent*) ev;
- (void) mouseEntered: (NSEvent*) ev;
- (void) mouseExited: (NSEvent*) ev;
- (void) rightMouseDown: (NSEvent*) ev;
- (void) rightMouseDragged: (NSEvent*) ev;
- (void) rightMouseUp: (NSEvent*) ev;
- (void) otherMouseDown: (NSEvent*) ev;
- (void) otherMouseDragged: (NSEvent*) ev;
- (void) otherMouseUp: (NSEvent*) ev;
- (void) scrollWheel: (NSEvent*) ev;
- (BOOL) acceptsFirstMouse: (NSEvent*) ev;
- (void) frameChanged: (NSNotification*) n;
- (void) viewDidMoveToWindow;

- (void) keyDown: (NSEvent*) ev;
- (void) keyUp: (NSEvent*) ev;

// NSTextInput Methods
- (void) insertText: (id) aString;
- (void) doCommandBySelector: (SEL) aSelector;
- (void) setMarkedText: (id) aString selectedRange: (NSRange) selRange;
- (void) unmarkText;
- (BOOL) hasMarkedText;
- (long) conversationIdentifier;
- (NSAttributedString*) attributedSubstringFromRange: (NSRange) theRange;
- (NSRange) markedRange;
- (NSRange) selectedRange;
- (NSRect) firstRectForCharacterRange: (NSRange) theRange;
- (NSUInteger) characterIndexForPoint: (NSPoint) thePoint;
- (NSArray*) validAttributesForMarkedText;

- (void) flagsChanged: (NSEvent*) ev;
#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
- (BOOL) performKeyEquivalent: (NSEvent*) ev;
#endif

- (BOOL) becomeFirstResponder;
- (BOOL) resignFirstResponder;
- (BOOL) acceptsFirstResponder;

- (NSArray*) getSupportedDragTypes;
- (BOOL) sendDragCallback: (int) type sender: (id <NSDraggingInfo>) sender;
- (NSDragOperation) draggingEntered: (id <NSDraggingInfo>) sender;
- (NSDragOperation) draggingUpdated: (id <NSDraggingInfo>) sender;
- (void) draggingEnded: (id <NSDraggingInfo>) sender;
- (void) draggingExited: (id <NSDraggingInfo>) sender;
- (BOOL) prepareForDragOperation: (id <NSDraggingInfo>) sender;
- (BOOL) performDragOperation: (id <NSDraggingInfo>) sender;
- (void) concludeDragOperation: (id <NSDraggingInfo>) sender;

@end

#define JuceNSWindow MakeObjCClassName(JuceNSWindow)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceNSWindow : NSWindow <NSWindowDelegate>
#else
@interface JuceNSWindow : NSWindow
#endif
{
@private
	NSViewComponentPeer* owner;
	bool isZooming;
}

- (void) setOwner: (NSViewComponentPeer*) owner;
- (BOOL) canBecomeKeyWindow;
- (void) becomeKeyWindow;
- (BOOL) windowShouldClose: (id) window;
- (NSRect) constrainFrameRect: (NSRect) frameRect toScreen: (NSScreen*) screen;
- (NSSize) windowWillResize: (NSWindow*) window toSize: (NSSize) proposedFrameSize;
- (void) zoom: (id) sender;
@end

namespace juce
{

class NSViewComponentPeer  : public ComponentPeer
{
public:
	NSViewComponentPeer (Component* const component,
						 const int windowStyleFlags,
						 NSView* viewToAttachTo);

	~NSViewComponentPeer();

	void* getNativeHandle() const;
	void setVisible (bool shouldBeVisible);
	void setTitle (const String& title);
	void setPosition (int x, int y);
	void setSize (int w, int h);
	void setBounds (int x, int y, int w, int h, const bool isNowFullScreen);
	Rectangle<int> getBounds (const bool global) const;
	Rectangle<int> getBounds() const;
	Point<int> getScreenPosition() const;
	Point<int> localToGlobal (const Point<int>& relativePosition);
	Point<int> globalToLocal (const Point<int>& screenPosition);
	void setAlpha (float newAlpha);
	void setMinimised (bool shouldBeMinimised);
	bool isMinimised() const;
	void setFullScreen (bool shouldBeFullScreen);
	bool isFullScreen() const;
	void updateFullscreenStatus();
	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const;
	bool hasNativeTitleBar() const        { return (getStyleFlags() & windowHasTitleBar) != 0; }
	BorderSize<int> getFrameSize() const;
	bool setAlwaysOnTop (bool alwaysOnTop);
	void toFront (bool makeActiveWindow);
	void toBehind (ComponentPeer* other);
	void setIcon (const Image& newIcon);
	StringArray getAvailableRenderingEngines();
	int getCurrentRenderingEngine() const;
	void setCurrentRenderingEngine (int index);

	/* When you use multiple DLLs which share similarly-named obj-c classes - like
	   for example having more than one juce plugin loaded into a host, then when a
	   method is called, the actual code that runs might actually be in a different module
	   than the one you expect... So any calls to library functions or statics that are
	   made inside obj-c methods will probably end up getting executed in a different DLL's
	   memory space. Not a great thing to happen - this obviously leads to bizarre crashes.

	   To work around this insanity, I'm only allowing obj-c methods to make calls to
	   virtual methods of an object that's known to live inside the right module's space.
	*/
	virtual void redirectMouseDown (NSEvent* ev);
	virtual void redirectMouseUp (NSEvent* ev);
	virtual void redirectMouseDrag (NSEvent* ev);
	virtual void redirectMouseMove (NSEvent* ev);
	virtual void redirectMouseEnter (NSEvent* ev);
	virtual void redirectMouseExit (NSEvent* ev);
	virtual void redirectMouseWheel (NSEvent* ev);
	void sendMouseEvent (NSEvent* ev);

	bool handleKeyEvent (NSEvent* ev, bool isKeyDown);
	virtual bool redirectKeyDown (NSEvent* ev);
	virtual bool redirectKeyUp (NSEvent* ev);
	virtual void redirectModKeyChange (NSEvent* ev);
   #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
	virtual bool redirectPerformKeyEquivalent (NSEvent* ev);
   #endif

	virtual BOOL sendDragCallback (int type, id <NSDraggingInfo> sender);

	virtual bool isOpaque();
	virtual void drawRect (NSRect r);

	virtual bool canBecomeKeyWindow();
	virtual void becomeKeyWindow();
	virtual bool windowShouldClose();

	virtual void redirectMovedOrResized();
	virtual void viewMovedToWindow();

	virtual NSRect constrainRect (NSRect r);

	static void showArrowCursorIfNeeded();
	static void updateModifiers (NSEvent* e);
	static void updateModifiers (NSUInteger);
	static void updateKeysDown (NSEvent* ev, bool isKeyDown);

	static int getKeyCodeFromEvent (NSEvent* ev)
	{
		const String unmodified (nsStringToJuce ([ev charactersIgnoringModifiers]));
		int keyCode = unmodified[0];

		if (keyCode == 0x19) // (backwards-tab)
			keyCode = '\t';
		else if (keyCode == 0x03) // (enter)
			keyCode = '\r';
		else
			keyCode = (int) CharacterFunctions::toUpperCase ((juce_wchar) keyCode);

		if (([ev modifierFlags] & NSNumericPadKeyMask) != 0)
		{
			const int numPadConversions[] = { '0', KeyPress::numberPad0, '1', KeyPress::numberPad1,
											  '2', KeyPress::numberPad2, '3', KeyPress::numberPad3,
											  '4', KeyPress::numberPad4, '5', KeyPress::numberPad5,
											  '6', KeyPress::numberPad6, '7', KeyPress::numberPad7,
											  '8', KeyPress::numberPad8, '9', KeyPress::numberPad9,
											  '+', KeyPress::numberPadAdd,  '-', KeyPress::numberPadSubtract,
											  '*', KeyPress::numberPadMultiply, '/', KeyPress::numberPadDivide,
											  '.', KeyPress::numberPadDecimalPoint, '=', KeyPress::numberPadEquals };

			for (int i = 0; i < numElementsInArray (numPadConversions); i += 2)
				if (keyCode == numPadConversions [i])
					keyCode = numPadConversions [i + 1];
		}

		return keyCode;
	}

	static int64 getMouseTime (NSEvent* e)
	{
		return (Time::currentTimeMillis() - Time::getMillisecondCounter())
				+ (int64) ([e timestamp] * 1000.0);
	}

	static Point<int> getMousePos (NSEvent* e, NSView* view)
	{
		NSPoint p = [view convertPoint: [e locationInWindow] fromView: nil];
		return Point<int> (roundToInt (p.x), roundToInt ([view frame].size.height - p.y));
	}

	static int getModifierForButtonNumber (const NSInteger num)
	{
		return num == 0 ? ModifierKeys::leftButtonModifier
					: (num == 1 ? ModifierKeys::rightButtonModifier
								: (num == 2 ? ModifierKeys::middleButtonModifier : 0));
	}

	static unsigned int getNSWindowStyleMask (const int flags) noexcept
	{
		unsigned int style = (flags & windowHasTitleBar) != 0 ? NSTitledWindowMask
															  : NSBorderlessWindowMask;

		if ((flags & windowHasMinimiseButton) != 0)  style |= NSMiniaturizableWindowMask;
		if ((flags & windowHasCloseButton) != 0)     style |= NSClosableWindowMask;
		if ((flags & windowIsResizable) != 0)        style |= NSResizableWindowMask;
		return style;
	}

	virtual void viewFocusGain();
	virtual void viewFocusLoss();
	bool isFocused() const;
	void grabFocus();
	void textInputRequired (const Point<int>& position);

	void repaint (const Rectangle<int>& area);
	void performAnyPendingRepaintsNow();

	NSWindow* window;
	JuceNSView* view;
	bool isSharedWindow, fullScreen, insideDrawRect, usingCoreGraphics, recursiveToFrontCall;

	static ModifierKeys currentModifiers;
	static ComponentPeer* currentlyFocusedPeer;
	static Array<int> keysCurrentlyDown;

private:
	static void appFocusChanged()
	{
		keysCurrentlyDown.clear();

		if (isValidPeer (currentlyFocusedPeer))
		{
			if (Process::isForegroundProcess())
			{
				currentlyFocusedPeer->handleFocusGain();
				ModalComponentManager::getInstance()->bringModalComponentsToFront();
			}
			else
			{
				currentlyFocusedPeer->handleFocusLoss();
			}
		}
	}

	static bool checkEventBlockedByModalComps (NSEvent* e)
	{
		if (Component::getNumCurrentlyModalComponents() == 0)
			return false;

		NSWindow* const w = [e window];
		if (w == nil || [w worksWhenModal])
			return false;

		bool isKey = false, isInputAttempt = false;

		switch ([e type])
		{
			case NSKeyDown:
			case NSKeyUp:
				isKey = isInputAttempt = true;
				break;

			case NSLeftMouseDown:
			case NSRightMouseDown:
			case NSOtherMouseDown:
				isInputAttempt = true;
				break;

			case NSLeftMouseDragged:
			case NSRightMouseDragged:
			case NSLeftMouseUp:
			case NSRightMouseUp:
			case NSOtherMouseUp:
			case NSOtherMouseDragged:
				if (Desktop::getInstance().getDraggingMouseSource(0) != nullptr)
					return false;
				break;

			case NSMouseMoved:
			case NSMouseEntered:
			case NSMouseExited:
			case NSCursorUpdate:
			case NSScrollWheel:
			case NSTabletPoint:
			case NSTabletProximity:
				break;

			default:
				return false;
		}

		for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		{
			ComponentPeer* const peer = ComponentPeer::getPeer (i);
			NSView* const compView = (NSView*) peer->getNativeHandle();

			if ([compView window] == w)
			{
				if (isKey)
				{
					if (compView == [w firstResponder])
						return false;
				}
				else
				{
					NSViewComponentPeer* nsViewPeer = dynamic_cast<NSViewComponentPeer*> (peer);

					if ((nsViewPeer == nullptr || ! nsViewPeer->isSharedWindow)
							? NSPointInRect ([e locationInWindow], NSMakeRect (0, 0, [w frame].size.width, [w frame].size.height))
							: NSPointInRect ([compView convertPoint: [e locationInWindow] fromView: nil], [compView bounds]))
						return false;
				}
			}
		}

		if (isInputAttempt)
		{
			if (! [NSApp isActive])
				[NSApp activateIgnoringOtherApps: YES];

			Component* const modal = Component::getCurrentlyModalComponent (0);
			if (modal != nullptr)
				modal->inputAttemptWhenModal();
		}

		return true;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NSViewComponentPeer);
};

} // (juce namespace)

@implementation JuceNSView

- (JuceNSView*) initWithOwner: (NSViewComponentPeer*) owner_
					withFrame: (NSRect) frame
{
	[super initWithFrame: frame];
	owner = owner_;
	stringBeingComposed = nullptr;
	textWasInserted = false;

	notificationCenter = [NSNotificationCenter defaultCenter];

	[notificationCenter  addObserver: self
							selector: @selector (frameChanged:)
								name: NSViewFrameDidChangeNotification
							  object: self];

	if (! owner_->isSharedWindow)
	{
		[notificationCenter  addObserver: self
								selector: @selector (frameChanged:)
									name: NSWindowDidMoveNotification
								  object: owner_->window];
	}

	[self registerForDraggedTypes: [self getSupportedDragTypes]];

	return self;
}

- (void) dealloc
{
	[notificationCenter removeObserver: self];
	delete stringBeingComposed;
	[super dealloc];
}

- (void) drawRect: (NSRect) r
{
	if (owner != nullptr)
		owner->drawRect (r);
}

- (BOOL) isOpaque
{
	return owner == nullptr || owner->isOpaque();
}

- (void) mouseDown: (NSEvent*) ev
{
	if (JUCEApplication::isStandaloneApp())
		[self asyncMouseDown: ev];
	else
		// In some host situations, the host will stop modal loops from working
		// correctly if they're called from a mouse event, so we'll trigger
		// the event asynchronously..
		[self performSelectorOnMainThread: @selector (asyncMouseDown:)
							   withObject: ev
							waitUntilDone: NO];
}

- (void) asyncMouseDown: (NSEvent*) ev
{
	if (owner != nullptr)
		owner->redirectMouseDown (ev);
}

- (void) mouseUp: (NSEvent*) ev
{
	if (! JUCEApplication::isStandaloneApp())
		[self asyncMouseUp: ev];
	else
		// In some host situations, the host will stop modal loops from working
		// correctly if they're called from a mouse event, so we'll trigger
		// the event asynchronously..
		[self performSelectorOnMainThread: @selector (asyncMouseUp:)
							   withObject: ev
							waitUntilDone: NO];
}

- (void) asyncMouseUp: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseUp    (ev); }
- (void) mouseDragged: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseDrag  (ev); }
- (void) mouseMoved:   (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseMove  (ev); }
- (void) mouseEntered: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseEnter (ev); }
- (void) mouseExited:  (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseExit  (ev); }
- (void) scrollWheel:  (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseWheel (ev); }

- (void) rightMouseDown:    (NSEvent*) ev   { [self mouseDown:    ev]; }
- (void) rightMouseDragged: (NSEvent*) ev   { [self mouseDragged: ev]; }
- (void) rightMouseUp:      (NSEvent*) ev   { [self mouseUp:      ev]; }
- (void) otherMouseDown:    (NSEvent*) ev   { [self mouseDown:    ev]; }
- (void) otherMouseDragged: (NSEvent*) ev   { [self mouseDragged: ev]; }
- (void) otherMouseUp:      (NSEvent*) ev   { [self mouseUp:      ev]; }

- (BOOL) acceptsFirstMouse: (NSEvent*) ev
{
	(void) ev;
	return YES;
}

- (void) frameChanged: (NSNotification*) n
{
	(void) n;
	if (owner != nullptr)
		owner->redirectMovedOrResized();
}

- (void) viewDidMoveToWindow
{
   if (owner != nullptr)
	   owner->viewMovedToWindow();
}

- (void) keyDown: (NSEvent*) ev
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();
	textWasInserted = false;

	if (target != nullptr)
		[self interpretKeyEvents: [NSArray arrayWithObject: ev]];
	else
		deleteAndZero (stringBeingComposed);

	if ((! textWasInserted) && (owner == nullptr || ! owner->redirectKeyDown (ev)))
		[super keyDown: ev];
}

- (void) keyUp: (NSEvent*) ev
{
	if (owner == nullptr || ! owner->redirectKeyUp (ev))
		[super keyUp: ev];
}

- (void) insertText: (id) aString
{
	// This commits multi-byte text when return is pressed, or after every keypress for western keyboards
	NSString* newText = [aString isKindOfClass: [NSAttributedString class]] ? [aString string] : aString;

	if ([newText length] > 0)
	{
		TextInputTarget* const target = owner->findCurrentTextInputTarget();

		if (target != nullptr)
		{
			target->insertTextAtCaret (nsStringToJuce (newText));
			textWasInserted = true;
		}
	}

	deleteAndZero (stringBeingComposed);
}

- (void) doCommandBySelector: (SEL) aSelector
{
	(void) aSelector;
}

- (void) setMarkedText: (id) aString selectedRange: (NSRange) selectionRange
{
	(void) selectionRange;

	if (stringBeingComposed == 0)
		stringBeingComposed = new String();

	*stringBeingComposed = nsStringToJuce ([aString isKindOfClass:[NSAttributedString class]] ? [aString string] : aString);

	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> currentHighlight (target->getHighlightedRegion());
		target->insertTextAtCaret (*stringBeingComposed);
		target->setHighlightedRegion (currentHighlight.withLength (stringBeingComposed->length()));
		textWasInserted = true;
	}
}

- (void) unmarkText
{
	if (stringBeingComposed != nullptr)
	{
		TextInputTarget* const target = owner->findCurrentTextInputTarget();

		if (target != nullptr)
		{
			target->insertTextAtCaret (*stringBeingComposed);
			textWasInserted = true;
		}
	}

	deleteAndZero (stringBeingComposed);
}

- (BOOL) hasMarkedText
{
	return stringBeingComposed != nullptr;
}

- (long) conversationIdentifier
{
	return (long) (pointer_sized_int) self;
}

- (NSAttributedString*) attributedSubstringFromRange: (NSRange) theRange
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> r ((int) theRange.location,
							(int) (theRange.location + theRange.length));

		return [[[NSAttributedString alloc] initWithString: juceStringToNS (target->getTextInRange (r))] autorelease];
	}

	return nil;
}

- (NSRange) markedRange
{
	return stringBeingComposed != nullptr ? NSMakeRange (0, stringBeingComposed->length())
										  : NSMakeRange (NSNotFound, 0);
}

- (NSRange) selectedRange
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> highlight (target->getHighlightedRegion());

		if (! highlight.isEmpty())
			return NSMakeRange (highlight.getStart(), highlight.getLength());
	}

	return NSMakeRange (NSNotFound, 0);
}

- (NSRect) firstRectForCharacterRange: (NSRange) theRange
{
	(void) theRange;
	juce::Component* const comp = dynamic_cast <juce::Component*> (owner->findCurrentTextInputTarget());

	if (comp == 0)
		return NSMakeRect (0, 0, 0, 0);

	const Rectangle<int> bounds (comp->getScreenBounds());

	return NSMakeRect (bounds.getX(),
					   [[[NSScreen screens] objectAtIndex: 0] frame].size.height - bounds.getY(),
					   bounds.getWidth(),
					   bounds.getHeight());
}

- (NSUInteger) characterIndexForPoint: (NSPoint) thePoint
{
	(void) thePoint;
	return NSNotFound;
}

- (NSArray*) validAttributesForMarkedText
{
	return [NSArray array];
}

- (void) flagsChanged: (NSEvent*) ev
{
	if (owner != nullptr)
		owner->redirectModKeyChange (ev);
}

#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
- (BOOL) performKeyEquivalent: (NSEvent*) ev
{
	if (owner != nullptr && owner->redirectPerformKeyEquivalent (ev))
		return true;

	return [super performKeyEquivalent: ev];
}
#endif

- (BOOL) becomeFirstResponder   { if (owner != nullptr) owner->viewFocusGain(); return YES; }
- (BOOL) resignFirstResponder   { if (owner != nullptr) owner->viewFocusLoss(); return YES; }

- (BOOL) acceptsFirstResponder  { return owner != nullptr && owner->canBecomeKeyWindow(); }

- (NSArray*) getSupportedDragTypes
{
	return [NSArray arrayWithObjects: NSFilenamesPboardType, NSFilesPromisePboardType, /* NSStringPboardType,*/ nil];
}

- (BOOL) sendDragCallback: (int) type sender: (id <NSDraggingInfo>) sender
{
	return owner != nullptr && owner->sendDragCallback (type, sender);
}

- (NSDragOperation) draggingEntered: (id <NSDraggingInfo>) sender
{
	if ([self sendDragCallback: 0 sender: sender])
		return NSDragOperationCopy | NSDragOperationMove | NSDragOperationGeneric;
	else
		return NSDragOperationNone;
}

- (NSDragOperation) draggingUpdated: (id <NSDraggingInfo>) sender
{
	if ([self sendDragCallback: 0 sender: sender])
		return NSDragOperationCopy | NSDragOperationMove | NSDragOperationGeneric;
	else
		return NSDragOperationNone;
}

- (void) draggingEnded: (id <NSDraggingInfo>) sender
{
	[self sendDragCallback: 1 sender: sender];
}

- (void) draggingExited: (id <NSDraggingInfo>) sender
{
	[self sendDragCallback: 1 sender: sender];
}

- (BOOL) prepareForDragOperation: (id <NSDraggingInfo>) sender
{
	(void) sender;
	return YES;
}

- (BOOL) performDragOperation: (id <NSDraggingInfo>) sender
{
	return [self sendDragCallback: 2 sender: sender];
}

- (void) concludeDragOperation: (id <NSDraggingInfo>) sender
{
	(void) sender;
}

@end

@implementation JuceNSWindow

- (void) setOwner: (NSViewComponentPeer*) owner_
{
	owner = owner_;
	isZooming = false;
}

- (BOOL) canBecomeKeyWindow
{
	return owner != nullptr && owner->canBecomeKeyWindow();
}

- (void) becomeKeyWindow
{
	[super becomeKeyWindow];

	if (owner != nullptr)
		owner->becomeKeyWindow();
}

- (BOOL) windowShouldClose: (id) window
{
	(void) window;
	return owner == nullptr || owner->windowShouldClose();
}

- (NSRect) constrainFrameRect: (NSRect) frameRect toScreen: (NSScreen*) screen
{
	(void) screen;
	if (owner != nullptr)
		frameRect = owner->constrainRect (frameRect);

	return frameRect;
}

- (NSSize) windowWillResize: (NSWindow*) window toSize: (NSSize) proposedFrameSize
{
	(void) window;
	if (isZooming)
		return proposedFrameSize;

	NSRect frameRect = [self frame];
	frameRect.origin.y -= proposedFrameSize.height - frameRect.size.height;
	frameRect.size = proposedFrameSize;

	if (owner != nullptr)
		frameRect = owner->constrainRect (frameRect);

	if (juce::Component::getCurrentlyModalComponent() != nullptr
		  && owner->getComponent()->isCurrentlyBlockedByAnotherModalComponent()
		  && owner->hasNativeTitleBar())
		juce::Component::getCurrentlyModalComponent()->inputAttemptWhenModal();

	return frameRect.size;
}

- (void) zoom: (id) sender
{
	isZooming = true;
	[super zoom: sender];
	isZooming = false;

	owner->redirectMovedOrResized();
}

- (void) windowWillMove: (NSNotification*) notification
{
	(void) notification;

	if (juce::Component::getCurrentlyModalComponent() != nullptr
		  && owner->getComponent()->isCurrentlyBlockedByAnotherModalComponent()
		  && owner->hasNativeTitleBar())
		juce::Component::getCurrentlyModalComponent()->inputAttemptWhenModal();
}

@end

namespace juce
{

ModifierKeys NSViewComponentPeer::currentModifiers;
ComponentPeer* NSViewComponentPeer::currentlyFocusedPeer = nullptr;
Array<int> NSViewComponentPeer::keysCurrentlyDown;

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	if (NSViewComponentPeer::keysCurrentlyDown.contains (keyCode))
		return true;

	if (keyCode >= 'A' && keyCode <= 'Z'
		 && NSViewComponentPeer::keysCurrentlyDown.contains ((int) CharacterFunctions::toLowerCase ((juce_wchar) keyCode)))
		return true;

	if (keyCode >= 'a' && keyCode <= 'z'
		 && NSViewComponentPeer::keysCurrentlyDown.contains ((int) CharacterFunctions::toUpperCase ((juce_wchar) keyCode)))
		return true;

	return false;
}

void NSViewComponentPeer::updateModifiers (const NSUInteger flags)
{
	int m = 0;

	if ((flags & NSShiftKeyMask) != 0)        m |= ModifierKeys::shiftModifier;
	if ((flags & NSControlKeyMask) != 0)      m |= ModifierKeys::ctrlModifier;
	if ((flags & NSAlternateKeyMask) != 0)    m |= ModifierKeys::altModifier;
	if ((flags & NSCommandKeyMask) != 0)      m |= ModifierKeys::commandModifier;

	currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (m);
}

void NSViewComponentPeer::updateModifiers (NSEvent* e)
{
	updateModifiers ([e modifierFlags]);
}

void NSViewComponentPeer::updateKeysDown (NSEvent* ev, bool isKeyDown)
{
	updateModifiers (ev);
	int keyCode = getKeyCodeFromEvent (ev);

	if (keyCode != 0)
	{
		if (isKeyDown)
			keysCurrentlyDown.addIfNotAlreadyThere (keyCode);
		else
			keysCurrentlyDown.removeValue (keyCode);
	}
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	if ([NSEvent respondsToSelector: @selector (modifierFlags)])
		NSViewComponentPeer::updateModifiers ((NSUInteger) [NSEvent modifierFlags]);

	return NSViewComponentPeer::currentModifiers;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = NSViewComponentPeer::currentModifiers;
}

NSViewComponentPeer::NSViewComponentPeer (Component* const component_,
										  const int windowStyleFlags,
										  NSView* viewToAttachTo)
	: ComponentPeer (component_, windowStyleFlags),
	  window (nil),
	  view (nil),
	  isSharedWindow (viewToAttachTo != nil),
	  fullScreen (false),
	  insideDrawRect (false),
	 #if USE_COREGRAPHICS_RENDERING
	  usingCoreGraphics (true),
	 #else
	  usingCoreGraphics (false),
	 #endif
	  recursiveToFrontCall (false)
{
	appFocusChangeCallback = appFocusChanged;
	isEventBlockedByModalComps = checkEventBlockedByModalComps;

	NSRect r = NSMakeRect (0, 0, (CGFloat) component->getWidth(), (CGFloat) component->getHeight());

	view = [[JuceNSView alloc] initWithOwner: this withFrame: r];
	[view setPostsFrameChangedNotifications: YES];

	if (isSharedWindow)
	{
		window = [viewToAttachTo window];
		[viewToAttachTo addSubview: view];
	}
	else
	{
		r.origin.x = (CGFloat) component->getX();
		r.origin.y = (CGFloat) component->getY();
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - (r.origin.y + r.size.height);

		window = [[JuceNSWindow alloc] initWithContentRect: r
												 styleMask: getNSWindowStyleMask (windowStyleFlags)
												   backing: NSBackingStoreBuffered
													 defer: YES];

		[((JuceNSWindow*) window) setOwner: this];
		[window orderOut: nil];
		[window setDelegate: (JuceNSWindow*) window];
		[window setOpaque: component->isOpaque()];
		[window setHasShadow: ((windowStyleFlags & windowHasDropShadow) != 0)];

		if (component->isAlwaysOnTop())
			[window setLevel: NSFloatingWindowLevel];

		[window setContentView: view];
		[window setAutodisplay: YES];
		[window setAcceptsMouseMovedEvents: YES];

		// We'll both retain and also release this on closing because plugin hosts can unexpectedly
		// close the window for us, and also tend to get cause trouble if setReleasedWhenClosed is NO.
		[window setReleasedWhenClosed: YES];
		[window retain];

		[window setExcludedFromWindowsMenu: (windowStyleFlags & windowIsTemporary) != 0];
		[window setIgnoresMouseEvents: (windowStyleFlags & windowIgnoresMouseClicks) != 0];

	   #if defined (MAC_OS_X_VERSION_10_7) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
		if ((windowStyleFlags & (windowHasMaximiseButton | windowHasTitleBar)) == (windowHasMaximiseButton | windowHasTitleBar))
			[window setCollectionBehavior: NSWindowCollectionBehaviorFullScreenPrimary];
	   #endif
	}

	const float alpha = component->getAlpha();
	if (alpha < 1.0f)
		setAlpha (alpha);

	setTitle (component->getName());
}

NSViewComponentPeer::~NSViewComponentPeer()
{
	view->owner = nullptr;
	[view removeFromSuperview];
	[view release];

	if (! isSharedWindow)
	{
		[((JuceNSWindow*) window) setOwner: 0];
		[window close];
		[window release];
	}
}

void* NSViewComponentPeer::getNativeHandle() const
{
	return view;
}

void NSViewComponentPeer::setVisible (bool shouldBeVisible)
{
	if (isSharedWindow)
	{
		[view setHidden: ! shouldBeVisible];
	}
	else
	{
		if (shouldBeVisible)
		{
			[window orderFront: nil];
			handleBroughtToFront();
		}
		else
		{
			[window orderOut: nil];
		}
	}
}

void NSViewComponentPeer::setTitle (const String& title)
{
	JUCE_AUTORELEASEPOOL

	if (! isSharedWindow)
		[window setTitle: juceStringToNS (title)];
}

void NSViewComponentPeer::setPosition (int x, int y)
{
	setBounds (x, y, component->getWidth(), component->getHeight(), false);
}

void NSViewComponentPeer::setSize (int w, int h)
{
	setBounds (component->getX(), component->getY(), w, h, false);
}

void NSViewComponentPeer::setBounds (int x, int y, int w, int h, bool isNowFullScreen)
{
	fullScreen = isNowFullScreen;

	NSRect r = NSMakeRect ((CGFloat) x, (CGFloat) y, (CGFloat) jmax (0, w), (CGFloat) jmax (0, h));

	if (isSharedWindow)
	{
		r.origin.y = [[view superview] frame].size.height - (r.origin.y + r.size.height);

		if ([view frame].size.width != r.size.width
			 || [view frame].size.height != r.size.height)
		{
			[view setNeedsDisplay: true];
		}

		[view setFrame: r];
	}
	else
	{
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - (r.origin.y + r.size.height);

		[window setFrame: [window frameRectForContentRect: r]
				 display: true];
	}
}

Rectangle<int> NSViewComponentPeer::getBounds (const bool global) const
{
	NSRect r = [view frame];

	if (global && [view window] != nil)
	{
		r = [view convertRect: r toView: nil];
		NSRect wr = [[view window] frame];
		r.origin.x += wr.origin.x;
		r.origin.y += wr.origin.y;
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.origin.y - r.size.height;
	}
	else
	{
		r.origin.y = [[view superview] frame].size.height - r.origin.y - r.size.height;
	}

	return Rectangle<int> (convertToRectInt (r));
}

Rectangle<int> NSViewComponentPeer::getBounds() const
{
	return getBounds (! isSharedWindow);
}

Point<int> NSViewComponentPeer::getScreenPosition() const
{
	return getBounds (true).getPosition();
}

Point<int> NSViewComponentPeer::localToGlobal (const Point<int>& relativePosition)
{
	return relativePosition + getScreenPosition();
}

Point<int> NSViewComponentPeer::globalToLocal (const Point<int>& screenPosition)
{
	return screenPosition - getScreenPosition();
}

NSRect NSViewComponentPeer::constrainRect (NSRect r)
{
	if (constrainer != nullptr
		#if defined (MAC_OS_X_VERSION_10_7) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
		 && ([window styleMask] & NSFullScreenWindowMask) == 0
		#endif
		)
	{
		NSRect current = [window frame];
		current.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - current.origin.y - current.size.height;

		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.origin.y - r.size.height;

		Rectangle<int> pos (convertToRectInt (r));
		Rectangle<int> original (convertToRectInt (current));
		const Rectangle<int> screenBounds (Desktop::getInstance().getDisplays().getTotalBounds (true));

	   #if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MIN_ALLOWED >= MAC_OS_X_VERSION_10_6
		if ([window inLiveResize])
	   #else
		if ([window respondsToSelector: @selector (inLiveResize)]
			 && [window performSelector: @selector (inLiveResize)])
	   #endif
		{
			constrainer->checkBounds (pos, original, screenBounds,
									  false, false, true, true);
		}
		else
		{
			constrainer->checkBounds (pos, original, screenBounds,
									  pos.getY() != original.getY() && pos.getBottom() == original.getBottom(),
									  pos.getX() != original.getX() && pos.getRight() == original.getRight(),
									  pos.getY() == original.getY() && pos.getBottom() != original.getBottom(),
									  pos.getX() == original.getX() && pos.getRight() != original.getRight());
		}

		r.origin.x = pos.getX();
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.size.height - pos.getY();
		r.size.width = pos.getWidth();
		r.size.height = pos.getHeight();
	}

	return r;
}

void NSViewComponentPeer::setAlpha (float newAlpha)
{
	if (! isSharedWindow)
	{
		[window setAlphaValue: (CGFloat) newAlpha];
	}
	else
	{
	   #if defined (MAC_OS_X_VERSION_10_5) && MAC_OS_X_VERSION_MIN_ALLOWED >= MAC_OS_X_VERSION_10_5
		[view setAlphaValue: (CGFloat) newAlpha];
	   #else
		if ([view respondsToSelector: @selector (setAlphaValue:)])
		{
			// PITA dynamic invocation for 10.4 builds..
			NSInvocation* inv = [NSInvocation invocationWithMethodSignature: [view methodSignatureForSelector: @selector (setAlphaValue:)]];
			[inv setSelector: @selector (setAlphaValue:)];
			[inv setTarget: view];
			CGFloat cgNewAlpha = (CGFloat) newAlpha;
			[inv setArgument: &cgNewAlpha atIndex: 2];
			[inv invoke];
		}
	   #endif
	}
}

void NSViewComponentPeer::setMinimised (bool shouldBeMinimised)
{
	if (! isSharedWindow)
	{
		if (shouldBeMinimised)
			[window miniaturize: nil];
		else
			[window deminiaturize: nil];
	}
}

bool NSViewComponentPeer::isMinimised() const
{
	return [window isMiniaturized];
}

void NSViewComponentPeer::setFullScreen (bool shouldBeFullScreen)
{
	if (! isSharedWindow)
	{
		Rectangle<int> r (lastNonFullscreenBounds);

		if (isMinimised())
			setMinimised (false);

		if (fullScreen != shouldBeFullScreen)
		{
			if (shouldBeFullScreen && hasNativeTitleBar())
			{
				fullScreen = true;
				[window performZoom: nil];
			}
			else
			{
				if (shouldBeFullScreen)
					r = component->getParentMonitorArea();

				// (can't call the component's setBounds method because that'll reset our fullscreen flag)
				if (r != getComponent()->getBounds() && ! r.isEmpty())
					setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);
			}
		}
	}
}

bool NSViewComponentPeer::isFullScreen() const
{
	return fullScreen;
}

bool NSViewComponentPeer::contains (const Point<int>& position, bool trueIfInAChildWindow) const
{
	if (! (isPositiveAndBelow (position.getX(), component->getWidth())
			&& isPositiveAndBelow (position.getY(), component->getHeight())))
		return false;

	NSRect frameRect = [view frame];

	NSView* v = [view hitTest: NSMakePoint (frameRect.origin.x + position.getX(),
											frameRect.origin.y + frameRect.size.height - position.getY())];

	if (trueIfInAChildWindow)
		return v != nil;

	return v == view;
}

BorderSize<int> NSViewComponentPeer::getFrameSize() const
{
	BorderSize<int> b;

	if (! isSharedWindow)
	{
		NSRect v = [view convertRect: [view frame] toView: nil];
		NSRect w = [window frame];

		b.setTop ((int) (w.size.height - (v.origin.y + v.size.height)));
		b.setBottom ((int) v.origin.y);
		b.setLeft ((int) v.origin.x);
		b.setRight ((int) (w.size.width - (v.origin.x + v.size.width)));
	}

	return b;
}

bool NSViewComponentPeer::setAlwaysOnTop (bool alwaysOnTop)
{
	if (! isSharedWindow)
		[window setLevel: alwaysOnTop ? NSFloatingWindowLevel
									  : NSNormalWindowLevel];
	return true;
}

void NSViewComponentPeer::toFront (bool makeActiveWindow)
{
	if (isSharedWindow)
		[[view superview] addSubview: view
						  positioned: NSWindowAbove
						  relativeTo: nil];

	if (window != nil && component->isVisible())
	{
		if (makeActiveWindow)
			[window makeKeyAndOrderFront: nil];
		else
			[window orderFront: nil];

		if (! recursiveToFrontCall)
		{
			recursiveToFrontCall = true;
			Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
			handleBroughtToFront();
			recursiveToFrontCall = false;
		}
	}
}

void NSViewComponentPeer::toBehind (ComponentPeer* other)
{
	NSViewComponentPeer* const otherPeer = dynamic_cast <NSViewComponentPeer*> (other);
	jassert (otherPeer != nullptr); // wrong type of window?

	if (otherPeer != nullptr)
	{
		if (isSharedWindow)
		{
			[[view superview] addSubview: view
							  positioned: NSWindowBelow
							  relativeTo: otherPeer->view];
		}
		else
		{
			[window orderWindow: NSWindowBelow
					 relativeTo: [otherPeer->window windowNumber]];
		}
	}
}

void NSViewComponentPeer::setIcon (const Image& /*newIcon*/)
{
	// to do..
}

void NSViewComponentPeer::viewFocusGain()
{
	if (currentlyFocusedPeer != this)
	{
		if (ComponentPeer::isValidPeer (currentlyFocusedPeer))
			currentlyFocusedPeer->handleFocusLoss();

		currentlyFocusedPeer = this;
		handleFocusGain();
	}
}

void NSViewComponentPeer::viewFocusLoss()
{
	if (currentlyFocusedPeer == this)
	{
		currentlyFocusedPeer = nullptr;
		handleFocusLoss();
	}
}

bool NSViewComponentPeer::isFocused() const
{
	return isSharedWindow ? this == currentlyFocusedPeer
						  : [window isKeyWindow];
}

void NSViewComponentPeer::grabFocus()
{
	if (window != nil)
	{
		[window makeKeyWindow];
		[window makeFirstResponder: view];

		viewFocusGain();
	}
}

void NSViewComponentPeer::textInputRequired (const Point<int>&)
{
}

bool NSViewComponentPeer::handleKeyEvent (NSEvent* ev, bool isKeyDown)
{
	String unicode (nsStringToJuce ([ev characters]));
	String unmodified (nsStringToJuce ([ev charactersIgnoringModifiers]));
	int keyCode = getKeyCodeFromEvent (ev);

	//DBG ("unicode: " + unicode + " " + String::toHexString ((int) unicode[0]));
	//DBG ("unmodified: " + unmodified + " " + String::toHexString ((int) unmodified[0]));

	if (unicode.isNotEmpty() || keyCode != 0)
	{
		if (isKeyDown)
		{
			bool used = false;

			while (unicode.length() > 0)
			{
				juce_wchar textCharacter = unicode[0];
				unicode = unicode.substring (1);

				if (([ev modifierFlags] & NSCommandKeyMask) != 0)
					textCharacter = 0;

				used = handleKeyUpOrDown (true) || used;
				used = handleKeyPress (keyCode, textCharacter) || used;
			}

			return used;
		}
		else
		{
			if (handleKeyUpOrDown (false))
				return true;
		}
	}

	return false;
}

bool NSViewComponentPeer::redirectKeyDown (NSEvent* ev)
{
	updateKeysDown (ev, true);
	bool used = handleKeyEvent (ev, true);

	if (([ev modifierFlags] & NSCommandKeyMask) != 0)
	{
		// for command keys, the key-up event is thrown away, so simulate one..
		updateKeysDown (ev, false);
		used = (isValidPeer (this) && handleKeyEvent (ev, false)) || used;
	}

	// (If we're running modally, don't allow unused keystrokes to be passed
	// along to other blocked views..)
	if (Component::getCurrentlyModalComponent() != nullptr)
		used = true;

	return used;
}

bool NSViewComponentPeer::redirectKeyUp (NSEvent* ev)
{
	updateKeysDown (ev, false);
	return handleKeyEvent (ev, false)
			|| Component::getCurrentlyModalComponent() != nullptr;
}

void NSViewComponentPeer::redirectModKeyChange (NSEvent* ev)
{
	keysCurrentlyDown.clear();
	handleKeyUpOrDown (true);

	updateModifiers (ev);
	handleModifierKeysChange();
}

#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
bool NSViewComponentPeer::redirectPerformKeyEquivalent (NSEvent* ev)
{
	if ([ev type] == NSKeyDown)
		return redirectKeyDown (ev);
	else if ([ev type] == NSKeyUp)
		return redirectKeyUp (ev);

	return false;
}
#endif

void NSViewComponentPeer::sendMouseEvent (NSEvent* ev)
{
	updateModifiers (ev);
	handleMouseEvent (0, getMousePos (ev, view), currentModifiers, getMouseTime (ev));
}

void NSViewComponentPeer::redirectMouseDown (NSEvent* ev)
{
	currentModifiers = currentModifiers.withFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseUp (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
	showArrowCursorIfNeeded();
}

void NSViewComponentPeer::redirectMouseDrag (NSEvent* ev)
{
	currentModifiers = currentModifiers.withFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseMove (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
	showArrowCursorIfNeeded();
}

void NSViewComponentPeer::redirectMouseEnter (NSEvent* ev)
{
	Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseExit (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseWheel (NSEvent* ev)
{
	updateModifiers (ev);

	float x = 0, y = 0;

	@try
	{
	   #if defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
		if ([ev respondsToSelector: @selector (hasPreciseScrollingDeltas)])
		{
			if ([ev hasPreciseScrollingDeltas])
			{
				x = [ev scrollingDeltaX] * 0.5f;
				y = [ev scrollingDeltaY] * 0.5f;
			}
		}
		else
	   #endif
		{
			x = [ev deviceDeltaX] * 0.5f;
			y = [ev deviceDeltaY] * 0.5f;
		}
	}
	@catch (...)
	{}

	if (x == 0 && y == 0)
	{
		x = [ev deltaX] * 10.0f;
		y = [ev deltaY] * 10.0f;
	}

	handleMouseWheel (0, getMousePos (ev, view), getMouseTime (ev), x, y);
}

void NSViewComponentPeer::showArrowCursorIfNeeded()
{
	MouseInputSource& mouse = Desktop::getInstance().getMainMouseSource();

	if (mouse.getComponentUnderMouse() == nullptr
		 && Desktop::getInstance().findComponentAt (mouse.getScreenPosition()) == nullptr)
	{
		[[NSCursor arrowCursor] set];
	}
}

BOOL NSViewComponentPeer::sendDragCallback (const int type, id <NSDraggingInfo> sender)
{
	NSString* bestType
		= [[sender draggingPasteboard] availableTypeFromArray: [view getSupportedDragTypes]];

	if (bestType == nil)
		return false;

	NSPoint p = [view convertPoint: [sender draggingLocation] fromView: nil];
	const Point<int> pos ((int) p.x, (int) ([view frame].size.height - p.y));

	NSPasteboard* pasteBoard = [sender draggingPasteboard];
	StringArray files;

	NSString* iTunesPasteboardType = nsStringLiteral ("CorePasteboardFlavorType 0x6974756E"); // 'itun'

	if (bestType == NSFilesPromisePboardType
		 && [[pasteBoard types] containsObject: iTunesPasteboardType])
	{
		id list = [pasteBoard propertyListForType: iTunesPasteboardType];

		if ([list isKindOfClass: [NSDictionary class]])
		{
			NSDictionary* iTunesDictionary = (NSDictionary*) list;
			NSArray* tracks = [iTunesDictionary valueForKey: nsStringLiteral ("Tracks")];
			NSEnumerator* enumerator = [tracks objectEnumerator];
			NSDictionary* track;

			while ((track = [enumerator nextObject]) != nil)
			{
				NSURL* url = [NSURL URLWithString: [track valueForKey: nsStringLiteral ("Location")]];

				if ([url isFileURL])
					files.add (nsStringToJuce ([url path]));
			}
		}
	}
	else
	{
		id list = [pasteBoard propertyListForType: NSFilenamesPboardType];

		if ([list isKindOfClass: [NSArray class]])
		{
			NSArray* items = (NSArray*) [pasteBoard propertyListForType: NSFilenamesPboardType];

			for (unsigned int i = 0; i < [items count]; ++i)
				files.add (nsStringToJuce ((NSString*) [items objectAtIndex: i]));
		}
	}

	if (files.size() > 0)
	{
		switch (type)
		{
			case 0:   return handleFileDragMove (files, pos);
			case 1:   return handleFileDragExit (files);
			case 2:   return handleFileDragDrop (files, pos);
			default:  jassertfalse; break;
		}
	}

	return false;
}

bool NSViewComponentPeer::isOpaque()
{
	return component == nullptr || component->isOpaque();
}

static void getClipRects (RectangleList& clip, NSView* view,
						  const int xOffset, const int yOffset, const int clipW, const int clipH)
{
	const NSRect* rects = nullptr;
	NSInteger numRects = 0;
	[view getRectsBeingDrawn: &rects count: &numRects];

	const Rectangle<int> clipBounds (clipW, clipH);
	const CGFloat viewH = [view frame].size.height;

	for (int i = 0; i < numRects; ++i)
		clip.addWithoutMerging (clipBounds.getIntersection (Rectangle<int> (roundToInt (rects[i].origin.x) + xOffset,
																			roundToInt (viewH - (rects[i].origin.y + rects[i].size.height)) + yOffset,
																			roundToInt (rects[i].size.width),
																			roundToInt (rects[i].size.height))));
}

void NSViewComponentPeer::drawRect (NSRect r)
{
	if (r.size.width < 1.0f || r.size.height < 1.0f)
		return;

	CGContextRef cg = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];

	if (! component->isOpaque())
		CGContextClearRect (cg, CGContextGetClipBoundingBox (cg));

   #if USE_COREGRAPHICS_RENDERING
	if (usingCoreGraphics)
	{
		CoreGraphicsContext context (cg, (float) [view frame].size.height);

		insideDrawRect = true;
		handlePaint (context);
		insideDrawRect = false;
	}
	else
   #endif
	{
		const int xOffset = -roundToInt (r.origin.x);
		const int yOffset = -roundToInt ([view frame].size.height - (r.origin.y + r.size.height));
		const int clipW = (int) (r.size.width  + 0.5f);
		const int clipH = (int) (r.size.height + 0.5f);

		RectangleList clip;
		getClipRects (clip, view, xOffset, yOffset, clipW, clipH);

		if (! clip.isEmpty())
		{
			Image temp (getComponent()->isOpaque() ? Image::RGB : Image::ARGB,
						clipW, clipH, ! getComponent()->isOpaque());

			{
				ScopedPointer<LowLevelGraphicsContext> context (component->getLookAndFeel()
																	.createGraphicsContext (temp, Point<int> (xOffset, yOffset), clip));

				insideDrawRect = true;
				handlePaint (*context);
				insideDrawRect = false;
			}

			CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();
			CGImageRef image = juce_createCoreGraphicsImage (temp, false, colourSpace, false);
			CGColorSpaceRelease (colourSpace);
			CGContextDrawImage (cg, CGRectMake (r.origin.x, r.origin.y, clipW, clipH), image);
			CGImageRelease (image);
		}
	}
}

StringArray NSViewComponentPeer::getAvailableRenderingEngines()
{
	StringArray s (ComponentPeer::getAvailableRenderingEngines());

   #if USE_COREGRAPHICS_RENDERING
	s.add ("CoreGraphics Renderer");
   #endif

	return s;
}

int NSViewComponentPeer::getCurrentRenderingEngine() const
{
	return usingCoreGraphics ? 1 : 0;
}

void NSViewComponentPeer::setCurrentRenderingEngine (int index)
{
   #if USE_COREGRAPHICS_RENDERING
	if (usingCoreGraphics != (index > 0))
	{
		usingCoreGraphics = index > 0;
		[view setNeedsDisplay: true];
	}
   #endif
}

bool NSViewComponentPeer::canBecomeKeyWindow()
{
	return (getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0;
}

void NSViewComponentPeer::becomeKeyWindow()
{
	handleBroughtToFront();
	grabFocus();
}

bool NSViewComponentPeer::windowShouldClose()
{
	if (! isValidPeer (this))
		return YES;

	handleUserClosingWindow();
	return NO;
}

void NSViewComponentPeer::updateFullscreenStatus()
{
	if (hasNativeTitleBar())
	{
		const Rectangle<int> screen (getFrameSize().subtractedFrom (component->getParentMonitorArea()));
		const Rectangle<int> window (component->getScreenBounds());

		fullScreen = std::abs (screen.getX() - window.getX()) <= 2
				  && std::abs (screen.getY() - window.getY()) <= 2
				  && std::abs (screen.getRight() - window.getRight()) <= 2
				  && std::abs (screen.getBottom() - window.getBottom()) <= 2;
	}
}

void NSViewComponentPeer::redirectMovedOrResized()
{
	updateFullscreenStatus();
	handleMovedOrResized();
}

void NSViewComponentPeer::viewMovedToWindow()
{
	if (isSharedWindow)
		window = [view window];
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
   #if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6

	NSViewComponentPeer* const peer = dynamic_cast<NSViewComponentPeer*> (kioskModeComponent->getPeer());

   #if defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
	if (peer != nullptr
		 && peer->hasNativeTitleBar()
		 && [peer->window respondsToSelector: @selector (toggleFullScreen:)])
	{
		[peer->window performSelector: @selector (toggleFullScreen:)
						   withObject: [NSNumber numberWithBool: (BOOL) enableOrDisable]];
	}
	else
   #endif
	{
		if (enableOrDisable)
		{
			if (peer->hasNativeTitleBar())
				[peer->window setStyleMask: NSBorderlessWindowMask];

			[NSApp setPresentationOptions: (allowMenusAndBars ? (NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)
															  : (NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar))];
			kioskModeComponent->setBounds (Desktop::getInstance().getDisplays().getMainDisplay().totalArea);
			peer->becomeKeyWindow();
		}
		else
		{
			if (peer->hasNativeTitleBar())
			{
				[peer->window setStyleMask: (NSViewComponentPeer::getNSWindowStyleMask (peer->getStyleFlags()))];
				peer->setTitle (peer->component->getName()); // required to force the OS to update the title
			}

			[NSApp setPresentationOptions: NSApplicationPresentationDefault];
		}
	}
   #elif JUCE_SUPPORT_CARBON
	if (enableOrDisable)
	{
		SetSystemUIMode (kUIModeAllSuppressed, allowMenusAndBars ? kUIOptionAutoShowMenuBar : 0);
		kioskModeComponent->setBounds (Desktop::getInstance().getDisplays().getMainDisplay().totalArea);
	}
	else
	{
		SetSystemUIMode (kUIModeNormal, 0);
	}
   #else
	// If you're targeting OSes earlier than 10.6 and want to use this feature,
	// you'll need to enable JUCE_SUPPORT_CARBON.
	jassertfalse;
   #endif
}

void NSViewComponentPeer::repaint (const Rectangle<int>& area)
{
	if (insideDrawRect)
	{
		class AsyncRepaintMessage  : public CallbackMessage
		{
		public:
			AsyncRepaintMessage (NSViewComponentPeer* const peer_, const Rectangle<int>& rect_)
				: peer (peer_), rect (rect_)
			{
			}

			void messageCallback()
			{
				if (ComponentPeer::isValidPeer (peer))
					peer->repaint (rect);
			}

		private:
			NSViewComponentPeer* const peer;
			const Rectangle<int> rect;
		};

		(new AsyncRepaintMessage (this, area))->post();
	}
	else
	{
		[view setNeedsDisplayInRect: NSMakeRect ((CGFloat) area.getX(), [view frame].size.height - (CGFloat) area.getBottom(),
												 (CGFloat) area.getWidth(), (CGFloat) area.getHeight())];
	}
}

void NSViewComponentPeer::performAnyPendingRepaintsNow()
{
	[view displayIfNeeded];
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* windowToAttachTo)
{
	return new NSViewComponentPeer (this, styleFlags, (NSView*) windowToAttachTo);
}

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = NSLeftArrowFunctionKey;
const int KeyPress::rightKey        = NSRightArrowFunctionKey;
const int KeyPress::upKey           = NSUpArrowFunctionKey;
const int KeyPress::downKey         = NSDownArrowFunctionKey;
const int KeyPress::pageUpKey       = NSPageUpFunctionKey;
const int KeyPress::pageDownKey     = NSPageDownFunctionKey;
const int KeyPress::endKey          = NSEndFunctionKey;
const int KeyPress::homeKey         = NSHomeFunctionKey;
const int KeyPress::deleteKey       = NSDeleteFunctionKey;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = NSF1FunctionKey;
const int KeyPress::F2Key           = NSF2FunctionKey;
const int KeyPress::F3Key           = NSF3FunctionKey;
const int KeyPress::F4Key           = NSF4FunctionKey;
const int KeyPress::F5Key           = NSF5FunctionKey;
const int KeyPress::F6Key           = NSF6FunctionKey;
const int KeyPress::F7Key           = NSF7FunctionKey;
const int KeyPress::F8Key           = NSF8FunctionKey;
const int KeyPress::F9Key           = NSF9FunctionKey;
const int KeyPress::F10Key          = NSF10FunctionKey;
const int KeyPress::F11Key          = NSF1FunctionKey;
const int KeyPress::F12Key          = NSF12FunctionKey;
const int KeyPress::F13Key          = NSF13FunctionKey;
const int KeyPress::F14Key          = NSF14FunctionKey;
const int KeyPress::F15Key          = NSF15FunctionKey;
const int KeyPress::F16Key          = NSF16FunctionKey;
const int KeyPress::numberPad0      = 0x30020;
const int KeyPress::numberPad1      = 0x30021;
const int KeyPress::numberPad2      = 0x30022;
const int KeyPress::numberPad3      = 0x30023;
const int KeyPress::numberPad4      = 0x30024;
const int KeyPress::numberPad5      = 0x30025;
const int KeyPress::numberPad6      = 0x30026;
const int KeyPress::numberPad7      = 0x30027;
const int KeyPress::numberPad8      = 0x30028;
const int KeyPress::numberPad9      = 0x30029;
const int KeyPress::numberPadAdd            = 0x3002a;
const int KeyPress::numberPadSubtract       = 0x3002b;
const int KeyPress::numberPadMultiply       = 0x3002c;
const int KeyPress::numberPadDivide         = 0x3002d;
const int KeyPress::numberPadSeparator      = 0x3002e;
const int KeyPress::numberPadDecimalPoint   = 0x3002f;
const int KeyPress::numberPadEquals         = 0x30030;
const int KeyPress::numberPadDelete         = 0x30031;
const int KeyPress::playKey         = 0x30000;
const int KeyPress::stopKey         = 0x30001;
const int KeyPress::fastForwardKey  = 0x30002;
const int KeyPress::rewindKey       = 0x30003;

/*** End of inlined file: juce_mac_NSViewComponentPeer.mm ***/



/*** Start of inlined file: juce_mac_Windowing.mm ***/
void LookAndFeel::playAlertSound()
{
	NSBeep();
}

class OSXMessageBox  : public AsyncUpdater
{
public:
	OSXMessageBox (AlertWindow::AlertIconType iconType_,
				   const String& title_, const String& message_,
				   NSString* button1_, NSString* button2_, NSString* button3_,
				   ModalComponentManager::Callback* callback_,
				   const bool runAsync)
		: iconType (iconType_), title (title_),
		  message (message_), callback (callback_),
		  button1 ([button1_ retain]),
		  button2 ([button2_ retain]),
		  button3 ([button3_ retain])
	{
		if (runAsync)
			triggerAsyncUpdate();
	}

	~OSXMessageBox()
	{
		[button1 release];
		[button2 release];
		[button3 release];
	}

	int getResult() const
	{
		JUCE_AUTORELEASEPOOL
		NSInteger r = getRawResult();
		return r == NSAlertDefaultReturn ? 1 : (r == NSAlertOtherReturn ? 2 : 0);
	}

	void handleAsyncUpdate()
	{
		const int result = getResult();

		if (callback != nullptr)
			callback->modalStateFinished (result);

		delete this;
	}

private:
	AlertWindow::AlertIconType iconType;
	String title, message;
	ModalComponentManager::Callback* callback;
	NSString* button1;
	NSString* button2;
	NSString* button3;

	NSInteger getRawResult() const
	{
		NSString* messageString = juceStringToNS (message);
		NSString* titleString = juceStringToNS (title);

		switch (iconType)
		{
			case AlertWindow::InfoIcon:     return NSRunInformationalAlertPanel (titleString, messageString, button1, button2, button3);
			case AlertWindow::WarningIcon:  return NSRunCriticalAlertPanel      (titleString, messageString, button1, button2, button3);
			default:                        return NSRunAlertPanel              (titleString, messageString, button1, button2, button3);
		}
	}
};

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	OSXMessageBox box (iconType, title, message, nsStringLiteral ("OK"), nil, nil, 0, false);
	(void) box.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	new OSXMessageBox (iconType, title, message, nsStringLiteral ("OK"), nil, nil, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<OSXMessageBox> mb (new OSXMessageBox (iconType, title, message,
														nsStringLiteral ("OK"),
														nsStringLiteral ("Cancel"),
														nil, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult() == 1;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<OSXMessageBox> mb (new OSXMessageBox (iconType, title, message,
														nsStringLiteral ("Yes"),
														nsStringLiteral ("Cancel"),
														nsStringLiteral ("No"),
														callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool /*canMoveFiles*/)
{
	if (files.size() == 0)
		return false;

	MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0);

	if (draggingSource == nullptr)
	{
		jassertfalse;  // This method must be called in response to a component's mouseDown or mouseDrag event!
		return false;
	}

	Component* sourceComp = draggingSource->getComponentUnderMouse();

	if (sourceComp == nullptr)
	{
		jassertfalse;  // This method must be called in response to a component's mouseDown or mouseDrag event!
		return false;
	}

	JUCE_AUTORELEASEPOOL

	NSView* view = (NSView*) sourceComp->getWindowHandle();

	if (view == nil)
		return false;

	NSPasteboard* pboard = [NSPasteboard pasteboardWithName: NSDragPboard];
	[pboard declareTypes: [NSArray arrayWithObject: NSFilenamesPboardType]
				   owner: nil];

	NSMutableArray* filesArray = [NSMutableArray arrayWithCapacity: 4];
	for (int i = 0; i < files.size(); ++i)
		[filesArray addObject: juceStringToNS (files[i])];

	[pboard setPropertyList: filesArray
					forType: NSFilenamesPboardType];

	NSPoint dragPosition = [view convertPoint: [[[view window] currentEvent] locationInWindow]
									 fromView: nil];
	dragPosition.x -= 16;
	dragPosition.y -= 16;

	[view dragImage: [[NSWorkspace sharedWorkspace] iconForFile: juceStringToNS (files[0])]
				 at: dragPosition
			 offset: NSMakeSize (0, 0)
			  event: [[view window] currentEvent]
		 pasteboard: pboard
			 source: view
		  slideBack: YES];

	return true;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& /*text*/)
{
	jassertfalse;    // not implemented!
	return false;
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	JUCE_AUTORELEASEPOOL
	const NSPoint p ([NSEvent mouseLocation]);
	return Point<int> (roundToInt (p.x), roundToInt ([[[NSScreen screens] objectAtIndex: 0] frame].size.height - p.y));
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	// this rubbish needs to be done around the warp call, to avoid causing a
	// bizarre glitch..
	CGAssociateMouseAndMouseCursorPosition (false);
	CGWarpMouseCursorPosition (CGPointMake (newPosition.getX(), newPosition.getY()));
	CGAssociateMouseAndMouseCursorPosition (true);
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

#ifndef __POWER__  // Some versions of the SDK omit this function..
 extern "C"  { extern OSErr UpdateSystemActivity (UInt8); }
#endif

class ScreenSaverDefeater   : public Timer
{
public:
	ScreenSaverDefeater()
	{
		startTimer (10000);
		timerCallback();
	}

	void timerCallback()
	{
		if (Process::isForegroundProcess())
			UpdateSystemActivity (1 /*UsrActivity*/);
	}
};

static ScopedPointer<ScreenSaverDefeater> screenSaverDefeater;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (isEnabled)
		screenSaverDefeater = nullptr;
	else if (screenSaverDefeater == nullptr)
		screenSaverDefeater = new ScreenSaverDefeater();
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverDefeater == nullptr;
}

class DisplaySettingsChangeCallback  : public DeletedAtShutdown
{
public:
	DisplaySettingsChangeCallback()
	{
		CGDisplayRegisterReconfigurationCallback (displayReconfigurationCallBack, 0);
	}

	~DisplaySettingsChangeCallback()
	{
		CGDisplayRemoveReconfigurationCallback (displayReconfigurationCallBack, 0);
		clearSingletonInstance();
	}

	static void displayReconfigurationCallBack (CGDirectDisplayID, CGDisplayChangeSummaryFlags, void*)
	{
		const_cast <Desktop::Displays&> (Desktop::getInstance().getDisplays()).refresh();
	}

	juce_DeclareSingleton_SingleThreaded_Minimal (DisplaySettingsChangeCallback);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DisplaySettingsChangeCallback);
};

juce_ImplementSingleton_SingleThreaded (DisplaySettingsChangeCallback);

static Rectangle<int> convertDisplayRect (NSRect r, CGFloat mainScreenBottom)
{
	r.origin.y = mainScreenBottom - (r.origin.y + r.size.height);
	return convertToRectInt (r);
}

void Desktop::Displays::findDisplays()
{
	JUCE_AUTORELEASEPOOL

	DisplaySettingsChangeCallback::getInstance();

	NSArray* screens = [NSScreen screens];
	const CGFloat mainScreenBottom = [[screens objectAtIndex: 0] frame].size.height;

	for (unsigned int i = 0; i < [screens count]; ++i)
	{
		NSScreen* s = (NSScreen*) [screens objectAtIndex: i];

		Display d;
		d.userArea  = convertDisplayRect ([s visibleFrame], mainScreenBottom);
		d.totalArea = convertDisplayRect ([s frame], mainScreenBottom);
		d.isMain = (i == 0);

	   #if defined (MAC_OS_X_VERSION_10_7) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
		if ([s respondsToSelector: @selector (backingScaleFactor)])
			d.scale = s.backingScaleFactor;
		else
	   #endif
			d.scale = 1.0;

		displays.add (d);
	}
}

Image juce_createIconForFile (const File& file)
{
	JUCE_AUTORELEASEPOOL

	NSImage* image = [[NSWorkspace sharedWorkspace] iconForFile: juceStringToNS (file.getFullPathName())];

	Image result (Image::ARGB, (int) [image size].width, (int) [image size].height, true);

	[NSGraphicsContext saveGraphicsState];
	[NSGraphicsContext setCurrentContext: [NSGraphicsContext graphicsContextWithGraphicsPort: juce_getImageContext (result) flipped: false]];

	[image drawAtPoint: NSMakePoint (0, 0)
			  fromRect: NSMakeRect (0, 0, [image size].width, [image size].height)
			 operation: NSCompositeSourceOver fraction: 1.0f];

	[[NSGraphicsContext currentContext] flushGraphics];
	[NSGraphicsContext restoreGraphicsState];

	return result;
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	NSPasteboard* pb = [NSPasteboard generalPasteboard];

	[pb declareTypes: [NSArray arrayWithObject: NSStringPboardType]
			   owner: nil];

	[pb setString: juceStringToNS (text)
		  forType: NSStringPboardType];
}

String SystemClipboard::getTextFromClipboard()
{
	NSString* text = [[NSPasteboard generalPasteboard] stringForType: NSStringPboardType];

	return text == nil ? String::empty
					   : nsStringToJuce (text);
}

/*** End of inlined file: juce_mac_Windowing.mm ***/


/*** Start of inlined file: juce_mac_MainMenu.mm ***/
class JuceMainMenuHandler;

} // (juce namespace)

using namespace juce;

#define JuceMenuCallback MakeObjCClassName(JuceMenuCallback)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceMenuCallback  : NSObject <NSMenuDelegate>
#else
@interface JuceMenuCallback  : NSObject
#endif
{
	JuceMainMenuHandler* owner;
}

- (JuceMenuCallback*) initWithOwner: (JuceMainMenuHandler*) owner_;
- (void) dealloc;
- (void) menuItemInvoked: (id) menu;
- (void) menuNeedsUpdate: (NSMenu*) menu;
@end

namespace juce
{

class JuceMainMenuHandler   : private MenuBarModel::Listener,
							  private DeletedAtShutdown
{
public:

	JuceMainMenuHandler()
		: currentModel (nullptr),
		  lastUpdateTime (0)
	{
		callback = [[JuceMenuCallback alloc] initWithOwner: this];
	}

	~JuceMainMenuHandler()
	{
		setMenu (nullptr);

		jassert (instance == this);
		instance = nullptr;

		[callback release];
	}

	void setMenu (MenuBarModel* const newMenuBarModel)
	{
		if (currentModel != newMenuBarModel)
		{
			if (currentModel != nullptr)
				currentModel->removeListener (this);

			currentModel = newMenuBarModel;

			if (currentModel != nullptr)
				currentModel->addListener (this);

			menuBarItemsChanged (nullptr);
		}
	}

	void addSubMenu (NSMenu* parent, const PopupMenu& child,
					 const String& name, const int menuId, const int tag)
	{
		NSMenuItem* item = [parent addItemWithTitle: juceStringToNS (name)
											 action: nil
									  keyEquivalent: nsEmptyString()];
		[item setTag: tag];

		NSMenu* sub = createMenu (child, name, menuId, tag);

		[parent setSubmenu: sub forItem: item];
		[sub setAutoenablesItems: false];
		[sub release];
	}

	void updateSubMenu (NSMenuItem* parentItem, const PopupMenu& menuToCopy,
						const String& name, const int menuId, const int tag)
	{
	   #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
		static bool is10_4 = (SystemStats::getOSXMinorVersionNumber() <= 4);

		if (is10_4)
		{
			[parentItem setTag: tag];
			NSMenu* menu = [parentItem submenu];

			[menu setTitle: juceStringToNS (name)];

			while ([menu numberOfItems] > 0)
				[menu removeItemAtIndex: 0];

			PopupMenu::MenuItemIterator iter (menuToCopy);

			while (iter.next())
				addMenuItem (iter, menu, menuId, tag);

			[menu setAutoenablesItems: false];
			[menu update];
			return;
		}
	   #endif

		// Note: This method used to update the contents of the existing menu in-place, but that caused
		// weird side-effects which messed-up keyboard focus when switching between windows. By creating
		// a new menu and replacing the old one with it, that problem seems to be avoided..
		NSMenu* menu = [[NSMenu alloc] initWithTitle: juceStringToNS (name)];

		PopupMenu::MenuItemIterator iter (menuToCopy);
		while (iter.next())
			addMenuItem (iter, menu, menuId, tag);

		[menu setAutoenablesItems: false];
		[menu update];
		[parentItem setTag: tag];
		[parentItem setSubmenu: menu];
		[menu release];
	}

	void menuBarItemsChanged (MenuBarModel*)
	{
		lastUpdateTime = Time::getMillisecondCounter();

		StringArray menuNames;
		if (currentModel != nullptr)
			menuNames = currentModel->getMenuBarNames();

		NSMenu* menuBar = [NSApp mainMenu];
		while ([menuBar numberOfItems] > 1 + menuNames.size())
			[menuBar removeItemAtIndex: [menuBar numberOfItems] - 1];

		int menuId = 1;

		for (int i = 0; i < menuNames.size(); ++i)
		{
			const PopupMenu menu (currentModel->getMenuForIndex (i, menuNames [i]));

			if (i >= [menuBar numberOfItems] - 1)
				addSubMenu (menuBar, menu, menuNames[i], menuId, i);
			else
				updateSubMenu ([menuBar itemAtIndex: 1 + i], menu, menuNames[i], menuId, i);
		}
	}

	void menuCommandInvoked (MenuBarModel*, const ApplicationCommandTarget::InvocationInfo& info)
	{
		NSMenuItem* item = findMenuItem ([NSApp mainMenu], info);

		if (item != nil)
			flashMenuBar ([item menu]);
	}

	void updateMenus (NSMenu* menu)
	{
		if (PopupMenu::dismissAllActiveMenus())
		{
			// If we were running a juce menu, then we should let that modal loop finish before allowing
			// the OS menus to start their own modal loop - so cancel the menu that was being opened..
			if ([menu respondsToSelector: @selector (cancelTracking)])
				[menu performSelector: @selector (cancelTracking)];
		}

		if (Time::getMillisecondCounter() > lastUpdateTime + 100)
			(new AsyncMenuUpdater())->post();
	}

	void invoke (const int commandId, ApplicationCommandManager* const commandManager, const int topLevelIndex) const
	{
		if (currentModel != nullptr)
		{
			if (commandManager != nullptr)
			{
				ApplicationCommandTarget::InvocationInfo info (commandId);
				info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromMenu;

				commandManager->invoke (info, true);
			}

			(new AsyncCommandInvoker (commandId, topLevelIndex))->post();
		}
	}

	void invokeDirectly (const int commandId, const int topLevelIndex)
	{
		if (currentModel != nullptr)
			currentModel->menuItemSelected (commandId, topLevelIndex);
	}

	void addMenuItem (PopupMenu::MenuItemIterator& iter, NSMenu* menuToAddTo,
					  const int topLevelMenuId, const int topLevelIndex)
	{
		NSString* text = juceStringToNS (iter.itemName.upToFirstOccurrenceOf ("<end>", false, true));

		if (text == nil)
			text = nsEmptyString();

		if (iter.isSeparator)
		{
			[menuToAddTo addItem: [NSMenuItem separatorItem]];
		}
		else if (iter.isSectionHeader)
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: nil
											   keyEquivalent: nsEmptyString()];

			[item setEnabled: false];
		}
		else if (iter.subMenu != nullptr)
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: nil
											   keyEquivalent: nsEmptyString()];

			[item setTag: iter.itemId];
			[item setEnabled: iter.isEnabled];

			NSMenu* sub = createMenu (*iter.subMenu, iter.itemName, topLevelMenuId, topLevelIndex);
			[sub setDelegate: nil];
			[menuToAddTo setSubmenu: sub forItem: item];
			[sub release];
		}
		else
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: @selector (menuItemInvoked:)
											   keyEquivalent: nsEmptyString()];

			[item setTag: iter.itemId];
			[item setEnabled: iter.isEnabled];
			[item setState: iter.isTicked ? NSOnState : NSOffState];
			[item setTarget: (id) callback];

			NSMutableArray* info = [NSMutableArray arrayWithObject: [NSNumber numberWithUnsignedLongLong: (pointer_sized_int) (void*) iter.commandManager]];
			[info addObject: [NSNumber numberWithInt: topLevelIndex]];
			[item setRepresentedObject: info];

			if (iter.commandManager != nullptr)
			{
				const Array <KeyPress> keyPresses (iter.commandManager->getKeyMappings()
												   ->getKeyPressesAssignedToCommand (iter.itemId));

				if (keyPresses.size() > 0)
				{
					const KeyPress& kp = keyPresses.getReference(0);

					if (kp.getKeyCode() != KeyPress::backspaceKey   // (adding these is annoying because it flashes the menu bar
						 && kp.getKeyCode() != KeyPress::deleteKey) // every time you press the key while editing text)
					{
						juce_wchar key = kp.getTextCharacter();
						if (key == 0)
							key = (juce_wchar) kp.getKeyCode();

						[item setKeyEquivalent: juceStringToNS (String::charToString (key).toLowerCase())];
						[item setKeyEquivalentModifierMask: juceModsToNSMods (kp.getModifiers())];
					}
				}
			}
		}
	}

	static JuceMainMenuHandler* instance;

	MenuBarModel* currentModel;
	uint32 lastUpdateTime;
	JuceMenuCallback* callback;

private:

	NSMenu* createMenu (const PopupMenu menu,
						const String& menuName,
						const int topLevelMenuId,
						const int topLevelIndex)
	{
		NSMenu* m = [[NSMenu alloc] initWithTitle: juceStringToNS (menuName)];

		[m setAutoenablesItems: false];
		[m setDelegate: callback];

		PopupMenu::MenuItemIterator iter (menu);

		while (iter.next())
			addMenuItem (iter, m, topLevelMenuId, topLevelIndex);

		[m update];
		return m;
	}

	static NSMenuItem* findMenuItem (NSMenu* const menu, const ApplicationCommandTarget::InvocationInfo& info)
	{
		for (NSInteger i = [menu numberOfItems]; --i >= 0;)
		{
			NSMenuItem* m = [menu itemAtIndex: i];
			if ([m tag] == info.commandID)
				return m;

			if ([m submenu] != nil)
			{
				NSMenuItem* found = findMenuItem ([m submenu], info);
				if (found != nil)
					return found;
			}
		}

		return nil;
	}

	static void flashMenuBar (NSMenu* menu)
	{
		if ([[menu title] isEqualToString: nsStringLiteral ("Apple")])
			return;

		[menu retain];

		const unichar f35Key = NSF35FunctionKey;
		NSString* f35String = [NSString stringWithCharacters: &f35Key length: 1];

		NSMenuItem* item = [[NSMenuItem alloc] initWithTitle: nsStringLiteral ("x")
													  action: nil
											   keyEquivalent: f35String];
		[item setTarget: nil];
		[menu insertItem: item atIndex: [menu numberOfItems]];
		[item release];

		if ([menu indexOfItem: item] >= 0)
		{
			NSEvent* f35Event = [NSEvent keyEventWithType: NSKeyDown
												 location: NSZeroPoint
											modifierFlags: NSCommandKeyMask
												timestamp: 0
											 windowNumber: 0
												  context: [NSGraphicsContext currentContext]
											   characters: f35String
							  charactersIgnoringModifiers: f35String
												isARepeat: NO
												  keyCode: 0];

			[menu performKeyEquivalent: f35Event];

			if ([menu indexOfItem: item] >= 0)
				[menu removeItem: item]; // (this throws if the item isn't actually in the menu)
		}

		[menu release];
	}

	static unsigned int juceModsToNSMods (const ModifierKeys& mods)
	{
		unsigned int m = 0;
		if (mods.isShiftDown())    m |= NSShiftKeyMask;
		if (mods.isCtrlDown())     m |= NSControlKeyMask;
		if (mods.isAltDown())      m |= NSAlternateKeyMask;
		if (mods.isCommandDown())  m |= NSCommandKeyMask;
		return m;
	}

	class AsyncMenuUpdater  : public CallbackMessage
	{
	public:
		AsyncMenuUpdater() {}

		void messageCallback()
		{
			if (JuceMainMenuHandler::instance != nullptr)
				JuceMainMenuHandler::instance->menuBarItemsChanged (nullptr);
		}

	private:
		JUCE_DECLARE_NON_COPYABLE (AsyncMenuUpdater);
	};

	class AsyncCommandInvoker  : public CallbackMessage
	{
	public:
		AsyncCommandInvoker (const int commandId_, const int topLevelIndex_)
			: commandId (commandId_), topLevelIndex (topLevelIndex_)
		{}

		void messageCallback()
		{
			if (JuceMainMenuHandler::instance != nullptr)
				JuceMainMenuHandler::instance->invokeDirectly (commandId, topLevelIndex);
		}

	private:
		const int commandId, topLevelIndex;

		JUCE_DECLARE_NON_COPYABLE (AsyncCommandInvoker);
	};
};

JuceMainMenuHandler* JuceMainMenuHandler::instance = nullptr;

} // (juce namespace)

@implementation JuceMenuCallback

- (JuceMenuCallback*) initWithOwner: (JuceMainMenuHandler*) owner_
{
	[super init];
	owner = owner_;
	return self;
}

- (void) dealloc
{
	[super dealloc];
}

- (void) menuItemInvoked: (id) menu
{
	NSMenuItem* item = (NSMenuItem*) menu;

	if ([[item representedObject] isKindOfClass: [NSArray class]])
	{
		// If the menu is being triggered by a keypress, the OS will have picked it up before we had a chance to offer it to
		// our own components, which may have wanted to intercept it. So, rather than dispatching directly, we'll feed it back
		// into the focused component and let it trigger the menu item indirectly.
		NSEvent* e = [NSApp currentEvent];
		if ([e type] == NSKeyDown || [e type] == NSKeyUp)
		{
			if (juce::Component::getCurrentlyFocusedComponent() != nullptr)
			{
				juce::NSViewComponentPeer* peer = dynamic_cast <juce::NSViewComponentPeer*> (juce::Component::getCurrentlyFocusedComponent()->getPeer());

				if (peer != nullptr)
				{
					if ([e type] == NSKeyDown)
						peer->redirectKeyDown (e);
					else
						peer->redirectKeyUp (e);

					return;
				}
			}
		}

		NSArray* info = (NSArray*) [item representedObject];

		owner->invoke ((int) [item tag],
					   (ApplicationCommandManager*) (pointer_sized_int)
							[((NSNumber*) [info objectAtIndex: 0]) unsignedLongLongValue],
					   (int) [((NSNumber*) [info objectAtIndex: 1]) intValue]);
	}
}

- (void) menuNeedsUpdate: (NSMenu*) menu;
{
	if (JuceMainMenuHandler::instance != nullptr)
		JuceMainMenuHandler::instance->updateMenus (menu);
}

@end

namespace juce
{

namespace MainMenuHelpers
{
	static NSMenu* createStandardAppMenu (NSMenu* menu, const String& appName, const PopupMenu* extraItems)
	{
		if (extraItems != nullptr && JuceMainMenuHandler::instance != nullptr && extraItems->getNumItems() > 0)
		{
			PopupMenu::MenuItemIterator iter (*extraItems);

			while (iter.next())
				JuceMainMenuHandler::instance->addMenuItem (iter, menu, 0, -1);

			[menu addItem: [NSMenuItem separatorItem]];
		}

		NSMenuItem* item;

		// Services...
		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Services"), nil)
										  action: nil  keyEquivalent: nsEmptyString()];
		[menu addItem: item];
		[item release];
		NSMenu* servicesMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Services")];
		[menu setSubmenu: servicesMenu forItem: item];
		[NSApp setServicesMenu: servicesMenu];
		[servicesMenu release];
		[menu addItem: [NSMenuItem separatorItem]];

		// Hide + Show stuff...
		item = [[NSMenuItem alloc] initWithTitle: juceStringToNS ("Hide " + appName)
										  action: @selector (hide:)  keyEquivalent: nsStringLiteral ("h")];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Hide Others"), nil)
										  action: @selector (hideOtherApplications:)  keyEquivalent: nsStringLiteral ("h")];
		[item setKeyEquivalentModifierMask: NSCommandKeyMask | NSAlternateKeyMask];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Show All"), nil)
										  action: @selector (unhideAllApplications:)  keyEquivalent: nsEmptyString()];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		[menu addItem: [NSMenuItem separatorItem]];

		// Quit item....
		item = [[NSMenuItem alloc] initWithTitle: juceStringToNS ("Quit " + appName)
										  action: @selector (terminate:)  keyEquivalent: nsStringLiteral ("q")];

		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		return menu;
	}

	// Since our app has no NIB, this initialises a standard app menu...
	static void rebuildMainMenu (const PopupMenu* extraItems)
	{
		// this can't be used in a plugin!
		jassert (JUCEApplication::isStandaloneApp());

		if (JUCEApplication::getInstance() != nullptr)
		{
			JUCE_AUTORELEASEPOOL

			NSMenu* mainMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("MainMenu")];
			NSMenuItem* item = [mainMenu addItemWithTitle: nsStringLiteral ("Apple") action: nil keyEquivalent: nsEmptyString()];

			NSMenu* appMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Apple")];

			[NSApp performSelector: @selector (setAppleMenu:) withObject: appMenu];
			[mainMenu setSubmenu: appMenu forItem: item];

			[NSApp setMainMenu: mainMenu];
			MainMenuHelpers::createStandardAppMenu (appMenu, JUCEApplication::getInstance()->getApplicationName(), extraItems);

			[appMenu release];
			[mainMenu release];
		}
	}
}

void MenuBarModel::setMacMainMenu (MenuBarModel* newMenuBarModel,
								   const PopupMenu* extraAppleMenuItems)
{
	if (getMacMainMenu() != newMenuBarModel)
	{
		JUCE_AUTORELEASEPOOL

		if (newMenuBarModel == nullptr)
		{
			delete JuceMainMenuHandler::instance;
			jassert (JuceMainMenuHandler::instance == nullptr); // should be zeroed in the destructor
			jassert (extraAppleMenuItems == nullptr); // you can't specify some extra items without also supplying a model

			extraAppleMenuItems = nullptr;
		}
		else
		{
			if (JuceMainMenuHandler::instance == nullptr)
				JuceMainMenuHandler::instance = new JuceMainMenuHandler();

			JuceMainMenuHandler::instance->setMenu (newMenuBarModel);
		}
	}

	MainMenuHelpers::rebuildMainMenu (extraAppleMenuItems);

	if (newMenuBarModel != nullptr)
		newMenuBarModel->menuItemsChanged();
}

MenuBarModel* MenuBarModel::getMacMainMenu()
{
	return JuceMainMenuHandler::instance != nullptr
			 ? JuceMainMenuHandler::instance->currentModel : nullptr;
}

void juce_initialiseMacMainMenu()
{
	if (JuceMainMenuHandler::instance == nullptr)
		MainMenuHelpers::rebuildMainMenu (nullptr);
}

/*** End of inlined file: juce_mac_MainMenu.mm ***/

 #endif


/*** Start of inlined file: juce_mac_MouseCursor.mm ***/
#if JUCE_MAC

namespace MouseCursorHelpers
{
	static NSImage* createNSImage (const Image& image)
	{
		JUCE_AUTORELEASEPOOL

		NSImage* im = [[NSImage alloc] init];
		[im setSize: NSMakeSize (image.getWidth(), image.getHeight())];
		[im lockFocus];

		CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();
		CGImageRef imageRef = juce_createCoreGraphicsImage (image, false, colourSpace, false);
		CGColorSpaceRelease (colourSpace);

		CGContextRef cg = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];
		CGContextDrawImage (cg, CGRectMake (0, 0, image.getWidth(), image.getHeight()), imageRef);

		CGImageRelease (imageRef);
		[im unlockFocus];

		return im;
	}

	static void* createFromImage (const Image& image, float hotspotX, float hotspotY)
	{
		NSImage* im = createNSImage (image);
		NSCursor* c = [[NSCursor alloc] initWithImage: im
											  hotSpot: NSMakePoint (hotspotX, hotspotY)];
		[im release];
		return c;
	}

	static void* fromWebKitFile (const char* filename, float hx, float hy)
	{
		FileInputStream fileStream (String ("/System/Library/Frameworks/WebKit.framework/Frameworks/WebCore.framework/Resources/") + filename);
		BufferedInputStream buf (fileStream, 4096);

		PNGImageFormat pngFormat;
		Image im (pngFormat.decodeImage (buf));

		if (im.isValid())
			return createFromImage (im, hx * im.getWidth(), hy * im.getHeight());

		jassertfalse;
		return nullptr;
	}
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	return MouseCursorHelpers::createFromImage (image, (float) hotspotX, (float) hotspotY);
}

void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
{
	JUCE_AUTORELEASEPOOL
	NSCursor* c = nil;

	switch (type)
	{
		case NormalCursor:          c = [NSCursor arrowCursor]; break;
		case NoCursor:              return createMouseCursorFromImage (Image (Image::ARGB, 8, 8, true), 0, 0);
		case DraggingHandCursor:    c = [NSCursor openHandCursor]; break;
		case WaitCursor:            c = [NSCursor arrowCursor]; break; // avoid this on the mac, let the OS provide the beachball
		case IBeamCursor:           c = [NSCursor IBeamCursor]; break;
		case PointingHandCursor:    c = [NSCursor pointingHandCursor]; break;
		case LeftRightResizeCursor: c = [NSCursor resizeLeftRightCursor]; break;
		case LeftEdgeResizeCursor:  c = [NSCursor resizeLeftCursor]; break;
		case RightEdgeResizeCursor: c = [NSCursor resizeRightCursor]; break;
		case CrosshairCursor:       c = [NSCursor crosshairCursor]; break;
		case CopyingCursor:         return MouseCursorHelpers::fromWebKitFile ("copyCursor.png", 0, 0);

		case UpDownResizeCursor:
		case TopEdgeResizeCursor:
		case BottomEdgeResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northSouthResizeCursor.png", 0.5f, 0.5f);

		case TopLeftCornerResizeCursor:
		case BottomRightCornerResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northWestSouthEastResizeCursor.png", 0.5f, 0.5f);

		case TopRightCornerResizeCursor:
		case BottomLeftCornerResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northEastSouthWestResizeCursor.png", 0.5f, 0.5f);

		case UpDownLeftRightResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("moveCursor.png", 0.5f, 0.5f);

		default:
			jassertfalse;
			break;
	}

	[c retain];
	return c;
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool /*isStandard*/)
{
	[((NSCursor*) cursorHandle) release];
}

void MouseCursor::showInAllWindows() const
{
	showInWindow (nullptr);
}

void MouseCursor::showInWindow (ComponentPeer*) const
{
	NSCursor* c = (NSCursor*) getHandle();

	if (c == nil)
		c = [NSCursor arrowCursor];

	[c set];
}

#else

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)  { return nullptr; }
void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)             { return nullptr; }
void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool isStandard)           {}
void MouseCursor::showInAllWindows() const                                                      {}
void MouseCursor::showInWindow (ComponentPeer*) const                                           {}

#endif

/*** End of inlined file: juce_mac_MouseCursor.mm ***/


/*** Start of inlined file: juce_mac_FileChooser.mm ***/
#if JUCE_MAC

} // (juce namespace)

using namespace juce;

#define JuceFileChooserDelegate MakeObjCClassName(JuceFileChooserDelegate)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceFileChooserDelegate   : NSObject <NSOpenSavePanelDelegate>
#else
@interface JuceFileChooserDelegate   : NSObject
#endif
{
	StringArray* filters;
}

- (JuceFileChooserDelegate*) initWithFilters: (StringArray*) filters_;
- (void) dealloc;
- (BOOL) panel: (id) sender shouldShowFilename: (NSString*) filename;

@end

@implementation JuceFileChooserDelegate
- (JuceFileChooserDelegate*) initWithFilters: (StringArray*) filters_
{
	[super init];
	filters = filters_;
	return self;
}

- (void) dealloc
{
	delete filters;
	[super dealloc];
}

- (BOOL) panel: (id) sender shouldShowFilename: (NSString*) filename
{
	(void) sender;
	const File f (nsStringToJuce (filename));

	for (int i = filters->size(); --i >= 0;)
		if (f.getFileName().matchesWildcard ((*filters)[i], true))
			return true;

   #if (! defined (MAC_OS_X_VERSION_10_7)) || MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_7
	NSError* error;
	NSString* name = [[NSWorkspace sharedWorkspace] typeOfFile: filename error: &error];

	if ([name isEqualToString: nsStringLiteral ("com.apple.alias-file")])
	{
		FSRef ref;
		FSPathMakeRef ((const UInt8*) [filename fileSystemRepresentation], &ref, nullptr);

		Boolean targetIsFolder = false, wasAliased = false;
		FSResolveAliasFileWithMountFlags (&ref, true, &targetIsFolder, &wasAliased, 0);

		return wasAliased && targetIsFolder;
	}
   #endif

	return f.isDirectory()
			&& ! [[NSWorkspace sharedWorkspace] isFilePackageAtPath: filename];
}
@end

namespace juce
{

bool FileChooser::isPlatformDialogAvailable()
{
	return true;
}

class TemporaryMainMenuWithStandardCommands
{
public:
	TemporaryMainMenuWithStandardCommands()
		: oldMenu (MenuBarModel::getMacMainMenu())
	{
		MenuBarModel::setMacMainMenu (nullptr);

		NSMenu* menu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Edit")];
		NSMenuItem* item;

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Cut"), nil)
										  action: @selector (cut:)  keyEquivalent: nsStringLiteral ("x")];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Copy"), nil)
										  action: @selector (copy:)  keyEquivalent: nsStringLiteral ("c")];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Paste"), nil)
										  action: @selector (paste:)  keyEquivalent: nsStringLiteral ("v")];
		[menu addItem: item];
		[item release];

		item = [[NSApp mainMenu] addItemWithTitle: NSLocalizedString (nsStringLiteral ("Edit"), nil)
										   action: nil keyEquivalent: nsEmptyString()];
		[[NSApp mainMenu] setSubmenu: menu forItem: item];
		[menu release];
	}

	~TemporaryMainMenuWithStandardCommands()
	{
		MenuBarModel::setMacMainMenu (oldMenu);
	}

private:
	MenuBarModel* oldMenu;
};

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool /*warnAboutOverwritingExistingFiles*/,
									  bool selectMultipleFiles,
									  FilePreviewComponent* /*extraInfoComponent*/)
{
	JUCE_AUTORELEASEPOOL

	const TemporaryMainMenuWithStandardCommands tempMenu;

	StringArray* filters = new StringArray();
	filters->addTokens (filter.replaceCharacters (",:", ";;"), ";", String::empty);
	filters->trim();
	filters->removeEmptyStrings();

	JuceFileChooserDelegate* delegate = [[JuceFileChooserDelegate alloc] initWithFilters: filters];
	[delegate autorelease];

	NSSavePanel* panel = isSaveDialogue ? [NSSavePanel savePanel]
										: [NSOpenPanel openPanel];

	[panel setTitle: juceStringToNS (title)];

	if (! isSaveDialogue)
	{
		NSOpenPanel* openPanel = (NSOpenPanel*) panel;
		[openPanel setCanChooseDirectories: selectsDirectory];
		[openPanel setCanChooseFiles: selectsFiles];
		[openPanel setAllowsMultipleSelection: selectMultipleFiles];
		[openPanel setResolvesAliases: YES];
	}

	[panel setDelegate: delegate];

	if (isSaveDialogue || selectsDirectory)
		[panel setCanCreateDirectories: YES];

	String directory, filename;

	if (currentFileOrDirectory.isDirectory())
	{
		directory = currentFileOrDirectory.getFullPathName();
	}
	else
	{
		directory = currentFileOrDirectory.getParentDirectory().getFullPathName();
		filename = currentFileOrDirectory.getFileName();
	}

   #if defined (MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6)
	[panel setDirectoryURL: [NSURL fileURLWithPath: juceStringToNS (directory)]];
	[panel setNameFieldStringValue: juceStringToNS (filename)];

	if ([panel runModal] == NSOKButton)
   #else
	if ([panel runModalForDirectory: juceStringToNS (directory)
							   file: juceStringToNS (filename)] == NSOKButton)
   #endif
	{
		if (isSaveDialogue)
		{
			results.add (File (nsStringToJuce ([[panel URL] path])));
		}
		else
		{
			NSOpenPanel* openPanel = (NSOpenPanel*) panel;
			NSArray* urls = [openPanel URLs];

			for (unsigned int i = 0; i < [urls count]; ++i)
				results.add (File (nsStringToJuce ([[urls objectAtIndex: i] path])));
		}
	}

	[panel setDelegate: nil];
}

#else

bool FileChooser::isPlatformDialogAvailable()
{
	return false;
}

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* extraInfoComponent)
{
	JUCE_AUTORELEASEPOOL

	jassertfalse; //there's no such thing in iOS
}

#endif

/*** End of inlined file: juce_mac_FileChooser.mm ***/

#elif JUCE_WINDOWS

/*** Start of inlined file: juce_win32_ComSmartPtr.h ***/
#ifndef __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__
#define __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/** A simple COM smart pointer.
*/
template <class ComClass>
class ComSmartPtr
{
public:
	ComSmartPtr() throw() : p (0)                               {}
	ComSmartPtr (ComClass* const p_) : p (p_)                   { if (p_ != 0) p_->AddRef(); }
	ComSmartPtr (const ComSmartPtr<ComClass>& p_) : p (p_.p)    { if (p  != 0) p ->AddRef(); }
	~ComSmartPtr()                                              { release(); }

	operator ComClass*() const throw()     { return p; }
	ComClass& operator*() const throw()    { return *p; }
	ComClass* operator->() const throw()   { return p; }

	ComSmartPtr& operator= (ComClass* const newP)
	{
		if (newP != 0)  newP->AddRef();
		release();
		p = newP;
		return *this;
	}

	ComSmartPtr& operator= (const ComSmartPtr<ComClass>& newP)  { return operator= (newP.p); }

	// Releases and nullifies this pointer and returns its address
	ComClass** resetAndGetPointerAddress()
	{
		release();
		p = 0;
		return &p;
	}

	HRESULT CoCreateInstance (REFCLSID classUUID, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
	{
	   #if ! JUCE_MINGW
		return ::CoCreateInstance (classUUID, 0, dwClsContext, __uuidof (ComClass), (void**) resetAndGetPointerAddress());
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

	template <class OtherComClass>
	HRESULT QueryInterface (REFCLSID classUUID, ComSmartPtr<OtherComClass>& destObject) const
	{
		if (p == 0)
			return E_POINTER;

		return p->QueryInterface (classUUID, (void**) destObject.resetAndGetPointerAddress());
	}

	template <class OtherComClass>
	HRESULT QueryInterface (ComSmartPtr<OtherComClass>& destObject) const
	{
	   #if ! JUCE_MINGW
		return this->QueryInterface (__uuidof (OtherComClass), destObject);
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

private:
	ComClass* p;

	void release()  { if (p != 0) p->Release(); }

	ComClass** operator&() throw(); // private to avoid it being used accidentally
};

#define JUCE_COMRESULT  HRESULT __stdcall

template <class ComClass>
class ComBaseClassHelperBase   : public ComClass
{
public:
	ComBaseClassHelperBase()  : refCount (1) {}
	virtual ~ComBaseClassHelperBase() {}

	ULONG __stdcall AddRef()    { return ++refCount; }
	ULONG __stdcall Release()   { const ULONG r = --refCount; if (r == 0) delete this; return r; }

	void resetReferenceCount() noexcept     { refCount = 0; }

protected:
	ULONG refCount;
};

/** Handy base class for writing COM objects, providing ref-counting and a basic QueryInterface method.
*/
template <class ComClass>
class ComBaseClassHelper   : public ComBaseClassHelperBase <ComClass>
{
public:
	ComBaseClassHelper() {}
	~ComBaseClassHelper() {}

	JUCE_COMRESULT QueryInterface (REFIID refId, void** result)
	{
	   #if ! JUCE_MINGW
		if (refId == __uuidof (ComClass))   { AddRef(); *result = dynamic_cast <ComClass*> (this); return S_OK; }
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
	   #endif

		if (refId == IID_IUnknown)          { AddRef(); *result = dynamic_cast <IUnknown*> (this); return S_OK; }

		*result = 0;
		return E_NOINTERFACE;
	}
};

#endif   // __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/*** End of inlined file: juce_win32_ComSmartPtr.h ***/



/*** Start of inlined file: juce_win32_HiddenMessageWindow.h ***/
#ifndef __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__
#define __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__

class HiddenMessageWindow
{
public:
	HiddenMessageWindow (const TCHAR* const messageWindowName, WNDPROC wndProc)
	{
		String className ("JUCE_");
		className << String::toHexString (Time::getHighResolutionTicks());

		HMODULE moduleHandle = (HMODULE) Process::getCurrentModuleInstanceHandle();

		WNDCLASSEX wc = { 0 };
		wc.cbSize         = sizeof (wc);
		wc.lpfnWndProc    = wndProc;
		wc.cbWndExtra     = 4;
		wc.hInstance      = moduleHandle;
		wc.lpszClassName  = className.toWideCharPointer();

		atom = RegisterClassEx (&wc);
		jassert (atom != 0);

		hwnd = CreateWindow (getClassNameFromAtom(), messageWindowName,
							 0, 0, 0, 0, 0, 0, 0, moduleHandle, 0);
		jassert (hwnd != 0);
	}

	~HiddenMessageWindow()
	{
		DestroyWindow (hwnd);
		UnregisterClass (getClassNameFromAtom(), 0);
	}

	inline HWND getHWND() const noexcept     { return hwnd; }

private:
	ATOM atom;
	HWND hwnd;

	LPCTSTR getClassNameFromAtom() noexcept  { return (LPCTSTR) MAKELONG (atom, 0); }
};

class JuceWindowIdentifier
{
public:
	static bool isJUCEWindow (HWND hwnd) noexcept
	{
		return GetWindowLongPtr (hwnd, GWLP_USERDATA) == getImprobableWindowNumber();
	}

	static void setAsJUCEWindow (HWND hwnd, bool isJuceWindow) noexcept
	{
		SetWindowLongPtr (hwnd, GWLP_USERDATA, isJuceWindow ? getImprobableWindowNumber() : 0);
	}

private:
	static LONG_PTR getImprobableWindowNumber() noexcept
	{
		static LONG_PTR number = (LONG_PTR) Random::getSystemRandom().nextInt64();
		return number;
	}
};

class DeviceChangeDetector  : private Timer
{
public:
	DeviceChangeDetector (const wchar_t* const name)
		: messageWindow (name, (WNDPROC) deviceChangeEventCallback)
	{
		SetWindowLongPtr (messageWindow.getHWND(), GWLP_USERDATA, (LONG_PTR) this);
	}

	virtual ~DeviceChangeDetector() {}

protected:
	virtual void systemDeviceChanged() = 0;

private:
	HiddenMessageWindow messageWindow;

	static LRESULT CALLBACK deviceChangeEventCallback (HWND h, const UINT message,
													   const WPARAM wParam, const LPARAM lParam)
	{
		if (message == WM_DEVICECHANGE
			 && (wParam == 0x8000 /*DBT_DEVICEARRIVAL*/
				  || wParam == 0x8004 /*DBT_DEVICEREMOVECOMPLETE*/
				  || wParam == 0x0007 /*DBT_DEVNODES_CHANGED*/))
		{
			// We'll pause before sending a message, because on device removal, the OS hasn't always updated
			// its device lists correctly at this point. This also helps avoid repeated callbacks.
			((DeviceChangeDetector*) GetWindowLongPtr (h, GWLP_USERDATA))->startTimer (500);
		}

		return DefWindowProc (h, message, wParam, lParam);
	}

	void timerCallback()
	{
		systemDeviceChanged();
	}
};

#endif   // __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__

/*** End of inlined file: juce_win32_HiddenMessageWindow.h ***/


/*** Start of inlined file: juce_win32_Windowing.cpp ***/
#undef GetSystemMetrics // multimon overrides this for some reason and causes a mess..

// these are in the windows SDK, but need to be repeated here for GCC..
#ifndef GET_APPCOMMAND_LPARAM
 #define GET_APPCOMMAND_LPARAM(lParam)     ((short) (HIWORD (lParam) & ~FAPPCOMMAND_MASK))

 #define FAPPCOMMAND_MASK                  0xF000
 #define APPCOMMAND_MEDIA_NEXTTRACK        11
 #define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
 #define APPCOMMAND_MEDIA_STOP             13
 #define APPCOMMAND_MEDIA_PLAY_PAUSE       14
#endif

#ifndef WM_APPCOMMAND
 #define WM_APPCOMMAND                     0x0319
#endif

extern void juce_repeatLastProcessPriority();
extern void juce_CheckCurrentlyFocusedTopLevelWindow();  // in juce_TopLevelWindow.cpp
extern bool juce_IsRunningInWine();

typedef bool (*CheckEventBlockedByModalComps) (const MSG&);
extern CheckEventBlockedByModalComps isEventBlockedByModalComps;

static bool shouldDeactivateTitleBar = true;

void* getUser32Function (const char* functionName) // (NB: this function also used from other modules)
{
	HMODULE user32Mod = GetModuleHandleA ("user32.dll");
	jassert (user32Mod != 0);

	return static_cast <void*> (GetProcAddress (user32Mod, functionName));
}

typedef BOOL (WINAPI* UpdateLayeredWinFunc) (HWND, HDC, POINT*, SIZE*, HDC, POINT*, COLORREF, BLENDFUNCTION*, DWORD);
static UpdateLayeredWinFunc updateLayeredWindow = nullptr;

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	if (updateLayeredWindow == nullptr && ! juce_IsRunningInWine())
		updateLayeredWindow = (UpdateLayeredWinFunc) getUser32Function ("UpdateLayeredWindow");

	return updateLayeredWindow != 0;
}

#ifndef WM_TOUCH
 #define WM_TOUCH 0x0240
 #define TOUCH_COORD_TO_PIXEL(l)  ((l) / 100)
 #define TOUCHEVENTF_MOVE   0x0001
 #define TOUCHEVENTF_DOWN   0x0002
 #define TOUCHEVENTF_UP     0x0004
 DECLARE_HANDLE (HTOUCHINPUT);

 typedef struct tagTOUCHINPUT
 {
	LONG x;
	LONG y;
	HANDLE hSource;
	DWORD dwID;
	DWORD dwFlags;
	DWORD dwMask;
	DWORD dwTime;
	ULONG_PTR dwExtraInfo;
	DWORD cxContact;
	DWORD cyContact;
 } TOUCHINPUT, *PTOUCHINPUT;
#endif

typedef BOOL (WINAPI* RegisterTouchWindowFunc) (HWND, ULONG);
typedef BOOL (WINAPI* GetTouchInputInfoFunc) (HTOUCHINPUT, UINT, PTOUCHINPUT, int);
typedef BOOL (WINAPI* CloseTouchInputHandleFunc) (HTOUCHINPUT);

static RegisterTouchWindowFunc   registerTouchWindow = nullptr;
static GetTouchInputInfoFunc     getTouchInputInfo = nullptr;
static CloseTouchInputHandleFunc closeTouchInputHandle = nullptr;

static bool hasCheckedForMultiTouch = false;

static bool canUseMultiTouch()
{
	if (registerTouchWindow == nullptr && ! hasCheckedForMultiTouch)
	{
		hasCheckedForMultiTouch = true;

		registerTouchWindow   = (RegisterTouchWindowFunc)   getUser32Function ("RegisterTouchWindow");
		getTouchInputInfo     = (GetTouchInputInfoFunc)     getUser32Function ("GetTouchInputInfo");
		closeTouchInputHandle = (CloseTouchInputHandleFunc) getUser32Function ("CloseTouchInputHandle");
	}

	return registerTouchWindow != nullptr;
}

static inline Rectangle<int> rectangleFromRECT (const RECT& r) noexcept
{
	return Rectangle<int>::leftTopRightBottom ((int) r.left, (int) r.top, (int) r.right, (int) r.bottom);
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

int64 getMouseEventTime()
{
	static int64 eventTimeOffset = 0;
	static LONG lastMessageTime = 0;
	const LONG thisMessageTime = GetMessageTime();

	if (thisMessageTime < lastMessageTime || lastMessageTime == 0)
	{
		lastMessageTime = thisMessageTime;
		eventTimeOffset = Time::currentTimeMillis() - thisMessageTime;
	}

	return eventTimeOffset + thisMessageTime;
}

const int extendedKeyModifier               = 0x10000;

const int KeyPress::spaceKey                = VK_SPACE;
const int KeyPress::returnKey               = VK_RETURN;
const int KeyPress::escapeKey               = VK_ESCAPE;
const int KeyPress::backspaceKey            = VK_BACK;
const int KeyPress::deleteKey               = VK_DELETE         | extendedKeyModifier;
const int KeyPress::insertKey               = VK_INSERT         | extendedKeyModifier;
const int KeyPress::tabKey                  = VK_TAB;
const int KeyPress::leftKey                 = VK_LEFT           | extendedKeyModifier;
const int KeyPress::rightKey                = VK_RIGHT          | extendedKeyModifier;
const int KeyPress::upKey                   = VK_UP             | extendedKeyModifier;
const int KeyPress::downKey                 = VK_DOWN           | extendedKeyModifier;
const int KeyPress::homeKey                 = VK_HOME           | extendedKeyModifier;
const int KeyPress::endKey                  = VK_END            | extendedKeyModifier;
const int KeyPress::pageUpKey               = VK_PRIOR          | extendedKeyModifier;
const int KeyPress::pageDownKey             = VK_NEXT           | extendedKeyModifier;
const int KeyPress::F1Key                   = VK_F1             | extendedKeyModifier;
const int KeyPress::F2Key                   = VK_F2             | extendedKeyModifier;
const int KeyPress::F3Key                   = VK_F3             | extendedKeyModifier;
const int KeyPress::F4Key                   = VK_F4             | extendedKeyModifier;
const int KeyPress::F5Key                   = VK_F5             | extendedKeyModifier;
const int KeyPress::F6Key                   = VK_F6             | extendedKeyModifier;
const int KeyPress::F7Key                   = VK_F7             | extendedKeyModifier;
const int KeyPress::F8Key                   = VK_F8             | extendedKeyModifier;
const int KeyPress::F9Key                   = VK_F9             | extendedKeyModifier;
const int KeyPress::F10Key                  = VK_F10            | extendedKeyModifier;
const int KeyPress::F11Key                  = VK_F11            | extendedKeyModifier;
const int KeyPress::F12Key                  = VK_F12            | extendedKeyModifier;
const int KeyPress::F13Key                  = VK_F13            | extendedKeyModifier;
const int KeyPress::F14Key                  = VK_F14            | extendedKeyModifier;
const int KeyPress::F15Key                  = VK_F15            | extendedKeyModifier;
const int KeyPress::F16Key                  = VK_F16            | extendedKeyModifier;
const int KeyPress::numberPad0              = VK_NUMPAD0        | extendedKeyModifier;
const int KeyPress::numberPad1              = VK_NUMPAD1        | extendedKeyModifier;
const int KeyPress::numberPad2              = VK_NUMPAD2        | extendedKeyModifier;
const int KeyPress::numberPad3              = VK_NUMPAD3        | extendedKeyModifier;
const int KeyPress::numberPad4              = VK_NUMPAD4        | extendedKeyModifier;
const int KeyPress::numberPad5              = VK_NUMPAD5        | extendedKeyModifier;
const int KeyPress::numberPad6              = VK_NUMPAD6        | extendedKeyModifier;
const int KeyPress::numberPad7              = VK_NUMPAD7        | extendedKeyModifier;
const int KeyPress::numberPad8              = VK_NUMPAD8        | extendedKeyModifier;
const int KeyPress::numberPad9              = VK_NUMPAD9        | extendedKeyModifier;
const int KeyPress::numberPadAdd            = VK_ADD            | extendedKeyModifier;
const int KeyPress::numberPadSubtract       = VK_SUBTRACT       | extendedKeyModifier;
const int KeyPress::numberPadMultiply       = VK_MULTIPLY       | extendedKeyModifier;
const int KeyPress::numberPadDivide         = VK_DIVIDE         | extendedKeyModifier;
const int KeyPress::numberPadSeparator      = VK_SEPARATOR      | extendedKeyModifier;
const int KeyPress::numberPadDecimalPoint   = VK_DECIMAL        | extendedKeyModifier;
const int KeyPress::numberPadEquals         = 0x92 /*VK_OEM_NEC_EQUAL*/  | extendedKeyModifier;
const int KeyPress::numberPadDelete         = VK_DELETE         | extendedKeyModifier;
const int KeyPress::playKey                 = 0x30000;
const int KeyPress::stopKey                 = 0x30001;
const int KeyPress::fastForwardKey          = 0x30002;
const int KeyPress::rewindKey               = 0x30003;

class WindowsBitmapImage  : public ImagePixelData
{
public:
	WindowsBitmapImage (const Image::PixelFormat format,
						const int w, const int h, const bool clearImage)
		: ImagePixelData (format, w, h)
	{
		jassert (format == Image::RGB || format == Image::ARGB);

		pixelStride = (format == Image::RGB) ? 3 : 4;
		lineStride = -((w * pixelStride + 3) & ~3);

		zerostruct (bitmapInfo);
		bitmapInfo.bV4Size     = sizeof (BITMAPV4HEADER);
		bitmapInfo.bV4Width    = w;
		bitmapInfo.bV4Height   = h;
		bitmapInfo.bV4Planes   = 1;
		bitmapInfo.bV4CSType   = 1;
		bitmapInfo.bV4BitCount = (unsigned short) (pixelStride * 8);

		if (format == Image::ARGB)
		{
			bitmapInfo.bV4AlphaMask      = 0xff000000;
			bitmapInfo.bV4RedMask        = 0xff0000;
			bitmapInfo.bV4GreenMask      = 0xff00;
			bitmapInfo.bV4BlueMask       = 0xff;
			bitmapInfo.bV4V4Compression  = BI_BITFIELDS;
		}
		else
		{
			bitmapInfo.bV4V4Compression  = BI_RGB;
		}

		HDC dc = GetDC (0);
		hdc = CreateCompatibleDC (dc);
		ReleaseDC (0, dc);

		SetMapMode (hdc, MM_TEXT);

		hBitmap = CreateDIBSection (hdc, (BITMAPINFO*) &(bitmapInfo), DIB_RGB_COLORS,
									(void**) &bitmapData, 0, 0);

		previousBitmap = SelectObject (hdc, hBitmap);

		if (format == Image::ARGB && clearImage)
			zeromem (bitmapData, (size_t) std::abs (h * lineStride));

		imageData = bitmapData - (lineStride * (h - 1));
	}

	~WindowsBitmapImage()
	{
		SelectObject (hdc, previousBitmap); // Selecting the previous bitmap before deleting the DC avoids a warning in BoundsChecker
		DeleteDC (hdc);
		DeleteObject (hBitmap);
	}

	ImageType* createType() const                       { return new NativeImageType(); }

	LowLevelGraphicsContext* createLowLevelContext()
	{
		return new LowLevelGraphicsSoftwareRenderer (Image (this));
	}

	void initialiseBitmapData (Image::BitmapData& bitmap, int x, int y, Image::BitmapData::ReadWriteMode)
	{
		bitmap.data = imageData + x * pixelStride + y * lineStride;
		bitmap.pixelFormat = pixelFormat;
		bitmap.lineStride = lineStride;
		bitmap.pixelStride = pixelStride;
	}

	ImagePixelData* clone()
	{
		WindowsBitmapImage* im = new WindowsBitmapImage (pixelFormat, width, height, false);

		for (int i = 0; i < height; ++i)
			memcpy (im->imageData + i * lineStride, imageData + i * lineStride, (size_t) lineStride);

		return im;
	}

	void blitToWindow (HWND hwnd, HDC dc, const bool transparent,
					   const int x, const int y,
					   const RectangleList& maskedRegion,
					   const uint8 updateLayeredWindowAlpha) noexcept
	{
		SetMapMode (dc, MM_TEXT);

		if (transparent)
		{
			if (! maskedRegion.isEmpty())
			{
				for (RectangleList::Iterator i (maskedRegion); i.next();)
				{
					const Rectangle<int>& r = *i.getRectangle();
					ExcludeClipRect (hdc, r.getX(), r.getY(), r.getRight(), r.getBottom());
				}
			}

			RECT windowBounds;
			GetWindowRect (hwnd, &windowBounds);

			POINT p = { -x, -y };
			POINT pos = { windowBounds.left, windowBounds.top };
			SIZE size = { windowBounds.right - windowBounds.left,
						  windowBounds.bottom - windowBounds.top };

			BLENDFUNCTION bf;
			bf.AlphaFormat = 1 /*AC_SRC_ALPHA*/;
			bf.BlendFlags = 0;
			bf.BlendOp = AC_SRC_OVER;
			bf.SourceConstantAlpha = updateLayeredWindowAlpha;

			updateLayeredWindow (hwnd, 0, &pos, &size, hdc, &p, 0, &bf, 2 /*ULW_ALPHA*/);
		}
		else
		{
			int savedDC = 0;

			if (! maskedRegion.isEmpty())
			{
				savedDC = SaveDC (dc);

				for (RectangleList::Iterator i (maskedRegion); i.next();)
				{
					const Rectangle<int>& r = *i.getRectangle();
					ExcludeClipRect (dc, r.getX(), r.getY(), r.getRight(), r.getBottom());
				}
			}

			StretchDIBits (dc,
						   x, y, width, height,
						   0, 0, width, height,
						   bitmapData, (const BITMAPINFO*) &bitmapInfo,
						   DIB_RGB_COLORS, SRCCOPY);

			if (! maskedRegion.isEmpty())
				RestoreDC (dc, savedDC);
		}
	}

	HBITMAP hBitmap;
	HGDIOBJ previousBitmap;
	BITMAPV4HEADER bitmapInfo;
	HDC hdc;
	uint8* bitmapData;
	int pixelStride, lineStride;
	uint8* imageData;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WindowsBitmapImage);
};

namespace IconConverters
{
	Image createImageFromHBITMAP (HBITMAP bitmap)
	{
		Image im;

		if (bitmap != 0)
		{
			BITMAP bm;

			if (GetObject (bitmap, sizeof (BITMAP), &bm)
				 && bm.bmWidth > 0 && bm.bmHeight > 0)
			{
				HDC tempDC = GetDC (0);
				HDC dc = CreateCompatibleDC (tempDC);
				ReleaseDC (0, tempDC);

				SelectObject (dc, bitmap);

				im = Image (Image::ARGB, bm.bmWidth, bm.bmHeight, true);
				Image::BitmapData imageData (im, Image::BitmapData::writeOnly);

				for (int y = bm.bmHeight; --y >= 0;)
				{
					for (int x = bm.bmWidth; --x >= 0;)
					{
						COLORREF col = GetPixel (dc, x, y);

						imageData.setPixelColour (x, y, Colour ((uint8) GetRValue (col),
																(uint8) GetGValue (col),
																(uint8) GetBValue (col)));
					}
				}

				DeleteDC (dc);
			}
		}

		return im;
	}

	Image createImageFromHICON (HICON icon)
	{
		ICONINFO info;

		if (GetIconInfo (icon, &info))
		{
			Image mask  (createImageFromHBITMAP (info.hbmMask));
			Image image (createImageFromHBITMAP (info.hbmColor));

			if (mask.isValid() && image.isValid())
			{
				for (int y = image.getHeight(); --y >= 0;)
				{
					for (int x = image.getWidth(); --x >= 0;)
					{
						const float brightness = mask.getPixelAt (x, y).getBrightness();

						if (brightness > 0.0f)
							image.multiplyAlphaAt (x, y, 1.0f - brightness);
					}
				}

				return image;
			}
		}

		return Image::null;
	}

	HICON createHICONFromImage (const Image& image, const BOOL isIcon, int hotspotX, int hotspotY)
	{
		WindowsBitmapImage* nativeBitmap = new WindowsBitmapImage (Image::ARGB, image.getWidth(), image.getHeight(), true);
		Image bitmap (nativeBitmap);

		{
			Graphics g (bitmap);
			g.drawImageAt (image, 0, 0);
		}

		HBITMAP mask = CreateBitmap (image.getWidth(), image.getHeight(), 1, 1, 0);

		ICONINFO info;
		info.fIcon = isIcon;
		info.xHotspot = (DWORD) hotspotX;
		info.yHotspot = (DWORD) hotspotY;
		info.hbmMask = mask;
		info.hbmColor = nativeBitmap->hBitmap;

		HICON hi = CreateIconIndirect (&info);
		DeleteObject (mask);
		return hi;
	}
}

class HWNDComponentPeer  : public ComponentPeer
{
public:
	enum RenderingEngineType
	{
		softwareRenderingEngine = 0,
		direct2DRenderingEngine
	};

	HWNDComponentPeer (Component* const component,
					   const int windowStyleFlags,
					   HWND parentToAddTo_)
		: ComponentPeer (component, windowStyleFlags),
		  dontRepaint (false),
		  currentRenderingEngine (softwareRenderingEngine),
		  fullScreen (false),
		  isDragging (false),
		  isMouseOver (false),
		  hasCreatedCaret (false),
		  constrainerIsResizing (false),
		  currentWindowIcon (0),
		  dropTarget (nullptr),
		  parentToAddTo (parentToAddTo_),
		  updateLayeredWindowAlpha (255)
	{
		callFunctionIfNotLocked (&createWindowCallback, this);

		setTitle (component->getName());

		if ((windowStyleFlags & windowHasDropShadow) != 0
			 && Desktop::canUseSemiTransparentWindows())
		{
			shadower = component->getLookAndFeel().createDropShadowerForComponent (component);

			if (shadower != nullptr)
				shadower->setOwner (component);
		}
	}

	~HWNDComponentPeer()
	{
		shadower = nullptr;

		// do this before the next bit to avoid messages arriving for this window
		// before it's destroyed
		JuceWindowIdentifier::setAsJUCEWindow (hwnd, false);

		callFunctionIfNotLocked (&destroyWindowCallback, (void*) hwnd);

		if (currentWindowIcon != 0)
			DestroyIcon (currentWindowIcon);

		if (dropTarget != nullptr)
		{
			dropTarget->clear();
			dropTarget->Release();
			dropTarget = nullptr;
		}

	   #if JUCE_DIRECT2D
		direct2DContext = nullptr;
	   #endif
	}

	void* getNativeHandle() const    { return hwnd; }

	void setVisible (bool shouldBeVisible)
	{
		ShowWindow (hwnd, shouldBeVisible ? SW_SHOWNA : SW_HIDE);

		if (shouldBeVisible)
			InvalidateRect (hwnd, 0, 0);
		else
			lastPaintTime = 0;
	}

	void setTitle (const String& title)
	{
		// Unfortunately some ancient bits of win32 mean you can only perform this operation from the message thread.
		jassert (MessageManager::getInstance()->isThisTheMessageThread());

		SetWindowText (hwnd, title.toWideCharPointer());
	}

	void setPosition (int x, int y)
	{
		offsetWithinParent (x, y);
		SetWindowPos (hwnd, 0,
					  x - windowBorder.getLeft(),
					  y - windowBorder.getTop(),
					  0, 0,
					  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
	}

	void repaintNowIfTransparent()
	{
		if (isUsingUpdateLayeredWindow() && lastPaintTime > 0 && Time::getMillisecondCounter() > lastPaintTime + 30)
			handlePaintMessage();
	}

	void updateBorderSize()
	{
		WINDOWINFO info;
		info.cbSize = sizeof (info);

		if (GetWindowInfo (hwnd, &info))
		{
			windowBorder = BorderSize<int> (info.rcClient.top - info.rcWindow.top,
											info.rcClient.left - info.rcWindow.left,
											info.rcWindow.bottom - info.rcClient.bottom,
											info.rcWindow.right - info.rcClient.right);
		}

	   #if JUCE_DIRECT2D
		if (direct2DContext != nullptr)
			direct2DContext->resized();
	   #endif
	}

	void setSize (int w, int h)
	{
		SetWindowPos (hwnd, 0, 0, 0,
					  w + windowBorder.getLeftAndRight(),
					  h + windowBorder.getTopAndBottom(),
					  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER);

		updateBorderSize();

		repaintNowIfTransparent();
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		fullScreen = isNowFullScreen;
		offsetWithinParent (x, y);

		SetWindowPos (hwnd, 0,
					  x - windowBorder.getLeft(),
					  y - windowBorder.getTop(),
					  w + windowBorder.getLeftAndRight(),
					  h + windowBorder.getTopAndBottom(),
					  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER);

		updateBorderSize();

		repaintNowIfTransparent();
	}

	Rectangle<int> getBounds() const
	{
		RECT r;
		GetWindowRect (hwnd, &r);
		Rectangle<int> bounds (rectangleFromRECT (r));

		HWND parentH = GetParent (hwnd);
		if (parentH != 0)
		{
			GetWindowRect (parentH, &r);
			bounds.translate (-r.left, -r.top);
		}

		return windowBorder.subtractedFrom (bounds);
	}

	Point<int> getScreenPosition() const
	{
		RECT r;
		GetWindowRect (hwnd, &r);
		return Point<int> (r.left + windowBorder.getLeft(),
						   r.top + windowBorder.getTop());
	}

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setAlpha (float newAlpha)
	{
		const uint8 intAlpha = (uint8) jlimit (0, 255, (int) (newAlpha * 255.0f));

		if (component->isOpaque())
		{
			if (newAlpha < 1.0f)
			{
				SetWindowLong (hwnd, GWL_EXSTYLE, GetWindowLong (hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
				SetLayeredWindowAttributes (hwnd, RGB (0, 0, 0), intAlpha, LWA_ALPHA);
			}
			else
			{
				SetWindowLong (hwnd, GWL_EXSTYLE, GetWindowLong (hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);
				RedrawWindow (hwnd, 0, 0, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);
			}
		}
		else
		{
			updateLayeredWindowAlpha = intAlpha;
			component->repaint();
		}
	}

	void setMinimised (bool shouldBeMinimised)
	{
		if (shouldBeMinimised != isMinimised())
			ShowWindow (hwnd, shouldBeMinimised ? SW_MINIMIZE : SW_SHOWNORMAL);
	}

	bool isMinimised() const
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof (WINDOWPLACEMENT);
		GetWindowPlacement (hwnd, &wp);

		return wp.showCmd == SW_SHOWMINIMIZED;
	}

	void setFullScreen (bool shouldBeFullScreen)
	{
		setMinimised (false);

		if (isFullScreen() != shouldBeFullScreen)
		{
			fullScreen = shouldBeFullScreen;
			const WeakReference<Component> deletionChecker (component);

			if (! fullScreen)
			{
				const Rectangle<int> boundsCopy (lastNonFullscreenBounds);

				if (hasTitleBar())
					ShowWindow (hwnd, SW_SHOWNORMAL);

				if (! boundsCopy.isEmpty())
				{
					setBounds (boundsCopy.getX(),
							   boundsCopy.getY(),
							   boundsCopy.getWidth(),
							   boundsCopy.getHeight(),
							   false);
				}
			}
			else
			{
				if (hasTitleBar())
					ShowWindow (hwnd, SW_SHOWMAXIMIZED);
				else
					SendMessageW (hwnd, WM_SETTINGCHANGE, 0, 0);
			}

			if (deletionChecker != nullptr)
				handleMovedOrResized();
		}
	}

	bool isFullScreen() const
	{
		if (! hasTitleBar())
			return fullScreen;

		WINDOWPLACEMENT wp;
		wp.length = sizeof (wp);
		GetWindowPlacement (hwnd, &wp);

		return wp.showCmd == SW_SHOWMAXIMIZED;
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		if (! (isPositiveAndBelow (position.x, component->getWidth())
				&& isPositiveAndBelow (position.y, component->getHeight())))
			return false;

		RECT r;
		GetWindowRect (hwnd, &r);

		POINT p = { position.x + r.left + windowBorder.getLeft(),
					position.y + r.top  + windowBorder.getTop() };

		HWND w = WindowFromPoint (p);
		return w == hwnd || (trueIfInAChildWindow && (IsChild (hwnd, w) != 0));
	}

	BorderSize<int> getFrameSize() const
	{
		return windowBorder;
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		SetWindowPos (hwnd, alwaysOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
					  0, 0, 0, 0,
					  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);

		shouldDeactivateTitleBar = oldDeactivate;

		if (shadower != nullptr)
			shadower->componentBroughtToFront (*component);

		return true;
	}

	void toFront (bool makeActive)
	{
		setMinimised (false);

		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		callFunctionIfNotLocked (makeActive ? &toFrontCallback1 : &toFrontCallback2, hwnd);

		shouldDeactivateTitleBar = oldDeactivate;

		if (! makeActive)
		{
			// in this case a broughttofront call won't have occured, so do it now..
			handleBroughtToFront();
		}
	}

	void toBehind (ComponentPeer* other)
	{
		HWNDComponentPeer* const otherPeer = dynamic_cast <HWNDComponentPeer*> (other);

		jassert (otherPeer != nullptr); // wrong type of window?

		if (otherPeer != nullptr)
		{
			setMinimised (false);

			// Must be careful not to try to put a topmost window behind a normal one, or Windows
			// promotes the normal one to be topmost!
			if (getComponent()->isAlwaysOnTop() == otherPeer->getComponent()->isAlwaysOnTop())
				SetWindowPos (hwnd, otherPeer->hwnd, 0, 0, 0, 0,
							  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
			else if (otherPeer->getComponent()->isAlwaysOnTop())
				SetWindowPos (hwnd, HWND_TOP, 0, 0, 0, 0,
							  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
		}
	}

	bool isFocused() const
	{
		return callFunctionIfNotLocked (&getFocusCallback, 0) == (void*) hwnd;
	}

	void grabFocus()
	{
		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		callFunctionIfNotLocked (&setFocusCallback, hwnd);

		shouldDeactivateTitleBar = oldDeactivate;
	}

	void textInputRequired (const Point<int>&)
	{
		if (! hasCreatedCaret)
		{
			hasCreatedCaret = true;
			CreateCaret (hwnd, (HBITMAP) 1, 0, 0);
		}

		ShowCaret (hwnd);
		SetCaretPos (0, 0);
	}

	void dismissPendingTextInput()
	{
		imeHandler.handleSetContext (hwnd, false);
	}

	void repaint (const Rectangle<int>& area)
	{
		const RECT r = { area.getX(), area.getY(), area.getRight(), area.getBottom() };
		InvalidateRect (hwnd, &r, FALSE);
	}

	void performAnyPendingRepaintsNow()
	{
		MSG m;
		if (component->isVisible()
			 && (PeekMessage (&m, hwnd, WM_PAINT, WM_PAINT, PM_REMOVE) || isUsingUpdateLayeredWindow()))
			handlePaintMessage();
	}

	static HWNDComponentPeer* getOwnerOfWindow (HWND h) noexcept
	{
		if (h != 0 && JuceWindowIdentifier::isJUCEWindow (h))
			return (HWNDComponentPeer*) GetWindowLongPtr (h, 8);

		return nullptr;
	}

	bool isInside (HWND h) const noexcept
	{
		return GetAncestor (hwnd, GA_ROOT) == h;
	}

	static bool isKeyDown (const int key) noexcept  { return (GetAsyncKeyState (key) & 0x8000) != 0; }

	static void updateKeyModifiers() noexcept
	{
		int keyMods = 0;
		if (isKeyDown (VK_SHIFT))   keyMods |= ModifierKeys::shiftModifier;
		if (isKeyDown (VK_CONTROL)) keyMods |= ModifierKeys::ctrlModifier;
		if (isKeyDown (VK_MENU))    keyMods |= ModifierKeys::altModifier;
		if (isKeyDown (VK_RMENU))   keyMods &= ~(ModifierKeys::ctrlModifier | ModifierKeys::altModifier);

		currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (keyMods);
	}

	static void updateModifiersFromWParam (const WPARAM wParam)
	{
		int mouseMods = 0;
		if (wParam & MK_LBUTTON)   mouseMods |= ModifierKeys::leftButtonModifier;
		if (wParam & MK_RBUTTON)   mouseMods |= ModifierKeys::rightButtonModifier;
		if (wParam & MK_MBUTTON)   mouseMods |= ModifierKeys::middleButtonModifier;

		currentModifiers = currentModifiers.withoutMouseButtons().withFlags (mouseMods);
		updateKeyModifiers();
	}

	bool dontRepaint;

	static ModifierKeys currentModifiers;
	static ModifierKeys modifiersAtLastCallback;

	class JuceDropTarget    : public ComBaseClassHelper <IDropTarget>
	{
	public:
		JuceDropTarget (HWNDComponentPeer& owner_)   : ownerInfo (new OwnerInfo (owner_)) {}

		void clear()
		{
			ownerInfo = nullptr;
		}

		JUCE_COMRESULT DragEnter (IDataObject* pDataObject, DWORD grfKeyState, POINTL mousePos, DWORD* pdwEffect)
		{
			HRESULT hr = updateFileList (pDataObject);
			if (FAILED (hr))
				return hr;

			return DragOver (grfKeyState, mousePos, pdwEffect);
		}

		JUCE_COMRESULT DragLeave()
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			ownerInfo->owner.handleFileDragExit (ownerInfo->files);
			return S_OK;
		}

		JUCE_COMRESULT DragOver (DWORD /*grfKeyState*/, POINTL mousePos, DWORD* pdwEffect)
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			const bool wasWanted = ownerInfo->owner.handleFileDragMove (ownerInfo->files, ownerInfo->getMousePos (mousePos));
			*pdwEffect = wasWanted ? (DWORD) DROPEFFECT_COPY : (DWORD) DROPEFFECT_NONE;
			return S_OK;
		}

		JUCE_COMRESULT Drop (IDataObject* pDataObject, DWORD /*grfKeyState*/, POINTL mousePos, DWORD* pdwEffect)
		{
			HRESULT hr = updateFileList (pDataObject);
			if (SUCCEEDED (hr))
			{
				const bool wasWanted = ownerInfo->owner.handleFileDragDrop (ownerInfo->files, ownerInfo->getMousePos (mousePos));
				*pdwEffect = wasWanted ? (DWORD) DROPEFFECT_COPY : (DWORD) DROPEFFECT_NONE;
				hr = S_OK;
			}

			return hr;
		}

	private:
		struct OwnerInfo
		{
			OwnerInfo (HWNDComponentPeer& owner_) : owner (owner_) {}

			Point<int> getMousePos (const POINTL& mousePos) const
			{
				return owner.globalToLocal (Point<int> (mousePos.x, mousePos.y));
			}

			template <typename CharType>
			void parseFileList (const CharType* names, const SIZE_T totalLen)
			{
				unsigned int i = 0;

				for (;;)
				{
					unsigned int len = 0;
					while (i + len < totalLen && names [i + len] != 0)
						++len;

					if (len == 0)
						break;

					files.add (String (names + i, len));
					i += len + 1;
				}
			}

			HWNDComponentPeer& owner;
			StringArray files;

			JUCE_DECLARE_NON_COPYABLE (OwnerInfo);
		};

		ScopedPointer<OwnerInfo> ownerInfo;

		HRESULT updateFileList (IDataObject* const pDataObject)
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			ownerInfo->files.clear();

			FORMATETC format = { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
			STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

			HRESULT hr = pDataObject->GetData (&format, &medium);

			if (SUCCEEDED (hr))
			{
				const SIZE_T totalLen = GlobalSize (medium.hGlobal);
				const LPDROPFILES dropFiles = (const LPDROPFILES) GlobalLock (medium.hGlobal);
				const void* const names = addBytesToPointer (dropFiles, sizeof (DROPFILES));

				if (dropFiles->fWide)
					ownerInfo->parseFileList (static_cast <const WCHAR*> (names), totalLen);
				else
					ownerInfo->parseFileList (static_cast <const char*>  (names), totalLen);

				GlobalUnlock (medium.hGlobal);
			}

			return hr;
		}

		JUCE_DECLARE_NON_COPYABLE (JuceDropTarget);
	};

private:
	HWND hwnd, parentToAddTo;
	ScopedPointer<DropShadower> shadower;
	RenderingEngineType currentRenderingEngine;
   #if JUCE_DIRECT2D
	ScopedPointer<Direct2DLowLevelGraphicsContext> direct2DContext;
   #endif
	bool fullScreen, isDragging, isMouseOver, hasCreatedCaret, constrainerIsResizing;
	BorderSize<int> windowBorder;
	HICON currentWindowIcon;
	JuceDropTarget* dropTarget;
	uint8 updateLayeredWindowAlpha;
	MultiTouchMapper<DWORD> currentTouches;

	class TemporaryImage    : public Timer
	{
	public:
		TemporaryImage() {}

		Image& getImage (const bool transparent, const int w, const int h)
		{
			static bool alwaysUseARGB = isGraphicsCard32Bit(); // NB: for 32-bit cards, it's faster to use a 32-bit image.
			const Image::PixelFormat format = (transparent || alwaysUseARGB) ? Image::ARGB : Image::RGB;

			if ((! image.isValid()) || image.getWidth() < w || image.getHeight() < h || image.getFormat() != format)
				image = Image (new WindowsBitmapImage (format, (w + 31) & ~31, (h + 31) & ~31, false));

			startTimer (3000);
			return image;
		}

		void timerCallback()
		{
			stopTimer();
			image = Image::null;
		}

	private:
		Image image;

		static bool isGraphicsCard32Bit()
		{
			HDC dc = GetDC (0);
			const int bitsPerPixel = GetDeviceCaps (dc, BITSPIXEL);
			ReleaseDC (0, dc);
			return bitsPerPixel > 24;
		}

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TemporaryImage);
	};

	TemporaryImage offscreenImageGenerator;

	class WindowClassHolder    : public DeletedAtShutdown
	{
	public:
		WindowClassHolder()
		{
			// this name has to be different for each app/dll instance because otherwise poor old Windows can
			// get a bit confused (even despite it not being a process-global window class).
			String windowClassName ("JUCE_");
			windowClassName << String::toHexString (Time::currentTimeMillis());

			HINSTANCE moduleHandle = (HINSTANCE) Process::getCurrentModuleInstanceHandle();

			TCHAR moduleFile [1024] = { 0 };
			GetModuleFileName (moduleHandle, moduleFile, 1024);
			WORD iconNum = 0;

			WNDCLASSEX wcex = { 0 };
			wcex.cbSize         = sizeof (wcex);
			wcex.style          = CS_OWNDC;
			wcex.lpfnWndProc    = (WNDPROC) windowProc;
			wcex.lpszClassName  = windowClassName.toWideCharPointer();
			wcex.cbWndExtra     = 32;
			wcex.hInstance      = moduleHandle;
			wcex.hIcon          = ExtractAssociatedIcon (moduleHandle, moduleFile, &iconNum);
			iconNum = 1;
			wcex.hIconSm        = ExtractAssociatedIcon (moduleHandle, moduleFile, &iconNum);

			atom = RegisterClassEx (&wcex);
			jassert (atom != 0);

			isEventBlockedByModalComps = checkEventBlockedByModalComps;
		}

		~WindowClassHolder()
		{
			if (ComponentPeer::getNumPeers() == 0)
				UnregisterClass (getWindowClassName(), (HINSTANCE) Process::getCurrentModuleInstanceHandle());

			clearSingletonInstance();
		}

		LPCTSTR getWindowClassName() const noexcept     { return (LPCTSTR) MAKELONG (atom, 0); }

		juce_DeclareSingleton_SingleThreaded_Minimal (WindowClassHolder);

	private:
		ATOM atom;

		static bool isHWNDBlockedByModalComponents (HWND h)
		{
			for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
			{
				Component* const c = Desktop::getInstance().getComponent (i);

				if (c != nullptr
					  && (! c->isCurrentlyBlockedByAnotherModalComponent())
					  && IsChild ((HWND) c->getWindowHandle(), h))
					return false;
			}

			return true;
		}

		static bool checkEventBlockedByModalComps (const MSG& m)
		{
			if (Component::getNumCurrentlyModalComponents() == 0 || JuceWindowIdentifier::isJUCEWindow (m.hwnd))
				return false;

			switch (m.message)
			{
				case WM_MOUSEMOVE:
				case WM_NCMOUSEMOVE:
				case 0x020A: /* WM_MOUSEWHEEL */
				case 0x020E: /* WM_MOUSEHWHEEL */
				case WM_KEYUP:
				case WM_SYSKEYUP:
				case WM_CHAR:
				case WM_APPCOMMAND:
				case WM_LBUTTONUP:
				case WM_MBUTTONUP:
				case WM_RBUTTONUP:
				case WM_MOUSEACTIVATE:
				case WM_NCMOUSEHOVER:
				case WM_MOUSEHOVER:
				case WM_TOUCH:
					return isHWNDBlockedByModalComponents (m.hwnd);

				case WM_NCLBUTTONDOWN:
				case WM_NCLBUTTONDBLCLK:
				case WM_NCRBUTTONDOWN:
				case WM_NCRBUTTONDBLCLK:
				case WM_NCMBUTTONDOWN:
				case WM_NCMBUTTONDBLCLK:
				case WM_LBUTTONDOWN:
				case WM_LBUTTONDBLCLK:
				case WM_MBUTTONDOWN:
				case WM_MBUTTONDBLCLK:
				case WM_RBUTTONDOWN:
				case WM_RBUTTONDBLCLK:
				case WM_KEYDOWN:
				case WM_SYSKEYDOWN:
					if (isHWNDBlockedByModalComponents (m.hwnd))
					{
						Component* const modal = Component::getCurrentlyModalComponent (0);
						if (modal != nullptr)
							modal->inputAttemptWhenModal();

						return true;
					}
					break;

				default:
					break;
			}

			return false;
		}

		JUCE_DECLARE_NON_COPYABLE (WindowClassHolder);
	};

	static void* createWindowCallback (void* userData)
	{
		static_cast <HWNDComponentPeer*> (userData)->createWindow();
		return nullptr;
	}

	void createWindow()
	{
		DWORD exstyle = WS_EX_ACCEPTFILES;
		DWORD type = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		if (hasTitleBar())
		{
			type |= WS_OVERLAPPED;

			if ((styleFlags & windowHasCloseButton) != 0)
			{
				type |= WS_SYSMENU;
			}
			else
			{
				// annoyingly, windows won't let you have a min/max button without a close button
				jassert ((styleFlags & (windowHasMinimiseButton | windowHasMaximiseButton)) == 0);
			}

			if ((styleFlags & windowIsResizable) != 0)
				type |= WS_THICKFRAME;
		}
		else if (parentToAddTo != 0)
		{
			type |= WS_CHILD;
		}
		else
		{
			type |= WS_POPUP | WS_SYSMENU;
		}

		if ((styleFlags & windowAppearsOnTaskbar) == 0)
			exstyle |= WS_EX_TOOLWINDOW;
		else
			exstyle |= WS_EX_APPWINDOW;

		if ((styleFlags & windowHasMinimiseButton) != 0)    type |= WS_MINIMIZEBOX;
		if ((styleFlags & windowHasMaximiseButton) != 0)    type |= WS_MAXIMIZEBOX;
		if ((styleFlags & windowIgnoresMouseClicks) != 0)   exstyle |= WS_EX_TRANSPARENT;

		if ((styleFlags & windowIsSemiTransparent) != 0 && Desktop::canUseSemiTransparentWindows())
			exstyle |= WS_EX_LAYERED;

		hwnd = CreateWindowEx (exstyle, WindowClassHolder::getInstance()->getWindowClassName(),
							   L"", type, 0, 0, 0, 0, parentToAddTo, 0,
							   (HINSTANCE) Process::getCurrentModuleInstanceHandle(), 0);

	   #if JUCE_DIRECT2D
		setCurrentRenderingEngine (1);
	   #endif

		if (hwnd != 0)
		{
			SetWindowLongPtr (hwnd, 0, 0);
			SetWindowLongPtr (hwnd, 8, (LONG_PTR) this);
			JuceWindowIdentifier::setAsJUCEWindow (hwnd, true);

			if (dropTarget == nullptr)
				dropTarget = new JuceDropTarget (*this);

			RegisterDragDrop (hwnd, dropTarget);

			if (canUseMultiTouch())
				registerTouchWindow (hwnd, 0);

			updateBorderSize();

			// Calling this function here is (for some reason) necessary to make Windows
			// correctly enable the menu items that we specify in the wm_initmenu message.
			GetSystemMenu (hwnd, false);

			const float alpha = component->getAlpha();
			if (alpha < 1.0f)
				setAlpha (alpha);
		}
		else
		{
			jassertfalse;
		}
	}

	static void* destroyWindowCallback (void* handle)
	{
		RevokeDragDrop ((HWND) handle);
		DestroyWindow ((HWND) handle);
		return nullptr;
	}

	static void* toFrontCallback1 (void* h)
	{
		SetForegroundWindow ((HWND) h);
		return nullptr;
	}

	static void* toFrontCallback2 (void* h)
	{
		SetWindowPos ((HWND) h, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
		return nullptr;
	}

	static void* setFocusCallback (void* h)
	{
		SetFocus ((HWND) h);
		return nullptr;
	}

	static void* getFocusCallback (void*)
	{
		return GetFocus();
	}

	void offsetWithinParent (int& x, int& y) const
	{
		if (isUsingUpdateLayeredWindow())
		{
			HWND parentHwnd = GetParent (hwnd);

			if (parentHwnd != 0)
			{
				RECT parentRect;
				GetWindowRect (parentHwnd, &parentRect);
				x += parentRect.left;
				y += parentRect.top;
			}
		}
	}

	bool isUsingUpdateLayeredWindow() const
	{
		return ! component->isOpaque();
	}

	inline bool hasTitleBar() const noexcept        { return (styleFlags & windowHasTitleBar) != 0; }

	void setIcon (const Image& newIcon)
	{
		HICON hicon = IconConverters::createHICONFromImage (newIcon, TRUE, 0, 0);

		if (hicon != 0)
		{
			SendMessage (hwnd, WM_SETICON, ICON_BIG, (LPARAM) hicon);
			SendMessage (hwnd, WM_SETICON, ICON_SMALL, (LPARAM) hicon);

			if (currentWindowIcon != 0)
				DestroyIcon (currentWindowIcon);

			currentWindowIcon = hicon;
		}
	}

	void handlePaintMessage()
	{
	   #if JUCE_DIRECT2D
		if (direct2DContext != nullptr)
		{
			RECT r;

			if (GetUpdateRect (hwnd, &r, false))
			{
				direct2DContext->start();
				direct2DContext->clipToRectangle (rectangleFromRECT (r));
				handlePaint (*direct2DContext);
				direct2DContext->end();
			}
		}
		else
	   #endif

		{
			HRGN rgn = CreateRectRgn (0, 0, 0, 0);
			const int regionType = GetUpdateRgn (hwnd, rgn, false);

			PAINTSTRUCT paintStruct;
			HDC dc = BeginPaint (hwnd, &paintStruct); // Note this can immediately generate a WM_NCPAINT
													  // message and become re-entrant, but that's OK

			// if something in a paint handler calls, e.g. a message box, this can become reentrant and
			// corrupt the image it's using to paint into, so do a check here.
			static bool reentrant = false;
			if (reentrant)
			{
				DeleteObject (rgn);
				EndPaint (hwnd, &paintStruct);
				return;
			}

			const ScopedValueSetter<bool> setter (reentrant, true, false);

			// this is the rectangle to update..
			int x = paintStruct.rcPaint.left;
			int y = paintStruct.rcPaint.top;
			int w = paintStruct.rcPaint.right - x;
			int h = paintStruct.rcPaint.bottom - y;

			const bool transparent = isUsingUpdateLayeredWindow();

			if (transparent)
			{
				// it's not possible to have a transparent window with a title bar at the moment!
				jassert (! hasTitleBar());

				RECT r;
				GetWindowRect (hwnd, &r);
				x = y = 0;
				w = r.right - r.left;
				h = r.bottom - r.top;
			}

			if (w > 0 && h > 0)
			{
				clearMaskedRegion();

				Image& offscreenImage = offscreenImageGenerator.getImage (transparent, w, h);

				RectangleList contextClip;
				const Rectangle<int> clipBounds (w, h);

				bool needToPaintAll = true;

				if (regionType == COMPLEXREGION && ! transparent)
				{
					HRGN clipRgn = CreateRectRgnIndirect (&paintStruct.rcPaint);
					CombineRgn (rgn, rgn, clipRgn, RGN_AND);
					DeleteObject (clipRgn);

					char rgnData [8192];
					const DWORD res = GetRegionData (rgn, sizeof (rgnData), (RGNDATA*) rgnData);

					if (res > 0 && res <= sizeof (rgnData))
					{
						const RGNDATAHEADER* const hdr = &(((const RGNDATA*) rgnData)->rdh);

						if (hdr->iType == RDH_RECTANGLES
							 && hdr->rcBound.right - hdr->rcBound.left >= w
							 && hdr->rcBound.bottom - hdr->rcBound.top >= h)
						{
							needToPaintAll = false;

							const RECT* rects = (const RECT*) (rgnData + sizeof (RGNDATAHEADER));

							for (int i = (int) ((RGNDATA*) rgnData)->rdh.nCount; --i >= 0;)
							{
								if (rects->right <= x + w && rects->bottom <= y + h)
								{
									const int cx = jmax (x, (int) rects->left);
									contextClip.addWithoutMerging (Rectangle<int> (cx - x, rects->top - y, rects->right - cx, rects->bottom - rects->top)
																	   .getIntersection (clipBounds));
								}
								else
								{
									needToPaintAll = true;
									break;
								}

								++rects;
							}
						}
					}
				}

				if (needToPaintAll)
				{
					contextClip.clear();
					contextClip.addWithoutMerging (Rectangle<int> (w, h));
				}

				if (transparent)
				{
					RectangleList::Iterator i (contextClip);

					while (i.next())
						offscreenImage.clear (*i.getRectangle());
				}

				// if the component's not opaque, this won't draw properly unless the platform can support this
				jassert (Desktop::canUseSemiTransparentWindows() || component->isOpaque());

				updateCurrentModifiers();

				{
					ScopedPointer<LowLevelGraphicsContext> context (component->getLookAndFeel()
																		.createGraphicsContext (offscreenImage, Point<int> (-x, -y), contextClip));
					handlePaint (*context);
				}

				if (! dontRepaint)
					static_cast <WindowsBitmapImage*> (offscreenImage.getPixelData())
						->blitToWindow (hwnd, dc, transparent, x, y, maskedRegion, updateLayeredWindowAlpha);
			}

			DeleteObject (rgn);
			EndPaint (hwnd, &paintStruct);
		}

	   #ifndef JUCE_GCC
		_fpreset(); // because some graphics cards can unmask FP exceptions
	   #endif

		lastPaintTime = Time::getMillisecondCounter();
	}

	void doMouseEvent (const Point<int>& position)
	{
		handleMouseEvent (0, position, currentModifiers, getMouseEventTime());
	}

	StringArray getAvailableRenderingEngines()
	{
		StringArray s (ComponentPeer::getAvailableRenderingEngines());

	   #if JUCE_DIRECT2D
		if (SystemStats::getOperatingSystemType() >= SystemStats::Windows7)
			s.add ("Direct2D");
	   #endif

		return s;
	}

	int getCurrentRenderingEngine() const    { return currentRenderingEngine; }

   #if JUCE_DIRECT2D
	void updateDirect2DContext()
	{
		if (currentRenderingEngine != direct2DRenderingEngine)
			direct2DContext = 0;
		else if (direct2DContext == 0)
			direct2DContext = new Direct2DLowLevelGraphicsContext (hwnd);
	}
   #endif

	void setCurrentRenderingEngine (int index)
	{
		(void) index;

	   #if JUCE_DIRECT2D
		if (getAvailableRenderingEngines().size() > 1)
		{
			currentRenderingEngine = index == 1 ? direct2DRenderingEngine : softwareRenderingEngine;
			updateDirect2DContext();
			repaint (component->getLocalBounds());
		}
	   #endif
	}

	static int getMinTimeBetweenMouseMoves()
	{
		if (SystemStats::getOperatingSystemType() >= SystemStats::WinVista)
			return 0;

		return 1000 / 60;  // Throttling the incoming mouse-events seems to still be needed in XP..
	}

	static bool isCurrentEventFromTouchScreen() noexcept
	{
		const LPARAM flags = GetMessageExtraInfo();
		return (flags & 0xffffff00 /* SIGNATURE_MASK */) == 0xff515700 /* MI_WP_SIGNATURE */
				&& (flags & 0x80) != 0; // (bit 7 = 0 for pen events, 1 for touch)
	}

	void doMouseMove (const Point<int>& position)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			if (! isMouseOver)
			{
				isMouseOver = true;
				ModifierKeys::getCurrentModifiersRealtime(); // (This avoids a rare stuck-button problem when focus is lost unexpectedly)
				updateKeyModifiers();

				TRACKMOUSEEVENT tme;
				tme.cbSize = sizeof (tme);
				tme.dwFlags = TME_LEAVE;
				tme.hwndTrack = hwnd;
				tme.dwHoverTime = 0;

				if (! TrackMouseEvent (&tme))
					jassertfalse;

				Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
			}
			else if (! isDragging)
			{
				if (! contains (position, false))
					return;
			}

			static uint32 lastMouseTime = 0;
			static int minTimeBetweenMouses = getMinTimeBetweenMouseMoves();
			const uint32 now = Time::getMillisecondCounter();

			if (now >= lastMouseTime + minTimeBetweenMouses)
			{
				lastMouseTime = now;
				doMouseEvent (position);
			}
		}
	}

	void doMouseDown (const Point<int>& position, const WPARAM wParam)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			if (GetCapture() != hwnd)
				SetCapture (hwnd);

			doMouseMove (position);

			updateModifiersFromWParam (wParam);
			isDragging = true;

			doMouseEvent (position);
		}
	}

	void doMouseUp (const Point<int>& position, const WPARAM wParam)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			updateModifiersFromWParam (wParam);
			const bool wasDragging = isDragging;
			isDragging = false;

			// release the mouse capture if the user has released all buttons
			if ((wParam & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)) == 0 && hwnd == GetCapture())
				ReleaseCapture();

			// NB: under some circumstances (e.g. double-clicking a native title bar), a mouse-up can
			// arrive without a mouse-down, so in that case we need to avoid sending a message.
			if (wasDragging)
				doMouseEvent (position);
		}
	}

	void doCaptureChanged()
	{
		if (constrainerIsResizing)
		{
			if (constrainer != nullptr)
				constrainer->resizeEnd();

			constrainerIsResizing = false;
		}

		if (isDragging)
			doMouseUp (getCurrentMousePos(), (WPARAM) 0);
	}

	void doMouseExit()
	{
		isMouseOver = false;
		doMouseEvent (getCurrentMousePos());
	}

	void doMouseWheel (const Point<int>& globalPos, const WPARAM wParam, const bool isVertical)
	{
		updateKeyModifiers();
		const float amount = jlimit (-1000.0f, 1000.0f, 0.75f * (short) HIWORD (wParam));

		// Because Windows stupidly sends all wheel events to the window with the keyboard
		// focus, we have to redirect them here according to the mouse pos..
		POINT p = { globalPos.x, globalPos.y };
		HWNDComponentPeer* peer = getOwnerOfWindow (WindowFromPoint (p));

		if (peer == nullptr)
			peer = this;

		peer->handleMouseWheel (0, peer->globalToLocal (globalPos), getMouseEventTime(),
								isVertical ? 0.0f : -amount,
								isVertical ? amount : 0.0f);
	}

	void doTouchEvent (const int numInputs, HTOUCHINPUT eventHandle)
	{
		HeapBlock<TOUCHINPUT> inputInfo (numInputs);

		if (getTouchInputInfo (eventHandle, numInputs, inputInfo, sizeof (TOUCHINPUT)))
		{
			for (int i = 0; i < numInputs; ++i)
			{
				const DWORD flags = inputInfo[i].dwFlags;

				if ((flags & (TOUCHEVENTF_DOWN | TOUCHEVENTF_MOVE | TOUCHEVENTF_UP)) != 0)
				{
					if (! handleTouchInput (inputInfo[i], (flags & TOUCHEVENTF_DOWN) != 0,
														  (flags & TOUCHEVENTF_UP) != 0))
						return;  // abandon method if this window was deleted by the callback
				}
			}
		}

		closeTouchInputHandle (eventHandle);
	}

	bool handleTouchInput (const TOUCHINPUT& touch, const bool isDown, const bool isUp)
	{
		bool isCancel = false;
		const int touchIndex = currentTouches.getIndexOfTouch (touch.dwID);
		const int64 time = getMouseEventTime();
		const Point<int> pos (globalToLocal (Point<int> ((int) TOUCH_COORD_TO_PIXEL (touch.x),
														 (int) TOUCH_COORD_TO_PIXEL (touch.y))));
		ModifierKeys modsToSend (currentModifiers);

		if (isDown)
		{
			currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
			modsToSend = currentModifiers;

			// this forces a mouse-enter/up event, in case for some reason we didn't get a mouse-up before.
			handleMouseEvent (touchIndex + 1, pos, modsToSend.withoutMouseButtons(), time);
			if (! isValidPeer (this)) // (in case this component was deleted by the event)
				return false;
		}
		else if (isUp)
		{
			modsToSend = modsToSend.withoutMouseButtons();
			currentTouches.clearTouch (touchIndex);

			if (! currentTouches.areAnyTouchesActive())
				isCancel = true;
		}

		if (isCancel)
		{
			currentTouches.clear();
			currentModifiers = currentModifiers.withoutMouseButtons();
		}

		handleMouseEvent (touchIndex + 1, pos, modsToSend, time);
		if (! isValidPeer (this)) // (in case this component was deleted by the event)
			return false;

		if (isUp || isCancel)
		{
			handleMouseEvent (touchIndex + 1, Point<int> (-1, -1), currentModifiers, time);
			if (! isValidPeer (this))
				return false;
		}

		return true;
	}

	void sendModifierKeyChangeIfNeeded()
	{
		if (modifiersAtLastCallback != currentModifiers)
		{
			modifiersAtLastCallback = currentModifiers;
			handleModifierKeysChange();
		}
	}

	bool doKeyUp (const WPARAM key)
	{
		updateKeyModifiers();

		switch (key)
		{
			case VK_SHIFT:
			case VK_CONTROL:
			case VK_MENU:
			case VK_CAPITAL:
			case VK_LWIN:
			case VK_RWIN:
			case VK_APPS:
			case VK_NUMLOCK:
			case VK_SCROLL:
			case VK_LSHIFT:
			case VK_RSHIFT:
			case VK_LCONTROL:
			case VK_LMENU:
			case VK_RCONTROL:
			case VK_RMENU:
				sendModifierKeyChangeIfNeeded();
		}

		return handleKeyUpOrDown (false)
				|| Component::getCurrentlyModalComponent() != nullptr;
	}

	bool doKeyDown (const WPARAM key)
	{
		updateKeyModifiers();
		bool used = false;

		switch (key)
		{
			case VK_SHIFT:
			case VK_LSHIFT:
			case VK_RSHIFT:
			case VK_CONTROL:
			case VK_LCONTROL:
			case VK_RCONTROL:
			case VK_MENU:
			case VK_LMENU:
			case VK_RMENU:
			case VK_LWIN:
			case VK_RWIN:
			case VK_CAPITAL:
			case VK_NUMLOCK:
			case VK_SCROLL:
			case VK_APPS:
				sendModifierKeyChangeIfNeeded();
				break;

			case VK_LEFT:
			case VK_RIGHT:
			case VK_UP:
			case VK_DOWN:
			case VK_PRIOR:
			case VK_NEXT:
			case VK_HOME:
			case VK_END:
			case VK_DELETE:
			case VK_INSERT:
			case VK_F1:
			case VK_F2:
			case VK_F3:
			case VK_F4:
			case VK_F5:
			case VK_F6:
			case VK_F7:
			case VK_F8:
			case VK_F9:
			case VK_F10:
			case VK_F11:
			case VK_F12:
			case VK_F13:
			case VK_F14:
			case VK_F15:
			case VK_F16:
				used = handleKeyUpOrDown (true);
				used = handleKeyPress (extendedKeyModifier | (int) key, 0) || used;
				break;

			case VK_ADD:
			case VK_SUBTRACT:
			case VK_MULTIPLY:
			case VK_DIVIDE:
			case VK_SEPARATOR:
			case VK_DECIMAL:
				used = handleKeyUpOrDown (true);
				break;

			default:
				used = handleKeyUpOrDown (true);

				{
					MSG msg;

					if (! PeekMessage (&msg, hwnd, WM_CHAR, WM_DEADCHAR, PM_NOREMOVE))
					{
						// if there isn't a WM_CHAR or WM_DEADCHAR message pending, we need to
						// manually generate the key-press event that matches this key-down.

						const UINT keyChar = MapVirtualKey ((UINT) key, 2);
						used = handleKeyPress ((int) LOWORD (keyChar), 0) || used;
					}
				}

				break;
		}

		return used || (Component::getCurrentlyModalComponent() != nullptr);
	}

	bool doKeyChar (int key, const LPARAM flags)
	{
		updateKeyModifiers();

		juce_wchar textChar = (juce_wchar) key;

		const int virtualScanCode = (flags >> 16) & 0xff;

		if (key >= '0' && key <= '9')
		{
			switch (virtualScanCode)  // check for a numeric keypad scan-code
			{
				case 0x52:
				case 0x4f:
				case 0x50:
				case 0x51:
				case 0x4b:
				case 0x4c:
				case 0x4d:
				case 0x47:
				case 0x48:
				case 0x49:
					key = (key - '0') + KeyPress::numberPad0;
					break;
				default:
					break;
			}
		}
		else
		{
			// convert the scan code to an unmodified character code..
			const UINT virtualKey = MapVirtualKey ((UINT) virtualScanCode, 1);
			UINT keyChar = MapVirtualKey (virtualKey, 2);

			keyChar = LOWORD (keyChar);

			if (keyChar != 0)
				key = (int) keyChar;

			// avoid sending junk text characters for some control-key combinations
			if (textChar < ' ' && currentModifiers.testFlags (ModifierKeys::ctrlModifier | ModifierKeys::altModifier))
				textChar = 0;
		}

		return handleKeyPress (key, textChar);
	}

	void forwardMessageToParent (UINT message, WPARAM wParam, LPARAM lParam) const
	{
		HWND parentH = GetParent (hwnd);
		if (parentH != 0)
			PostMessage (parentH, message, wParam, lParam);
	}

	bool doAppCommand (const LPARAM lParam)
	{
		int key = 0;

		switch (GET_APPCOMMAND_LPARAM (lParam))
		{
			case APPCOMMAND_MEDIA_PLAY_PAUSE:       key = KeyPress::playKey; break;
			case APPCOMMAND_MEDIA_STOP:             key = KeyPress::stopKey; break;
			case APPCOMMAND_MEDIA_NEXTTRACK:        key = KeyPress::fastForwardKey; break;
			case APPCOMMAND_MEDIA_PREVIOUSTRACK:    key = KeyPress::rewindKey; break;
			default: break;
		}

		if (key != 0)
		{
			updateKeyModifiers();

			if (hwnd == GetActiveWindow())
			{
				handleKeyPress (key, 0);
				return true;
			}
		}

		return false;
	}

	bool isConstrainedNativeWindow() const
	{
		return constrainer != nullptr
				&& (styleFlags & (windowHasTitleBar | windowIsResizable)) == (windowHasTitleBar | windowIsResizable);
	}

	LRESULT handleSizeConstraining (RECT* const r, const WPARAM wParam)
	{
		if (isConstrainedNativeWindow())
		{
			Rectangle<int> pos (rectangleFromRECT (*r));

			constrainer->checkBounds (pos, windowBorder.addedTo (component->getBounds()),
									  Desktop::getInstance().getDisplays().getTotalBounds (true),
									  wParam == WMSZ_TOP    || wParam == WMSZ_TOPLEFT    || wParam == WMSZ_TOPRIGHT,
									  wParam == WMSZ_LEFT   || wParam == WMSZ_TOPLEFT    || wParam == WMSZ_BOTTOMLEFT,
									  wParam == WMSZ_BOTTOM || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_BOTTOMRIGHT,
									  wParam == WMSZ_RIGHT  || wParam == WMSZ_TOPRIGHT   || wParam == WMSZ_BOTTOMRIGHT);
			r->left   = pos.getX();
			r->top    = pos.getY();
			r->right  = pos.getRight();
			r->bottom = pos.getBottom();
		}

		return TRUE;
	}

	LRESULT handlePositionChanging (WINDOWPOS* const wp)
	{
		if (isConstrainedNativeWindow())
		{
			if ((wp->flags & (SWP_NOMOVE | SWP_NOSIZE)) != (SWP_NOMOVE | SWP_NOSIZE)
				 && ! Component::isMouseButtonDownAnywhere())
			{
				Rectangle<int> pos (wp->x, wp->y, wp->cx, wp->cy);
				const Rectangle<int> current (windowBorder.addedTo (component->getBounds()));

				constrainer->checkBounds (pos, current,
										  Desktop::getInstance().getDisplays().getTotalBounds (true),
										  pos.getY() != current.getY() && pos.getBottom() == current.getBottom(),
										  pos.getX() != current.getX() && pos.getRight() == current.getRight(),
										  pos.getY() == current.getY() && pos.getBottom() != current.getBottom(),
										  pos.getX() == current.getX() && pos.getRight() != current.getRight());
				wp->x = pos.getX();
				wp->y = pos.getY();
				wp->cx = pos.getWidth();
				wp->cy = pos.getHeight();
			}
		}

		return 0;
	}

	void handleAppActivation (const WPARAM wParam)
	{
		modifiersAtLastCallback = -1;
		updateKeyModifiers();

		if (isMinimised())
		{
			component->repaint();
			handleMovedOrResized();

			if (! ComponentPeer::isValidPeer (this))
				return;
		}

		Component* underMouse = component->getComponentAt (component->getMouseXYRelative());

		if (underMouse == nullptr)
			underMouse = component;

		if (underMouse->isCurrentlyBlockedByAnotherModalComponent())
		{
			if (LOWORD (wParam) == WA_CLICKACTIVE)
				Component::getCurrentlyModalComponent()->inputAttemptWhenModal();
			else
				ModalComponentManager::getInstance()->bringModalComponentsToFront();
		}
		else
		{
			handleBroughtToFront();
		}
	}

	void handleLeftClickInNCArea (WPARAM wParam)
	{
		if (! sendInputAttemptWhenModalMessage())
		{
			switch (wParam)
			{
			case HTBOTTOM:
			case HTBOTTOMLEFT:
			case HTBOTTOMRIGHT:
			case HTGROWBOX:
			case HTLEFT:
			case HTRIGHT:
			case HTTOP:
			case HTTOPLEFT:
			case HTTOPRIGHT:
				if (isConstrainedNativeWindow())
				{
					constrainerIsResizing = true;
					constrainer->resizeStart();
				}
				break;

			default:
				break;
			}
		}
	}

	void initialiseSysMenu (HMENU menu) const
	{
		if (! hasTitleBar())
		{
			if (isFullScreen())
			{
				EnableMenuItem (menu, SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
				EnableMenuItem (menu, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
			}
			else if (! isMinimised())
			{
				EnableMenuItem (menu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
			}
		}
	}

	void doSettingChange()
	{
		const_cast <Desktop::Displays&> (Desktop::getInstance().getDisplays()).refresh();

		if (fullScreen && ! isMinimised())
		{
			const Rectangle<int> r (component->getParentMonitorArea());

			SetWindowPos (hwnd, 0, r.getX(), r.getY(), r.getWidth(), r.getHeight(),
						  SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOSENDCHANGING);
		}
	}

public:
	static LRESULT CALLBACK windowProc (HWND h, UINT message, WPARAM wParam, LPARAM lParam)
	{
		HWNDComponentPeer* const peer = getOwnerOfWindow (h);

		if (peer != nullptr)
		{
			jassert (isValidPeer (peer));
			return peer->peerWindowProc (h, message, wParam, lParam);
		}

		return DefWindowProcW (h, message, wParam, lParam);
	}

private:
	static void* callFunctionIfNotLocked (MessageCallbackFunction* callback, void* userData)
	{
		if (MessageManager::getInstance()->currentThreadHasLockedMessageManager())
			return callback (userData);
		else
			return MessageManager::getInstance()->callFunctionOnMessageThread (callback, userData);
	}

	static Point<int> getPointFromLParam (LPARAM lParam) noexcept
	{
		return Point<int> (GET_X_LPARAM (lParam), GET_Y_LPARAM (lParam));
	}

	static Point<int> getCurrentMousePosGlobal() noexcept
	{
		const DWORD mp = GetMessagePos();
		return Point<int> (GET_X_LPARAM (mp),
						   GET_Y_LPARAM (mp));
	}

	Point<int> getCurrentMousePos() noexcept
	{
		return globalToLocal (getCurrentMousePosGlobal());
	}

	LRESULT peerWindowProc (HWND h, UINT message, WPARAM wParam, LPARAM lParam)
	{
		switch (message)
		{

			case WM_NCHITTEST:
				if ((styleFlags & windowIgnoresMouseClicks) != 0)
					return HTTRANSPARENT;
				else if (! hasTitleBar())
					return HTCLIENT;

				break;

			case WM_PAINT:
				handlePaintMessage();
				return 0;

			case WM_NCPAINT:
				if (wParam != 1) // (1 = a repaint of the entire NC region)
					handlePaintMessage(); // this must be done, even with native titlebars, or there are rendering artifacts.

				if (hasTitleBar())
					break; // let the DefWindowProc handle drawing the frame.

				return 0;

			case WM_ERASEBKGND:
			case WM_NCCALCSIZE:
				if (hasTitleBar())
					break;

				return 1;

			case WM_MOUSEMOVE:          doMouseMove (getPointFromLParam (lParam)); return 0;
			case WM_MOUSELEAVE:         doMouseExit(); return 0;

			case WM_LBUTTONDOWN:
			case WM_MBUTTONDOWN:
			case WM_RBUTTONDOWN:        doMouseDown (getPointFromLParam (lParam), wParam); return 0;

			case WM_LBUTTONUP:
			case WM_MBUTTONUP:
			case WM_RBUTTONUP:          doMouseUp (getPointFromLParam (lParam), wParam); return 0;

			case WM_CAPTURECHANGED:     doCaptureChanged(); return 0;

			case WM_NCMOUSEMOVE:
				if (hasTitleBar())
					break;

				return 0;

			case 0x020A: /* WM_MOUSEWHEEL */
			case 0x020E: /* WM_MOUSEHWHEEL */
				doMouseWheel (getCurrentMousePosGlobal(), wParam, message == 0x020A);
				return 0;

			case WM_TOUCH:
				if (getTouchInputInfo == nullptr)
					break;

				doTouchEvent ((int) wParam, (HTOUCHINPUT) lParam);
				return 0;

			case WM_SIZING:                return handleSizeConstraining ((RECT*) lParam, wParam);
			case WM_WINDOWPOSCHANGING:     return handlePositionChanging ((WINDOWPOS*) lParam);

			case WM_WINDOWPOSCHANGED:
				{
					const Point<int> pos (getCurrentMousePos());
					if (contains (pos, false))
						doMouseEvent (pos);
				}

				handleMovedOrResized();

				if (dontRepaint)
					break;  // needed for non-accelerated openGL windows to draw themselves correctly..

				return 0;

			case WM_KEYDOWN:
			case WM_SYSKEYDOWN:
				if (doKeyDown (wParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_KEYUP:
			case WM_SYSKEYUP:
				if (doKeyUp (wParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_CHAR:
				if (doKeyChar ((int) wParam, lParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_APPCOMMAND:
				if (doAppCommand (lParam))
					return TRUE;

				break;

			case WM_SETFOCUS:
				updateKeyModifiers();
				handleFocusGain();
				break;

			case WM_KILLFOCUS:
				if (hasCreatedCaret)
				{
					hasCreatedCaret = false;
					DestroyCaret();
				}

				handleFocusLoss();
				break;

			case WM_ACTIVATEAPP:
				// Windows does weird things to process priority when you swap apps,
				// so this forces an update when the app is brought to the front
				if (wParam != FALSE)
					juce_repeatLastProcessPriority();
				else
					Desktop::getInstance().setKioskModeComponent (nullptr); // turn kiosk mode off if we lose focus

				juce_CheckCurrentlyFocusedTopLevelWindow();
				modifiersAtLastCallback = -1;
				return 0;

			case WM_ACTIVATE:
				if (LOWORD (wParam) == WA_ACTIVE || LOWORD (wParam) == WA_CLICKACTIVE)
				{
					handleAppActivation (wParam);
					return 0;
				}

				break;

			case WM_NCACTIVATE:
				// while a temporary window is being shown, prevent Windows from deactivating the
				// title bars of our main windows.
				if (wParam == 0 && ! shouldDeactivateTitleBar)
					wParam = TRUE; // change this and let it get passed to the DefWindowProc.

				break;

			case WM_MOUSEACTIVATE:
				if (! component->getMouseClickGrabsKeyboardFocus())
					return MA_NOACTIVATE;

				break;

			case WM_SHOWWINDOW:
				if (wParam != 0)
					handleBroughtToFront();

				break;

			case WM_CLOSE:
				if (! component->isCurrentlyBlockedByAnotherModalComponent())
					handleUserClosingWindow();

				return 0;

			case WM_QUERYENDSESSION:
				if (JUCEApplication::getInstance() != nullptr)
				{
					JUCEApplication::getInstance()->systemRequestedQuit();
					return MessageManager::getInstance()->hasStopMessageBeenSent();
				}
				return TRUE;

			case WM_SYNCPAINT:
				return 0;

			case WM_DISPLAYCHANGE:
				InvalidateRect (h, 0, 0);
				// intentional fall-through...
			case WM_SETTINGCHANGE:  // note the fall-through in the previous case!
				doSettingChange();
				break;

			case WM_INITMENU:
				initialiseSysMenu ((HMENU) wParam);
				break;

			case WM_SYSCOMMAND:
				switch (wParam & 0xfff0)
				{
				case SC_CLOSE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (hasTitleBar())
					{
						PostMessage (h, WM_CLOSE, 0, 0);
						return 0;
					}
					break;

				case SC_KEYMENU:
					// (NB mustn't call sendInputAttemptWhenModalMessage() here because of very obscure
					// situations that can arise if a modal loop is started from an alt-key keypress).
					if (hasTitleBar() && h == GetCapture())
						ReleaseCapture();

					break;

				case SC_MAXIMIZE:
					if (! sendInputAttemptWhenModalMessage())
						setFullScreen (true);

					return 0;

				case SC_MINIMIZE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (! hasTitleBar())
					{
						setMinimised (true);
						return 0;
					}
					break;

				case SC_RESTORE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (hasTitleBar())
					{
						if (isFullScreen())
						{
							setFullScreen (false);
							return 0;
						}
					}
					else
					{
						if (isMinimised())
							setMinimised (false);
						else if (isFullScreen())
							setFullScreen (false);

						return 0;
					}
					break;
				}

				break;

			case WM_NCLBUTTONDOWN:
				handleLeftClickInNCArea (wParam);
				break;

			case WM_NCRBUTTONDOWN:
			case WM_NCMBUTTONDOWN:
				sendInputAttemptWhenModalMessage();
				break;

			case WM_IME_SETCONTEXT:
				imeHandler.handleSetContext (h, wParam == TRUE);
				lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
				break;

			case WM_IME_STARTCOMPOSITION:  imeHandler.handleStartComposition (*this); return 0;
			case WM_IME_ENDCOMPOSITION:    imeHandler.handleEndComposition (*this, h); break;
			case WM_IME_COMPOSITION:       imeHandler.handleComposition (*this, h, lParam); return 0;

			case WM_GETDLGCODE:
				return DLGC_WANTALLKEYS;

			default:
				break;
		}

		return DefWindowProcW (h, message, wParam, lParam);
	}

	bool sendInputAttemptWhenModalMessage()
	{
		if (component->isCurrentlyBlockedByAnotherModalComponent())
		{
			Component* const current = Component::getCurrentlyModalComponent();

			if (current != nullptr)
				current->inputAttemptWhenModal();

			return true;
		}

		return false;
	}

	class IMEHandler
	{
	public:
		IMEHandler()
		{
			reset();
		}

		void handleSetContext (HWND hWnd, const bool windowIsActive)
		{
			if (compositionInProgress && ! windowIsActive)
			{
				compositionInProgress = false;

				HIMC hImc = ImmGetContext (hWnd);
				if (hImc != 0)
				{
					ImmNotifyIME (hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
					ImmReleaseContext (hWnd, hImc);
				}
			}
		}

		void handleStartComposition (ComponentPeer& owner)
		{
			reset();
			TextInputTarget* const target = owner.findCurrentTextInputTarget();

			if (target != nullptr)
				target->insertTextAtCaret (String::empty);
		}

		void handleEndComposition (ComponentPeer& owner, HWND hWnd)
		{
			if (compositionInProgress)
			{
				// If this occurs, the user has cancelled the composition, so clear their changes..
				TextInputTarget* const target = owner.findCurrentTextInputTarget();

				if (target != nullptr)
				{
					target->setHighlightedRegion (compositionRange);
					target->insertTextAtCaret (String::empty);
					compositionRange.setLength (0);

					target->setHighlightedRegion (Range<int>::emptyRange (compositionRange.getEnd()));
					target->setTemporaryUnderlining (Array<Range<int> >());
				}

				HIMC hImc = ImmGetContext (hWnd);

				if (hImc != 0)
				{
					ImmNotifyIME (hImc, NI_CLOSECANDIDATE, 0, 0);
					ImmReleaseContext (hWnd, hImc);
				}
			}

			reset();
		}

		void handleComposition (ComponentPeer& owner, HWND hWnd, const LPARAM lParam)
		{
			TextInputTarget* const target = owner.findCurrentTextInputTarget();
			HIMC hImc = ImmGetContext (hWnd);

			if (target == nullptr || hImc == 0)
				return;

			if (compositionRange.getStart() < 0)
				compositionRange = Range<int>::emptyRange (target->getHighlightedRegion().getStart());

			if ((lParam & GCS_RESULTSTR) != 0) // (composition has finished)
			{
				replaceCurrentSelection (target, getCompositionString (hImc, GCS_RESULTSTR),
										 Range<int>::emptyRange (-1));

				reset();
				target->setTemporaryUnderlining (Array<Range<int> >());
			}
			else if ((lParam & GCS_COMPSTR) != 0) // (composition is still in-progress)
			{
				replaceCurrentSelection (target, getCompositionString (hImc, GCS_COMPSTR),
										 getCompositionSelection (hImc, lParam));

				target->setTemporaryUnderlining (getCompositionUnderlines (hImc, lParam));
				compositionInProgress = true;
			}

			moveCandidateWindowToLeftAlignWithSelection (hImc, owner, target);
			ImmReleaseContext (hWnd, hImc);
		}

	private:

		Range<int> compositionRange; // The range being modified in the TextInputTarget
		bool compositionInProgress;

		void reset()
		{
			compositionRange = Range<int>::emptyRange (-1);
			compositionInProgress = false;
		}

		String getCompositionString (HIMC hImc, const DWORD type) const
		{
			jassert (hImc != 0);

			const int stringSizeBytes = ImmGetCompositionString (hImc, type, 0, 0);

			if (stringSizeBytes > 0)
			{
				HeapBlock<TCHAR> buffer;
				buffer.calloc (stringSizeBytes / sizeof (TCHAR) + 1);
				ImmGetCompositionString (hImc, type, buffer, (DWORD) stringSizeBytes);
				return String (buffer);
			}

			return String::empty;
		}

		int getCompositionCaretPos (HIMC hImc, LPARAM lParam, const String& currentIMEString) const
		{
			jassert (hImc != 0);

			if ((lParam & CS_NOMOVECARET) != 0)
				return compositionRange.getStart();

			if ((lParam & GCS_CURSORPOS) != 0)
			{
				const int localCaretPos = ImmGetCompositionString (hImc, GCS_CURSORPOS, 0, 0);
				return compositionRange.getStart() + jmax (0, localCaretPos);
			}

			return compositionRange.getStart() + currentIMEString.length();
		}

		// Get selected/highlighted range while doing composition:
		// returned range is relative to beginning of TextInputTarget, not composition string
		Range<int> getCompositionSelection (HIMC hImc, LPARAM lParam) const
		{
			jassert (hImc != 0);
			int selectionStart = 0;
			int selectionEnd = 0;

			if ((lParam & GCS_COMPATTR) != 0)
			{
				// Get size of attributes array:
				const int attributeSizeBytes = ImmGetCompositionString (hImc, GCS_COMPATTR, 0, 0);

				if (attributeSizeBytes > 0)
				{
					// Get attributes (8 bit flag per character):
					HeapBlock<char> attributes ((size_t) attributeSizeBytes);
					ImmGetCompositionString (hImc, GCS_COMPATTR, attributes, (DWORD) attributeSizeBytes);

					selectionStart = 0;

					for (selectionStart = 0; selectionStart < attributeSizeBytes; ++selectionStart)
						if (attributes[selectionStart] == ATTR_TARGET_CONVERTED || attributes[selectionStart] == ATTR_TARGET_NOTCONVERTED)
							break;

					for (selectionEnd = selectionStart; selectionEnd < attributeSizeBytes; ++selectionEnd)
						if (attributes [selectionEnd] != ATTR_TARGET_CONVERTED && attributes[selectionEnd] != ATTR_TARGET_NOTCONVERTED)
							break;
				}
			}

			return Range<int> (selectionStart, selectionEnd) + compositionRange.getStart();
		}

		void replaceCurrentSelection (TextInputTarget* const target, const String& newContent, Range<int> newSelection)
		{
			if (compositionInProgress)
				target->setHighlightedRegion (compositionRange);

			target->insertTextAtCaret (newContent);
			compositionRange.setLength (newContent.length());

			if (newSelection.getStart() < 0)
				newSelection = Range<int>::emptyRange (compositionRange.getEnd());

			target->setHighlightedRegion (newSelection);
		}

		Array<Range<int> > getCompositionUnderlines (HIMC hImc, LPARAM lParam) const
		{
			Array<Range<int> > result;

			if (hImc != 0 && (lParam & GCS_COMPCLAUSE) != 0)
			{
				const int clauseDataSizeBytes = ImmGetCompositionString (hImc, GCS_COMPCLAUSE, 0, 0);

				if (clauseDataSizeBytes > 0)
				{
					const size_t numItems = clauseDataSizeBytes / sizeof (uint32);
					HeapBlock<uint32> clauseData (numItems);

					if (ImmGetCompositionString (hImc, GCS_COMPCLAUSE, clauseData, (DWORD) clauseDataSizeBytes) > 0)
						for (size_t i = 0; i + 1 < numItems; ++i)
							result.add (Range<int> ((int) clauseData [i], (int) clauseData [i + 1]) + compositionRange.getStart());
				}
			}

			return result;
		}

		void moveCandidateWindowToLeftAlignWithSelection (HIMC hImc, ComponentPeer& peer, TextInputTarget* target) const
		{
			Component* const targetComp = dynamic_cast <Component*> (target);

			if (targetComp != nullptr)
			{
				const Rectangle<int> area (peer.getComponent()
											  ->getLocalArea (targetComp, target->getCaretRectangle()));

				CANDIDATEFORM pos = { 0, CFS_CANDIDATEPOS, { area.getX(), area.getBottom() }, { 0, 0, 0, 0 } };
				ImmSetCandidateWindow (hImc, &pos);
			}
		}

		JUCE_DECLARE_NON_COPYABLE (IMEHandler);
	};

	IMEHandler imeHandler;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HWNDComponentPeer);
};

ModifierKeys HWNDComponentPeer::currentModifiers;
ModifierKeys HWNDComponentPeer::modifiersAtLastCallback;

ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
{
	return new HWNDComponentPeer (this, styleFlags, (HWND) nativeWindowToAttachTo);
}

ComponentPeer* createNonRepaintingEmbeddedWindowsPeer (Component* component, void* parent)
{
	HWNDComponentPeer* const p = new HWNDComponentPeer (component, ComponentPeer::windowIgnoresMouseClicks, (HWND) parent);
	p->dontRepaint = true;
	return p;
}

juce_ImplementSingleton_SingleThreaded (HWNDComponentPeer::WindowClassHolder);

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = HWNDComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	HWNDComponentPeer::updateKeyModifiers();

	int mouseMods = 0;
	if (HWNDComponentPeer::isKeyDown (VK_LBUTTON))  mouseMods |= ModifierKeys::leftButtonModifier;
	if (HWNDComponentPeer::isKeyDown (VK_RBUTTON))  mouseMods |= ModifierKeys::rightButtonModifier;
	if (HWNDComponentPeer::isKeyDown (VK_MBUTTON))  mouseMods |= ModifierKeys::middleButtonModifier;

	HWNDComponentPeer::currentModifiers
		= HWNDComponentPeer::currentModifiers.withoutMouseButtons().withFlags (mouseMods);

	return HWNDComponentPeer::currentModifiers;
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	SHORT k = (SHORT) keyCode;

	if ((keyCode & extendedKeyModifier) == 0
		 && (k >= (SHORT) 'a' && k <= (SHORT) 'z'))
		k += (SHORT) 'A' - (SHORT) 'a';

	const SHORT translatedValues[] = { (SHORT) ',', VK_OEM_COMMA,
									   (SHORT) '+', VK_OEM_PLUS,
									   (SHORT) '-', VK_OEM_MINUS,
									   (SHORT) '.', VK_OEM_PERIOD,
									   (SHORT) ';', VK_OEM_1,
									   (SHORT) ':', VK_OEM_1,
									   (SHORT) '/', VK_OEM_2,
									   (SHORT) '?', VK_OEM_2,
									   (SHORT) '[', VK_OEM_4,
									   (SHORT) ']', VK_OEM_6 };

	for (int i = 0; i < numElementsInArray (translatedValues); i += 2)
		if (k == translatedValues [i])
			k = translatedValues [i + 1];

	return HWNDComponentPeer::isKeyDown (k);
}

bool Process::isForegroundProcess()
{
	HWND fg = GetForegroundWindow();

	if (fg == 0)
		return true;

	// when running as a plugin in IE8, the browser UI runs in a different process to the plugin, so
	// process ID isn't a reliable way to check if the foreground window belongs to us - instead, we
	// have to see if any of our windows are children of the foreground window
	fg = GetAncestor (fg, GA_ROOT);

	for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
	{
		HWNDComponentPeer* const wp = dynamic_cast <HWNDComponentPeer*> (ComponentPeer::getPeer (i));

		if (wp != nullptr && wp->isInside (fg))
			return true;
	}

	return false;
}

class WindowsMessageBox  : public AsyncUpdater
{
public:
	WindowsMessageBox (AlertWindow::AlertIconType iconType,
					   const String& title_, const String& message_,
					   Component* associatedComponent,
					   UINT extraFlags,
					   ModalComponentManager::Callback* callback_,
					   const bool runAsync)
		: flags (extraFlags | getMessageBoxFlags (iconType)),
		  owner (getWindowForMessageBox (associatedComponent)),
		  title (title_), message (message_), callback (callback_)
	{
		if (runAsync)
			triggerAsyncUpdate();
	}

	int getResult() const
	{
		const int r = MessageBox (owner, message.toWideCharPointer(), title.toWideCharPointer(), flags);
		return (r == IDYES || r == IDOK) ? 1 : (r == IDNO ? 2 : 0);
	}

	void handleAsyncUpdate()
	{
		const int result = getResult();

		if (callback != nullptr)
			callback->modalStateFinished (result);

		delete this;
	}

private:
	UINT flags;
	HWND owner;
	String title, message;
	ModalComponentManager::Callback* callback;

	static UINT getMessageBoxFlags (AlertWindow::AlertIconType iconType) noexcept
	{
		UINT flags = MB_TASKMODAL | MB_SETFOREGROUND;

		switch (iconType)
		{
			case AlertWindow::QuestionIcon:  flags |= MB_ICONQUESTION; break;
			case AlertWindow::WarningIcon:   flags |= MB_ICONWARNING; break;
			case AlertWindow::InfoIcon:      flags |= MB_ICONINFORMATION; break;
			default: break;
		}

		return flags;
	}

	static HWND getWindowForMessageBox (Component* associatedComponent)
	{
		return associatedComponent != nullptr ? (HWND) associatedComponent->getWindowHandle() : 0;
	}
};

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	WindowsMessageBox box (iconType, title, message, associatedComponent, MB_OK, 0, false);
	(void) box.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	new WindowsMessageBox (iconType, title, message, associatedComponent, MB_OK, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<WindowsMessageBox> mb (new WindowsMessageBox (iconType, title, message, associatedComponent,
																MB_OKCANCEL, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult() != 0;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<WindowsMessageBox> mb (new WindowsMessageBox (iconType, title, message, associatedComponent,
																MB_YESNOCANCEL, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));

	if (canUseMultiTouch())
		for (int i = 1; i <= 10; ++i)
			mouseSources.add (new MouseInputSource (i, false));
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	POINT mousePos;
	GetCursorPos (&mousePos);
	return Point<int> (mousePos.x, mousePos.y);
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	SetCursorPos (newPosition.x, newPosition.y);
}

ImagePixelData* NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
{
	return SoftwareImageType().create (format, width, height, clearImage);
}

class ScreenSaverDefeater   : public Timer
{
public:
	ScreenSaverDefeater()
	{
		startTimer (10000);
		timerCallback();
	}

	void timerCallback()
	{
		if (Process::isForegroundProcess())
		{
			// simulate a shift key getting pressed..
			INPUT input[2];
			input[0].type = INPUT_KEYBOARD;
			input[0].ki.wVk = VK_SHIFT;
			input[0].ki.dwFlags = 0;
			input[0].ki.dwExtraInfo = 0;

			input[1].type = INPUT_KEYBOARD;
			input[1].ki.wVk = VK_SHIFT;
			input[1].ki.dwFlags = KEYEVENTF_KEYUP;
			input[1].ki.dwExtraInfo = 0;

			SendInput (2, input, sizeof (INPUT));
		}
	}
};

static ScopedPointer<ScreenSaverDefeater> screenSaverDefeater;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (isEnabled)
		screenSaverDefeater = nullptr;
	else if (screenSaverDefeater == nullptr)
		screenSaverDefeater = new ScreenSaverDefeater();
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverDefeater == nullptr;
}

/* (The code below is the "correct" way to disable the screen saver, but it
	completely fails on winXP when the saver is password-protected...)

static bool juce_screenSaverEnabled = true;

void Desktop::setScreenSaverEnabled (const bool isEnabled) noexcept
{
	juce_screenSaverEnabled = isEnabled;
	SetThreadExecutionState (isEnabled ? ES_CONTINUOUS
									   : (ES_DISPLAY_REQUIRED | ES_CONTINUOUS));
}

bool Desktop::isScreenSaverEnabled() noexcept
{
	return juce_screenSaverEnabled;
}
*/

void LookAndFeel::playAlertSound()
{
	MessageBeep (MB_OK);
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	if (OpenClipboard (0) != 0)
	{
		if (EmptyClipboard() != 0)
		{
			const size_t bytesNeeded = CharPointer_UTF16::getBytesRequiredFor (text.getCharPointer()) + 4;

			if (bytesNeeded > 0)
			{
				HGLOBAL bufH = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE | GMEM_ZEROINIT, bytesNeeded + sizeof (WCHAR));

				if (bufH != 0)
				{
					WCHAR* const data = static_cast <WCHAR*> (GlobalLock (bufH));

					if (data != nullptr)
					{
						text.copyToUTF16 (data, (int) bytesNeeded);
						GlobalUnlock (bufH);

						SetClipboardData (CF_UNICODETEXT, bufH);
					}
				}
			}
		}

		CloseClipboard();
	}
}

String SystemClipboard::getTextFromClipboard()
{
	String result;

	if (OpenClipboard (0) != 0)
	{
		HANDLE bufH = GetClipboardData (CF_UNICODETEXT);

		if (bufH != 0)
		{
			const WCHAR* const data = (const WCHAR*) GlobalLock (bufH);

			if (data != nullptr)
			{
				result = String (data, (size_t) (GlobalSize (bufH) / sizeof (WCHAR)));
				GlobalUnlock (bufH);
			}
		}

		CloseClipboard();
	}

	return result;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool /*allowMenusAndBars*/)
{
	if (enableOrDisable)
		kioskModeComponent->setBounds (getDisplays().getMainDisplay().totalArea);
}

static BOOL CALLBACK enumMonitorsProc (HMONITOR, HDC, LPRECT r, LPARAM userInfo)
{
	Array <Rectangle<int> >* const monitorCoords = (Array <Rectangle<int> >*) userInfo;
	monitorCoords->add (rectangleFromRECT (*r));
	return TRUE;
}

void Desktop::Displays::findDisplays()
{
	Array <Rectangle<int> > monitors;
	EnumDisplayMonitors (0, 0, &enumMonitorsProc, (LPARAM) &monitors);

	// make sure the first in the list is the main monitor
	for (int i = 1; i < monitors.size(); ++i)
		if (monitors.getReference(i).getX() == 0 && monitors.getReference(i).getY() == 0)
			monitors.swap (i, 0);

	if (monitors.size() == 0)
	{
		RECT r;
		GetWindowRect (GetDesktopWindow(), &r);
		monitors.add (rectangleFromRECT (r));
	}

	RECT workArea;
	SystemParametersInfo (SPI_GETWORKAREA, 0, &workArea, 0);

	for (int i = 0; i < monitors.size(); ++i)
	{
		Display d;
		d.userArea = d.totalArea = monitors.getReference(i);
		d.isMain = (i == 0);
		d.scale = 1.0;

		if (i == 0)
			d.userArea = d.userArea.getIntersection (rectangleFromRECT (workArea));

		displays.add (d);
	}
}

static HICON extractFileHICON (const File& file)
{
	WORD iconNum = 0;
	WCHAR name [MAX_PATH * 2];
	file.getFullPathName().copyToUTF16 (name, sizeof (name));

	return ExtractAssociatedIcon ((HINSTANCE) Process::getCurrentModuleInstanceHandle(),
								  name, &iconNum);
}

Image juce_createIconForFile (const File& file)
{
	Image image;
	HICON icon = extractFileHICON (file);

	if (icon != 0)
	{
		image = IconConverters::createImageFromHICON (icon);
		DestroyIcon (icon);
	}

	return image;
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	const int maxW = GetSystemMetrics (SM_CXCURSOR);
	const int maxH = GetSystemMetrics (SM_CYCURSOR);

	Image im (image);

	if (im.getWidth() > maxW || im.getHeight() > maxH)
	{
		im = im.rescaled (maxW, maxH);

		hotspotX = (hotspotX * maxW) / image.getWidth();
		hotspotY = (hotspotY * maxH) / image.getHeight();
	}

	return IconConverters::createHICONFromImage (im, FALSE, hotspotX, hotspotY);
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool isStandard)
{
	if (cursorHandle != nullptr && ! isStandard)
		DestroyCursor ((HCURSOR) cursorHandle);
}

enum
{
	hiddenMouseCursorHandle = 32500 // (arbitrary non-zero value to mark this type of cursor)
};

void* MouseCursor::createStandardMouseCursor (const MouseCursor::StandardCursorType type)
{
	LPCTSTR cursorName = IDC_ARROW;

	switch (type)
	{
		case NormalCursor:                  break;
		case NoCursor:                      return (void*) hiddenMouseCursorHandle;
		case WaitCursor:                    cursorName = IDC_WAIT; break;
		case IBeamCursor:                   cursorName = IDC_IBEAM; break;
		case PointingHandCursor:            cursorName = MAKEINTRESOURCE(32649); break;
		case CrosshairCursor:               cursorName = IDC_CROSS; break;
		case CopyingCursor:                 break; // can't seem to find one of these in the system list..

		case LeftRightResizeCursor:
		case LeftEdgeResizeCursor:
		case RightEdgeResizeCursor:         cursorName = IDC_SIZEWE; break;

		case UpDownResizeCursor:
		case TopEdgeResizeCursor:
		case BottomEdgeResizeCursor:        cursorName = IDC_SIZENS; break;

		case TopLeftCornerResizeCursor:
		case BottomRightCornerResizeCursor: cursorName = IDC_SIZENWSE; break;

		case TopRightCornerResizeCursor:
		case BottomLeftCornerResizeCursor:  cursorName = IDC_SIZENESW; break;

		case UpDownLeftRightResizeCursor:   cursorName = IDC_SIZEALL; break;

		case DraggingHandCursor:
		{
			static void* dragHandCursor = nullptr;

			if (dragHandCursor == nullptr)
			{
				static const unsigned char dragHandData[] =
					{ 71,73,70,56,57,97,16,0,16,0,145,2,0,0,0,0,255,255,255,0,0,0,0,0,0,33,249,4,1,0,0,2,0,44,0,0,0,0,16,0,
					  16,0,0,2,52,148,47,0,200,185,16,130,90,12,74,139,107,84,123,39,132,117,151,116,132,146,248,60,209,138,
					  98,22,203,114,34,236,37,52,77,217,247,154,191,119,110,240,193,128,193,95,163,56,60,234,98,135,2,0,59 };

				dragHandCursor = createMouseCursorFromImage (ImageFileFormat::loadFrom (dragHandData, sizeof (dragHandData)), 8, 7);
			}

			return dragHandCursor;
		}

		default:
			jassertfalse; break;
	}

	HCURSOR cursorH = LoadCursor (0, cursorName);

	if (cursorH == 0)
		cursorH = LoadCursor (0, IDC_ARROW);

	return cursorH;
}

void MouseCursor::showInWindow (ComponentPeer*) const
{
	HCURSOR c = (HCURSOR) getHandle();

	if (c == 0)
		c = LoadCursor (0, IDC_ARROW);
	else if (c == (HCURSOR) hiddenMouseCursorHandle)
		c = 0;

	SetCursor (c);
}

void MouseCursor::showInAllWindows() const
{
	showInWindow (nullptr);
}

/*** End of inlined file: juce_win32_Windowing.cpp ***/


/*** Start of inlined file: juce_win32_DragAndDrop.cpp ***/
namespace DragAndDropHelpers
{

	class JuceDropSource   : public ComBaseClassHelper <IDropSource>
	{
	public:
		JuceDropSource() {}

		JUCE_COMRESULT QueryContinueDrag (BOOL escapePressed, DWORD keys)
		{
			if (escapePressed)
				return DRAGDROP_S_CANCEL;

			if ((keys & (MK_LBUTTON | MK_RBUTTON)) == 0)
				return DRAGDROP_S_DROP;

			return S_OK;
		}

		JUCE_COMRESULT GiveFeedback (DWORD)
		{
			return DRAGDROP_S_USEDEFAULTCURSORS;
		}
	};

	class JuceEnumFormatEtc   : public ComBaseClassHelper <IEnumFORMATETC>
	{
	public:
		JuceEnumFormatEtc (const FORMATETC* const format_)
			: format (format_),
			  index (0)
		{
		}

		JUCE_COMRESULT Clone (IEnumFORMATETC** result)
		{
			if (result == 0)
				return E_POINTER;

			JuceEnumFormatEtc* const newOne = new JuceEnumFormatEtc (format);
			newOne->index = index;

			*result = newOne;
			return S_OK;
		}

		JUCE_COMRESULT Next (ULONG celt, LPFORMATETC lpFormatEtc, ULONG* pceltFetched)
		{
			if (pceltFetched != nullptr)
				*pceltFetched = 0;
			else if (celt != 1)
				return S_FALSE;

			if (index == 0 && celt > 0 && lpFormatEtc != 0)
			{
				copyFormatEtc (lpFormatEtc [0], *format);
				++index;

				if (pceltFetched != nullptr)
					*pceltFetched = 1;

				return S_OK;
			}

			return S_FALSE;
		}

		JUCE_COMRESULT Skip (ULONG celt)
		{
			if (index + (int) celt >= 1)
				return S_FALSE;

			index += celt;
			return S_OK;
		}

		JUCE_COMRESULT Reset()
		{
			index = 0;
			return S_OK;
		}

	private:
		const FORMATETC* const format;
		int index;

		static void copyFormatEtc (FORMATETC& dest, const FORMATETC& source)
		{
			dest = source;

			if (source.ptd != 0)
			{
				dest.ptd = (DVTARGETDEVICE*) CoTaskMemAlloc (sizeof (DVTARGETDEVICE));
				*(dest.ptd) = *(source.ptd);
			}
		}

		JUCE_DECLARE_NON_COPYABLE (JuceEnumFormatEtc);
	};

	class JuceDataObject  : public ComBaseClassHelper <IDataObject>
	{
	public:
		JuceDataObject (JuceDropSource* const dropSource_,
						const FORMATETC* const format_,
						const STGMEDIUM* const medium_)
			: dropSource (dropSource_),
			  format (format_),
			  medium (medium_)
		{
		}

		~JuceDataObject()
		{
			jassert (refCount == 0);
		}

		JUCE_COMRESULT GetData (FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
		{
			if ((pFormatEtc->tymed & format->tymed) != 0
				 && pFormatEtc->cfFormat == format->cfFormat
				 && pFormatEtc->dwAspect == format->dwAspect)
			{
				pMedium->tymed = format->tymed;
				pMedium->pUnkForRelease = 0;

				if (format->tymed == TYMED_HGLOBAL)
				{
					const SIZE_T len = GlobalSize (medium->hGlobal);
					void* const src = GlobalLock (medium->hGlobal);
					void* const dst = GlobalAlloc (GMEM_FIXED, len);

					memcpy (dst, src, len);

					GlobalUnlock (medium->hGlobal);

					pMedium->hGlobal = dst;
					return S_OK;
				}
			}

			return DV_E_FORMATETC;
		}

		JUCE_COMRESULT QueryGetData (FORMATETC* f)
		{
			if (f == 0)
				return E_INVALIDARG;

			if (f->tymed == format->tymed
				  && f->cfFormat == format->cfFormat
				  && f->dwAspect == format->dwAspect)
				return S_OK;

			return DV_E_FORMATETC;
		}

		JUCE_COMRESULT GetCanonicalFormatEtc (FORMATETC*, FORMATETC* pFormatEtcOut)
		{
			pFormatEtcOut->ptd = 0;
			return E_NOTIMPL;
		}

		JUCE_COMRESULT EnumFormatEtc (DWORD direction, IEnumFORMATETC** result)
		{
			if (result == 0)
				return E_POINTER;

			if (direction == DATADIR_GET)
			{
				*result = new JuceEnumFormatEtc (format);
				return S_OK;
			}

			*result = 0;
			return E_NOTIMPL;
		}

		JUCE_COMRESULT GetDataHere (FORMATETC*, STGMEDIUM*)                  { return DATA_E_FORMATETC; }
		JUCE_COMRESULT SetData (FORMATETC*, STGMEDIUM*, BOOL)                { return E_NOTIMPL; }
		JUCE_COMRESULT DAdvise (FORMATETC*, DWORD, IAdviseSink*, DWORD*)     { return OLE_E_ADVISENOTSUPPORTED; }
		JUCE_COMRESULT DUnadvise (DWORD)                                     { return E_NOTIMPL; }
		JUCE_COMRESULT EnumDAdvise (IEnumSTATDATA**)                         { return OLE_E_ADVISENOTSUPPORTED; }

	private:
		JuceDropSource* const dropSource;
		const FORMATETC* const format;
		const STGMEDIUM* const medium;

		JUCE_DECLARE_NON_COPYABLE (JuceDataObject);
	};

	HDROP createHDrop (const StringArray& fileNames)
	{
		int totalBytes = 0;
		for (int i = fileNames.size(); --i >= 0;)
			totalBytes += (int) CharPointer_UTF16::getBytesRequiredFor (fileNames[i].getCharPointer()) + sizeof (WCHAR);

		HDROP hDrop = (HDROP) GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (DROPFILES) + totalBytes + 4);

		if (hDrop != 0)
		{
			LPDROPFILES pDropFiles = (LPDROPFILES) GlobalLock (hDrop);
			pDropFiles->pFiles = sizeof (DROPFILES);
			pDropFiles->fWide = true;

			WCHAR* fname = reinterpret_cast<WCHAR*> (addBytesToPointer (pDropFiles, sizeof (DROPFILES)));

			for (int i = 0; i < fileNames.size(); ++i)
			{
				const int bytesWritten = fileNames[i].copyToUTF16 (fname, 2048);
				fname = reinterpret_cast<WCHAR*> (addBytesToPointer (fname, bytesWritten));
			}

			*fname = 0;

			GlobalUnlock (hDrop);
		}

		return hDrop;
	}

	bool performDragDrop (FORMATETC* const format, STGMEDIUM* const medium, const DWORD whatToDo)
	{
		JuceDropSource* const source = new JuceDropSource();
		JuceDataObject* const data = new JuceDataObject (source, format, medium);

		DWORD effect;
		const HRESULT res = DoDragDrop (data, source, whatToDo, &effect);

		data->Release();
		source->Release();

		return res == DRAGDROP_S_DROP;
	}
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMove)
{
	FORMATETC format = { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

	medium.hGlobal = DragAndDropHelpers::createHDrop (files);

	return DragAndDropHelpers::performDragDrop (&format, &medium, canMove ? (DWORD) (DROPEFFECT_COPY | DROPEFFECT_MOVE)
																		  : (DWORD) DROPEFFECT_COPY);
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	FORMATETC format = { CF_TEXT, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

	const size_t numBytes = CharPointer_UTF16::getBytesRequiredFor (text.getCharPointer());

	medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, numBytes + 2);
	WCHAR* const data = static_cast <WCHAR*> (GlobalLock (medium.hGlobal));

	text.copyToUTF16 (data, (int) numBytes);
	format.cfFormat = CF_UNICODETEXT;

	GlobalUnlock (medium.hGlobal);

	return DragAndDropHelpers::performDragDrop (&format, &medium, DROPEFFECT_COPY | DROPEFFECT_MOVE);
}

/*** End of inlined file: juce_win32_DragAndDrop.cpp ***/


/*** Start of inlined file: juce_win32_FileChooser.cpp ***/
namespace FileChooserHelpers
{
	static bool areThereAnyAlwaysOnTopWindows()
	{
		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			Component* const c = Desktop::getInstance().getComponent (i);

			if (c != nullptr && c->isAlwaysOnTop() && c->isShowing())
				return true;
		}

		return false;
	}

	struct FileChooserCallbackInfo
	{
		String initialPath;
		String returnedString; // need this to get non-existent pathnames from the directory chooser
		ScopedPointer<Component> customComponent;
	};

	static int CALLBACK browseCallbackProc (HWND hWnd, UINT msg, LPARAM lParam, LPARAM lpData)
	{
		FileChooserCallbackInfo* info = (FileChooserCallbackInfo*) lpData;

		if (msg == BFFM_INITIALIZED)
			SendMessage (hWnd, BFFM_SETSELECTIONW, TRUE, (LPARAM) info->initialPath.toWideCharPointer());
		else if (msg == BFFM_VALIDATEFAILEDW)
			info->returnedString = (LPCWSTR) lParam;
		else if (msg == BFFM_VALIDATEFAILEDA)
			info->returnedString = (const char*) lParam;

		return 0;
	}

	static UINT_PTR CALLBACK openCallback (HWND hdlg, UINT uiMsg, WPARAM /*wParam*/, LPARAM lParam)
	{
		if (uiMsg == WM_INITDIALOG)
		{
			Component* customComp = ((FileChooserCallbackInfo*) (((OPENFILENAMEW*) lParam)->lCustData))->customComponent;

			HWND dialogH = GetParent (hdlg);
			jassert (dialogH != 0);
			if (dialogH == 0)
				dialogH = hdlg;

			RECT r, cr;
			GetWindowRect (dialogH, &r);
			GetClientRect (dialogH, &cr);

			SetWindowPos (dialogH, 0,
						  r.left, r.top,
						  customComp->getWidth() + jmax (150, (int) (r.right - r.left)),
						  jmax (150, (int) (r.bottom - r.top)),
						  SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

			customComp->setBounds (cr.right, cr.top, customComp->getWidth(), cr.bottom - cr.top);
			customComp->addToDesktop (0, dialogH);
		}
		else if (uiMsg == WM_NOTIFY)
		{
			LPOFNOTIFY ofn = (LPOFNOTIFY) lParam;

			if (ofn->hdr.code == CDN_SELCHANGE)
			{
				FileChooserCallbackInfo* info = (FileChooserCallbackInfo*) ofn->lpOFN->lCustData;
				FilePreviewComponent* comp = dynamic_cast<FilePreviewComponent*> (info->customComponent->getChildComponent(0));

				if (comp != nullptr)
				{
					WCHAR path [MAX_PATH * 2] = { 0 };
					CommDlg_OpenSave_GetFilePath (GetParent (hdlg), (LPARAM) &path, MAX_PATH);

					comp->selectedFileChanged (File (path));
				}
			}
		}

		return 0;
	}

	class CustomComponentHolder  : public Component
	{
	public:
		CustomComponentHolder (Component* const customComp)
		{
			setVisible (true);
			setOpaque (true);
			addAndMakeVisible (customComp);
			setSize (jlimit (20, 800, customComp->getWidth()), customComp->getHeight());
		}

		void paint (Graphics& g)
		{
			g.fillAll (Colours::lightgrey);
		}

		void resized()
		{
			Component* const c = getChildComponent(0);
			if (c != nullptr)
				c->setBounds (getLocalBounds());
		}

	private:
		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CustomComponentHolder);
	};
}

bool FileChooser::isPlatformDialogAvailable()
{
	return true;
}

void FileChooser::showPlatformDialog (Array<File>& results, const String& title_, const File& currentFileOrDirectory,
									  const String& filter, bool selectsDirectory, bool /*selectsFiles*/,
									  bool isSaveDialogue, bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles, FilePreviewComponent* extraInfoComponent)
{
	using namespace FileChooserHelpers;

	const String title (title_);
	HeapBlock<WCHAR> files;
	const int charsAvailableForResult = 32768;
	files.calloc (charsAvailableForResult + 1);
	int filenameOffset = 0;

	FileChooserCallbackInfo info;

	// use a modal window as the parent for this dialog box
	// to block input from other app windows
	Component parentWindow (String::empty);
	const Rectangle<int> mainMon (Desktop::getInstance().getDisplays().getMainDisplay().userArea);
	parentWindow.setBounds (mainMon.getX() + mainMon.getWidth() / 4,
							mainMon.getY() + mainMon.getHeight() / 4,
							0, 0);
	parentWindow.setOpaque (true);
	parentWindow.setAlwaysOnTop (areThereAnyAlwaysOnTopWindows());
	parentWindow.addToDesktop (0);

	if (extraInfoComponent == nullptr)
		parentWindow.enterModalState();

	if (currentFileOrDirectory.isDirectory())
	{
		info.initialPath = currentFileOrDirectory.getFullPathName();
	}
	else
	{
		currentFileOrDirectory.getFileName().copyToUTF16 (files, charsAvailableForResult * sizeof (WCHAR));
		info.initialPath = currentFileOrDirectory.getParentDirectory().getFullPathName();
	}

	if (selectsDirectory)
	{
		BROWSEINFO bi = { 0 };
		bi.hwndOwner = (HWND) parentWindow.getWindowHandle();
		bi.pszDisplayName = files;
		bi.lpszTitle = title.toWideCharPointer();
		bi.lParam = (LPARAM) &info;
		bi.lpfn = browseCallbackProc;
	   #ifdef BIF_USENEWUI
		bi.ulFlags = BIF_USENEWUI | BIF_VALIDATE;
	   #else
		bi.ulFlags = 0x50;
	   #endif

		LPITEMIDLIST list = SHBrowseForFolder (&bi);

		if (! SHGetPathFromIDListW (list, files))
		{
			files[0] = 0;
			info.returnedString = String::empty;
		}

		LPMALLOC al;
		if (list != 0 && SUCCEEDED (SHGetMalloc (&al)))
			al->Free (list);

		if (info.returnedString.isNotEmpty())
		{
			results.add (File (String (files)).getSiblingFile (info.returnedString));
			return;
		}
	}
	else
	{
		DWORD flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR | OFN_HIDEREADONLY;

		if (warnAboutOverwritingExistingFiles)
			flags |= OFN_OVERWRITEPROMPT;

		if (selectMultipleFiles)
			flags |= OFN_ALLOWMULTISELECT;

		if (extraInfoComponent != nullptr)
		{
			flags |= OFN_ENABLEHOOK;

			info.customComponent = new CustomComponentHolder (extraInfoComponent);
			info.customComponent->enterModalState();
		}

		const int filterSpaceNumChars = 2048;
		HeapBlock<WCHAR> filters;
		filters.calloc (filterSpaceNumChars);
		const int bytesWritten = filter.copyToUTF16 (filters.getData(), filterSpaceNumChars * sizeof (WCHAR));
		filter.copyToUTF16 (filters + (bytesWritten / sizeof (WCHAR)),
							(int) ((filterSpaceNumChars - 1) * sizeof (WCHAR) - bytesWritten));

		OPENFILENAMEW of = { 0 };
		String localPath (info.initialPath);

	   #ifdef OPENFILENAME_SIZE_VERSION_400W
		of.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
	   #else
		of.lStructSize = sizeof (of);
	   #endif
		of.hwndOwner = (HWND) parentWindow.getWindowHandle();
		of.lpstrFilter = filters.getData();
		of.nFilterIndex = 1;
		of.lpstrFile = files;
		of.nMaxFile = charsAvailableForResult;
		of.lpstrInitialDir = localPath.toWideCharPointer();
		of.lpstrTitle = title.toWideCharPointer();
		of.Flags = flags;
		of.lCustData = (LPARAM) &info;

		if (extraInfoComponent != nullptr)
			of.lpfnHook = &openCallback;

		if (! (isSaveDialogue ? GetSaveFileName (&of)
							  : GetOpenFileName (&of)))
			return;

		filenameOffset = of.nFileOffset;
	}

	if (selectMultipleFiles && filenameOffset > 0 && files [filenameOffset - 1] == 0)
	{
		const WCHAR* filename = files + filenameOffset;

		while (*filename != 0)
		{
			results.add (File (String (files) + "\\" + String (filename)));
			filename += wcslen (filename) + 1;
		}
	}
	else if (files[0] != 0)
	{
		results.add (File (String (files)));
	}
}

/*** End of inlined file: juce_win32_FileChooser.cpp ***/

#elif JUCE_LINUX

/*** Start of inlined file: juce_linux_Clipboard.cpp ***/
extern Display* display;
extern Window juce_messageWindowHandle;

namespace ClipboardHelpers
{
	static String localClipboardContent;
	static Atom   atom_UTF8_STRING;
	static Atom   atom_CLIPBOARD;
	static Atom   atom_TARGETS;

	void initSelectionAtoms()
	{
		static bool isInitialised = false;
		if (! isInitialised)
		{
			atom_UTF8_STRING = XInternAtom (display, "UTF8_STRING", False);
			atom_CLIPBOARD   = XInternAtom (display, "CLIPBOARD", False);
			atom_TARGETS     = XInternAtom (display, "TARGETS", False);
		}
	}

	// Read the content of a window property as either a locale-dependent string or an utf8 string
	// works only for strings shorter than 1000000 bytes
	String readWindowProperty (Window window, Atom prop, Atom fmt)
	{
		String returnData;
		char* clipData;
		Atom actualType;
		int  actualFormat;
		unsigned long numItems, bytesLeft;

		if (XGetWindowProperty (display, window, prop,
								0L /* offset */, 1000000 /* length (max) */, False,
								AnyPropertyType /* format */,
								&actualType, &actualFormat, &numItems, &bytesLeft,
								(unsigned char**) &clipData) == Success)
		{
			if (actualType == atom_UTF8_STRING && actualFormat == 8)
				returnData = String::fromUTF8 (clipData, numItems);
			else if (actualType == XA_STRING && actualFormat == 8)
				returnData = String (clipData, numItems);

			if (clipData != nullptr)
				XFree (clipData);

			jassert (bytesLeft == 0 || numItems == 1000000);
		}

		XDeleteProperty (display, window, prop);
		return returnData;
	}

	// Send a SelectionRequest to the window owning the selection and waits for its answer (with a timeout) */
	bool requestSelectionContent (String& selectionContent, Atom selection, Atom requestedFormat)
	{
		Atom property_name = XInternAtom (display, "JUCE_SEL", false);

		// The selection owner will be asked to set the JUCE_SEL property on the
		// juce_messageWindowHandle with the selection content
		XConvertSelection (display, selection, requestedFormat, property_name,
						   juce_messageWindowHandle, CurrentTime);

		int count = 50; // will wait at most for 200 ms

		while (--count >= 0)
		{
			XEvent event;
			if (XCheckTypedWindowEvent (display, juce_messageWindowHandle, SelectionNotify, &event))
			{
				if (event.xselection.property == property_name)
				{
					jassert (event.xselection.requestor == juce_messageWindowHandle);

					selectionContent = readWindowProperty (event.xselection.requestor,
														   event.xselection.property,
														   requestedFormat);
					return true;
				}
				else
				{
					return false; // the format we asked for was denied.. (event.xselection.property == None)
				}
			}

			// not very elegant.. we could do a select() or something like that...
			// however clipboard content requesting is inherently slow on x11, it
			// often takes 50ms or more so...
			Thread::sleep (4);
		}

		return false;
	}
}

// Called from the event loop in juce_linux_Messaging in response to SelectionRequest events
void juce_handleSelectionRequest (XSelectionRequestEvent &evt)
{
	ClipboardHelpers::initSelectionAtoms();

	// the selection content is sent to the target window as a window property
	XSelectionEvent reply;
	reply.type = SelectionNotify;
	reply.display = evt.display;
	reply.requestor = evt.requestor;
	reply.selection = evt.selection;
	reply.target = evt.target;
	reply.property = None; // == "fail"
	reply.time = evt.time;

	HeapBlock <char> data;
	int propertyFormat = 0, numDataItems = 0;

	if (evt.selection == XA_PRIMARY || evt.selection == ClipboardHelpers::atom_CLIPBOARD)
	{
		if (evt.target == XA_STRING || evt.target == ClipboardHelpers::atom_UTF8_STRING)
		{
			// translate to utf8
			numDataItems = ClipboardHelpers::localClipboardContent.getNumBytesAsUTF8() + 1;
			data.calloc (numDataItems + 1);
			ClipboardHelpers::localClipboardContent.copyToUTF8 (data, numDataItems);
			propertyFormat = 8; // bits/item
		}
		else if (evt.target == ClipboardHelpers::atom_TARGETS)
		{
			// another application wants to know what we are able to send
			numDataItems = 2;
			propertyFormat = 32; // atoms are 32-bit
			data.calloc (numDataItems * 4);
			Atom* atoms = reinterpret_cast<Atom*> (data.getData());
			atoms[0] = ClipboardHelpers::atom_UTF8_STRING;
			atoms[1] = XA_STRING;

			evt.target = XA_ATOM;
		}
	}
	else
	{
		DBG ("requested unsupported clipboard");
	}

	if (data != nullptr)
	{
		const int maxReasonableSelectionSize = 1000000;

		// for very big chunks of data, we should use the "INCR" protocol , which is a pain in the *ss
		if (evt.property != None && numDataItems < maxReasonableSelectionSize)
		{
			XChangeProperty (evt.display, evt.requestor,
							 evt.property, evt.target,
							 propertyFormat /* 8 or 32 */, PropModeReplace,
							 reinterpret_cast<const unsigned char*> (data.getData()), numDataItems);
			reply.property = evt.property; // " == success"
		}
	}

	XSendEvent (evt.display, evt.requestor, 0, NoEventMask, (XEvent*) &reply);
}

void SystemClipboard::copyTextToClipboard (const String& clipText)
{
	ClipboardHelpers::initSelectionAtoms();
	ClipboardHelpers::localClipboardContent = clipText;

	XSetSelectionOwner (display, XA_PRIMARY, juce_messageWindowHandle, CurrentTime);
	XSetSelectionOwner (display, ClipboardHelpers::atom_CLIPBOARD, juce_messageWindowHandle, CurrentTime);
}

String SystemClipboard::getTextFromClipboard()
{
	ClipboardHelpers::initSelectionAtoms();

	/* 1) try to read from the "CLIPBOARD" selection first (the "high
	   level" clipboard that is supposed to be filled by ctrl-C
	   etc). When a clipboard manager is running, the content of this
	   selection is preserved even when the original selection owner
	   exits.

	   2) and then try to read from "PRIMARY" selection (the "legacy" selection
	   filled by good old x11 apps such as xterm)
	*/
	String content;
	Atom selection = XA_PRIMARY;
	Window selectionOwner = None;

	if ((selectionOwner = XGetSelectionOwner (display, selection)) == None)
	{
		selection = ClipboardHelpers::atom_CLIPBOARD;
		selectionOwner = XGetSelectionOwner (display, selection);
	}

	if (selectionOwner != None)
	{
		if (selectionOwner == juce_messageWindowHandle)
		{
			content = ClipboardHelpers::localClipboardContent;
		}
		else
		{
			// first try: we want an utf8 string
			bool ok = ClipboardHelpers::requestSelectionContent (content, selection, ClipboardHelpers::atom_UTF8_STRING);

			if (! ok)
			{
				// second chance, ask for a good old locale-dependent string ..
				ok = ClipboardHelpers::requestSelectionContent (content, selection, XA_STRING);
			}
		}
	}

	return content;
}

/*** End of inlined file: juce_linux_Clipboard.cpp ***/



/*** Start of inlined file: juce_linux_Windowing.cpp ***/
extern Display* display;
extern XContext windowHandleXContext;

namespace Atoms
{
	enum ProtocolItems
	{
		TAKE_FOCUS = 0,
		DELETE_WINDOW = 1,
		PING = 2
	};

	static Atom Protocols, ProtocolList[3], ChangeState, State,
				ActiveWin, Pid, WindowType, WindowState,
				XdndAware, XdndEnter, XdndLeave, XdndPosition, XdndStatus,
				XdndDrop, XdndFinished, XdndSelection, XdndTypeList, XdndActionList,
				XdndActionDescription, XdndActionCopy,
				allowedActions[5],
				allowedMimeTypes[2];

	const unsigned long DndVersion = 3;

	Atom getIfExists (const char* name)    { return XInternAtom (display, name, True); }
	Atom getCreating (const char* name)    { return XInternAtom (display, name, False); }

	void initialiseAtoms()
	{
		static bool atomsInitialised = false;

		if (! atomsInitialised)
		{
			atomsInitialised = true;

			Protocols                       = getIfExists ("WM_PROTOCOLS");
			ProtocolList [TAKE_FOCUS]       = getIfExists ("WM_TAKE_FOCUS");
			ProtocolList [DELETE_WINDOW]    = getIfExists ("WM_DELETE_WINDOW");
			ProtocolList [PING]             = getIfExists ("_NET_WM_PING");
			ChangeState                     = getIfExists ("WM_CHANGE_STATE");
			State                           = getIfExists ("WM_STATE");
			ActiveWin                       = getCreating ("_NET_ACTIVE_WINDOW");
			Pid                             = getCreating ("_NET_WM_PID");
			WindowType                      = getIfExists ("_NET_WM_WINDOW_TYPE");
			WindowState                     = getIfExists ("_NET_WM_STATE");

			XdndAware                       = getCreating ("XdndAware");
			XdndEnter                       = getCreating ("XdndEnter");
			XdndLeave                       = getCreating ("XdndLeave");
			XdndPosition                    = getCreating ("XdndPosition");
			XdndStatus                      = getCreating ("XdndStatus");
			XdndDrop                        = getCreating ("XdndDrop");
			XdndFinished                    = getCreating ("XdndFinished");
			XdndSelection                   = getCreating ("XdndSelection");

			XdndTypeList                    = getCreating ("XdndTypeList");
			XdndActionList                  = getCreating ("XdndActionList");
			XdndActionCopy                  = getCreating ("XdndActionCopy");
			XdndActionDescription           = getCreating ("XdndActionDescription");

			allowedMimeTypes[0]             = getCreating ("text/plain");
			allowedMimeTypes[1]             = getCreating ("text/uri-list");

			allowedActions[0]               = getCreating ("XdndActionMove");
			allowedActions[1]               = XdndActionCopy;
			allowedActions[2]               = getCreating ("XdndActionLink");
			allowedActions[3]               = getCreating ("XdndActionAsk");
			allowedActions[4]               = getCreating ("XdndActionPrivate");
		}
	}
}

namespace Keys
{
	enum MouseButtons
	{
		NoButton = 0,
		LeftButton = 1,
		MiddleButton = 2,
		RightButton = 3,
		WheelUp = 4,
		WheelDown = 5
	};

	static int AltMask = 0;
	static int NumLockMask = 0;
	static bool numLock = false;
	static bool capsLock = false;
	static char keyStates [32];
	static const int extendedKeyModifier = 0x10000000;
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	int keysym;

	if (keyCode & Keys::extendedKeyModifier)
	{
		keysym = 0xff00 | (keyCode & 0xff);
	}
	else
	{
		keysym = keyCode;

		if (keysym == (XK_Tab & 0xff)
			|| keysym == (XK_Return & 0xff)
			|| keysym == (XK_Escape & 0xff)
			|| keysym == (XK_BackSpace & 0xff))
		{
			keysym |= 0xff00;
		}
	}

	ScopedXLock xlock;

	const int keycode = XKeysymToKeycode (display, keysym);

	const int keybyte = keycode >> 3;
	const int keybit = (1 << (keycode & 7));
	return (Keys::keyStates [keybyte] & keybit) != 0;
}

#if JUCE_USE_XSHM
namespace XSHMHelpers
{
	static int trappedErrorCode = 0;
	extern "C" int errorTrapHandler (Display*, XErrorEvent* err)
	{
		trappedErrorCode = err->error_code;
		return 0;
	}

	static bool isShmAvailable() noexcept
	{
		static bool isChecked = false;
		static bool isAvailable = false;

		if (! isChecked)
		{
			isChecked = true;
			int major, minor;
			Bool pixmaps;

			ScopedXLock xlock;

			if (XShmQueryVersion (display, &major, &minor, &pixmaps))
			{
				trappedErrorCode = 0;
				XErrorHandler oldHandler = XSetErrorHandler (errorTrapHandler);

				XShmSegmentInfo segmentInfo = { 0 };
				XImage* xImage = XShmCreateImage (display, DefaultVisual (display, DefaultScreen (display)),
												  24, ZPixmap, 0, &segmentInfo, 50, 50);

				if ((segmentInfo.shmid = shmget (IPC_PRIVATE,
												 xImage->bytes_per_line * xImage->height,
												 IPC_CREAT | 0777)) >= 0)
				{
					segmentInfo.shmaddr = (char*) shmat (segmentInfo.shmid, 0, 0);

					if (segmentInfo.shmaddr != (void*) -1)
					{
						segmentInfo.readOnly = False;
						xImage->data = segmentInfo.shmaddr;
						XSync (display, False);

						if (XShmAttach (display, &segmentInfo) != 0)
						{
							XSync (display, False);
							XShmDetach (display, &segmentInfo);

							isAvailable = true;
						}
					}

					XFlush (display);
					XDestroyImage (xImage);

					shmdt (segmentInfo.shmaddr);
				}

				shmctl (segmentInfo.shmid, IPC_RMID, 0);

				XSetErrorHandler (oldHandler);
				if (trappedErrorCode != 0)
					isAvailable = false;
			}
		}

		return isAvailable;
	}
}
#endif

#if JUCE_USE_XRENDER
namespace XRender
{
	typedef Status (*tXRenderQueryVersion) (Display*, int*, int*);
	typedef XRenderPictFormat* (*tXrenderFindStandardFormat) (Display*, int);
	typedef XRenderPictFormat* (*tXRenderFindFormat) (Display*, unsigned long, XRenderPictFormat*, int);
	typedef XRenderPictFormat* (*tXRenderFindVisualFormat) (Display*, Visual*);

	static tXRenderQueryVersion xRenderQueryVersion = 0;
	static tXrenderFindStandardFormat xRenderFindStandardFormat = 0;
	static tXRenderFindFormat xRenderFindFormat = 0;
	static tXRenderFindVisualFormat xRenderFindVisualFormat = 0;

	static bool isAvailable()
	{
		static bool hasLoaded = false;

		if (! hasLoaded)
		{
			ScopedXLock xlock;
			hasLoaded = true;

			void* h = dlopen ("libXrender.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xRenderQueryVersion         = (tXRenderQueryVersion)        dlsym (h, "XRenderQueryVersion");
				xRenderFindStandardFormat   = (tXrenderFindStandardFormat)  dlsym (h, "XrenderFindStandardFormat");
				xRenderFindFormat           = (tXRenderFindFormat)          dlsym (h, "XRenderFindFormat");
				xRenderFindVisualFormat     = (tXRenderFindVisualFormat)    dlsym (h, "XRenderFindVisualFormat");
			}

			if (xRenderQueryVersion != 0
				 && xRenderFindStandardFormat != 0
				 && xRenderFindFormat != 0
				 && xRenderFindVisualFormat != 0)
			{
				int major, minor;
				if (xRenderQueryVersion (display, &major, &minor))
					return true;
			}

			xRenderQueryVersion = 0;
		}

		return xRenderQueryVersion != 0;
	}

	static XRenderPictFormat* findPictureFormat()
	{
		ScopedXLock xlock;

		XRenderPictFormat* pictFormat = nullptr;

		if (isAvailable())
		{
			pictFormat = xRenderFindStandardFormat (display, PictStandardARGB32);

			if (pictFormat == 0)
			{
				XRenderPictFormat desiredFormat;
				desiredFormat.type = PictTypeDirect;
				desiredFormat.depth = 32;

				desiredFormat.direct.alphaMask = 0xff;
				desiredFormat.direct.redMask = 0xff;
				desiredFormat.direct.greenMask = 0xff;
				desiredFormat.direct.blueMask = 0xff;

				desiredFormat.direct.alpha = 24;
				desiredFormat.direct.red = 16;
				desiredFormat.direct.green = 8;
				desiredFormat.direct.blue = 0;

				pictFormat = xRenderFindFormat (display,
												PictFormatType | PictFormatDepth
												 | PictFormatRedMask | PictFormatRed
												 | PictFormatGreenMask | PictFormatGreen
												 | PictFormatBlueMask | PictFormatBlue
												 | PictFormatAlphaMask | PictFormatAlpha,
												&desiredFormat,
												0);
			}
		}

		return pictFormat;
	}
}
#endif

namespace Visuals
{
	static Visual* findVisualWithDepth (const int desiredDepth) noexcept
	{
		ScopedXLock xlock;

		Visual* visual = nullptr;
		int numVisuals = 0;
		long desiredMask = VisualNoMask;
		XVisualInfo desiredVisual;

		desiredVisual.screen = DefaultScreen (display);
		desiredVisual.depth = desiredDepth;

		desiredMask = VisualScreenMask | VisualDepthMask;

		if (desiredDepth == 32)
		{
			desiredVisual.c_class    = TrueColor;
			desiredVisual.red_mask   = 0x00FF0000;
			desiredVisual.green_mask = 0x0000FF00;
			desiredVisual.blue_mask  = 0x000000FF;
			desiredVisual.bits_per_rgb = 8;

			desiredMask |= VisualClassMask;
			desiredMask |= VisualRedMaskMask;
			desiredMask |= VisualGreenMaskMask;
			desiredMask |= VisualBlueMaskMask;
			desiredMask |= VisualBitsPerRGBMask;
		}

		XVisualInfo* xvinfos = XGetVisualInfo (display,
											   desiredMask,
											   &desiredVisual,
											   &numVisuals);

		if (xvinfos != 0)
		{
			for (int i = 0; i < numVisuals; i++)
			{
				if (xvinfos[i].depth == desiredDepth)
				{
					visual = xvinfos[i].visual;
					break;
				}
			}

			XFree (xvinfos);
		}

		return visual;
	}

	static Visual* findVisualFormat (const int desiredDepth, int& matchedDepth) noexcept
	{
		Visual* visual = nullptr;

		if (desiredDepth == 32)
		{
		   #if JUCE_USE_XSHM
			if (XSHMHelpers::isShmAvailable())
			{
			   #if JUCE_USE_XRENDER
				if (XRender::isAvailable())
				{
					XRenderPictFormat* pictFormat = XRender::findPictureFormat();

					if (pictFormat != 0)
					{
						int numVisuals = 0;
						XVisualInfo desiredVisual;
						desiredVisual.screen = DefaultScreen (display);
						desiredVisual.depth = 32;
						desiredVisual.bits_per_rgb = 8;

						XVisualInfo* xvinfos = XGetVisualInfo (display,
															   VisualScreenMask | VisualDepthMask | VisualBitsPerRGBMask,
															   &desiredVisual, &numVisuals);
						if (xvinfos != 0)
						{
							for (int i = 0; i < numVisuals; ++i)
							{
								XRenderPictFormat* pictVisualFormat = XRender::xRenderFindVisualFormat (display, xvinfos[i].visual);

								if (pictVisualFormat != 0
									 && pictVisualFormat->type == PictTypeDirect
									 && pictVisualFormat->direct.alphaMask)
								{
									visual = xvinfos[i].visual;
									matchedDepth = 32;
									break;
								}
							}

							XFree (xvinfos);
						}
					}
				}
			   #endif
				if (visual == 0)
				{
					visual = findVisualWithDepth (32);
					if (visual != 0)
						matchedDepth = 32;
				}
			}
		   #endif
		}

		if (visual == 0 && desiredDepth >= 24)
		{
			visual = findVisualWithDepth (24);
			if (visual != 0)
				matchedDepth = 24;
		}

		if (visual == 0 && desiredDepth >= 16)
		{
			visual = findVisualWithDepth (16);
			if (visual != 0)
				matchedDepth = 16;
		}

		return visual;
	}
}

class XBitmapImage  : public ImagePixelData
{
public:
	XBitmapImage (const Image::PixelFormat format, const int w, const int h,
				  const bool clearImage, const int imageDepth_, Visual* visual)
		: ImagePixelData (format, w, h),
		  imageDepth (imageDepth_),
		  gc (None)
	{
		jassert (format == Image::RGB || format == Image::ARGB);

		pixelStride = (format == Image::RGB) ? 3 : 4;
		lineStride = ((w * pixelStride + 3) & ~3);

		ScopedXLock xlock;

	   #if JUCE_USE_XSHM
		usingXShm = false;

		if ((imageDepth > 16) && XSHMHelpers::isShmAvailable())
		{
			zerostruct (segmentInfo);

			segmentInfo.shmid = -1;
			segmentInfo.shmaddr = (char *) -1;
			segmentInfo.readOnly = False;

			xImage = XShmCreateImage (display, visual, imageDepth, ZPixmap, 0, &segmentInfo, w, h);

			if (xImage != 0)
			{
				if ((segmentInfo.shmid = shmget (IPC_PRIVATE,
												 xImage->bytes_per_line * xImage->height,
												 IPC_CREAT | 0777)) >= 0)
				{
					if (segmentInfo.shmid != -1)
					{
						segmentInfo.shmaddr = (char*) shmat (segmentInfo.shmid, 0, 0);

						if (segmentInfo.shmaddr != (void*) -1)
						{
							segmentInfo.readOnly = False;

							xImage->data = segmentInfo.shmaddr;
							imageData = (uint8*) segmentInfo.shmaddr;

							if (XShmAttach (display, &segmentInfo) != 0)
								usingXShm = true;
							else
								jassertfalse;
						}
						else
						{
							shmctl (segmentInfo.shmid, IPC_RMID, 0);
						}
					}
				}
			}
		}

		if (! usingXShm)
	   #endif
		{
			imageDataAllocated.allocate (lineStride * h, format == Image::ARGB && clearImage);
			imageData = imageDataAllocated;

			xImage = (XImage*) ::calloc (1, sizeof (XImage));

			xImage->width = w;
			xImage->height = h;
			xImage->xoffset = 0;
			xImage->format = ZPixmap;
			xImage->data = (char*) imageData;
			xImage->byte_order = ImageByteOrder (display);
			xImage->bitmap_unit = BitmapUnit (display);
			xImage->bitmap_bit_order = BitmapBitOrder (display);
			xImage->bitmap_pad = 32;
			xImage->depth = pixelStride * 8;
			xImage->bytes_per_line = lineStride;
			xImage->bits_per_pixel = pixelStride * 8;
			xImage->red_mask   = 0x00FF0000;
			xImage->green_mask = 0x0000FF00;
			xImage->blue_mask  = 0x000000FF;

			if (imageDepth == 16)
			{
				const int pixelStride = 2;
				const int lineStride = ((w * pixelStride + 3) & ~3);

				imageData16Bit.malloc (lineStride * h);
				xImage->data = imageData16Bit;
				xImage->bitmap_pad = 16;
				xImage->depth = pixelStride * 8;
				xImage->bytes_per_line = lineStride;
				xImage->bits_per_pixel = pixelStride * 8;
				xImage->red_mask   = visual->red_mask;
				xImage->green_mask = visual->green_mask;
				xImage->blue_mask  = visual->blue_mask;
			}

			if (! XInitImage (xImage))
				jassertfalse;
		}
	}

	~XBitmapImage()
	{
		ScopedXLock xlock;

		if (gc != None)
			XFreeGC (display, gc);

	   #if JUCE_USE_XSHM
		if (usingXShm)
		{
			XShmDetach (display, &segmentInfo);

			XFlush (display);
			XDestroyImage (xImage);

			shmdt (segmentInfo.shmaddr);
			shmctl (segmentInfo.shmid, IPC_RMID, 0);
		}
		else
	   #endif
		{
			xImage->data = nullptr;
			XDestroyImage (xImage);
		}
	}

	LowLevelGraphicsContext* createLowLevelContext()
	{
		return new LowLevelGraphicsSoftwareRenderer (Image (this));
	}

	void initialiseBitmapData (Image::BitmapData& bitmap, int x, int y, Image::BitmapData::ReadWriteMode)
	{
		bitmap.data = imageData + x * pixelStride + y * lineStride;
		bitmap.pixelFormat = pixelFormat;
		bitmap.lineStride = lineStride;
		bitmap.pixelStride = pixelStride;
	}

	ImagePixelData* clone()
	{
		jassertfalse;
		return nullptr;
	}

	ImageType* createType() const                       { return new NativeImageType(); }

	void blitToWindow (Window window, int dx, int dy, int dw, int dh, int sx, int sy)
	{
		ScopedXLock xlock;

		if (gc == None)
		{
			XGCValues gcvalues;
			gcvalues.foreground = None;
			gcvalues.background = None;
			gcvalues.function = GXcopy;
			gcvalues.plane_mask = AllPlanes;
			gcvalues.clip_mask = None;
			gcvalues.graphics_exposures = False;

			gc = XCreateGC (display, window,
							GCBackground | GCForeground | GCFunction | GCPlaneMask | GCClipMask | GCGraphicsExposures,
							&gcvalues);
		}

		if (imageDepth == 16)
		{
			const uint32 rMask = xImage->red_mask;
			const uint32 rShiftL = jmax (0, getShiftNeeded (rMask));
			const uint32 rShiftR = jmax (0, -getShiftNeeded (rMask));
			const uint32 gMask = xImage->green_mask;
			const uint32 gShiftL = jmax (0, getShiftNeeded (gMask));
			const uint32 gShiftR = jmax (0, -getShiftNeeded (gMask));
			const uint32 bMask = xImage->blue_mask;
			const uint32 bShiftL = jmax (0, getShiftNeeded (bMask));
			const uint32 bShiftR = jmax (0, -getShiftNeeded (bMask));

			const Image::BitmapData srcData (Image (this), Image::BitmapData::readOnly);

			for (int y = sy; y < sy + dh; ++y)
			{
				const uint8* p = srcData.getPixelPointer (sx, y);

				for (int x = sx; x < sx + dw; ++x)
				{
					const PixelRGB* const pixel = (const PixelRGB*) p;
					p += srcData.pixelStride;

					XPutPixel (xImage, x, y,
							   (((((uint32) pixel->getRed()) << rShiftL) >> rShiftR) & rMask)
								 | (((((uint32) pixel->getGreen()) << gShiftL) >> gShiftR) & gMask)
								 | (((((uint32) pixel->getBlue()) << bShiftL) >> bShiftR) & bMask));
				}
			}
		}

		// blit results to screen.
	   #if JUCE_USE_XSHM
		if (usingXShm)
			XShmPutImage (display, (::Drawable) window, gc, xImage, sx, sy, dx, dy, dw, dh, True);
		else
	   #endif
			XPutImage (display, (::Drawable) window, gc, xImage, sx, sy, dx, dy, dw, dh);
	}

private:

	XImage* xImage;
	const int imageDepth;
	HeapBlock <uint8> imageDataAllocated;
	HeapBlock <char> imageData16Bit;
	int pixelStride, lineStride;
	uint8* imageData;
	GC gc;

   #if JUCE_USE_XSHM
	XShmSegmentInfo segmentInfo;
	bool usingXShm;
   #endif

	static int getShiftNeeded (const uint32 mask) noexcept
	{
		for (int i = 32; --i >= 0;)
			if (((mask >> i) & 1) != 0)
				return i - 7;

		jassertfalse;
		return 0;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (XBitmapImage);
};

namespace PixmapHelpers
{
	Pixmap createColourPixmapFromImage (Display* display, const Image& image)
	{
		ScopedXLock xlock;

		const int width = image.getWidth();
		const int height = image.getHeight();
		HeapBlock <uint32> colour (width * height);
		int index = 0;

		for (int y = 0; y < height; ++y)
			for (int x = 0; x < width; ++x)
				colour[index++] = image.getPixelAt (x, y).getARGB();

		XImage* ximage = XCreateImage (display, CopyFromParent, 24, ZPixmap,
									   0, reinterpret_cast<char*> (colour.getData()),
									   width, height, 32, 0);

		Pixmap pixmap = XCreatePixmap (display, DefaultRootWindow (display),
									   width, height, 24);

		GC gc = XCreateGC (display, pixmap, 0, 0);
		XPutImage (display, pixmap, gc, ximage, 0, 0, 0, 0, width, height);
		XFreeGC (display, gc);

		return pixmap;
	}

	Pixmap createMaskPixmapFromImage (Display* display, const Image& image)
	{
		ScopedXLock xlock;

		const int width = image.getWidth();
		const int height = image.getHeight();
		const int stride = (width + 7) >> 3;
		HeapBlock <char> mask;
		mask.calloc (stride * height);
		const bool msbfirst = (BitmapBitOrder (display) == MSBFirst);

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width; ++x)
			{
				const char bit = (char) (1 << (msbfirst ? (7 - (x & 7)) : (x & 7)));
				const int offset = y * stride + (x >> 3);

				if (image.getPixelAt (x, y).getAlpha() >= 128)
					mask[offset] |= bit;
			}
		}

		return XCreatePixmapFromBitmapData (display, DefaultRootWindow (display),
											mask.getData(), width, height, 1, 0, 1);
	}
}

class LinuxComponentPeer  : public ComponentPeer
{
public:
	LinuxComponentPeer (Component* const component, const int windowStyleFlags, Window parentToAddTo)
		: ComponentPeer (component, windowStyleFlags),
		  windowH (0), parentWindow (0),
		  fullScreen (false), mapped (false),
		  visual (0), depth (0)
	{
		// it's dangerous to create a window on a thread other than the message thread..
		jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

		repainter = new LinuxRepaintManager (this);

		createWindow (parentToAddTo);

		setTitle (component->getName());
	}

	~LinuxComponentPeer()
	{
		// it's dangerous to delete a window on a thread other than the message thread..
		jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

		deleteIconPixmaps();

		destroyWindow();

		windowH = 0;
	}

	void* getNativeHandle() const
	{
		return (void*) windowH;
	}

	static LinuxComponentPeer* getPeerFor (Window windowHandle) noexcept
	{
		XPointer peer = nullptr;

		ScopedXLock xlock;
		if (! XFindContext (display, (XID) windowHandle, windowHandleXContext, &peer))
			if (peer != nullptr && ! ComponentPeer::isValidPeer (reinterpret_cast <LinuxComponentPeer*> (peer)))
				peer = nullptr;

		return reinterpret_cast <LinuxComponentPeer*> (peer);
	}

	void setVisible (bool shouldBeVisible)
	{
		ScopedXLock xlock;
		if (shouldBeVisible)
			XMapWindow (display, windowH);
		else
			XUnmapWindow (display, windowH);
	}

	void setTitle (const String& title)
	{
		XTextProperty nameProperty;
		char* strings[] = { const_cast <char*> (title.toUTF8().getAddress()) };
		ScopedXLock xlock;

		if (XStringListToTextProperty (strings, 1, &nameProperty))
		{
			XSetWMName (display, windowH, &nameProperty);
			XSetWMIconName (display, windowH, &nameProperty);

			XFree (nameProperty.value);
		}
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		if (fullScreen && ! isNowFullScreen)
		{
			// When transitioning back from fullscreen, we might need to remove
			// the FULLSCREEN window property
			Atom fs = Atoms::getIfExists ("_NET_WM_STATE_FULLSCREEN");

			if (fs != None)
			{
				Window root = RootWindow (display, DefaultScreen (display));

				XClientMessageEvent clientMsg;
				clientMsg.display = display;
				clientMsg.window = windowH;
				clientMsg.type = ClientMessage;
				clientMsg.format = 32;
				clientMsg.message_type = Atoms::WindowState;
				clientMsg.data.l[0] = 0;  // Remove
				clientMsg.data.l[1] = fs;
				clientMsg.data.l[2] = 0;
				clientMsg.data.l[3] = 1;  // Normal Source

				ScopedXLock xlock;
				XSendEvent (display, root, false,
							SubstructureRedirectMask | SubstructureNotifyMask,
							(XEvent*) &clientMsg);
			}
		}

		fullScreen = isNowFullScreen;

		if (windowH != 0)
		{
			bounds.setBounds (x, y, jmax (1, w), jmax (1, h));

			WeakReference<Component> deletionChecker (component);
			ScopedXLock xlock;

			XSizeHints* const hints = XAllocSizeHints();
			hints->flags  = USSize | USPosition;
			hints->x      = bounds.getX();
			hints->y      = bounds.getY();
			hints->width  = bounds.getWidth();
			hints->height = bounds.getHeight();

			if ((getStyleFlags() & (windowHasTitleBar | windowIsResizable)) == windowHasTitleBar)
			{
				hints->min_width  = hints->max_width  = hints->width;
				hints->min_height = hints->max_height = hints->height;
				hints->flags |= PMinSize | PMaxSize;
			}

			XSetWMNormalHints (display, windowH, hints);
			XFree (hints);

			XMoveResizeWindow (display, windowH,
							   bounds.getX() - windowBorder.getLeft(),
							   bounds.getY() - windowBorder.getTop(),
							   bounds.getWidth(),
							   bounds.getHeight());

			if (deletionChecker != nullptr)
			{
				updateBorderSize();
				handleMovedOrResized();
			}
		}
	}

	void setPosition (int x, int y)           { setBounds (x, y, bounds.getWidth(), bounds.getHeight(), false); }
	void setSize (int w, int h)               { setBounds (bounds.getX(), bounds.getY(), w, h, false); }
	Rectangle<int> getBounds() const          { return bounds; }
	Point<int> getScreenPosition() const      { return bounds.getPosition(); }

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setAlpha (float newAlpha)
	{
		//xxx todo!
	}

	void setMinimised (bool shouldBeMinimised)
	{
		if (shouldBeMinimised)
		{
			Window root = RootWindow (display, DefaultScreen (display));

			XClientMessageEvent clientMsg;
			clientMsg.display = display;
			clientMsg.window = windowH;
			clientMsg.type = ClientMessage;
			clientMsg.format = 32;
			clientMsg.message_type = Atoms::ChangeState;
			clientMsg.data.l[0] = IconicState;

			ScopedXLock xlock;
			XSendEvent (display, root, false, SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*) &clientMsg);
		}
		else
		{
			setVisible (true);
		}
	}

	bool isMinimised() const
	{
		bool minimised = false;

		unsigned char* stateProp;
		unsigned long nitems, bytesLeft;
		Atom actualType;
		int actualFormat;

		ScopedXLock xlock;
		if (XGetWindowProperty (display, windowH, Atoms::State, 0, 64, False,
								Atoms::State, &actualType, &actualFormat, &nitems, &bytesLeft,
								&stateProp) == Success
			&& actualType == Atoms::State
			&& actualFormat == 32
			&& nitems > 0)
		{
			if (((unsigned long*) stateProp)[0] == IconicState)
				minimised = true;

			XFree (stateProp);
		}

		return minimised;
	}

	void setFullScreen (const bool shouldBeFullScreen)
	{
		Rectangle<int> r (lastNonFullscreenBounds); // (get a copy of this before de-minimising)

		setMinimised (false);

		if (fullScreen != shouldBeFullScreen)
		{
			if (shouldBeFullScreen)
				r = Desktop::getInstance().getDisplays().getMainDisplay().userArea;

			if (! r.isEmpty())
				setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

			getComponent()->repaint();
		}
	}

	bool isFullScreen() const
	{
		return fullScreen;
	}

	bool isChildWindowOf (Window possibleParent) const
	{
		Window* windowList = nullptr;
		uint32 windowListSize = 0;
		Window parent, root;

		ScopedXLock xlock;
		if (XQueryTree (display, windowH, &root, &parent, &windowList, &windowListSize) != 0)
		{
			if (windowList != 0)
				XFree (windowList);

			return parent == possibleParent;
		}

		return false;
	}

	bool isFrontWindow() const
	{
		Window* windowList = nullptr;
		uint32 windowListSize = 0;
		bool result = false;

		ScopedXLock xlock;
		Window parent, root = RootWindow (display, DefaultScreen (display));

		if (XQueryTree (display, root, &root, &parent, &windowList, &windowListSize) != 0)
		{
			for (int i = windowListSize; --i >= 0;)
			{
				LinuxComponentPeer* const peer = LinuxComponentPeer::getPeerFor (windowList[i]);

				if (peer != 0)
				{
					result = (peer == this);
					break;
				}
			}
		}

		if (windowList != 0)
			XFree (windowList);

		return result;
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		if (! bounds.withZeroOrigin().contains (position))
			return false;

		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			Component* const c = Desktop::getInstance().getComponent (i);

			if (c == getComponent())
				break;

			if (c->contains (position + bounds.getPosition() - c->getScreenPosition()))
				return false;
		}

		if (trueIfInAChildWindow)
			return true;

		::Window root, child;
		int wx, wy;
		unsigned int ww, wh, bw, depth;

		ScopedXLock xlock;

		return XGetGeometry (display, (::Drawable) windowH, &root, &wx, &wy, &ww, &wh, &bw, &depth)
				&& XTranslateCoordinates (display, windowH, windowH, position.getX(), position.getY(), &wx, &wy, &child)
				&& child == None;
	}

	BorderSize<int> getFrameSize() const
	{
		return BorderSize<int>();
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		return false;
	}

	void toFront (bool makeActive)
	{
		if (makeActive)
		{
			setVisible (true);
			grabFocus();
		}

		XEvent ev;
		ev.xclient.type = ClientMessage;
		ev.xclient.serial = 0;
		ev.xclient.send_event = True;
		ev.xclient.message_type = Atoms::ActiveWin;
		ev.xclient.window = windowH;
		ev.xclient.format = 32;
		ev.xclient.data.l[0] = 2;
		ev.xclient.data.l[1] = CurrentTime;
		ev.xclient.data.l[2] = 0;
		ev.xclient.data.l[3] = 0;
		ev.xclient.data.l[4] = 0;

		{
			ScopedXLock xlock;
			XSendEvent (display, RootWindow (display, DefaultScreen (display)),
						False, SubstructureRedirectMask | SubstructureNotifyMask, &ev);

			XWindowAttributes attr;
			XGetWindowAttributes (display, windowH, &attr);

			if (component->isAlwaysOnTop())
				XRaiseWindow (display, windowH);

			XSync (display, False);
		}

		handleBroughtToFront();
	}

	void toBehind (ComponentPeer* other)
	{
		LinuxComponentPeer* const otherPeer = dynamic_cast <LinuxComponentPeer*> (other);
		jassert (otherPeer != nullptr); // wrong type of window?

		if (otherPeer != nullptr)
		{
			setMinimised (false);

			Window newStack[] = { otherPeer->windowH, windowH };

			ScopedXLock xlock;
			XRestackWindows (display, newStack, 2);
		}
	}

	bool isFocused() const
	{
		int revert = 0;
		Window focusedWindow = 0;
		ScopedXLock xlock;
		XGetInputFocus (display, &focusedWindow, &revert);

		return focusedWindow == windowH;
	}

	void grabFocus()
	{
		XWindowAttributes atts;
		ScopedXLock xlock;

		if (windowH != 0
			&& XGetWindowAttributes (display, windowH, &atts)
			&& atts.map_state == IsViewable
			&& ! isFocused())
		{
			XSetInputFocus (display, windowH, RevertToParent, CurrentTime);
			isActiveApplication = true;
		}
	}

	void textInputRequired (const Point<int>&)
	{
	}

	void repaint (const Rectangle<int>& area)
	{
		repainter->repaint (area.getIntersection (getComponent()->getLocalBounds()));
	}

	void performAnyPendingRepaintsNow()
	{
		repainter->performAnyPendingRepaintsNow();
	}

	void setIcon (const Image& newIcon)
	{
		const int dataSize = newIcon.getWidth() * newIcon.getHeight() + 2;
		HeapBlock <unsigned long> data (dataSize);

		int index = 0;
		data[index++] = (unsigned long) newIcon.getWidth();
		data[index++] = (unsigned long) newIcon.getHeight();

		for (int y = 0; y < newIcon.getHeight(); ++y)
			for (int x = 0; x < newIcon.getWidth(); ++x)
				data[index++] = (unsigned long) newIcon.getPixelAt (x, y).getARGB();

		ScopedXLock xlock;
		xchangeProperty (windowH, Atoms::getCreating ("_NET_WM_ICON"), XA_CARDINAL, 32, data.getData(), dataSize);

		deleteIconPixmaps();

		XWMHints* wmHints = XGetWMHints (display, windowH);

		if (wmHints == nullptr)
			wmHints = XAllocWMHints();

		wmHints->flags |= IconPixmapHint | IconMaskHint;
		wmHints->icon_pixmap = PixmapHelpers::createColourPixmapFromImage (display, newIcon);
		wmHints->icon_mask = PixmapHelpers::createMaskPixmapFromImage (display, newIcon);

		XSetWMHints (display, windowH, wmHints);
		XFree (wmHints);

		XSync (display, False);
	}

	void deleteIconPixmaps()
	{
		ScopedXLock xlock;
		XWMHints* wmHints = XGetWMHints (display, windowH);

		if (wmHints != nullptr)
		{
			if ((wmHints->flags & IconPixmapHint) != 0)
			{
				wmHints->flags &= ~IconPixmapHint;
				XFreePixmap (display, wmHints->icon_pixmap);
			}

			if ((wmHints->flags & IconMaskHint) != 0)
			{
				wmHints->flags &= ~IconMaskHint;
				XFreePixmap (display, wmHints->icon_mask);
			}

			XSetWMHints (display, windowH, wmHints);
			XFree (wmHints);
		}
	}

	void handleWindowMessage (XEvent* event)
	{
		switch (event->xany.type)
		{
			case KeyPressEventType:     handleKeyPressEvent ((XKeyEvent*) &event->xkey); break;
			case KeyRelease:            handleKeyReleaseEvent ((const XKeyEvent*) &event->xkey); break;
			case ButtonPress:           handleButtonPressEvent ((const XButtonPressedEvent*) &event->xbutton); break;
			case ButtonRelease:         handleButtonReleaseEvent ((const XButtonReleasedEvent*) &event->xbutton); break;
			case MotionNotify:          handleMotionNotifyEvent ((const XPointerMovedEvent*) &event->xmotion); break;
			case EnterNotify:           handleEnterNotifyEvent ((const XEnterWindowEvent*) &event->xcrossing); break;
			case LeaveNotify:           handleLeaveNotifyEvent ((const XLeaveWindowEvent*) &event->xcrossing); break;
			case FocusIn:               handleFocusInEvent(); break;
			case FocusOut:              handleFocusOutEvent(); break;
			case Expose:                handleExposeEvent ((XExposeEvent*) &event->xexpose); break;
			case MappingNotify:         handleMappingNotify ((XMappingEvent*) &event->xmapping); break;
			case ClientMessage:         handleClientMessageEvent ((XClientMessageEvent*) &event->xclient, event); break;
			case SelectionNotify:       handleDragAndDropSelection (event); break;
			case ConfigureNotify:       handleConfigureNotifyEvent ((XConfigureEvent*) &event->xconfigure); break;
			case ReparentNotify:        handleReparentNotifyEvent(); break;
			case GravityNotify:         handleGravityNotify(); break;

			case CirculateNotify:
			case CreateNotify:
			case DestroyNotify:
				// Think we can ignore these
				break;

			case MapNotify:
				mapped = true;
				handleBroughtToFront();
				break;

			case UnmapNotify:
				mapped = false;
				break;

			case SelectionClear:
			case SelectionRequest:
				break;

			default:
			   #if JUCE_USE_XSHM
				{
					ScopedXLock xlock;
					if (event->xany.type == XShmGetEventBase (display))
						repainter->notifyPaintCompleted();
				}
			   #endif
				break;
		}
	}

	void handleKeyPressEvent (XKeyEvent* const keyEvent)
	{
		char utf8 [64] = { 0 };
		juce_wchar unicodeChar = 0;
		int keyCode = 0;
		bool keyDownChange = false;
		KeySym sym;

		{
			ScopedXLock xlock;
			updateKeyStates (keyEvent->keycode, true);

			const char* oldLocale = ::setlocale (LC_ALL, 0);
			::setlocale (LC_ALL, "");
			XLookupString (keyEvent, utf8, sizeof (utf8), &sym, 0);
			::setlocale (LC_ALL, oldLocale);

			unicodeChar = *CharPointer_UTF8 (utf8);
			keyCode = (int) unicodeChar;

			if (keyCode < 0x20)
				keyCode = XkbKeycodeToKeysym (display, keyEvent->keycode, 0, currentModifiers.isShiftDown() ? 1 : 0);

			keyDownChange = (sym != NoSymbol) && ! updateKeyModifiersFromSym (sym, true);
		}

		const ModifierKeys oldMods (currentModifiers);
		bool keyPressed = false;

		if ((sym & 0xff00) == 0xff00)
		{
			switch (sym)  // Translate keypad
			{
				case XK_KP_Divide:      keyCode = XK_slash; break;
				case XK_KP_Multiply:    keyCode = XK_asterisk; break;
				case XK_KP_Subtract:    keyCode = XK_hyphen; break;
				case XK_KP_Add:         keyCode = XK_plus; break;
				case XK_KP_Enter:       keyCode = XK_Return; break;
				case XK_KP_Decimal:     keyCode = Keys::numLock ? XK_period : XK_Delete; break;
				case XK_KP_0:           keyCode = Keys::numLock ? XK_0 : XK_Insert; break;
				case XK_KP_1:           keyCode = Keys::numLock ? XK_1 : XK_End; break;
				case XK_KP_2:           keyCode = Keys::numLock ? XK_2 : XK_Down; break;
				case XK_KP_3:           keyCode = Keys::numLock ? XK_3 : XK_Page_Down; break;
				case XK_KP_4:           keyCode = Keys::numLock ? XK_4 : XK_Left; break;
				case XK_KP_5:           keyCode = XK_5; break;
				case XK_KP_6:           keyCode = Keys::numLock ? XK_6 : XK_Right; break;
				case XK_KP_7:           keyCode = Keys::numLock ? XK_7 : XK_Home; break;
				case XK_KP_8:           keyCode = Keys::numLock ? XK_8 : XK_Up; break;
				case XK_KP_9:           keyCode = Keys::numLock ? XK_9 : XK_Page_Up; break;
				default:                break;
			}

			switch (sym)
			{
				case XK_Left:
				case XK_Right:
				case XK_Up:
				case XK_Down:
				case XK_Page_Up:
				case XK_Page_Down:
				case XK_End:
				case XK_Home:
				case XK_Delete:
				case XK_Insert:
					keyPressed = true;
					keyCode = (sym & 0xff) | Keys::extendedKeyModifier;
					break;

				case XK_Tab:
				case XK_Return:
				case XK_Escape:
				case XK_BackSpace:
					keyPressed = true;
					keyCode &= 0xff;
					break;

				default:
					if (sym >= XK_F1 && sym <= XK_F16)
					{
						keyPressed = true;
						keyCode = (sym & 0xff) | Keys::extendedKeyModifier;
					}
					break;
			}
		}

		if (utf8[0] != 0 || ((sym & 0xff00) == 0 && sym >= 8))
			keyPressed = true;

		if (oldMods != currentModifiers)
			handleModifierKeysChange();

		if (keyDownChange)
			handleKeyUpOrDown (true);

		if (keyPressed)
			handleKeyPress (keyCode, unicodeChar);
	}

	static bool isKeyReleasePartOfAutoRepeat (const XKeyEvent* const keyReleaseEvent)
	{
		if (XPending (display))
		{
			XEvent e;
			XPeekEvent (display, &e);

			// Look for a subsequent key-down event with the same timestamp and keycode
			return e.type == KeyPressEventType
					&& e.xkey.keycode == keyReleaseEvent->keycode
					&& e.xkey.time == keyReleaseEvent->time;
		}

		return false;
	}

	void handleKeyReleaseEvent (const XKeyEvent* const keyEvent)
	{
		if (! isKeyReleasePartOfAutoRepeat (keyEvent))
		{
			updateKeyStates (keyEvent->keycode, false);
			KeySym sym;

			{
				ScopedXLock xlock;
				sym = XkbKeycodeToKeysym (display, keyEvent->keycode, 0, 0);
			}

			const ModifierKeys oldMods (currentModifiers);
			const bool keyDownChange = (sym != NoSymbol) && ! updateKeyModifiersFromSym (sym, false);

			if (oldMods != currentModifiers)
				handleModifierKeysChange();

			if (keyDownChange)
				handleKeyUpOrDown (false);
		}
	}

	void handleWheelEvent (const XButtonPressedEvent* const buttonPressEvent, const float amount)
	{
		handleMouseWheel (0, Point<int> (buttonPressEvent->x, buttonPressEvent->y),
						  getEventTime (buttonPressEvent->time), 0, amount);
	}

	void handleButtonPressEvent (const XButtonPressedEvent* const buttonPressEvent, int buttonModifierFlag)
	{
		currentModifiers = currentModifiers.withFlags (buttonModifierFlag);
		toFront (true);
		handleMouseEvent (0, Point<int> (buttonPressEvent->x, buttonPressEvent->y), currentModifiers,
						  getEventTime (buttonPressEvent->time));
	}

	void handleButtonPressEvent (const XButtonPressedEvent* const buttonPressEvent)
	{
		updateKeyModifiers (buttonPressEvent->state);

		switch (pointerMap [buttonPressEvent->button - Button1])
		{
			case Keys::WheelUp:         handleWheelEvent (buttonPressEvent, 84.0f); break;
			case Keys::WheelDown:       handleWheelEvent (buttonPressEvent, -84.0f); break;
			case Keys::LeftButton:      handleButtonPressEvent (buttonPressEvent, ModifierKeys::leftButtonModifier); break;
			case Keys::RightButton:     handleButtonPressEvent (buttonPressEvent, ModifierKeys::rightButtonModifier); break;
			case Keys::MiddleButton:    handleButtonPressEvent (buttonPressEvent, ModifierKeys::middleButtonModifier); break;
			default: break;
		}

		clearLastMousePos();
	}

	void handleButtonReleaseEvent (const XButtonReleasedEvent* const buttonRelEvent)
	{
		updateKeyModifiers (buttonRelEvent->state);

		switch (pointerMap [buttonRelEvent->button - Button1])
		{
			case Keys::LeftButton:      currentModifiers = currentModifiers.withoutFlags (ModifierKeys::leftButtonModifier); break;
			case Keys::RightButton:     currentModifiers = currentModifiers.withoutFlags (ModifierKeys::rightButtonModifier); break;
			case Keys::MiddleButton:    currentModifiers = currentModifiers.withoutFlags (ModifierKeys::middleButtonModifier); break;
			default: break;
		}

		handleMouseEvent (0, Point<int> (buttonRelEvent->x, buttonRelEvent->y), currentModifiers,
						  getEventTime (buttonRelEvent->time));

		clearLastMousePos();
	}

	void handleMotionNotifyEvent (const XPointerMovedEvent* const movedEvent)
	{
		updateKeyModifiers (movedEvent->state);
		const Point<int> mousePos (movedEvent->x_root, movedEvent->y_root);

		if (lastMousePos != mousePos)
		{
			lastMousePos = mousePos;

			if (parentWindow != nullptr && (styleFlags & windowHasTitleBar) == 0)
			{
				Window wRoot = 0, wParent = 0;

				{
					ScopedXLock xlock;
					unsigned int numChildren;
					Window* wChild = nullptr;
					XQueryTree (display, windowH, &wRoot, &wParent, &wChild, &numChildren);
				}

				if (wParent != 0
					 && wParent != windowH
					 && wParent != wRoot)
				{
					parentWindow = wParent;
					updateBounds();
				}
				else
				{
					parentWindow = 0;
				}
			}

			handleMouseEvent (0, mousePos - getScreenPosition(), currentModifiers, getEventTime (movedEvent->time));
		}
	}

	void handleEnterNotifyEvent (const XEnterWindowEvent* const enterEvent)
	{
		clearLastMousePos();

		if (! currentModifiers.isAnyMouseButtonDown())
		{
			updateKeyModifiers (enterEvent->state);
			handleMouseEvent (0, Point<int> (enterEvent->x, enterEvent->y), currentModifiers, getEventTime (enterEvent->time));
		}
	}

	void handleLeaveNotifyEvent (const XLeaveWindowEvent* const leaveEvent)
	{
		// Suppress the normal leave if we've got a pointer grab, or if
		// it's a bogus one caused by clicking a mouse button when running
		// in a Window manager
		if (((! currentModifiers.isAnyMouseButtonDown()) && leaveEvent->mode == NotifyNormal)
			 || leaveEvent->mode == NotifyUngrab)
		{
			updateKeyModifiers (leaveEvent->state);
			handleMouseEvent (0, Point<int> (leaveEvent->x, leaveEvent->y), currentModifiers, getEventTime (leaveEvent->time));
		}
	}

	void handleFocusInEvent()
	{
		isActiveApplication = true;
		if (isFocused())
			handleFocusGain();
	}

	void handleFocusOutEvent()
	{
		isActiveApplication = false;
		if (! isFocused())
			handleFocusLoss();
	}

	void handleExposeEvent (XExposeEvent* exposeEvent)
	{
		// Batch together all pending expose events
		XEvent nextEvent;
		ScopedXLock xlock;

		if (exposeEvent->window != windowH)
		{
			Window child;
			XTranslateCoordinates (display, exposeEvent->window, windowH,
								   exposeEvent->x, exposeEvent->y, &exposeEvent->x, &exposeEvent->y,
								   &child);
		}

		repaint (Rectangle<int> (exposeEvent->x, exposeEvent->y,
								 exposeEvent->width, exposeEvent->height));

		while (XEventsQueued (display, QueuedAfterFlush) > 0)
		{
			XPeekEvent (display, &nextEvent);
			if (nextEvent.type != Expose || nextEvent.xany.window != exposeEvent->window)
				break;

			XNextEvent (display, &nextEvent);
			XExposeEvent* nextExposeEvent = (XExposeEvent*) &nextEvent.xexpose;
			repaint (Rectangle<int> (nextExposeEvent->x, nextExposeEvent->y,
									 nextExposeEvent->width, nextExposeEvent->height));
		}
	}

	void handleConfigureNotifyEvent (XConfigureEvent* const confEvent)
	{
		updateBounds();
		updateBorderSize();
		handleMovedOrResized();

		// if the native title bar is dragged, need to tell any active menus, etc.
		if ((styleFlags & windowHasTitleBar) != 0
			  && component->isCurrentlyBlockedByAnotherModalComponent())
		{
			Component* const currentModalComp = Component::getCurrentlyModalComponent();

			if (currentModalComp != 0)
				currentModalComp->inputAttemptWhenModal();
		}

		if (confEvent->window == windowH
			 && confEvent->above != 0
			 && isFrontWindow())
		{
			handleBroughtToFront();
		}
	}

	void handleReparentNotifyEvent()
	{
		parentWindow = 0;
		Window wRoot = 0;
		Window* wChild = nullptr;
		unsigned int numChildren;

		{
			ScopedXLock xlock;
			XQueryTree (display, windowH, &wRoot, &parentWindow, &wChild, &numChildren);
		}

		if (parentWindow == windowH || parentWindow == wRoot)
			parentWindow = 0;

		handleGravityNotify();
	}

	void handleGravityNotify()
	{
		updateBounds();
		updateBorderSize();
		handleMovedOrResized();
	}

	void handleMappingNotify (XMappingEvent* const mappingEvent)
	{
		if (mappingEvent->request != MappingPointer)
		{
			// Deal with modifier/keyboard mapping
			ScopedXLock xlock;
			XRefreshKeyboardMapping (mappingEvent);
			updateModifierMappings();
		}
	}

	void handleClientMessageEvent (XClientMessageEvent* const clientMsg, XEvent* event)
	{
		if (clientMsg->message_type == Atoms::Protocols && clientMsg->format == 32)
		{
			const Atom atom = (Atom) clientMsg->data.l[0];

			if (atom == Atoms::ProtocolList [Atoms::PING])
			{
				Window root = RootWindow (display, DefaultScreen (display));

				clientMsg->window = root;

				XSendEvent (display, root, False, NoEventMask, event);
				XFlush (display);
			}
			else if (atom == Atoms::ProtocolList [Atoms::TAKE_FOCUS])
			{
				if ((getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0)
				{
					XWindowAttributes atts;

					ScopedXLock xlock;
					if (clientMsg->window != 0
						 && XGetWindowAttributes (display, clientMsg->window, &atts))
					{
						if (atts.map_state == IsViewable)
							XSetInputFocus (display, clientMsg->window, RevertToParent, clientMsg->data.l[1]);
					}
				}
			}
			else if (atom == Atoms::ProtocolList [Atoms::DELETE_WINDOW])
			{
				handleUserClosingWindow();
			}
		}
		else if (clientMsg->message_type == Atoms::XdndEnter)
		{
			handleDragAndDropEnter (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndLeave)
		{
			resetDragAndDrop();
		}
		else if (clientMsg->message_type == Atoms::XdndPosition)
		{
			handleDragAndDropPosition (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndDrop)
		{
			handleDragAndDropDrop (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndStatus)
		{
			handleDragAndDropStatus (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndFinished)
		{
			resetDragAndDrop();
		}
	}

	void showMouseCursor (Cursor cursor) noexcept
	{
		ScopedXLock xlock;
		XDefineCursor (display, windowH, cursor);
	}

	bool dontRepaint;

	static ModifierKeys currentModifiers;
	static bool isActiveApplication;

private:

	class LinuxRepaintManager : public Timer
	{
	public:
		LinuxRepaintManager (LinuxComponentPeer* const peer_)
			: peer (peer_),
			  lastTimeImageUsed (0)
		{
		   #if JUCE_USE_XSHM
			shmCompletedDrawing = true;

			useARGBImagesForRendering = XSHMHelpers::isShmAvailable();

			if (useARGBImagesForRendering)
			{
				ScopedXLock xlock;
				XShmSegmentInfo segmentinfo;

				XImage* const testImage
					= XShmCreateImage (display, DefaultVisual (display, DefaultScreen (display)),
									   24, ZPixmap, 0, &segmentinfo, 64, 64);

				useARGBImagesForRendering = (testImage->bits_per_pixel == 32);
				XDestroyImage (testImage);
			}
		   #endif
		}

		void timerCallback()
		{
		   #if JUCE_USE_XSHM
			if (! shmCompletedDrawing)
				return;
		   #endif
			if (! regionsNeedingRepaint.isEmpty())
			{
				stopTimer();
				performAnyPendingRepaintsNow();
			}
			else if (Time::getApproximateMillisecondCounter() > lastTimeImageUsed + 3000)
			{
				stopTimer();
				image = Image::null;
			}
		}

		void repaint (const Rectangle<int>& area)
		{
			if (! isTimerRunning())
				startTimer (repaintTimerPeriod);

			regionsNeedingRepaint.add (area);
		}

		void performAnyPendingRepaintsNow()
		{
		   #if JUCE_USE_XSHM
			if (! shmCompletedDrawing)
			{
				startTimer (repaintTimerPeriod);
				return;
			}
		   #endif

			peer->clearMaskedRegion();

			RectangleList originalRepaintRegion (regionsNeedingRepaint);
			regionsNeedingRepaint.clear();
			const Rectangle<int> totalArea (originalRepaintRegion.getBounds());

			if (! totalArea.isEmpty())
			{
				if (image.isNull() || image.getWidth() < totalArea.getWidth()
					 || image.getHeight() < totalArea.getHeight())
				{
				   #if JUCE_USE_XSHM
					image = Image (new XBitmapImage (useARGBImagesForRendering ? Image::ARGB
																			   : Image::RGB,
				   #else
					image = Image (new XBitmapImage (Image::RGB,
				   #endif
													 (totalArea.getWidth() + 31) & ~31,
													 (totalArea.getHeight() + 31) & ~31,
													 false, peer->depth, peer->visual));
				}

				startTimer (repaintTimerPeriod);

				RectangleList adjustedList (originalRepaintRegion);
				adjustedList.offsetAll (-totalArea.getX(), -totalArea.getY());

				if (peer->depth == 32)
				{
					RectangleList::Iterator i (originalRepaintRegion);

					while (i.next())
						image.clear (*i.getRectangle() - totalArea.getPosition());
				}

				{
					ScopedPointer<LowLevelGraphicsContext> context (peer->getComponent()->getLookAndFeel()
																	  .createGraphicsContext (image, -totalArea.getPosition(), adjustedList));
					peer->handlePaint (*context);
				}

				if (! peer->maskedRegion.isEmpty())
					originalRepaintRegion.subtract (peer->maskedRegion);

				for (RectangleList::Iterator i (originalRepaintRegion); i.next();)
				{
				   #if JUCE_USE_XSHM
					shmCompletedDrawing = false;
				   #endif
					const Rectangle<int>& r = *i.getRectangle();

					static_cast<XBitmapImage*> (image.getPixelData())
						->blitToWindow (peer->windowH,
										r.getX(), r.getY(), r.getWidth(), r.getHeight(),
										r.getX() - totalArea.getX(), r.getY() - totalArea.getY());
				}
			}

			lastTimeImageUsed = Time::getApproximateMillisecondCounter();
			startTimer (repaintTimerPeriod);
		}

	   #if JUCE_USE_XSHM
		void notifyPaintCompleted()                 { shmCompletedDrawing = true; }
	   #endif

	private:
		enum { repaintTimerPeriod = 1000 / 100 };

		LinuxComponentPeer* const peer;
		Image image;
		uint32 lastTimeImageUsed;
		RectangleList regionsNeedingRepaint;

	   #if JUCE_USE_XSHM
		bool useARGBImagesForRendering, shmCompletedDrawing;
	   #endif
		JUCE_DECLARE_NON_COPYABLE (LinuxRepaintManager);
	};

	ScopedPointer <LinuxRepaintManager> repainter;

	friend class LinuxRepaintManager;
	Window windowH, parentWindow;
	Rectangle<int> bounds;
	Image taskbarImage;
	bool fullScreen, mapped;
	Visual* visual;
	int depth;
	BorderSize<int> windowBorder;
	enum { KeyPressEventType = 2 };

	struct MotifWmHints
	{
		unsigned long flags;
		unsigned long functions;
		unsigned long decorations;
		long input_mode;
		unsigned long status;
	};

	static void updateKeyStates (const int keycode, const bool press) noexcept
	{
		const int keybyte = keycode >> 3;
		const int keybit = (1 << (keycode & 7));

		if (press)
			Keys::keyStates [keybyte] |= keybit;
		else
			Keys::keyStates [keybyte] &= ~keybit;
	}

	static void updateKeyModifiers (const int status) noexcept
	{
		int keyMods = 0;

		if ((status & ShiftMask) != 0)     keyMods |= ModifierKeys::shiftModifier;
		if ((status & ControlMask) != 0)   keyMods |= ModifierKeys::ctrlModifier;
		if ((status & Keys::AltMask) != 0) keyMods |= ModifierKeys::altModifier;

		currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (keyMods);

		Keys::numLock  = ((status & Keys::NumLockMask) != 0);
		Keys::capsLock = ((status & LockMask) != 0);
	}

	static bool updateKeyModifiersFromSym (KeySym sym, const bool press) noexcept
	{
		int modifier = 0;
		bool isModifier = true;

		switch (sym)
		{
			case XK_Shift_L:
			case XK_Shift_R:
				modifier = ModifierKeys::shiftModifier;
				break;

			case XK_Control_L:
			case XK_Control_R:
				modifier = ModifierKeys::ctrlModifier;
				break;

			case XK_Alt_L:
			case XK_Alt_R:
				modifier = ModifierKeys::altModifier;
				break;

			case XK_Num_Lock:
				if (press)
					Keys::numLock = ! Keys::numLock;

				break;

			case XK_Caps_Lock:
				if (press)
					Keys::capsLock = ! Keys::capsLock;

				break;

			case XK_Scroll_Lock:
				break;

			default:
				isModifier = false;
				break;
		}

		currentModifiers = press ? currentModifiers.withFlags (modifier)
								 : currentModifiers.withoutFlags (modifier);

		return isModifier;
	}

	// Alt and Num lock are not defined by standard X
	// modifier constants: check what they're mapped to
	static void updateModifierMappings() noexcept
	{
		ScopedXLock xlock;
		const int altLeftCode = XKeysymToKeycode (display, XK_Alt_L);
		const int numLockCode = XKeysymToKeycode (display, XK_Num_Lock);

		Keys::AltMask = 0;
		Keys::NumLockMask = 0;

		XModifierKeymap* mapping = XGetModifierMapping (display);

		if (mapping)
		{
			for (int i = 0; i < 8; i++)
			{
				if (mapping->modifiermap [i << 1] == altLeftCode)
					Keys::AltMask = 1 << i;
				else if (mapping->modifiermap [i << 1] == numLockCode)
					Keys::NumLockMask = 1 << i;
			}

			XFreeModifiermap (mapping);
		}
	}

	static void xchangeProperty (Window wndH, Atom property, Atom type, int format, const void* data, int numElements)
	{
		XChangeProperty (display, wndH, property, type, format, PropModeReplace, (const unsigned char*) data, numElements);
	}

	void removeWindowDecorations (Window wndH)
	{
		Atom hints = Atoms::getIfExists ("_MOTIF_WM_HINTS");

		if (hints != None)
		{
			MotifWmHints motifHints = { 0 };
			motifHints.flags = 2; /* MWM_HINTS_DECORATIONS */
			motifHints.decorations = 0;

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &motifHints, 4);
		}

		hints = Atoms::getIfExists ("_WIN_HINTS");

		if (hints != None)
		{
			long gnomeHints = 0;

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &gnomeHints, 1);
		}

		hints = Atoms::getIfExists ("KWM_WIN_DECORATION");

		if (hints != None)
		{
			long kwmHints = 2; /*KDE_tinyDecoration*/

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &kwmHints, 1);
		}
	}

	void addWindowButtons (Window wndH)
	{
		ScopedXLock xlock;
		Atom hints = Atoms::getIfExists ("_MOTIF_WM_HINTS");

		if (hints != None)
		{
			MotifWmHints motifHints = { 0 };
			motifHints.flags = 1 | 2; /* MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS */
			motifHints.decorations = 2 /* MWM_DECOR_BORDER */ | 8 /* MWM_DECOR_TITLE */ | 16; /* MWM_DECOR_MENU */

			motifHints.functions = 4 /* MWM_FUNC_MOVE */;

			if ((styleFlags & windowHasCloseButton) != 0)
				motifHints.functions |= 32; /* MWM_FUNC_CLOSE */

			if ((styleFlags & windowHasMinimiseButton) != 0)
			{
				motifHints.functions |= 8; /* MWM_FUNC_MINIMIZE */
				motifHints.decorations |= 0x20; /* MWM_DECOR_MINIMIZE */
			}

			if ((styleFlags & windowHasMaximiseButton) != 0)
			{
				motifHints.functions |= 0x10; /* MWM_FUNC_MAXIMIZE */
				motifHints.decorations |= 0x40; /* MWM_DECOR_MAXIMIZE */
			}

			if ((styleFlags & windowIsResizable) != 0)
			{
				motifHints.functions |= 2; /* MWM_FUNC_RESIZE */
				motifHints.decorations |= 0x4; /* MWM_DECOR_RESIZEH */
			}

			xchangeProperty (wndH, hints, hints, 32, &motifHints, 5);
		}

		hints = Atoms::getIfExists ("_NET_WM_ALLOWED_ACTIONS");

		if (hints != None)
		{
			Atom netHints [6];
			int num = 0;

			if ((styleFlags & windowIsResizable) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_RESIZE");

			if ((styleFlags & windowHasMaximiseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_FULLSCREEN");

			if ((styleFlags & windowHasMinimiseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_MINIMIZE");

			if ((styleFlags & windowHasCloseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_CLOSE");

			xchangeProperty (wndH, hints, XA_ATOM, 32, &netHints, num);
		}
	}

	void setWindowType()
	{
		Atom netHints [2];

		if ((styleFlags & windowIsTemporary) != 0
			 || ((styleFlags & windowHasDropShadow) == 0 && Desktop::canUseSemiTransparentWindows()))
			netHints [0] = Atoms::getIfExists ("_NET_WM_WINDOW_TYPE_COMBO");
		else
			netHints [0] = Atoms::getIfExists ("_NET_WM_WINDOW_TYPE_NORMAL");

		netHints[1] = Atoms::getIfExists ("_KDE_NET_WM_WINDOW_TYPE_OVERRIDE");

		xchangeProperty (windowH, Atoms::WindowType, XA_ATOM, 32, &netHints, 2);

		int numHints = 0;

		if ((styleFlags & windowAppearsOnTaskbar) == 0)
			netHints [numHints++] = Atoms::getIfExists ("_NET_WM_STATE_SKIP_TASKBAR");

		if (component->isAlwaysOnTop())
			netHints [numHints++] = Atoms::getIfExists ("_NET_WM_STATE_ABOVE");

		if (numHints > 0)
			xchangeProperty (windowH, Atoms::WindowState, XA_ATOM, 32, &netHints, numHints);
	}

	void createWindow (Window parentToAddTo)
	{
		ScopedXLock xlock;
		Atoms::initialiseAtoms();
		resetDragAndDrop();

		// Get defaults for various properties
		const int screen = DefaultScreen (display);
		Window root = RootWindow (display, screen);

		// Try to obtain a 32-bit visual or fallback to 24 or 16
		visual = Visuals::findVisualFormat ((styleFlags & windowIsSemiTransparent) ? 32 : 24, depth);

		if (visual == 0)
		{
			Logger::outputDebugString ("ERROR: System doesn't support 32, 24 or 16 bit RGB display.\n");
			Process::terminate();
		}

		// Create and install a colormap suitable fr our visual
		Colormap colormap = XCreateColormap (display, root, visual, AllocNone);
		XInstallColormap (display, colormap);

		// Set up the window attributes
		XSetWindowAttributes swa;
		swa.border_pixel = 0;
		swa.background_pixmap = None;
		swa.colormap = colormap;
		swa.override_redirect = (getComponent()->isAlwaysOnTop() && (styleFlags & windowIsTemporary) != 0) ? True : False;
		swa.event_mask = getAllEventsMask();

		windowH = XCreateWindow (display, parentToAddTo != 0 ? parentToAddTo : root,
								 0, 0, 1, 1,
								 0, depth, InputOutput, visual,
								 CWBorderPixel | CWColormap | CWBackPixmap | CWEventMask | CWOverrideRedirect,
								 &swa);

		XGrabButton (display, AnyButton, AnyModifier, windowH, False,
					 ButtonPressMask | ButtonReleaseMask | EnterWindowMask | LeaveWindowMask | PointerMotionMask,
					 GrabModeAsync, GrabModeAsync, None, None);

		// Set the window context to identify the window handle object
		if (XSaveContext (display, (XID) windowH, windowHandleXContext, (XPointer) this))
		{
			// Failed
			jassertfalse;
			Logger::outputDebugString ("Failed to create context information for window.\n");
			XDestroyWindow (display, windowH);
			windowH = 0;
			return;
		}

		// Set window manager hints
		XWMHints* wmHints = XAllocWMHints();
		wmHints->flags = InputHint | StateHint;
		wmHints->input = True;      // Locally active input model
		wmHints->initial_state = NormalState;
		XSetWMHints (display, windowH, wmHints);
		XFree (wmHints);

		// Set the window type
		setWindowType();

		// Define decoration
		if ((styleFlags & windowHasTitleBar) == 0)
			removeWindowDecorations (windowH);
		else
			addWindowButtons (windowH);

		setTitle (getComponent()->getName());

		// Associate the PID, allowing to be shut down when something goes wrong
		unsigned long pid = getpid();
		xchangeProperty (windowH, Atoms::Pid, XA_CARDINAL, 32, &pid, 1);

		// Set window manager protocols
		xchangeProperty (windowH, Atoms::Protocols, XA_ATOM, 32, Atoms::ProtocolList, 2);

		// Set drag and drop flags
		xchangeProperty (windowH, Atoms::XdndTypeList, XA_ATOM, 32, Atoms::allowedMimeTypes, numElementsInArray (Atoms::allowedMimeTypes));
		xchangeProperty (windowH, Atoms::XdndActionList, XA_ATOM, 32, Atoms::allowedActions, numElementsInArray (Atoms::allowedActions));
		xchangeProperty (windowH, Atoms::XdndActionDescription, XA_STRING, 8, "", 0);
		xchangeProperty (windowH, Atoms::XdndAware, XA_ATOM, 32, &Atoms::DndVersion, 1);

		initialisePointerMap();
		updateModifierMappings();
	}

	void destroyWindow()
	{
		ScopedXLock xlock;

		XPointer handlePointer;
		if (! XFindContext (display, (XID) windowH, windowHandleXContext, &handlePointer))
			XDeleteContext (display, (XID) windowH, windowHandleXContext);

		XDestroyWindow (display, windowH);

		// Wait for it to complete and then remove any events for this
		// window from the event queue.
		XSync (display, false);

		XEvent event;
		while (XCheckWindowEvent (display, windowH, getAllEventsMask(), &event) == True)
		{}
	}

	static int getAllEventsMask() noexcept
	{
		return NoEventMask | KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask
				 | EnterWindowMask | LeaveWindowMask | PointerMotionMask | KeymapStateMask
				 | ExposureMask | StructureNotifyMask | FocusChangeMask;
	}

	static int64 getEventTime (::Time t)
	{
		static int64 eventTimeOffset = 0x12345678;
		const int64 thisMessageTime = t;

		if (eventTimeOffset == 0x12345678)
			eventTimeOffset = Time::currentTimeMillis() - thisMessageTime;

		return eventTimeOffset + thisMessageTime;
	}

	void updateBorderSize()
	{
		if ((styleFlags & windowHasTitleBar) == 0)
		{
			windowBorder = BorderSize<int> (0);
		}
		else if (windowBorder.getTopAndBottom() == 0 && windowBorder.getLeftAndRight() == 0)
		{
			ScopedXLock xlock;
			Atom hints = Atoms::getIfExists ("_NET_FRAME_EXTENTS");

			if (hints != None)
			{
				unsigned char* data = nullptr;
				unsigned long nitems, bytesLeft;
				Atom actualType;
				int actualFormat;

				if (XGetWindowProperty (display, windowH, hints, 0, 4, False,
										XA_CARDINAL, &actualType, &actualFormat, &nitems, &bytesLeft,
										&data) == Success)
				{
					const unsigned long* const sizes = (const unsigned long*) data;

					if (actualFormat == 32)
						windowBorder = BorderSize<int> ((int) sizes[2], (int) sizes[0],
														(int) sizes[3], (int) sizes[1]);

					XFree (data);
				}
			}
		}
	}

	void updateBounds()
	{
		jassert (windowH != 0);
		if (windowH != 0)
		{
			Window root, child;
			int wx = 0, wy = 0;
			unsigned int ww = 0, wh = 0, bw, depth;

			ScopedXLock xlock;

			if (XGetGeometry (display, (::Drawable) windowH, &root, &wx, &wy, &ww, &wh, &bw, &depth))
				if (! XTranslateCoordinates (display, windowH, root, 0, 0, &wx, &wy, &child))
					wx = wy = 0;

			bounds.setBounds (wx, wy, ww, wh);
		}
	}

	void resetDragAndDrop()
	{
		dragAndDropFiles.clear();
		lastDropPos = Point<int> (-1, -1);
		dragAndDropCurrentMimeType = 0;
		dragAndDropSourceWindow = 0;
		srcMimeTypeAtomList.clear();
	}

	void sendDragAndDropMessage (XClientMessageEvent& msg)
	{
		msg.type = ClientMessage;
		msg.display = display;
		msg.window = dragAndDropSourceWindow;
		msg.format = 32;
		msg.data.l[0] = windowH;

		ScopedXLock xlock;
		XSendEvent (display, dragAndDropSourceWindow, False, 0, (XEvent*) &msg);
	}

	void sendDragAndDropStatus (const bool acceptDrop, Atom dropAction)
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndStatus;
		msg.data.l[1] = (acceptDrop ? 1 : 0) | 2; // 2 indicates that we want to receive position messages
		msg.data.l[4] = dropAction;

		sendDragAndDropMessage (msg);
	}

	void sendDragAndDropLeave()
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndLeave;
		sendDragAndDropMessage (msg);
	}

	void sendDragAndDropFinish()
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndFinished;
		sendDragAndDropMessage (msg);
	}

	void handleDragAndDropStatus (const XClientMessageEvent* const clientMsg)
	{
		if ((clientMsg->data.l[1] & 1) == 0)
		{
			sendDragAndDropLeave();

			if (dragAndDropFiles.size() > 0)
				handleFileDragExit (dragAndDropFiles);

			dragAndDropFiles.clear();
		}
	}

	void handleDragAndDropPosition (const XClientMessageEvent* const clientMsg)
	{
		if (dragAndDropSourceWindow == 0)
			return;

		dragAndDropSourceWindow = clientMsg->data.l[0];

		Point<int> dropPos ((int) clientMsg->data.l[2] >> 16,
							(int) clientMsg->data.l[2] & 0xffff);
		dropPos -= getScreenPosition();

		if (lastDropPos != dropPos)
		{
			lastDropPos = dropPos;
			dragAndDropTimestamp = clientMsg->data.l[3];

			Atom targetAction = Atoms::XdndActionCopy;

			for (int i = numElementsInArray (Atoms::allowedActions); --i >= 0;)
			{
				if ((Atom) clientMsg->data.l[4] == Atoms::allowedActions[i])
				{
					targetAction = Atoms::allowedActions[i];
					break;
				}
			}

			sendDragAndDropStatus (true, targetAction);

			if (dragAndDropFiles.size() == 0)
				updateDraggedFileList (clientMsg);

			if (dragAndDropFiles.size() > 0)
				handleFileDragMove (dragAndDropFiles, dropPos);
		}
	}

	void handleDragAndDropDrop (const XClientMessageEvent* const clientMsg)
	{
		if (dragAndDropFiles.size() == 0)
			updateDraggedFileList (clientMsg);

		const StringArray files (dragAndDropFiles);
		const Point<int> lastPos (lastDropPos);

		sendDragAndDropFinish();
		resetDragAndDrop();

		if (files.size() > 0)
			handleFileDragDrop (files, lastPos);
	}

	void handleDragAndDropEnter (const XClientMessageEvent* const clientMsg)
	{
		dragAndDropFiles.clear();
		srcMimeTypeAtomList.clear();

		dragAndDropCurrentMimeType = 0;
		const unsigned long dndCurrentVersion = static_cast <unsigned long> (clientMsg->data.l[1] & 0xff000000) >> 24;

		if (dndCurrentVersion < 3 || dndCurrentVersion > Atoms::DndVersion)
		{
			dragAndDropSourceWindow = 0;
			return;
		}

		dragAndDropSourceWindow = clientMsg->data.l[0];

		if ((clientMsg->data.l[1] & 1) != 0)
		{
			Atom actual;
			int format;
			unsigned long count = 0, remaining = 0;
			unsigned char* data = 0;

			ScopedXLock xlock;
			XGetWindowProperty (display, dragAndDropSourceWindow, Atoms::XdndTypeList,
								0, 0x8000000L, False, XA_ATOM, &actual, &format,
								&count, &remaining, &data);

			if (data != 0)
			{
				if (actual == XA_ATOM && format == 32 && count != 0)
				{
					const unsigned long* const types = (const unsigned long*) data;

					for (unsigned int i = 0; i < count; ++i)
						if (types[i] != None)
							srcMimeTypeAtomList.add (types[i]);
				}

				XFree (data);
			}
		}

		if (srcMimeTypeAtomList.size() == 0)
		{
			for (int i = 2; i < 5; ++i)
				if (clientMsg->data.l[i] != None)
					srcMimeTypeAtomList.add (clientMsg->data.l[i]);

			if (srcMimeTypeAtomList.size() == 0)
			{
				dragAndDropSourceWindow = 0;
				return;
			}
		}

		for (int i = 0; i < srcMimeTypeAtomList.size() && dragAndDropCurrentMimeType == 0; ++i)
			for (int j = 0; j < numElementsInArray (Atoms::allowedMimeTypes); ++j)
				if (srcMimeTypeAtomList[i] == Atoms::allowedMimeTypes[j])
					dragAndDropCurrentMimeType = Atoms::allowedMimeTypes[j];

		handleDragAndDropPosition (clientMsg);
	}

	void handleDragAndDropSelection (const XEvent* const evt)
	{
		dragAndDropFiles.clear();

		if (evt->xselection.property != 0)
		{
			StringArray lines;

			{
				MemoryBlock dropData;

				for (;;)
				{
					Atom actual;
					uint8* data = 0;
					unsigned long count = 0, remaining = 0;
					int format = 0;
					ScopedXLock xlock;

					if (XGetWindowProperty (display, evt->xany.window, evt->xselection.property,
											dropData.getSize() / 4, 65536, 1, AnyPropertyType, &actual,
											&format, &count, &remaining, &data) == Success)
					{
						dropData.append (data, count * format / 8);
						XFree (data);

						if (remaining == 0)
							break;
					}
					else
					{
						XFree (data);
						break;
					}
				}

				lines.addLines (dropData.toString());
			}

			for (int i = 0; i < lines.size(); ++i)
				dragAndDropFiles.add (URL::removeEscapeChars (lines[i].fromFirstOccurrenceOf ("file://", false, true)));

			dragAndDropFiles.trim();
			dragAndDropFiles.removeEmptyStrings();
		}
	}

	void updateDraggedFileList (const XClientMessageEvent* const clientMsg)
	{
		dragAndDropFiles.clear();

		if (dragAndDropSourceWindow != None
			 && dragAndDropCurrentMimeType != 0)
		{
			dragAndDropTimestamp = clientMsg->data.l[2];

			ScopedXLock xlock;
			XConvertSelection (display,
							   Atoms::XdndSelection,
							   dragAndDropCurrentMimeType,
							   Atoms::getCreating ("JXSelectionWindowProperty"),
							   windowH,
							   dragAndDropTimestamp);
		}
	}

	StringArray dragAndDropFiles;
	int dragAndDropTimestamp;
	Point<int> lastDropPos;

	Atom dragAndDropCurrentMimeType;
	Window dragAndDropSourceWindow;

	Array <Atom> srcMimeTypeAtomList;

	int pointerMap[5];

	void initialisePointerMap()
	{
		const int numButtons = XGetPointerMapping (display, 0, 0);

		if (numButtons == 2)
		{
			pointerMap[0] = Keys::LeftButton;
			pointerMap[1] = Keys::RightButton;
			pointerMap[2] = pointerMap[3] = pointerMap[4] = Keys::NoButton;
		}
		else if (numButtons >= 3)
		{
			pointerMap[0] = Keys::LeftButton;
			pointerMap[1] = Keys::MiddleButton;
			pointerMap[2] = Keys::RightButton;

			if (numButtons >= 5)
			{
				pointerMap[3] = Keys::WheelUp;
				pointerMap[4] = Keys::WheelDown;
			}
		}
	}

	static Point<int> lastMousePos;

	static void clearLastMousePos() noexcept
	{
		lastMousePos = Point<int> (0x100000, 0x100000);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LinuxComponentPeer);
};

ModifierKeys LinuxComponentPeer::currentModifiers;
bool LinuxComponentPeer::isActiveApplication = false;
Point<int> LinuxComponentPeer::lastMousePos;

bool Process::isForegroundProcess()
{
	return LinuxComponentPeer::isActiveApplication;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = LinuxComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	Window root, child;
	int x, y, winx, winy;
	unsigned int mask;
	int mouseMods = 0;

	ScopedXLock xlock;

	if (XQueryPointer (display, RootWindow (display, DefaultScreen (display)),
					   &root, &child, &x, &y, &winx, &winy, &mask) != False)
	{
		if ((mask & Button1Mask) != 0)  mouseMods |= ModifierKeys::leftButtonModifier;
		if ((mask & Button2Mask) != 0)  mouseMods |= ModifierKeys::middleButtonModifier;
		if ((mask & Button3Mask) != 0)  mouseMods |= ModifierKeys::rightButtonModifier;
	}

	LinuxComponentPeer::currentModifiers = LinuxComponentPeer::currentModifiers.withoutMouseButtons().withFlags (mouseMods);
	return LinuxComponentPeer::currentModifiers;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	if (enableOrDisable)
		kioskModeComponent->setBounds (Desktop::getInstance().getDisplays().getMainDisplay().totalArea);
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
{
	return new LinuxComponentPeer (this, styleFlags, (Window) nativeWindowToAttachTo);
}

// (this callback is hooked up in the messaging code)
void juce_windowMessageReceive (XEvent* event)
{
	if (event->xany.window != None)
	{
		LinuxComponentPeer* const peer = LinuxComponentPeer::getPeerFor (event->xany.window);

		if (ComponentPeer::isValidPeer (peer))
			peer->handleWindowMessage (event);
	}
	else
	{
		switch (event->xany.type)
		{
			case KeymapNotify:
			{
				const XKeymapEvent* const keymapEvent = (const XKeymapEvent*) &event->xkeymap;
				memcpy (Keys::keyStates, keymapEvent->key_vector, 32);
				break;
			}

			default:
				break;
		}
	}
}

void Desktop::Displays::findDisplays()
{
	if (display == 0)
		return;

  #if JUCE_USE_XINERAMA
	int major_opcode, first_event, first_error;

	ScopedXLock xlock;
	if (XQueryExtension (display, "XINERAMA", &major_opcode, &first_event, &first_error))
	{
		typedef Bool (*tXineramaIsActive) (::Display*);
		typedef XineramaScreenInfo* (*tXineramaQueryScreens) (::Display*, int*);

		static tXineramaIsActive xXineramaIsActive = 0;
		static tXineramaQueryScreens xXineramaQueryScreens = 0;

		if (xXineramaIsActive == 0 || xXineramaQueryScreens == 0)
		{
			void* h = dlopen ("libXinerama.so", RTLD_GLOBAL | RTLD_NOW);

			if (h == 0)
				h = dlopen ("libXinerama.so.1", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xXineramaIsActive = (tXineramaIsActive) dlsym (h, "XineramaIsActive");
				xXineramaQueryScreens = (tXineramaQueryScreens) dlsym (h, "XineramaQueryScreens");
			}
		}

		if (xXineramaIsActive != 0
			&& xXineramaQueryScreens != 0
			&& xXineramaIsActive (display))
		{
			int numMonitors = 0;
			XineramaScreenInfo* const screens = xXineramaQueryScreens (display, &numMonitors);

			if (screens != nullptr)
			{
				for (int index = 0; index < numMonitors; ++index)
				{
					for (int j = numMonitors; --j >= 0;)
					{
						if (screens[j].screen_number == index)
						{
							Display d;
							d.userArea = d.totalArea = Rectangle<int> (screens[j].x_org,
																	   screens[j].y_org,
																	   screens[j].width,
																	   screens[j].height);
							d.isMain = (index == 0);
							d.scale = 1.0;

							displays.add (d);
						}
					}
				}

				XFree (screens);
			}
		}
	}

	if (displays.size() == 0)
  #endif
	{
		Atom hints = Atoms::getIfExists ("_NET_WORKAREA");

		if (hints != None)
		{
			const int numMonitors = ScreenCount (display);

			for (int i = 0; i < numMonitors; ++i)
			{
				Window root = RootWindow (display, i);

				unsigned long nitems, bytesLeft;
				Atom actualType;
				int actualFormat;
				unsigned char* data = nullptr;

				if (XGetWindowProperty (display, root, hints, 0, 4, False,
										XA_CARDINAL, &actualType, &actualFormat, &nitems, &bytesLeft,
										&data) == Success)
				{
					const long* const position = (const long*) data;

					if (actualType == XA_CARDINAL && actualFormat == 32 && nitems == 4)
					{
						Display d;
						d.userArea = d.totalArea = Rectangle<int> (position[0], position[1],
																   position[2], position[3]);
						d.isMain = (displays.size() == 0);
						d.scale = 1.0;

						displays.add (d);
					}

					XFree (data);
				}
			}
		}

		if (displays.size() == 0)
		{
			Display d;
			d.userArea = d.totalArea = Rectangle<int> (DisplayWidth (display, DefaultScreen (display)),
													   DisplayHeight (display, DefaultScreen (display)));
			d.isMain = true;
			d.scale = 1.0;

			displays.add (d);
		}
	}
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	int matchedDepth = 0;
	const int desiredDepth = 32;

	return Visuals::findVisualFormat (desiredDepth, matchedDepth) != 0
			 && (matchedDepth == desiredDepth);
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	Window root, child;
	int x, y, winx, winy;
	unsigned int mask;

	ScopedXLock xlock;

	if (XQueryPointer (display,
					   RootWindow (display, DefaultScreen (display)),
					   &root, &child,
					   &x, &y, &winx, &winy, &mask) == False)
	{
		// Pointer not on the default screen
		x = y = -1;
	}

	return Point<int> (x, y);
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	ScopedXLock xlock;
	Window root = RootWindow (display, DefaultScreen (display));
	XWarpPointer (display, None, root, 0, 0, 0, 0, newPosition.getX(), newPosition.getY());
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

static bool screenSaverAllowed = true;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (screenSaverAllowed != isEnabled)
	{
		screenSaverAllowed = isEnabled;

		typedef void (*tXScreenSaverSuspend) (Display*, Bool);
		static tXScreenSaverSuspend xScreenSaverSuspend = 0;

		if (xScreenSaverSuspend == 0)
		{
			void* h = dlopen ("libXss.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
				xScreenSaverSuspend = (tXScreenSaverSuspend) dlsym (h, "XScreenSaverSuspend");
		}

		ScopedXLock xlock;
		if (xScreenSaverSuspend != 0)
			xScreenSaverSuspend (display, ! isEnabled);
	}
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverAllowed;
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	ScopedXLock xlock;
	const unsigned int imageW = image.getWidth();
	const unsigned int imageH = image.getHeight();

  #if JUCE_USE_XCURSOR
	{
		typedef XcursorBool (*tXcursorSupportsARGB) (Display*);
		typedef XcursorImage* (*tXcursorImageCreate) (int, int);
		typedef void (*tXcursorImageDestroy) (XcursorImage*);
		typedef Cursor (*tXcursorImageLoadCursor) (Display*, const XcursorImage*);

		static tXcursorSupportsARGB xXcursorSupportsARGB = 0;
		static tXcursorImageCreate xXcursorImageCreate = 0;
		static tXcursorImageDestroy xXcursorImageDestroy = 0;
		static tXcursorImageLoadCursor xXcursorImageLoadCursor = 0;
		static bool hasBeenLoaded = false;

		if (! hasBeenLoaded)
		{
			hasBeenLoaded = true;
			void* h = dlopen ("libXcursor.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xXcursorSupportsARGB    = (tXcursorSupportsARGB)    dlsym (h, "XcursorSupportsARGB");
				xXcursorImageCreate     = (tXcursorImageCreate)     dlsym (h, "XcursorImageCreate");
				xXcursorImageLoadCursor = (tXcursorImageLoadCursor) dlsym (h, "XcursorImageLoadCursor");
				xXcursorImageDestroy    = (tXcursorImageDestroy)    dlsym (h, "XcursorImageDestroy");

				if (xXcursorSupportsARGB == 0 || xXcursorImageCreate == 0
					  || xXcursorImageLoadCursor == 0 || xXcursorImageDestroy == 0
					  || ! xXcursorSupportsARGB (display))
					xXcursorSupportsARGB = 0;
			}
		}

		if (xXcursorSupportsARGB != 0)
		{
			XcursorImage* xcImage = xXcursorImageCreate (imageW, imageH);

			if (xcImage != 0)
			{
				xcImage->xhot = hotspotX;
				xcImage->yhot = hotspotY;
				XcursorPixel* dest = xcImage->pixels;

				for (int y = 0; y < (int) imageH; ++y)
					for (int x = 0; x < (int) imageW; ++x)
						*dest++ = image.getPixelAt (x, y).getARGB();

				void* result = (void*) xXcursorImageLoadCursor (display, xcImage);
				xXcursorImageDestroy (xcImage);

				if (result != 0)
					return result;
			}
		}
	}
  #endif

	Window root = RootWindow (display, DefaultScreen (display));
	unsigned int cursorW, cursorH;
	if (! XQueryBestCursor (display, root, imageW, imageH, &cursorW, &cursorH))
		return nullptr;

	Image im (Image::ARGB, cursorW, cursorH, true);

	{
		Graphics g (im);

		if (imageW > cursorW || imageH > cursorH)
		{
			hotspotX = (hotspotX * cursorW) / imageW;
			hotspotY = (hotspotY * cursorH) / imageH;

			g.drawImageWithin (image, 0, 0, imageW, imageH,
							   RectanglePlacement::xLeft | RectanglePlacement::yTop | RectanglePlacement::onlyReduceInSize,
							   false);
		}
		else
		{
			g.drawImageAt (image, 0, 0);
		}
	}

	const int stride = (cursorW + 7) >> 3;
	HeapBlock <char> maskPlane, sourcePlane;
	maskPlane.calloc (stride * cursorH);
	sourcePlane.calloc (stride * cursorH);

	const bool msbfirst = (BitmapBitOrder (display) == MSBFirst);

	for (int y = cursorH; --y >= 0;)
	{
		for (int x = cursorW; --x >= 0;)
		{
			const char mask = (char) (1 << (msbfirst ? (7 - (x & 7)) : (x & 7)));
			const int offset = y * stride + (x >> 3);

			const Colour c (im.getPixelAt (x, y));

			if (c.getAlpha() >= 128)
				maskPlane[offset] |= mask;

			if (c.getBrightness() >= 0.5f)
				sourcePlane[offset] |= mask;
		}
	}

	Pixmap sourcePixmap = XCreatePixmapFromBitmapData (display, root, sourcePlane.getData(), cursorW, cursorH, 0xffff, 0, 1);
	Pixmap maskPixmap = XCreatePixmapFromBitmapData (display, root, maskPlane.getData(), cursorW, cursorH, 0xffff, 0, 1);

	XColor white, black;
	black.red = black.green = black.blue = 0;
	white.red = white.green = white.blue = 0xffff;

	void* result = (void*) XCreatePixmapCursor (display, sourcePixmap, maskPixmap, &white, &black, hotspotX, hotspotY);

	XFreePixmap (display, sourcePixmap);
	XFreePixmap (display, maskPixmap);

	return result;
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool)
{
	ScopedXLock xlock;
	if (cursorHandle != 0)
		XFreeCursor (display, (Cursor) cursorHandle);
}

void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
{
	unsigned int shape;

	switch (type)
	{
		case NormalCursor:                  return None; // Use parent cursor
		case NoCursor:                      return createMouseCursorFromImage (Image (Image::ARGB, 16, 16, true), 0, 0);

		case WaitCursor:                    shape = XC_watch; break;
		case IBeamCursor:                   shape = XC_xterm; break;
		case PointingHandCursor:            shape = XC_hand2; break;
		case LeftRightResizeCursor:         shape = XC_sb_h_double_arrow; break;
		case UpDownResizeCursor:            shape = XC_sb_v_double_arrow; break;
		case UpDownLeftRightResizeCursor:   shape = XC_fleur; break;
		case TopEdgeResizeCursor:           shape = XC_top_side; break;
		case BottomEdgeResizeCursor:        shape = XC_bottom_side; break;
		case LeftEdgeResizeCursor:          shape = XC_left_side; break;
		case RightEdgeResizeCursor:         shape = XC_right_side; break;
		case TopLeftCornerResizeCursor:     shape = XC_top_left_corner; break;
		case TopRightCornerResizeCursor:    shape = XC_top_right_corner; break;
		case BottomLeftCornerResizeCursor:  shape = XC_bottom_left_corner; break;
		case BottomRightCornerResizeCursor: shape = XC_bottom_right_corner; break;
		case CrosshairCursor:               shape = XC_crosshair; break;

		case DraggingHandCursor:
		{
			static unsigned char dragHandData[] = { 71,73,70,56,57,97,16,0,16,0,145,2,0,0,0,0,255,255,255,0,
			  0,0,0,0,0,33,249,4,1,0,0,2,0,44,0,0,0,0,16,0, 16,0,0,2,52,148,47,0,200,185,16,130,90,12,74,139,107,84,123,39,
			  132,117,151,116,132,146,248,60,209,138,98,22,203,114,34,236,37,52,77,217, 247,154,191,119,110,240,193,128,193,95,163,56,60,234,98,135,2,0,59 };
			const int dragHandDataSize = 99;

			return createMouseCursorFromImage (ImageFileFormat::loadFrom (dragHandData, dragHandDataSize), 8, 7);
		}

		case CopyingCursor:
		{
			static unsigned char copyCursorData[] = { 71,73,70,56,57,97,21,0,21,0,145,0,0,0,0,0,255,255,255,0,
			  128,128,255,255,255,33,249,4,1,0,0,3,0,44,0,0,0,0,21,0, 21,0,0,2,72,4,134,169,171,16,199,98,11,79,90,71,161,93,56,111,
			  78,133,218,215,137,31,82,154,100,200,86,91,202,142,12,108,212,87,235,174, 15,54,214,126,237,226,37,96,59,141,16,37,18,201,142,157,230,204,51,112,
			  252,114,147,74,83,5,50,68,147,208,217,16,71,149,252,124,5,0,59,0,0 };
			const int copyCursorSize = 119;

			return createMouseCursorFromImage (ImageFileFormat::loadFrom (copyCursorData, copyCursorSize), 1, 3);
		}

		default:
			jassertfalse;
			return None;
	}

	ScopedXLock xlock;
	return (void*) XCreateFontCursor (display, shape);
}

void MouseCursor::showInWindow (ComponentPeer* peer) const
{
	LinuxComponentPeer* const lp = dynamic_cast <LinuxComponentPeer*> (peer);

	if (lp != 0)
		lp->showMouseCursor ((Cursor) getHandle());
}

void MouseCursor::showInAllWindows() const
{
	for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		showInWindow (ComponentPeer::getPeer (i));
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

ImagePixelData* NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
{
	return SoftwareImageType().create (format, width, height, clearImage);
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
{
	jassertfalse;    // not implemented!
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	jassertfalse;    // not implemented!
	return false;
}

void LookAndFeel::playAlertSound()
{
	std::cout << "\a" << std::flush;
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	AlertWindow::showMessageBox (AlertWindow::NoIcon, title, message);
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	AlertWindow::showMessageBoxAsync (AlertWindow::NoIcon, title, message);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	return AlertWindow::showOkCancelBox (iconType, title, message, String::empty, String::empty,
										 associatedComponent, callback);
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	return AlertWindow::showYesNoCancelBox (iconType, title, message,
											String::empty, String::empty, String::empty,
											associatedComponent, callback);
}

const int KeyPress::spaceKey                = XK_space & 0xff;
const int KeyPress::returnKey               = XK_Return & 0xff;
const int KeyPress::escapeKey               = XK_Escape & 0xff;
const int KeyPress::backspaceKey            = XK_BackSpace & 0xff;
const int KeyPress::leftKey                 = (XK_Left & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::rightKey                = (XK_Right & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::upKey                   = (XK_Up & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::downKey                 = (XK_Down & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::pageUpKey               = (XK_Page_Up & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::pageDownKey             = (XK_Page_Down & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::endKey                  = (XK_End & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::homeKey                 = (XK_Home & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::insertKey               = (XK_Insert & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::deleteKey               = (XK_Delete & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::tabKey                  = XK_Tab & 0xff;
const int KeyPress::F1Key                   = (XK_F1 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F2Key                   = (XK_F2 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F3Key                   = (XK_F3 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F4Key                   = (XK_F4 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F5Key                   = (XK_F5 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F6Key                   = (XK_F6 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F7Key                   = (XK_F7 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F8Key                   = (XK_F8 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F9Key                   = (XK_F9 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F10Key                  = (XK_F10 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F11Key                  = (XK_F11 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F12Key                  = (XK_F12 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F13Key                  = (XK_F13 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F14Key                  = (XK_F14 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F15Key                  = (XK_F15 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F16Key                  = (XK_F16 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad0              = (XK_KP_0 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad1              = (XK_KP_1 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad2              = (XK_KP_2 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad3              = (XK_KP_3 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad4              = (XK_KP_4 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad5              = (XK_KP_5 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad6              = (XK_KP_6 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad7              = (XK_KP_7 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPad8              = (XK_KP_8 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPad9              = (XK_KP_9 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadAdd            = (XK_KP_Add & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadSubtract       = (XK_KP_Subtract & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadMultiply       = (XK_KP_Multiply & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDivide         = (XK_KP_Divide & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadSeparator      = (XK_KP_Separator & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDecimalPoint   = (XK_KP_Decimal & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadEquals         = (XK_KP_Equal & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDelete         = (XK_KP_Delete & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::playKey                 = (0xffeeff00) | Keys::extendedKeyModifier;
const int KeyPress::stopKey                 = (0xffeeff01) | Keys::extendedKeyModifier;
const int KeyPress::fastForwardKey          = (0xffeeff02) | Keys::extendedKeyModifier;
const int KeyPress::rewindKey               = (0xffeeff03) | Keys::extendedKeyModifier;

/*** End of inlined file: juce_linux_Windowing.cpp ***/


/*** Start of inlined file: juce_linux_FileChooser.cpp ***/
bool FileChooser::isPlatformDialogAvailable()
{
	ChildProcess child;
	const bool ok = child.start ("which zenity")
					 && child.readAllProcessOutput().trim().isNotEmpty();

	child.waitForProcessToFinish (60 * 1000);
	return ok;
}

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& file,
									  const String& filters,
									  bool isDirectory,
									  bool selectsFiles,
									  bool isSave,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* previewComponent)
{
	const String separator (":");
	String command ("zenity --file-selection");

	if (title.isNotEmpty())         command << " --title=\"" << title << "\"";
	if (file != File::nonexistent)  command << " --filename=\"" << file.getFullPathName () << "\"";
	if (isDirectory)                command << " --directory";
	if (isSave)                     command << " --save";
	if (selectMultipleFiles)        command << " --multiple --separator=" << separator;

	command << " 2>&1";

	ChildProcess child;
	if (child.start (command))
	{
		const String result (child.readAllProcessOutput().trim());

		if (result.isNotEmpty())
		{
			StringArray tokens;

			if (selectMultipleFiles)
				tokens.addTokens (result, separator, "\"");
			else
				tokens.add (result);

			for (int i = 0; i < tokens.size(); i++)
				results.add (File (tokens[i]));
		}

		child.waitForProcessToFinish (60 * 1000);
	}
}

/*** End of inlined file: juce_linux_FileChooser.cpp ***/

#elif JUCE_ANDROID

/*** Start of inlined file: juce_android_JNIHelpers.h ***/
#ifndef __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__
#define __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

#if ! (defined (JUCE_ANDROID_ACTIVITY_CLASSNAME) && defined (JUCE_ANDROID_ACTIVITY_CLASSPATH))
 #error "The JUCE_ANDROID_ACTIVITY_CLASSNAME and JUCE_ANDROID_ACTIVITY_CLASSPATH macros must be set!"
#endif

extern JNIEnv* getEnv() noexcept;

class GlobalRef
{
public:
	inline GlobalRef() noexcept                 : obj (0) {}
	inline explicit GlobalRef (jobject obj_)    : obj (retain (obj_)) {}
	inline GlobalRef (const GlobalRef& other)   : obj (retain (other.obj)) {}
	~GlobalRef()                                { clear(); }

	inline void clear()
	{
		if (obj != 0)
		{
			getEnv()->DeleteGlobalRef (obj);
			obj = 0;
		}
	}

	inline GlobalRef& operator= (const GlobalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator jobject() const noexcept    { return obj; }
	inline jobject get() const noexcept         { return obj; }

	#define DECLARE_CALL_TYPE_METHOD(returnType, typeName) \
		returnType call##typeName##Method (jmethodID methodID, ... ) const \
		{ \
			va_list args; \
			va_start (args, methodID); \
			returnType result = getEnv()->Call##typeName##MethodV (obj, methodID, args); \
			va_end (args); \
			return result; \
		}

	DECLARE_CALL_TYPE_METHOD (jobject, Object)
	DECLARE_CALL_TYPE_METHOD (jboolean, Boolean)
	DECLARE_CALL_TYPE_METHOD (jbyte, Byte)
	DECLARE_CALL_TYPE_METHOD (jchar, Char)
	DECLARE_CALL_TYPE_METHOD (jshort, Short)
	DECLARE_CALL_TYPE_METHOD (jint, Int)
	DECLARE_CALL_TYPE_METHOD (jlong, Long)
	DECLARE_CALL_TYPE_METHOD (jfloat, Float)
	DECLARE_CALL_TYPE_METHOD (jdouble, Double)
	#undef DECLARE_CALL_TYPE_METHOD

	void callVoidMethod (jmethodID methodID, ... ) const
	{
		va_list args;
		va_start (args, methodID);
		getEnv()->CallVoidMethodV (obj, methodID, args);
		va_end (args);
	}

private:

	jobject obj;

	static inline jobject retain (jobject obj_)
	{
		return obj_ == 0 ? 0 : getEnv()->NewGlobalRef (obj_);
	}
};

template <typename JavaType>
class LocalRef
{
public:
	explicit inline LocalRef (JavaType obj_) noexcept   : obj (obj_) {}
	inline LocalRef (const LocalRef& other) noexcept    : obj (retain (other.obj)) {}
	~LocalRef()                                         { clear(); }

	void clear()
	{
		if (obj != 0)
			getEnv()->DeleteLocalRef (obj);
	}

	LocalRef& operator= (const LocalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator JavaType() const noexcept   { return obj; }
	inline JavaType get() const noexcept        { return obj; }

private:
	JavaType obj;

	static JavaType retain (JavaType obj_)
	{
		return obj_ == 0 ? 0 : (JavaType) getEnv()->NewLocalRef (obj_);
	}
};

namespace
{
	String juceString (JNIEnv* env, jstring s)
	{
		const char* const utf8 = env->GetStringUTFChars (s, nullptr);
		CharPointer_UTF8 utf8CP (utf8);
		const String result (utf8CP);
		env->ReleaseStringUTFChars (s, utf8);
		return result;
	}

	String juceString (jstring s)
	{
		return juceString (getEnv(), s);
	}

	LocalRef<jstring> javaString (const String& s)
	{
		return LocalRef<jstring> (getEnv()->NewStringUTF (s.toUTF8()));
	}

	LocalRef<jstring> javaStringFromChar (const juce_wchar c)
	{
		char utf8[8] = { 0 };
		CharPointer_UTF8 (utf8).write (c);
		return LocalRef<jstring> (getEnv()->NewStringUTF (utf8));
	}
}

class JNIClassBase
{
public:
	explicit JNIClassBase (const char* classPath_);
	virtual ~JNIClassBase();

	inline operator jclass() const noexcept { return classRef; }

	static void initialiseAllClasses (JNIEnv*);
	static void releaseAllClasses (JNIEnv*);

protected:
	virtual void initialiseFields (JNIEnv*) = 0;

	jmethodID resolveMethod (JNIEnv*, const char* methodName, const char* params);
	jmethodID resolveStaticMethod (JNIEnv*, const char* methodName, const char* params);
	jfieldID resolveField (JNIEnv*, const char* fieldName, const char* signature);
	jfieldID resolveStaticField (JNIEnv*, const char* fieldName, const char* signature);

private:
	const char* const classPath;
	jclass classRef;

	static Array<JNIClassBase*>& getClasses();
	void initialise (JNIEnv*);
	void release (JNIEnv*);

	JUCE_DECLARE_NON_COPYABLE (JNIClassBase);
};

#define CREATE_JNI_METHOD(methodID, stringName, params)         methodID = resolveMethod (env, stringName, params);
#define CREATE_JNI_STATICMETHOD(methodID, stringName, params)   methodID = resolveStaticMethod (env, stringName, params);
#define CREATE_JNI_FIELD(fieldID, stringName, signature)        fieldID  = resolveField (env, stringName, signature);
#define CREATE_JNI_STATICFIELD(fieldID, stringName, signature)  fieldID  = resolveStaticField (env, stringName, signature);
#define DECLARE_JNI_METHOD(methodID, stringName, params)        jmethodID methodID;
#define DECLARE_JNI_FIELD(fieldID, stringName, signature)       jfieldID  fieldID;

#define DECLARE_JNI_CLASS(CppClassName, javaPath) \
	class CppClassName ## _Class   : public JNIClassBase \
	{ \
	public: \
		CppClassName ## _Class() : JNIClassBase (javaPath) {} \
	\
		void initialiseFields (JNIEnv* env) \
		{ \
			JNI_CLASS_MEMBERS (CREATE_JNI_METHOD, CREATE_JNI_STATICMETHOD, CREATE_JNI_FIELD, CREATE_JNI_STATICFIELD); \
		} \
	\
		JNI_CLASS_MEMBERS (DECLARE_JNI_METHOD, DECLARE_JNI_METHOD, DECLARE_JNI_FIELD, DECLARE_JNI_FIELD); \
	}; \
	static CppClassName ## _Class CppClassName;

#define JUCE_JNI_CALLBACK(className, methodName, returnType, params) \
  extern "C" __attribute__ ((visibility("default"))) returnType JUCE_JOIN_MACRO (JUCE_JOIN_MACRO (Java_, className), _ ## methodName) params

class AndroidSystem
{
public:
	AndroidSystem();

	void initialise (JNIEnv*, jobject activity, jstring appFile, jstring appDataDir);
	void shutdown (JNIEnv*);

	GlobalRef activity;
	String appFile, appDataDir;
	int screenWidth, screenHeight;
};

extern AndroidSystem android;

class ThreadLocalJNIEnvHolder
{
public:
	ThreadLocalJNIEnvHolder()
		: jvm (nullptr)
	{
		zeromem (threads, sizeof (threads));
		zeromem (envs, sizeof (envs));
	}

	void initialise (JNIEnv* env)
	{
		// NB: the DLL can be left loaded by the JVM, so the same static
		// objects can end up being reused by subsequent runs of the app
		zeromem (threads, sizeof (threads));
		zeromem (envs, sizeof (envs));

		env->GetJavaVM (&jvm);
		addEnv (env);
	}

	JNIEnv* attach()
	{
		JNIEnv* env = nullptr;
		jvm->AttachCurrentThread (&env, nullptr);

		if (env != nullptr)
			addEnv (env);

		return env;
	}

	void detach()
	{
		jvm->DetachCurrentThread();

		const pthread_t thisThread = pthread_self();

		SpinLock::ScopedLockType sl (addRemoveLock);
		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				threads[i] = 0;
	}

	JNIEnv* getOrAttach() noexcept
	{
		JNIEnv* env = get();

		if (env == nullptr)
			env = attach();

		jassert (env != nullptr);
		return env;
	}

	JNIEnv* get() const noexcept
	{
		const pthread_t thisThread = pthread_self();

		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				return envs[i];

		return nullptr;
	}

	enum { maxThreads = 32 };

private:
	JavaVM* jvm;
	pthread_t threads [maxThreads];
	JNIEnv* envs [maxThreads];
	SpinLock addRemoveLock;

	void addEnv (JNIEnv* env)
	{
		SpinLock::ScopedLockType sl (addRemoveLock);

		if (get() == nullptr)
		{
			const pthread_t thisThread = pthread_self();

			for (int i = 0; i < maxThreads; ++i)
			{
				if (threads[i] == 0)
				{
					envs[i] = env;
					threads[i] = thisThread;
					return;
				}
			}
		}

		jassertfalse; // too many threads!
	}
};

extern ThreadLocalJNIEnvHolder threadLocalJNIEnvHolder;

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (createNewView,          "createNewView",        "(Z)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;") \
 METHOD (deleteView,             "deleteView",           "(L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;)V") \
 METHOD (postMessage,            "postMessage",          "(J)V") \
 METHOD (finish,                 "finish",               "()V") \
 METHOD (getClipboardContent,    "getClipboardContent",  "()Ljava/lang/String;") \
 METHOD (setClipboardContent,    "setClipboardContent",  "(Ljava/lang/String;)V") \
 METHOD (excludeClipRegion,      "excludeClipRegion",    "(Landroid/graphics/Canvas;FFFF)V") \
 METHOD (renderGlyph,            "renderGlyph",          "(CLandroid/graphics/Paint;Landroid/graphics/Matrix;Landroid/graphics/Rect;)[I") \
 STATICMETHOD (createHTTPStream, "createHTTPStream",     "(Ljava/lang/String;Z[BLjava/lang/String;ILjava/lang/StringBuffer;)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$HTTPStream;") \
 METHOD (launchURL,              "launchURL",            "(Ljava/lang/String;)V") \
 METHOD (showMessageBox,         "showMessageBox",       "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showOkCancelBox,        "showOkCancelBox",      "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showYesNoCancelBox,     "showYesNoCancelBox",   "(Ljava/lang/String;Ljava/lang/String;J)V") \

DECLARE_JNI_CLASS (JuceAppActivity, JUCE_ANDROID_ACTIVITY_CLASSPATH);
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",           "(I)V") \
 METHOD (setColor,      "setColor",         "(I)V") \
 METHOD (setAlpha,      "setAlpha",         "(I)V") \
 METHOD (setTypeface,   "setTypeface",      "(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;") \
 METHOD (ascent,        "ascent",           "()F") \
 METHOD (descent,       "descent",          "()F") \
 METHOD (setTextSize,   "setTextSize",      "(F)V") \
 METHOD (getTextWidths, "getTextWidths",    "(Ljava/lang/String;[F)I") \
 METHOD (setTextScaleX, "setTextScaleX",    "(F)V") \
 METHOD (getTextPath,   "getTextPath",      "(Ljava/lang/String;IIFFLandroid/graphics/Path;)V") \
 METHOD (setShader,     "setShader",        "(Landroid/graphics/Shader;)Landroid/graphics/Shader;") \

DECLARE_JNI_CLASS (Paint, "android/graphics/Paint");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",    "()V") \
 METHOD (setValues,     "setValues", "([F)V") \

DECLARE_JNI_CLASS (Matrix, "android/graphics/Matrix");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",   "(IIII)V") \
 FIELD (left,           "left",     "I") \
 FIELD (right,          "right",    "I") \
 FIELD (top,            "top",      "I") \
 FIELD (bottom,         "bottom",   "I") \

DECLARE_JNI_CLASS (RectClass, "android/graphics/Rect");
#undef JNI_CLASS_MEMBERS

#endif   // __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

/*** End of inlined file: juce_android_JNIHelpers.h ***/



/*** Start of inlined file: juce_android_Windowing.cpp ***/
} // (juce namespace)

extern juce::JUCEApplicationBase* juce_CreateApplication(); // (from START_JUCE_APPLICATION)

namespace juce
{

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, launchApp, void, (JNIEnv* env, jobject activity,
																	  jstring appFile, jstring appDataDir))
{
	android.initialise (env, activity, appFile, appDataDir);

	DBG (SystemStats::getJUCEVersion());

	JUCEApplicationBase::createInstance = &juce_CreateApplication;

	initialiseJuce_GUI();

	JUCEApplication* app = dynamic_cast <JUCEApplication*> (JUCEApplicationBase::createInstance());
	if (! app->initialiseApp (String::empty))
		exit (0);

	jassert (MessageManager::getInstance()->isThisTheMessageThread());
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, quitApp, void, (JNIEnv* env, jobject activity))
{
	JUCEApplicationBase::appWillTerminateByForce();

	android.shutdown (env);
}

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (drawBitmap,       "drawBitmap",    "([IIIFFIIZLandroid/graphics/Paint;)V") \
 METHOD (getClipBounds,    "getClipBounds", "()Landroid/graphics/Rect;")

DECLARE_JNI_CLASS (CanvasMinimal, "android/graphics/Canvas");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (setViewName,   "setViewName",      "(Ljava/lang/String;)V") \
 METHOD (layout,        "layout",           "(IIII)V") \
 METHOD (getLeft,       "getLeft",          "()I") \
 METHOD (getTop,        "getTop",           "()I") \
 METHOD (getWidth,      "getWidth",         "()I") \
 METHOD (getHeight,     "getHeight",        "()I") \
 METHOD (getLocationOnScreen, "getLocationOnScreen", "([I)V") \
 METHOD (bringToFront,  "bringToFront",     "()V") \
 METHOD (requestFocus,  "requestFocus",     "()Z") \
 METHOD (setVisible,    "setVisible",       "(Z)V") \
 METHOD (isVisible,     "isVisible",        "()Z") \
 METHOD (hasFocus,      "hasFocus",         "()Z") \
 METHOD (invalidate,    "invalidate",       "(IIII)V") \
 METHOD (containsPoint, "containsPoint",    "(II)Z") \
 METHOD (createGLView,  "createGLView",     "()L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$OpenGLView;") \

DECLARE_JNI_CLASS (ComponentPeerView, JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView");
#undef JNI_CLASS_MEMBERS

class AndroidComponentPeer  : public ComponentPeer
{
public:
	AndroidComponentPeer (Component* const component, const int windowStyleFlags)
		: ComponentPeer (component, windowStyleFlags),
		  usingAndroidGraphics (false),
		  fullScreen (false),
		  sizeAllocated (0)
	{
		// NB: must not put this in the initialiser list, as it invokes a callback,
		// which will fail if the peer is only half-constructed.
		view = GlobalRef (android.activity.callObjectMethod (JuceAppActivity.createNewView,
															 component->isOpaque()));

		if (isFocused())
			handleFocusGain();
	}

	~AndroidComponentPeer()
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			android.activity.callVoidMethod (JuceAppActivity.deleteView, view.get());
		}
		else
		{
			struct ViewDeleter  : public CallbackMessage
			{
				ViewDeleter (const GlobalRef& view_) : view (view_) {}

				void messageCallback()
				{
					android.activity.callVoidMethod (JuceAppActivity.deleteView, view.get());
				}

			private:
				GlobalRef view;
			};

			(new ViewDeleter (view))->post();
		}

		view.clear();
	}

	void* getNativeHandle() const
	{
		return (void*) view.get();
	}

	void setVisible (bool shouldBeVisible)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			view.callVoidMethod (ComponentPeerView.setVisible, shouldBeVisible);
		}
		else
		{
			struct VisibilityChanger  : public CallbackMessage
			{
				VisibilityChanger (const GlobalRef& view_, bool shouldBeVisible_)
					: view (view_), shouldBeVisible (shouldBeVisible_)
				{}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.setVisible, shouldBeVisible);
				}

			private:
				GlobalRef view;
				bool shouldBeVisible;
			};

			(new VisibilityChanger (view, shouldBeVisible))->post();
		}
	}

	void setTitle (const String& title)
	{
		view.callVoidMethod (ComponentPeerView.setViewName, javaString (title).get());
	}

	void setPosition (int x, int y)
	{
		const Rectangle<int> pos (getBounds());
		setBounds (x, y, pos.getWidth(), pos.getHeight(), false);
	}

	void setSize (int w, int h)
	{
		const Rectangle<int> pos (getBounds());
		setBounds (pos.getX(), pos.getY(), w, h, false);
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			fullScreen = isNowFullScreen;
			w = jmax (0, w);
			h = jmax (0, h);

			view.callVoidMethod (ComponentPeerView.layout, x, y, x + w, y + h);
		}
		else
		{
			class ViewMover  : public CallbackMessage
			{
			public:
				ViewMover (const GlobalRef& view_, int x_, int y_, int w_, int h_)
					: view (view_), x (x_), y (y_), w (w_), h (h_)
				{
					post();
				}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.layout, x, y, x + w, y + h);
				}

			private:
				GlobalRef view;
				int x, y, w, h;
			};

			new ViewMover (view, x, y, w, h);
		}
	}

	Rectangle<int> getBounds() const
	{
		return Rectangle<int> (view.callIntMethod (ComponentPeerView.getLeft),
							   view.callIntMethod (ComponentPeerView.getTop),
							   view.callIntMethod (ComponentPeerView.getWidth),
							   view.callIntMethod (ComponentPeerView.getHeight));
	}

	void handleScreenSizeChange()
	{
		ComponentPeer::handleScreenSizeChange();

		if (isFullScreen())
			setFullScreen (true);
	}

	Point<int> getScreenPosition() const
	{
		return Point<int> (view.callIntMethod (ComponentPeerView.getLeft),
						   view.callIntMethod (ComponentPeerView.getTop));
	}

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setMinimised (bool shouldBeMinimised)
	{
		// n/a
	}

	bool isMinimised() const
	{
		return false;
	}

	void setFullScreen (bool shouldBeFullScreen)
	{
		Rectangle<int> r (shouldBeFullScreen ? Desktop::getInstance().getDisplays().getMainDisplay().userArea
											 : lastNonFullscreenBounds);

		if ((! shouldBeFullScreen) && r.isEmpty())
			r = getBounds();

		// (can't call the component's setBounds method because that'll reset our fullscreen flag)
		if (! r.isEmpty())
			setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

		component->repaint();
	}

	bool isFullScreen() const
	{
		return fullScreen;
	}

	void setIcon (const Image& newIcon)
	{
		// n/a
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		return isPositiveAndBelow (position.x, component->getWidth())
			&& isPositiveAndBelow (position.y, component->getHeight())
			&& ((! trueIfInAChildWindow) || view.callBooleanMethod (ComponentPeerView.containsPoint,
																	position.x, position.y));
	}

	BorderSize<int> getFrameSize() const
	{
		// TODO
		return BorderSize<int>();
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		// TODO
		return false;
	}

	void toFront (bool makeActive)
	{
		view.callVoidMethod (ComponentPeerView.bringToFront);

		if (makeActive)
			grabFocus();

		handleBroughtToFront();
	}

	void toBehind (ComponentPeer* other)
	{
		// TODO
	}

	void handleMouseDownCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		currentModifiers = currentModifiers.withoutMouseButtons();
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
		currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	void handleMouseDragCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	void handleMouseUpCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		currentModifiers = currentModifiers.withoutMouseButtons();
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	bool isFocused() const
	{
		return view.callBooleanMethod (ComponentPeerView.hasFocus);
	}

	void grabFocus()
	{
		view.callBooleanMethod (ComponentPeerView.requestFocus);
	}

	void handleFocusChangeCallback (bool hasFocus)
	{
		if (hasFocus)
			handleFocusGain();
		else
			handleFocusLoss();
	}

	void textInputRequired (const Point<int>& position)
	{
		// TODO
	}

	void handlePaintCallback (JNIEnv* env, jobject canvas)
	{
		jobject rect = env->CallObjectMethod (canvas, CanvasMinimal.getClipBounds);
		const int left   = env->GetIntField (rect, RectClass.left);
		const int top    = env->GetIntField (rect, RectClass.top);
		const int right  = env->GetIntField (rect, RectClass.right);
		const int bottom = env->GetIntField (rect, RectClass.bottom);
		env->DeleteLocalRef (rect);

		const Rectangle<int> clip (left, top, right - left, bottom - top);

		const int sizeNeeded = clip.getWidth() * clip.getHeight();
		if (sizeAllocated < sizeNeeded)
		{
			buffer.clear();
			sizeAllocated = sizeNeeded;
			buffer = GlobalRef (env->NewIntArray (sizeNeeded));
		}

		jint* dest = env->GetIntArrayElements ((jintArray) buffer.get(), 0);

		if (dest != nullptr)
		{
			{
				Image temp (new PreallocatedImage (clip.getWidth(), clip.getHeight(),
												   dest, ! component->isOpaque()));

				{
					LowLevelGraphicsSoftwareRenderer g (temp);
					g.setOrigin (-clip.getX(), -clip.getY());
					handlePaint (g);
				}
			}

			env->ReleaseIntArrayElements ((jintArray) buffer.get(), dest, 0);

			env->CallVoidMethod (canvas, CanvasMinimal.drawBitmap, (jintArray) buffer.get(), 0, clip.getWidth(),
								 (jfloat) clip.getX(), (jfloat) clip.getY(),
								 clip.getWidth(), clip.getHeight(), true, (jobject) 0);
		}
	}

	void repaint (const Rectangle<int>& area)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			view.callVoidMethod (ComponentPeerView.invalidate, area.getX(), area.getY(), area.getRight(), area.getBottom());
		}
		else
		{
			struct ViewRepainter  : public CallbackMessage
			{
				ViewRepainter (const GlobalRef& view_, const Rectangle<int>& area_)
					: view (view_), area (area_) {}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.invalidate, area.getX(), area.getY(),
										 area.getRight(), area.getBottom());
				}

			private:
				GlobalRef view;
				const Rectangle<int> area;
			};

			(new ViewRepainter (view, area))->post();
		}
	}

	void performAnyPendingRepaintsNow()
	{
		// TODO
	}

	void setAlpha (float newAlpha)
	{
		// TODO
	}

	static AndroidComponentPeer* findPeerForJavaView (JNIEnv* env, jobject viewToFind)
	{
		for (int i = getNumPeers(); --i >= 0;)
		{
			AndroidComponentPeer* const ap = static_cast <AndroidComponentPeer*> (getPeer(i));
			jassert (dynamic_cast <AndroidComponentPeer*> (getPeer(i)) != nullptr);

			if (env->IsSameObject (ap->view.get(), viewToFind))
				return ap;
		}

		return nullptr;
	}

	static ModifierKeys currentModifiers;
	static Point<int> lastMousePos;

private:

	GlobalRef view;
	GlobalRef buffer;
	bool usingAndroidGraphics, fullScreen;
	int sizeAllocated;

	class PreallocatedImage  : public ImagePixelData
	{
	public:
		PreallocatedImage (const int width_, const int height_, jint* data_, bool hasAlpha_)
			: ImagePixelData (Image::ARGB, width_, height_), data (data_), hasAlpha (hasAlpha_)
		{
			if (hasAlpha_)
				zeromem (data_, width * height * sizeof (jint));
		}

		~PreallocatedImage()
		{
			if (hasAlpha)
			{
				PixelARGB* pix = (PixelARGB*) data;

				for (int i = width * height; --i >= 0;)
				{
					pix->unpremultiply();
					++pix;
				}
			}
		}

		ImageType* createType() const                       { return new SoftwareImageType(); }
		LowLevelGraphicsContext* createLowLevelContext()    { return new LowLevelGraphicsSoftwareRenderer (Image (this)); }

		void initialiseBitmapData (Image::BitmapData& bm, int x, int y, Image::BitmapData::ReadWriteMode mode)
		{
			bm.lineStride = width * sizeof (jint);
			bm.pixelStride = sizeof (jint);
			bm.pixelFormat = Image::ARGB;
			bm.data = (uint8*) (data + x + y * width);
		}

		ImagePixelData* clone()
		{
			PreallocatedImage* s = new PreallocatedImage (width, height, 0, hasAlpha);
			s->allocatedData.malloc (sizeof (jint) * width * height);
			s->data = s->allocatedData;
			memcpy (s->data, data, sizeof (jint) * width * height);
			return s;
		}

	private:
		jint* data;
		HeapBlock<jint> allocatedData;
		bool hasAlpha;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PreallocatedImage);
	};

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AndroidComponentPeer);
};

ModifierKeys AndroidComponentPeer::currentModifiers = 0;
Point<int> AndroidComponentPeer::lastMousePos;

#define JUCE_VIEW_CALLBACK(returnType, javaMethodName, params, juceMethodInvocation) \
  JUCE_JNI_CALLBACK (JUCE_JOIN_MACRO (JUCE_ANDROID_ACTIVITY_CLASSNAME, _00024ComponentPeerView), javaMethodName, returnType, params) \
  { \
	  AndroidComponentPeer* const peer = AndroidComponentPeer::findPeerForJavaView (env, view); \
	  if (peer != nullptr) \
		  peer->juceMethodInvocation; \
  }

JUCE_VIEW_CALLBACK (void, handlePaint,      (JNIEnv* env, jobject view, jobject canvas),                    handlePaintCallback (env, canvas))
JUCE_VIEW_CALLBACK (void, handleMouseDown,  (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseDownCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, handleMouseDrag,  (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseDragCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, handleMouseUp,    (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseUpCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, viewSizeChanged,  (JNIEnv* env, jobject view),                                    handleMovedOrResized())
JUCE_VIEW_CALLBACK (void, focusChanged,     (JNIEnv* env, jobject view, jboolean hasFocus),                 handleFocusChangeCallback (hasFocus))

ComponentPeer* Component::createNewPeer (int styleFlags, void*)
{
	return new AndroidComponentPeer (this, styleFlags);
}

jobject createOpenGLView (ComponentPeer* peer)
{
	jobject parentView = static_cast <jobject> (peer->getNativeHandle());
	return getEnv()->CallObjectMethod (parentView, ComponentPeerView.createGLView);
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	// TODO
	return upright;
}

void Desktop::createMouseInputSources()
{
	// This creates a mouse input source for each possible finger

	for (int i = 0; i < 10; ++i)
		mouseSources.add (new MouseInputSource (i, false));
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	return AndroidComponentPeer::lastMousePos;
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	// not needed
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	// TODO
	return false;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = AndroidComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	return AndroidComponentPeer::currentModifiers;
}

bool Process::isForegroundProcess()
{
	return true;      // TODO
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	android.activity.callVoidMethod (JuceAppActivity.showMessageBox, javaString (title).get(), javaString (message).get(), (jlong) 0);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	jassert (callback != 0); // on android, all alerts must be non-modal!!

	android.activity.callVoidMethod (JuceAppActivity.showOkCancelBox, javaString (title).get(), javaString (message).get(),
									 (jlong) (pointer_sized_int) callback);
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	jassert (callback != 0); // on android, all alerts must be non-modal!!

	android.activity.callVoidMethod (JuceAppActivity.showYesNoCancelBox, javaString (title).get(), javaString (message).get(),
									 (jlong) (pointer_sized_int) callback);
	return 0;
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, alertDismissed, void, (JNIEnv* env, jobject activity,
																		   jlong callbackAsLong, jint result))
{
	ModalComponentManager::Callback* callback = (ModalComponentManager::Callback*) callbackAsLong;

	if (callback != 0)
		callback->modalStateFinished (result);
}

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	// TODO
}

bool Desktop::isScreenSaverEnabled()
{
	return true;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	// TODO
}

void Desktop::Displays::findDisplays()
{
	Display d;
	d.userArea = d.totalArea = Rectangle<int> (android.screenWidth, android.screenHeight);
	d.isMain = true;
	d.scale = 1.0;

	displays.add (d);
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, setScreenSize, void, (JNIEnv* env, jobject activity,
																		  jint screenWidth, jint screenHeight))
{
	const bool isSystemInitialised = android.screenWidth != 0;
	android.screenWidth = screenWidth;
	android.screenHeight = screenHeight;

	const_cast <Desktop::Displays&> (Desktop::getInstance().getDisplays()).refresh();
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

void* MouseCursor::createMouseCursorFromImage (const Image&, int, int)                          { return nullptr; }
void* MouseCursor::createStandardMouseCursor (const MouseCursor::StandardCursorType)            { return nullptr; }
void MouseCursor::deleteMouseCursor (void* const /*cursorHandle*/, const bool /*isStandard*/)   {}

void MouseCursor::showInWindow (ComponentPeer*) const   {}
void MouseCursor::showInAllWindows() const  {}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMove)
{
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	return false;
}

void LookAndFeel::playAlertSound()
{
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	const LocalRef<jstring> t (javaString (text));
	android.activity.callVoidMethod (JuceAppActivity.setClipboardContent, t.get());
}

String SystemClipboard::getTextFromClipboard()
{
	const LocalRef<jstring> text ((jstring) android.activity.callObjectMethod (JuceAppActivity.getClipboardContent));
	return juceString (text);
}

const int extendedKeyModifier       = 0x10000;

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = extendedKeyModifier + 1;
const int KeyPress::rightKey        = extendedKeyModifier + 2;
const int KeyPress::upKey           = extendedKeyModifier + 3;
const int KeyPress::downKey         = extendedKeyModifier + 4;
const int KeyPress::pageUpKey       = extendedKeyModifier + 5;
const int KeyPress::pageDownKey     = extendedKeyModifier + 6;
const int KeyPress::endKey          = extendedKeyModifier + 7;
const int KeyPress::homeKey         = extendedKeyModifier + 8;
const int KeyPress::deleteKey       = extendedKeyModifier + 9;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = extendedKeyModifier + 10;
const int KeyPress::F2Key           = extendedKeyModifier + 11;
const int KeyPress::F3Key           = extendedKeyModifier + 12;
const int KeyPress::F4Key           = extendedKeyModifier + 13;
const int KeyPress::F5Key           = extendedKeyModifier + 14;
const int KeyPress::F6Key           = extendedKeyModifier + 16;
const int KeyPress::F7Key           = extendedKeyModifier + 17;
const int KeyPress::F8Key           = extendedKeyModifier + 18;
const int KeyPress::F9Key           = extendedKeyModifier + 19;
const int KeyPress::F10Key          = extendedKeyModifier + 20;
const int KeyPress::F11Key          = extendedKeyModifier + 21;
const int KeyPress::F12Key          = extendedKeyModifier + 22;
const int KeyPress::F13Key          = extendedKeyModifier + 23;
const int KeyPress::F14Key          = extendedKeyModifier + 24;
const int KeyPress::F15Key          = extendedKeyModifier + 25;
const int KeyPress::F16Key          = extendedKeyModifier + 26;
const int KeyPress::numberPad0      = extendedKeyModifier + 27;
const int KeyPress::numberPad1      = extendedKeyModifier + 28;
const int KeyPress::numberPad2      = extendedKeyModifier + 29;
const int KeyPress::numberPad3      = extendedKeyModifier + 30;
const int KeyPress::numberPad4      = extendedKeyModifier + 31;
const int KeyPress::numberPad5      = extendedKeyModifier + 32;
const int KeyPress::numberPad6      = extendedKeyModifier + 33;
const int KeyPress::numberPad7      = extendedKeyModifier + 34;
const int KeyPress::numberPad8      = extendedKeyModifier + 35;
const int KeyPress::numberPad9      = extendedKeyModifier + 36;
const int KeyPress::numberPadAdd            = extendedKeyModifier + 37;
const int KeyPress::numberPadSubtract       = extendedKeyModifier + 38;
const int KeyPress::numberPadMultiply       = extendedKeyModifier + 39;
const int KeyPress::numberPadDivide         = extendedKeyModifier + 40;
const int KeyPress::numberPadSeparator      = extendedKeyModifier + 41;
const int KeyPress::numberPadDecimalPoint   = extendedKeyModifier + 42;
const int KeyPress::numberPadEquals         = extendedKeyModifier + 43;
const int KeyPress::numberPadDelete         = extendedKeyModifier + 44;
const int KeyPress::playKey         = extendedKeyModifier + 45;
const int KeyPress::stopKey         = extendedKeyModifier + 46;
const int KeyPress::fastForwardKey  = extendedKeyModifier + 47;
const int KeyPress::rewindKey       = extendedKeyModifier + 48;

/*** End of inlined file: juce_android_Windowing.cpp ***/


/*** Start of inlined file: juce_android_FileChooser.cpp ***/
void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* extraInfoComponent)
{
	// TODO

}

bool FileChooser::isPlatformDialogAvailable()
{
	return false;
}

/*** End of inlined file: juce_android_FileChooser.cpp ***/

#endif

}

/*** End of inlined file: juce_gui_basics.cpp ***/


#endif

